                   // ORG   $8000
  case 0x8000:
L8000:
                                                     #ifdef DEBUG
                                      mon("L8000    NEG   <$00                    ; 8000: 00 00         \n");
                                      #endif
    PC = 0x8000; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x00); 
    res = -val; 
 // V = val & (UINT8)res; 
 // C = res & 0x100; 
    val = (UINT8)res; 
    wr_mem(DP|0x00, val); 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                   // FCB   $05                     ; 8002:  ' ' 05             Invalid ; 
    // =============== S U B R O U T I N E =======================================
    // Entering trench
  case 0x8341:
L8341:
                                                     #ifdef DEBUG
                                      mon("L8341    LDA   #$00                    ; 8341: 86 00         \n");
                                      #endif
    PC = 0x8341; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$44                    ; 8343: 97 44         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x44; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   <$45                    ; 8345: 97 45         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x45; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4989                  ; 8347: 8E 49 89      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x4989; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; 834A: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0x834C:
L834C:
                                                     #ifdef DEBUG
                                      mon("L834C    STA   ,X+                     ; 834C: A7 80         \n");
                                      #endif
    PC = 0x834c; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, val); 
    X = X + 1; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$49A9                  ; 834E: 8C 49 A9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x49a9; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   L834C                   ; 8351: 25 F9         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L834C;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   $4B12                   ; 8353: F6 4B 12      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b12); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; 8356: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$7CC0                  ; 8357: 8E 7C C0      \n");
                                      #endif // Trench catwalk/turrets data?
    clockticks = clockticks + 3; 
    X = 0x7cc0; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; 835A: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$7CD6                  ; 835B: 8C 7C D6      \n");
                                      #endif // Trench catwalk/turrets data?
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x7cd6; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   L8365                   ; 835E: 25 05         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L8365;
    }
                                                     #ifdef DEBUG
                                      mon("         LDU   #$4B3F                  ; 8360: CE 4B 3F      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x4b3f; 
    Z = U; 
    N = (U) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   L8367                   ; 8363: 20 02         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L8367;
    
    // ---------------------------------------------------------------------------
  case 0x8365:
L8365:
                                                     #ifdef DEBUG
                                      mon("L8365    LDU   ,X                      ; 8365: EE 84         \n");
                                      #endif
    PC = 0x8365; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0x8367:
L8367:
                                                     #ifdef DEBUG
                                      mon("L8367    STU   $49A9                   ; 8367: FF 49 A9      \n");
                                      #endif
    PC = 0x8367; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    wr_mem(0x49a9, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem(0x49aa, (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         STU   $49AB                   ; 836A: FF 49 AB      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    wr_mem(0x49ab, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem(0x49ac, (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         LDU   ,U                      ; 836D: EE C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(U)<<8; 
    ea = ea | rd_mem((UINT16)((U)+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; 836F: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $49C0                   ; 8372: B7 49 C0      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x49c0, val); 
                                                     #ifdef DEBUG
                                      mon("         STD   $49B1                   ; 8375: FD 49 B1      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x49b1, A); // Care needed with I/O space and word fetches
    wr_mem(0x49b2, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $49B5                   ; 8378: FD 49 B5      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x49b5, A); // Care needed with I/O space and word fetches
    wr_mem(0x49b6, B); 
                                                     #ifdef DEBUG
                                      mon("         STA   <$92                    ; 837B: 97 92         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x92; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   <$95                    ; 837D: 97 95         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x95; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STU   $49AF                   ; 837F: FF 49 AF      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    wr_mem(0x49af, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem(0x49b0, (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         STU   $49B3                   ; 8382: FF 49 B3      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
    Z = val; 
    N = (UINT8)(val >> 8); 
    V = 0; 
    wr_mem(0x49b3, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem(0x49b4, (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   L8434                   ; 8385: BD 84 34      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x88); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x83); 
    clockticks = clockticks + 1; 
    goto L8434;
  case 0x8388:
L8388:
                                                     #ifdef DEBUG
                                      mon("L8388    JSR   L8408                   ; 8388: BD 84 08      \n");
                                      #endif // Trench
    PC = 0x8388; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x8b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x83); 
    clockticks = clockticks + 1; 
    goto L8408;
  case 0x838B:
L838B:
                                                     #ifdef DEBUG
                                      mon("L838B    JSR   L83CE                   ; 838B: BD 83 CE      \n");
                                      #endif
    PC = 0x838b; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x8e); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x83); 
    clockticks = clockticks + 1; 
    goto L83CE;
  case 0x838E:
L838E:
                                                     #ifdef DEBUG
                                      mon("L838E    JSR   L83CE                   ; 838E: BD 83 CE      \n");
                                      #endif
    PC = 0x838e; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x91); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x83); 
    clockticks = clockticks + 1; 
    goto L83CE;
  case 0x8391:
L8391:
                                                     #ifdef DEBUG
                                      mon("L8391    JSR   L83CE                   ; 8391: BD 83 CE      \n");
                                      #endif
    PC = 0x8391; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x94); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x83); 
    clockticks = clockticks + 1; 
    goto L83CE;
  case 0x8394:
L8394:
                                                     #ifdef DEBUG
                                      mon("L8394    JSR   L83CE                   ; 8394: BD 83 CE      \n");
                                      #endif
    PC = 0x8394; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x97); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x83); 
    clockticks = clockticks + 1; 
    goto L83CE;
  case 0x8397:
L8397:
                                                     #ifdef DEBUG
                                      mon("L8397    JSR   L83CE                   ; 8397: BD 83 CE      \n");
                                      #endif
    PC = 0x8397; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x9a); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x83); 
    clockticks = clockticks + 1; 
    goto L83CE;
  case 0x839A:
L839A:
                                                     #ifdef DEBUG
                                      mon("L839A    JSR   L83CE                   ; 839A: BD 83 CE      \n");
                                      #endif
    PC = 0x839a; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x9d); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x83); 
    clockticks = clockticks + 1; 
    goto L83CE;
  case 0x839D:
L839D:
                                                     #ifdef DEBUG
                                      mon("L839D    JSR   L83CE                   ; 839D: BD 83 CE      \n");
                                      #endif
    PC = 0x839d; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xa0); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x83); 
    clockticks = clockticks + 1; 
    goto L83CE;
  case 0x83A0:
L83A0:
                                                     #ifdef DEBUG
                                      mon("L83A0    JSR   L83CE                   ; 83A0: BD 83 CE      \n");
                                      #endif
    PC = 0x83a0; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xa3); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x83); 
    clockticks = clockticks + 1; 
    goto L83CE;
    // End of function sub_8341
  case 0x83A3:
L83A3:
                                                     #ifdef DEBUG
                                      mon("L83A3    RTS                           ; 83A3: 39            \n");
                                      #endif
    PC = 0x83a3; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Called when starting trench
  case 0x83A4:
L83A4:
                                                     #ifdef DEBUG
                                      mon("L83A4    LDU   #$4B3F                  ; 83A4: CE 4B 3F      \n");
                                      #endif
    PC = 0x83a4; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0x4b3f; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$7C7E                  ; 83A7: 8E 7C 7E      \n");
                                      #endif // Copy pointers from ROM to RAM starting at word_4B3F
    clockticks = clockticks + 3; 
    X = 0x7c7e; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0x83AA:
L83AA:
                                                     #ifdef DEBUG
                                      mon("L83AA    LDD   ,X++                    ; 83AA: EC 81         \n");
                                      #endif
    PC = 0x83aa; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
    A = rd_mem(X); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(X+1)); 
    X = X + 2; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,U++                    ; 83AC: ED C1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    U = U + 2; 
                                                     #ifdef DEBUG
                                      mon("         CMPU  #$4B5F                  ; 83AE: 11 83 4B 5F   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
    arg = 0x4b5f; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   L83AA                   ; 83B2: 25 F6         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L83AA;
    }
                                                     #ifdef DEBUG
                                      mon("         LDU   #$4B43                  ; 83B4: CE 4B 43      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x4b43; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$7C9E                  ; 83B7: 8E 7C 9E      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x7c9e; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0x83BA:
L83BA:
                                                     #ifdef DEBUG
                                      mon("L83BA    LDA   #$11                    ; 83BA: 86 11         \n");
                                      #endif
    PC = 0x83ba; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x11; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $4703                   ; 83BC: F6 47 03      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         MUL                           ; 83BF: 3D            \n");
                                      #endif
    res = (UINT16)(A * B); 
 // Z = res; 
 // C = res & 0x80; 
    A = res >> 8; 
    B = (UINT8)res; 
    clockticks = clockticks + 11; 
                                                     #ifdef DEBUG
                                      mon("         ASLA                          ; 83C0: 48            \n");
                                      #endif
    val = (UINT8)A; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   A,X                     ; 83C1: EC 86         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + (SINT8)A); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,U                      ; 83C3: ED C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LEAU  $04,U                   ; 83C5: 33 44         \n");
                                      #endif
    clockticks = clockticks + 5; 
    U = (U + 0x0004); 
                                                     #ifdef DEBUG
                                      mon("         CMPU  #$4B5F                  ; 83C7: 11 83 4B 5F   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
    arg = 0x4b5f; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   L83BA                   ; 83CB: 25 ED         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L83BA;
    }
    // End of function sub_83A4
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 83CD: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x83CE:
L83CE:
                                                     #ifdef DEBUG
                                      mon("L83CE    LDA   <$92                    ; 83CE: 96 92         \n");
                                      #endif
    PC = 0x83ce; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x92); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   locret_8407             ; 83D0: 26 35         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L8407;
    }
                                                     #ifdef DEBUG
                                      mon("         LDU   $49B3                   ; 83D2: FE 49 B3      \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x49b3)<<8; 
    ea = ea | rd_mem(0x49b4); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LEAU  $03,U                   ; 83D5: 33 43         \n");
                                      #endif
    clockticks = clockticks + 5; 
    U = (U + 0x0003); 
                                                     #ifdef DEBUG
                                      mon("         LDA   ,U                      ; 83D7: A6 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(U); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$05                    ; 83D9: 81 05         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x05; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   L83E2                   ; 83DB: 26 05         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L83E2;
    }
                                                     #ifdef DEBUG
                                      mon("         LDU   $49AB                   ; 83DD: FE 49 AB      \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x49ab)<<8; 
    ea = ea | rd_mem(0x49ac); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   $02,U                   ; 83E0: EE 42         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0002))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0002))+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0x83E2:
L83E2:
                                                     #ifdef DEBUG
                                      mon("L83E2    LDB   ,U                      ; 83E2: E6 C4         \n");
                                      #endif
    PC = 0x83e2; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(U); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$01                    ; 83E4: C1 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x01; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   L83ED                   ; 83E6: 26 05         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L83ED;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0800                  ; 83E8: CC 08 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x08; 
    B = 0x00; 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   L83F9                   ; 83EB: 20 0C         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L83F9;
    
    // ---------------------------------------------------------------------------
  case 0x83ED:
L83ED:
                                                     #ifdef DEBUG
                                      mon("L83ED    CMPB  #$03                    ; 83ED: C1 03         \n");
                                      #endif
    PC = 0x83ed; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x03; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   L83F6                   ; 83EF: 26 05         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L83F6;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; 83F1: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   L83F9                   ; 83F4: 20 03         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L83F9;
    
    // ---------------------------------------------------------------------------
  case 0x83F6:
L83F6:
                                                     #ifdef DEBUG
                                      mon("L83F6    LDD   #$1000                  ; 83F6: CC 10 00      \n");
                                      #endif
    PC = 0x83f6; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x10; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0x83F9:
L83F9:
                                                     #ifdef DEBUG
                                      mon("L83F9    ADDD  $49B7                   ; 83F9: F3 49 B7      \n");
                                      #endif
    PC = 0x83f9; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x49b7)<<8; 
    ea = ea | rd_mem(0x49b8); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $49B1                   ; 83FC: B3 49 B1      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x49b1)<<8; 
    ea = ea | rd_mem(0x49b2); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$6000                  ; 83FF: 83 60 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x6000; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BHI   locret_8407             ; 8402: 22 03         \n");
                                      #endif
    // temp hack to force a flush
    if (Z && (!C)) {
    clockticks = clockticks + 3; 
    goto L8407;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   L8408                   ; 8404: BD 84 08      \n");
                                      #endif // Trench
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x07); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x84); 
    clockticks = clockticks + 1; 
    goto L8408;
    // End of function sub_83CE
  case 0x8407:
L8407:
locret_8407:
                                                     #ifdef DEBUG
                                      mon("locret_8407 RTS                           ; 8407: 39            \n");
                                      #endif
    PC = 0x8407; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Trench
  case 0x8408:
L8408:
                                                     #ifdef DEBUG
                                      mon("L8408    LDU   $49B3                   ; 8408: FE 49 B3      \n");
                                      #endif
    PC = 0x8408; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x49b3)<<8; 
    ea = ea | rd_mem(0x49b4); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   ,U                      ; 840B: E6 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(U); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$01                    ; 840D: C1 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x01; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   L8416                   ; 840F: 26 05         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L8416;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0800                  ; 8411: CC 08 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x08; 
    B = 0x00; 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   L8419                   ; 8414: 20 03         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L8419;
    
    // ---------------------------------------------------------------------------
  case 0x8416:
L8416:
                                                     #ifdef DEBUG
                                      mon("L8416    LDD   #$1000                  ; 8416: CC 10 00      \n");
                                      #endif
    PC = 0x8416; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x10; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0x8419:
L8419:
                                                     #ifdef DEBUG
                                      mon("L8419    ADDD  $49B5                   ; 8419: F3 49 B5      \n");
                                      #endif
    PC = 0x8419; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x49b5)<<8; 
    ea = ea | rd_mem(0x49b6); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $49B5                   ; 841C: FD 49 B5      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x49b5, A); // Care needed with I/O space and word fetches
    wr_mem(0x49b6, B); 
                                                     #ifdef DEBUG
                                      mon("         LEAU  $03,U                   ; 841F: 33 43         \n");
                                      #endif
    clockticks = clockticks + 5; 
    U = (U + 0x0003); 
                                                     #ifdef DEBUG
                                      mon("         LDB   ,U                      ; 8421: E6 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(U); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$05                    ; 8423: C1 05         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x05; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
  case 0x8425:
L8425:
                                                     #ifdef DEBUG
                                      mon("L8425    BNE   L8431                   ; 8425: 26 0A         \n");
                                      #endif
    PC = 0x8425; 
    INSTRUCTION_START
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L8431;
    }
                                                     #ifdef DEBUG
                                      mon("         LDU   $49AB                   ; 8427: FE 49 AB      \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x49ab)<<8; 
    ea = ea | rd_mem(0x49ac); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LEAU  $02,U                   ; 842A: 33 42         \n");
                                      #endif
    clockticks = clockticks + 5; 
    U = (U + 0x0002); 
                                                     #ifdef DEBUG
                                      mon("         STU   $49AB                   ; 842C: FF 49 AB      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    wr_mem(0x49ab, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem(0x49ac, (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         LDU   ,U                      ; 842F: EE C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(U)<<8; 
    ea = ea | rd_mem((UINT16)((U)+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0x8431:
L8431:
                                                     #ifdef DEBUG
                                      mon("L8431    STU   $49B3                   ; 8431: FF 49 B3      \n");
                                      #endif
    PC = 0x8431; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    wr_mem(0x49b3, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem(0x49b4, (UINT8)val); 
  case 0x8434:
L8434:
                                                     #ifdef DEBUG
                                      mon("L8434    LDU   $49B3                   ; 8434: FE 49 B3      \n");
                                      #endif
    PC = 0x8434; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x49b3)<<8; 
    ea = ea | rd_mem(0x49b4); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   ,U                      ; 8437: E6 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(U); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$03                    ; 8439: C1 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x03; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   L8447                   ; 843B: 26 0A         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L8447;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $49B5                   ; 843D: FC 49 B5      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x49b5); // Care needed with I/O space and word fetches
    B = rd_mem(0x49b6); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$93                    ; 8440: DD 93         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x93; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$FF                    ; 8442: 86 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xff; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$92                    ; 8444: 97 92         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0x92; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 8446: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
  case 0x8447:
L8447:
                                                     #ifdef DEBUG
                                      mon("L8447    LDB   ,U                      ; 8447: E6 C4         \n");
                                      #endif
    PC = 0x8447; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(U); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$04                    ; 8449: C1 04         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x04; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   L846A                   ; 844B: 26 1D         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L846A;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $49B5                   ; 844D: FC 49 B5      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x49b5); // Care needed with I/O space and word fetches
    B = rd_mem(0x49b6); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$96                    ; 8450: DD 96         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x96; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$FF                    ; 8452: 86 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xff; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$95                    ; 8454: 97 95         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x95; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; 8456: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$44                    ; 8458: 97 44         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x44; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   <$45                    ; 845A: 97 45         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x45; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B36                   ; 845C: B6 4B 36      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b36); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L846A                   ; 845F: 26 09         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L846A;
    }
                                                     #ifdef DEBUG
                                      mon("         INC   $4B36                   ; 8461: 7C 4B 36      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b36); 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    wr_mem(0x4b36, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         JSR   L97E3                   ; 8464: BD 97 E3      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x67); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x84); 
    clockticks = clockticks + 1; 
    goto L97E3;
  case 0x8467:
L8467:
                                                     #ifdef DEBUG
                                      mon("L8467    LDU   $49B3                   ; 8467: FE 49 B3      \n");
                                      #endif
    PC = 0x8467; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x49b3)<<8; 
    ea = ea | rd_mem(0x49b4); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0x846A:
L846A:
                                                     #ifdef DEBUG
                                      mon("L846A    LDB   ,U                      ; 846A: E6 C4         \n");
                                      #endif
    PC = 0x846a; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(U); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$01                    ; 846C: C1 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x01; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   L8475                   ; 846E: 26 05         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L8475;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0800                  ; 8470: CC 08 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x08; 
    B = 0x00; 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   L8478                   ; 8473: 20 03         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L8478;
    
    // ---------------------------------------------------------------------------
  case 0x8475:
L8475:
                                                     #ifdef DEBUG
                                      mon("L8475    LDD   #$1000                  ; 8475: CC 10 00      \n");
                                      #endif
    PC = 0x8475; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x10; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0x8478:
L8478:
                                                     #ifdef DEBUG
                                      mon("L8478    ADDD  $49B5                   ; 8478: F3 49 B5      \n");
                                      #endif
    PC = 0x8478; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x49b5)<<8; 
    ea = ea | rd_mem(0x49b6); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $49B7                   ; 847B: FD 49 B7      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x49b7, A); // Care needed with I/O space and word fetches
    wr_mem(0x49b8, B); 
                                                     #ifdef DEBUG
                                      mon("         LDB   $49B5                   ; 847E: F6 49 B5      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x49b5); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LSRB                          ; 8481: 54            \n");
                                      #endif
    val = (UINT8)B; 
 // C = val & 1; 
    val = val >> 1; 
    B = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRB                          ; 8482: 54            \n");
                                      #endif
    val = (UINT8)B; 
 // C = val & 1; 
    val = val >> 1; 
    B = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRB                          ; 8483: 54            \n");
                                      #endif
    val = (UINT8)B; 
    C = val & 1; 
    val = val >> 1; 
    B = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$0F                    ; 8484: C4 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x0f; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4989                  ; 8486: 8E 49 89      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x4989; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $01,U                   ; 8489: A6 41         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(U + 0x0001)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   B,X                     ; 848B: A7 85         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + (SINT8)B); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4999                  ; 848D: 8E 49 99      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x4999; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $02,U                   ; 8490: A6 42         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(U + 0x0002)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   B,X                     ; 8492: A7 85         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = (UINT16)(X + (SINT8)B); 
    wr_mem(ea, val); 
    // End of function sub_8408
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 8494: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x8495:
L8495:
                                                     #ifdef DEBUG
                                      mon("L8495    LDA   <$45                    ; 8495: 96 45         \n");
                                      #endif
    PC = 0x8495; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x45); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   locret_84B5             ; 8497: 26 1C         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L84B5;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   $4B19                   ; 8499: F6 4B 19      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b19); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$07                    ; 849C: C1 07         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x07; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BLS   L84A2                   ; 849E: 23 02         \n");
                                      #endif
    // temp hack to force a flush
    if ((!Z) || C) {
    clockticks = clockticks + 3; 
    goto L84A2;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   #$07                    ; 84A0: C6 07         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x07; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0x84A2:
L84A2:
                                                     #ifdef DEBUG
                                      mon("L84A2    ASLB                          ; 84A2: 58            \n");
                                      #endif
    PC = 0x84a2; 
    INSTRUCTION_START
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #byte_84B6              ; 84A3: CE 84 B6      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x84b6; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LEAU  B,U                     ; 84A6: 33 C5         \n");
                                      #endif
    clockticks = clockticks + 5; 
    U = (U + (SINT8)B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$43                    ; 84A8: 96 43         \n");
                                      #endif // Game over/insert coins timer
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x43); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  ,U                      ; 84AA: A4 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)A; 
    res = val & rd_mem(U); 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   locret_84B5             ; 84AC: 26 07         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L84B5;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $01,U                   ; 84AE: A6 41         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(U + 0x0001)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$9B                    ; 84B0: 97 9B         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0x9b; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   L84C6                   ; 84B2: BD 84 C6      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xb5); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x84); 
    clockticks = clockticks + 1; 
    goto L84C6;
    // End of function sub_8495
    // ---------------------------------------------------------------------------
  case 0x84B5:
L84B5:
locret_84B5:
                                                     #ifdef DEBUG
                                      mon("locret_84B5 RTS                           ; 84B5: 39            \n");
                                      #endif
    PC = 0x84b5; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x84C6:
L84C6:
                                                     #ifdef DEBUG
                                      mon("L84C6    LDD   #$F800                  ; 84C6: CC F8 00      \n");
                                      #endif
    PC = 0x84c6; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0xf8; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  $5098                   ; 84C9: B4 50 98      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    res = val & rd_mem(0x5098); 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDA  #$24                    ; 84CC: 8B 24         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x24; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5078                   ; 84CE: FD 50 78      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5078, A); // Care needed with I/O space and word fetches
    wr_mem(0x5079, B); 
  case 0x84D1:
L84D1:
                                                     #ifdef DEBUG
                                      mon("L84D1    LDA   $5078                   ; 84D1: B6 50 78      \n");
                                      #endif
    PC = 0x84d1; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x5078); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; 84D4: 44            \n");
                                      #endif
    val = (UINT8)A; 
 // C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; 84D5: 44            \n");
                                      #endif
    val = (UINT8)A; 
 // C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; 84D6: 44            \n");
                                      #endif
    val = (UINT8)A; 
 // C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$0F                    ; 84D7: 84 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x0f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$99                    ; 84D9: 97 99         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x99; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$FE00                  ; 84DB: CC FE 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xfe; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $507C                   ; 84DE: FD 50 7C      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x507c, A); // Care needed with I/O space and word fetches
    wr_mem(0x507d, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$FC80                  ; 84E1: CC FC 80      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xfc; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $507A                   ; 84E4: FD 50 7A      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x507a, A); // Care needed with I/O space and word fetches
    wr_mem(0x507b, B); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4989                  ; 84E7: 8E 49 89      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x4989; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   <$99                    ; 84EA: D6 99         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x99); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   B,X                     ; 84EC: A6 85         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + (SINT8)B)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0x84EE:
L84EE:
                                                     #ifdef DEBUG
                                      mon("L84EE    STA   <$9A                    ; 84EE: 97 9A         \n");
                                      #endif
    PC = 0x84ee; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x9a; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$C0                    ; 84F0: 84 C0         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0xc0; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$C0                    ; 84F2: 81 C0         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xc0; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   L8522                   ; 84F4: 26 2C         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L8522;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $509C                   ; 84F6: FC 50 9C      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x509c); // Care needed with I/O space and word fetches
    B = rd_mem(0x509d); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $507C                   ; 84F9: B3 50 7C      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x507c)<<8; 
    ea = ea | rd_mem(0x507d); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BLT   L8522                   ; 84FC: 2D 24         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 3; 
    goto L8522;
    }
  case 0x84FE:
L84FE:
                                                     #ifdef DEBUG
                                      mon("L84FE    SUBD  #$0400                  ; 84FE: 83 04 00      \n");
                                      #endif
    PC = 0x84fe; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = 0x0400; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BGE   L850F                   ; 8501: 2C 0C         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) >= 0) {
    clockticks = clockticks + 3; 
    goto L850F;
    }
  case 0x8503:
L8503:
                                                     #ifdef DEBUG
                                      mon("L8503    LDA   $4703                   ; 8503: B6 47 03      \n");
                                      #endif
    PC = 0x8503; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  <$9B                    ; 8506: 91 9B         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)A; 
    arg = rd_mem(DP|0x9b); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   L850D                   ; 8508: 25 03         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L850D;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   LA7F7                   ; 850A: BD A7 F7      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x0d); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x85); 
    clockticks = clockticks + 1; 
    goto LA7F7;
  case 0x850D:
L850D:
                                                     #ifdef DEBUG
                                      mon("L850D    BRA   L8522                   ; 850D: 20 13         \n");
                                      #endif
    PC = 0x850d; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto L8522;
    
    // ---------------------------------------------------------------------------
  case 0x850F:
L850F:
                                                     #ifdef DEBUG
                                      mon("L850F    SUBD  #$0400                  ; 850F: 83 04 00      \n");
                                      #endif
    PC = 0x850f; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = 0x0400; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BGE   L8522                   ; 8512: 2C 0E         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) >= 0) {
    clockticks = clockticks + 3; 
    goto L8522;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4703                   ; 8514: B6 47 03      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $4703                   ; 8517: F6 47 03      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         MUL                           ; 851A: 3D            \n");
                                      #endif
    res = (UINT16)(A * B); 
 // Z = res; 
 // C = res & 0x80; 
    A = res >> 8; 
    B = (UINT8)res; 
    clockticks = clockticks + 11; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  <$9B                    ; 851B: 91 9B         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)A; 
    arg = rd_mem(DP|0x9b); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   L8522                   ; 851D: 25 03         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L8522;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   LA7F7                   ; 851F: BD A7 F7      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x22); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x85); 
    clockticks = clockticks + 1; 
    goto LA7F7;
  case 0x8522:
L8522:
                                                     #ifdef DEBUG
                                      mon("L8522    LDD   $507C                   ; 8522: FC 50 7C      \n");
                                      #endif
    PC = 0x8522; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x507c); // Care needed with I/O space and word fetches
    B = rd_mem(0x507d); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$0400                  ; 8525: 83 04 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0400; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $507C                   ; 8528: FD 50 7C      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x507c, A); // Care needed with I/O space and word fetches
    wr_mem(0x507d, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$9A                    ; 852B: 96 9A         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x9a); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLA                          ; 852D: 48            \n");
                                      #endif
    val = (UINT8)A; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLA                          ; 852E: 48            \n");
                                      #endif
    val = (UINT8)A; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
    Z = res; 
    N = res; 
    V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L84EE                   ; 852F: 26 BD         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L84EE;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$FE00                  ; 8531: CC FE 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xfe; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $507C                   ; 8534: FD 50 7C      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x507c, A); // Care needed with I/O space and word fetches
    wr_mem(0x507d, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0380                  ; 8537: CC 03 80      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x03; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $507A                   ; 853A: FD 50 7A      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x507a, A); // Care needed with I/O space and word fetches
    wr_mem(0x507b, B); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4999                  ; 853D: 8E 49 99      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x4999; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   <$99                    ; 8540: D6 99         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x99); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   B,X                     ; 8542: A6 85         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + (SINT8)B)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0x8544:
L8544:
                                                     #ifdef DEBUG
                                      mon("L8544    STA   <$9A                    ; 8544: 97 9A         \n");
                                      #endif
    PC = 0x8544; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x9a; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$C0                    ; 8546: 84 C0         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0xc0; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$C0                    ; 8548: 81 C0         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xc0; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   L8578                   ; 854A: 26 2C         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L8578;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $509C                   ; 854C: FC 50 9C      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x509c); // Care needed with I/O space and word fetches
    B = rd_mem(0x509d); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $507C                   ; 854F: B3 50 7C      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x507c)<<8; 
    ea = ea | rd_mem(0x507d); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BLT   L8578                   ; 8552: 2D 24         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 3; 
    goto L8578;
    }
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$0400                  ; 8554: 83 04 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0400; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BGE   L8565                   ; 8557: 2C 0C         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) >= 0) {
    clockticks = clockticks + 3; 
    goto L8565;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4703                   ; 8559: B6 47 03      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  <$9B                    ; 855C: 91 9B         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)A; 
    arg = rd_mem(DP|0x9b); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   L8563                   ; 855E: 25 03         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L8563;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   LA80B                   ; 8560: BD A8 0B      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x63); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x85); 
    clockticks = clockticks + 1; 
    goto LA80B;
  case 0x8563:
L8563:
                                                     #ifdef DEBUG
                                      mon("L8563    BRA   L8578                   ; 8563: 20 13         \n");
                                      #endif
    PC = 0x8563; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto L8578;
    
    // ---------------------------------------------------------------------------
  case 0x8565:
L8565:
                                                     #ifdef DEBUG
                                      mon("L8565    SUBD  #$0400                  ; 8565: 83 04 00      \n");
                                      #endif
    PC = 0x8565; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = 0x0400; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BGE   L8578                   ; 8568: 2C 0E         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) >= 0) {
    clockticks = clockticks + 3; 
    goto L8578;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4703                   ; 856A: B6 47 03      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $4703                   ; 856D: F6 47 03      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         MUL                           ; 8570: 3D            \n");
                                      #endif
    res = (UINT16)(A * B); 
 // Z = res; 
 // C = res & 0x80; 
    A = res >> 8; 
    B = (UINT8)res; 
    clockticks = clockticks + 11; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  <$9B                    ; 8571: 91 9B         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)A; 
    arg = rd_mem(DP|0x9b); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   L8578                   ; 8573: 25 03         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L8578;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   LA80B                   ; 8575: BD A8 0B      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x78); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x85); 
    clockticks = clockticks + 1; 
    goto LA80B;
  case 0x8578:
L8578:
                                                     #ifdef DEBUG
                                      mon("L8578    LDD   $507C                   ; 8578: FC 50 7C      \n");
                                      #endif
    PC = 0x8578; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x507c); // Care needed with I/O space and word fetches
    B = rd_mem(0x507d); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$0400                  ; 857B: 83 04 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0400; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $507C                   ; 857E: FD 50 7C      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x507c, A); // Care needed with I/O space and word fetches
    wr_mem(0x507d, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$9A                    ; 8581: 96 9A         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x9a); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLA                          ; 8583: 48            \n");
                                      #endif
    val = (UINT8)A; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLA                          ; 8584: 48            \n");
                                      #endif
    val = (UINT8)A; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
    Z = res; 
    N = res; 
    V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L8544                   ; 8585: 26 BD         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L8544;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $5078                   ; 8587: FC 50 78      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x5078); // Care needed with I/O space and word fetches
    B = rd_mem(0x5079); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$0800                  ; 858A: C3 08 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0800; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5078                   ; 858D: FD 50 78      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5078, A); // Care needed with I/O space and word fetches
    wr_mem(0x5079, B); 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5098                   ; 8590: B3 50 98      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5098)<<8; 
    ea = ea | rd_mem(0x5099); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$6000                  ; 8593: 83 60 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x6000; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         LBCS  L84D1                   ; 8596: 10 25 FF 37   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if (C) {
    clockticks = clockticks + 1; 
    goto L84D1;
    }
    // End of function sub_84C6
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 859A: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x859B:
L859B:
                                                     #ifdef DEBUG
                                      mon("L859B    LDA   $5040                   ; 859B: B6 50 40      \n");
                                      #endif // XT2
    PC = 0x859b; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x5040); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; 859E: 44            \n");
                                      #endif
    val = (UINT8)A; 
 // C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; 859F: 44            \n");
                                      #endif
    val = (UINT8)A; 
 // C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; 85A0: 44            \n");
                                      #endif
    val = (UINT8)A; 
 // C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$0F                    ; 85A1: 84 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x0f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  $49BF                   ; 85A3: B1 49 BF      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    arg = rd_mem(0x49bf); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L85DE                   ; 85A6: 27 36         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L85DE;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   $49BF                   ; 85A8: F6 49 BF      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x49bf); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $49BF                   ; 85AB: B7 49 BF      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x49bf, val); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4989                  ; 85AE: 8E 49 89      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x4989; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   B,X                     ; 85B1: A6 85         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + (SINT8)B)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0x85B3:
L85B3:
                                                     #ifdef DEBUG
                                      mon("L85B3    ASLA                          ; 85B3: 48            \n");
                                      #endif
    PC = 0x85b3; 
    INSTRUCTION_START
    val = (UINT8)A; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
    Z = res; 
    N = res; 
    V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BCC   L85BD                   ; 85B4: 24 07         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto L85BD;
    }
                                                     #ifdef DEBUG
                                      mon("         BMI   L85BD                   ; 85B6: 2B 05         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto L85BD;
    }
                                                     #ifdef DEBUG
                                      mon("         INC   $49C0                   ; 85B8: 7C 49 C0      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x49c0); 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    wr_mem(0x49c0, res); 
    clockticks = clockticks + 2; 
  case 0x85BB:
L85BB:
                                                     #ifdef DEBUG
                                      mon("L85BB    BRA   L85D2                   ; 85BB: 20 15         \n");
                                      #endif
    PC = 0x85bb; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto L85D2;
    
    // ---------------------------------------------------------------------------
  case 0x85BD:
L85BD:
                                                     #ifdef DEBUG
                                      mon("L85BD    ASLA                          ; 85BD: 48            \n");
                                      #endif
    PC = 0x85bd; 
    INSTRUCTION_START
    val = (UINT8)A; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
    Z = res; 
    N = res; 
    V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L85B3                   ; 85BE: 26 F3         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L85B3;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4999                  ; 85C0: 8E 49 99      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x4999; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   B,X                     ; 85C3: A6 85         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + (SINT8)B)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0x85C5:
L85C5:
                                                     #ifdef DEBUG
                                      mon("L85C5    ASLA                          ; 85C5: 48            \n");
                                      #endif
    PC = 0x85c5; 
    INSTRUCTION_START
    val = (UINT8)A; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
    Z = res; 
    N = res; 
    V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BCC   L85CF                   ; 85C6: 24 07         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto L85CF;
    }
                                                     #ifdef DEBUG
                                      mon("         BMI   L85CF                   ; 85C8: 2B 05         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto L85CF;
    }
                                                     #ifdef DEBUG
                                      mon("         INC   $49C0                   ; 85CA: 7C 49 C0      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x49c0); 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    wr_mem(0x49c0, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BRA   L85D2                   ; 85CD: 20 03         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L85D2;
    
    // ---------------------------------------------------------------------------
  case 0x85CF:
L85CF:
                                                     #ifdef DEBUG
                                      mon("L85CF    ASLA                          ; 85CF: 48            \n");
                                      #endif
    PC = 0x85cf; 
    INSTRUCTION_START
    val = (UINT8)A; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
    Z = res; 
    N = res; 
    V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L85C5                   ; 85D0: 26 F3         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L85C5;
    }
  case 0x85D2:
L85D2:
                                                     #ifdef DEBUG
                                      mon("L85D2    LDA   #$00                    ; 85D2: 86 00         \n");
                                      #endif
    PC = 0x85d2; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4989                  ; 85D4: 8E 49 89      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x4989; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   B,X                     ; 85D7: A7 85         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + (SINT8)B); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4999                  ; 85D9: 8E 49 99      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x4999; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   B,X                     ; 85DC: A7 85         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + (SINT8)B); 
    wr_mem(ea, val); 
  case 0x85DE:
L85DE:
                                                     #ifdef DEBUG
                                      mon("L85DE    JSR   LB3E4                   ; 85DE: BD B3 E4      \n");
                                      #endif
    PC = 0x85de; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xe1); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x85); 
    clockticks = clockticks + 1; 
    goto LB3E4;
  case 0x85E1:
L85E1:
                                                     #ifdef DEBUG
                                      mon("L85E1    JSR   L85F9                   ; 85E1: BD 85 F9      \n");
                                      #endif
    PC = 0x85e1; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xe4); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x85); 
    clockticks = clockticks + 1; 
    goto L85F9;
  case 0x85E4:
L85E4:
                                                     #ifdef DEBUG
                                      mon("L85E4    JSR   L8735                   ; 85E4: BD 87 35      \n");
                                      #endif
    PC = 0x85e4; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xe7); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x85); 
    clockticks = clockticks + 1; 
    goto L8735;
  case 0x85E7:
L85E7:
                                                     #ifdef DEBUG
                                      mon("L85E7    JSR   L86AE                   ; 85E7: BD 86 AE      \n");
                                      #endif
    PC = 0x85e7; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xea); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x85); 
    clockticks = clockticks + 1; 
    goto L86AE;
  case 0x85EA:
L85EA:
                                                     #ifdef DEBUG
                                      mon("L85EA    LDA   <$95                    ; 85EA: 96 95         \n");
                                      #endif
    PC = 0x85ea; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x95); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L85F1                   ; 85EC: 27 03         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L85F1;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   L889F                   ; 85EE: BD 88 9F      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf1); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x85); 
    clockticks = clockticks + 1; 
    goto L889F;
  case 0x85F1:
L85F1:
                                                     #ifdef DEBUG
                                      mon("L85F1    LDA   <$92                    ; 85F1: 96 92         \n");
                                      #endif
    PC = 0x85f1; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x92); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   locret_85F8             ; 85F3: 27 03         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L85F8;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   L88F5                   ; 85F5: BD 88 F5      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x85); 
    clockticks = clockticks + 1; 
    goto L88F5;
    // End of function sub_859B
  case 0x85F8:
L85F8:
locret_85F8:
                                                     #ifdef DEBUG
                                      mon("locret_85F8 RTS                           ; 85F8: 39            \n");
                                      #endif
    PC = 0x85f8; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x85F9:
L85F9:
                                                     #ifdef DEBUG
                                      mon("L85F9    LDD   #$00                    ; 85F9: CC 00 00      \n");
                                      #endif
    PC = 0x85f9; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5040                   ; 85FC: FD 50 40      \n");
                                      #endif // XT2
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5040, A); // Care needed with I/O space and word fetches
    wr_mem(0x5041, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$6270                  ; 85FF: CC 62 70      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x62; 
    B = 0x70; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 8602: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #word_8696              ; 8604: CE 86 96      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x8696; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0x8607:
L8607:
                                                     #ifdef DEBUG
                                      mon("L8607    LDA   <$92                    ; 8607: 96 92         \n");
                                      #endif
    PC = 0x8607; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x92); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L8618                   ; 8609: 27 0D         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L8618;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   <$93                    ; 860B: DC 93         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x93); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x94); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5098                   ; 860D: B3 50 98      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5098)<<8; 
    ea = ea | rd_mem(0x5099); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$7000                  ; 8610: 10 83 70 00   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x7000; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BHI   L8618                   ; 8614: 22 02         \n");
                                      #endif
    // temp hack to force a flush
    if (Z && (!C)) {
    clockticks = clockticks + 3; 
    goto L8618;
    }
                                                     #ifdef DEBUG
                                      mon("         BRA   L861B                   ; 8616: 20 03         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L861B;
    
    // ---------------------------------------------------------------------------
  case 0x8618:
L8618:
                                                     #ifdef DEBUG
                                      mon("L8618    LDD   #$7000                  ; 8618: CC 70 00      \n");
                                      #endif
    PC = 0x8618; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x70; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0x861B:
L861B:
                                                     #ifdef DEBUG
                                      mon("L861B    STD   $5078                   ; 861B: FD 50 78      \n");
                                      #endif
    PC = 0x861b; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5078, A); // Care needed with I/O space and word fetches
    wr_mem(0x5079, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   ,U                      ; 861E: EC C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(U); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(U+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $507A                   ; 8620: FD 50 7A      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x507a, A); // Care needed with I/O space and word fetches
    wr_mem(0x507b, B); 
  case 0x8623:
L8623:
                                                     #ifdef DEBUG
                                      mon("L8623    LDD   $02,U                   ; 8623: EC 42         \n");
                                      #endif
    PC = 0x8623; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0x0002); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $507C                   ; 8625: FD 50 7C      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x507c, A); // Care needed with I/O space and word fetches
    wr_mem(0x507d, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0F                    ; 8628: CC 00 0F      \n");
                                      #endif // Point BIC to $5078 MReg3C
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x0f; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4701                   ; 862B: FD 47 01      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4701, A); // Care needed with I/O space and word fetches
    wr_mem(0x4702, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$67                    ; 862E: 86 67         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x67; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCDBA                   ; 8630: BD CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x33); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x86); 
    clockticks = clockticks + 1; 
    goto LCDBA;
  case 0x8633:
L8633:
                                                     #ifdef DEBUG
                                      mon("L8633    LDD   $5000                   ; 8633: FC 50 00      \n");
                                      #endif // Math result X
    PC = 0x8633; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x5000); // Care needed with I/O space and word fetches
    B = rd_mem(0x5001); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4704                   ; 8636: FD 47 04      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4704, A); // Care needed with I/O space and word fetches
    wr_mem(0x4705, B); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCCE4                   ; 8639: BD CC E4      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x3c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x86); 
    clockticks = clockticks + 1; 
    goto LCCE4;
  case 0x863C:
L863C:
                                                     #ifdef DEBUG
                                      mon("L863C    LDD   #$0200                  ; 863C: CC 02 00      \n");
                                      #endif
    PC = 0x863c; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x02; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5078                   ; 863F: FD 50 78      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5078, A); // Care needed with I/O space and word fetches
    wr_mem(0x5079, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $507A                   ; 8642: FC 50 7A      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x507a); // Care needed with I/O space and word fetches
    B = rd_mem(0x507b); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $509A                   ; 8645: B3 50 9A      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x509a)<<8; 
    ea = ea | rd_mem(0x509b); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BPL   L864E                   ; 8648: 2A 04         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto L864E;
    }
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; 864A: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; 864B: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SBCA  #$FF                    ; 864C: 82 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xff; 
    res = val - (UINT8)arg - (C != 0 ? 1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)res; 
  case 0x864E:
L864E:
                                                     #ifdef DEBUG
                                      mon("L864E    CMPD  $5078                   ; 864E: 10 B3 50 78   \n");
                                      #endif
    PC = 0x864e; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5078)<<8; 
    ea = ea | rd_mem(0x5079); 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = ea; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
    clockticks = clockticks + 1; 
                                                     #ifdef DEBUG
                                      mon("         BLE   L8657                   ; 8652: 2F 03         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto L8657;
    }
                                                     #ifdef DEBUG
                                      mon("         STD   $5078                   ; 8654: FD 50 78      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5078, A); // Care needed with I/O space and word fetches
    wr_mem(0x5079, B); 
  case 0x8657:
L8657:
                                                     #ifdef DEBUG
                                      mon("L8657    LDD   $507C                   ; 8657: FC 50 7C      \n");
                                      #endif
    PC = 0x8657; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x507c); // Care needed with I/O space and word fetches
    B = rd_mem(0x507d); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $509C                   ; 865A: B3 50 9C      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x509c)<<8; 
    ea = ea | rd_mem(0x509d); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BPL   L8663                   ; 865D: 2A 04         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto L8663;
    }
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; 865F: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; 8660: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SBCA  #$FF                    ; 8661: 82 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xff; 
    res = val - (UINT8)arg - (C != 0 ? 1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)res; 
  case 0x8663:
L8663:
                                                     #ifdef DEBUG
                                      mon("L8663    CMPD  $5078                   ; 8663: 10 B3 50 78   \n");
                                      #endif
    PC = 0x8663; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5078)<<8; 
    ea = ea | rd_mem(0x5079); 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = ea; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
    clockticks = clockticks + 1; 
                                                     #ifdef DEBUG
                                      mon("         BLE   L866C                   ; 8667: 2F 03         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto L866C;
    }
                                                     #ifdef DEBUG
                                      mon("         STD   $5078                   ; 8669: FD 50 78      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5078, A); // Care needed with I/O space and word fetches
    wr_mem(0x5079, B); 
  case 0x866C:
L866C:
                                                     #ifdef DEBUG
                                      mon("L866C    LDD   #$0F                    ; 866C: CC 00 0F      \n");
                                      #endif // Point BIC to $5078 MReg3C
    PC = 0x866c; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x0f; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4701                   ; 866F: FD 47 01      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4701, A); // Care needed with I/O space and word fetches
    wr_mem(0x4702, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$67                    ; 8672: 86 67         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x67; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCDBA                   ; 8674: BD CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x77); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x86); 
    clockticks = clockticks + 1; 
    goto LCDBA;
  case 0x8677:
L8677:
                                                     #ifdef DEBUG
                                      mon("L8677    LDD   $5000                   ; 8677: FC 50 00      \n");
                                      #endif // Math result X
    PC = 0x8677; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x5000); // Care needed with I/O space and word fetches
    B = rd_mem(0x5001); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4704                   ; 867A: FD 47 04      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4704, A); // Care needed with I/O space and word fetches
    wr_mem(0x4705, B); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCCFC                   ; 867D: BD CC FC      \n");
                                      #endif // Trench floor lines calcs
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x80); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x86); 
    clockticks = clockticks + 1; 
    goto LCCFC;
  case 0x8680:
L8680:
                                                     #ifdef DEBUG
                                      mon("L8680    LDD   #$8040                  ; 8680: CC 80 40      \n");
                                      #endif
    PC = 0x8680; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 8683: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LEAU  $04,U                   ; 8685: 33 44         \n");
                                      #endif
    clockticks = clockticks + 5; 
    U = (U + 0x0004); 
                                                     #ifdef DEBUG
                                      mon("         CMPU  #L86AE                  ; 8687: 11 83 86 AE   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
    arg = 0x86ae; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         LBCS  L8607                   ; 868B: 10 25 FF 78   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if (C) {
    clockticks = clockticks + 1; 
    goto L8607;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $5098                   ; 868F: FC 50 98      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x5098); // Care needed with I/O space and word fetches
    B = rd_mem(0x5099); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5040                   ; 8692: FD 50 40      \n");
                                      #endif // XT2
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x5040, A); // Care needed with I/O space and word fetches
    wr_mem(0x5041, B); 
    // End of function sub_85F9
    // ---------------------------------------------------------------------------
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 8695: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x86AE:
L86AE:
                                                     #ifdef DEBUG
                                      mon("L86AE    LDD   #$00                    ; 86AE: CC 00 00      \n");
                                      #endif
    PC = 0x86ae; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5040                   ; 86B1: FD 50 40      \n");
                                      #endif // XT2
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5040, A); // Care needed with I/O space and word fetches
    wr_mem(0x5041, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$6250                  ; 86B4: CC 62 50      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x62; 
    B = 0x50; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 86B7: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #word_8725              ; 86B9: CE 87 25      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x8725; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$92                    ; 86BC: 96 92         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x92); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L86CD                   ; 86BE: 27 0D         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L86CD;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   <$93                    ; 86C0: DC 93         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x93); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x94); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5098                   ; 86C2: B3 50 98      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5098)<<8; 
    ea = ea | rd_mem(0x5099); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$7000                  ; 86C5: 10 83 70 00   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x7000; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BHI   L86CD                   ; 86C9: 22 02         \n");
                                      #endif
    // temp hack to force a flush
    if (Z && (!C)) {
    clockticks = clockticks + 3; 
    goto L86CD;
    }
                                                     #ifdef DEBUG
                                      mon("         BRA   L86D0                   ; 86CB: 20 03         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L86D0;
    
    // ---------------------------------------------------------------------------
  case 0x86CD:
L86CD:
                                                     #ifdef DEBUG
                                      mon("L86CD    LDD   #$7000                  ; 86CD: CC 70 00      \n");
                                      #endif
    PC = 0x86cd; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x70; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0x86D0:
L86D0:
                                                     #ifdef DEBUG
                                      mon("L86D0    STD   $5078                   ; 86D0: FD 50 78      \n");
                                      #endif
    PC = 0x86d0; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5078, A); // Care needed with I/O space and word fetches
    wr_mem(0x5079, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   ,U                      ; 86D3: EC C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(U); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(U+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $507A                   ; 86D5: FD 50 7A      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x507a, A); // Care needed with I/O space and word fetches
    wr_mem(0x507b, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $02,U                   ; 86D8: EC 42         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0x0002); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $507C                   ; 86DA: FD 50 7C      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x507c, A); // Care needed with I/O space and word fetches
    wr_mem(0x507d, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0F                    ; 86DD: CC 00 0F      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x0f; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4701                   ; 86E0: FD 47 01      \n");
                                      #endif // Point BIC to $5078 MReg3C
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4701, A); // Care needed with I/O space and word fetches
    wr_mem(0x4702, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$67                    ; 86E3: 86 67         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x67; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCDBA                   ; 86E5: BD CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xe8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x86); 
    clockticks = clockticks + 1; 
    goto LCDBA;
  case 0x86E8:
L86E8:
                                                     #ifdef DEBUG
                                      mon("L86E8    LDD   $5000                   ; 86E8: FC 50 00      \n");
                                      #endif // Math result X
    PC = 0x86e8; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x5000); // Care needed with I/O space and word fetches
    B = rd_mem(0x5001); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4704                   ; 86EB: FD 47 04      \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x4704, A); // Care needed with I/O space and word fetches
    wr_mem(0x4705, B); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCCE4                   ; 86EE: BD CC E4      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf1); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x86); 
    clockticks = clockticks + 1; 
    goto LCCE4;
  case 0x86F1:
L86F1:
                                                     #ifdef DEBUG
                                      mon("L86F1    BRA   L8711                   ; 86F1: 20 1E         \n");
                                      #endif
    PC = 0x86f1; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto L8711;
    
    // ---------------------------------------------------------------------------
  case 0x86F3:
L86F3:
                                                     #ifdef DEBUG
                                      mon("L86F3    LDD   ,U                      ; 86F3: EC C4         \n");
                                      #endif
    PC = 0x86f3; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(U); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(U+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $507A                   ; 86F5: FD 50 7A      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x507a, A); // Care needed with I/O space and word fetches
    wr_mem(0x507b, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $02,U                   ; 86F8: EC 42         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0x0002); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $507C                   ; 86FA: FD 50 7C      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x507c, A); // Care needed with I/O space and word fetches
    wr_mem(0x507d, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0F                    ; 86FD: CC 00 0F      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x0f; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4701                   ; 8700: FD 47 01      \n");
                                      #endif // Point BIC to $5078 MReg3C
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4701, A); // Care needed with I/O space and word fetches
    wr_mem(0x4702, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$67                    ; 8703: 86 67         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x67; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCDBA                   ; 8705: BD CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x08); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x87); 
    clockticks = clockticks + 1; 
    goto LCDBA;
  case 0x8708:
L8708:
                                                     #ifdef DEBUG
                                      mon("L8708    LDD   $5000                   ; 8708: FC 50 00      \n");
                                      #endif // Math result X
    PC = 0x8708; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x5000); // Care needed with I/O space and word fetches
    B = rd_mem(0x5001); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4704                   ; 870B: FD 47 04      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4704, A); // Care needed with I/O space and word fetches
    wr_mem(0x4705, B); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCCFC                   ; 870E: BD CC FC      \n");
                                      #endif // Trench floor lines calcs
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x11); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x87); 
    clockticks = clockticks + 1; 
    goto LCCFC;
  case 0x8711:
L8711:
                                                     #ifdef DEBUG
                                      mon("L8711    LEAU  $04,U                   ; 8711: 33 44         \n");
                                      #endif
    PC = 0x8711; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    U = (U + 0x0004); 
                                                     #ifdef DEBUG
                                      mon("         CMPU  #L8735                  ; 8713: 11 83 87 35   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
    arg = 0x8735; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   L86F3                   ; 8717: 25 DA         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L86F3;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$8040                  ; 8719: CC 80 40      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 871C: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   $5098                   ; 871E: FC 50 98      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x5098); // Care needed with I/O space and word fetches
    B = rd_mem(0x5099); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5040                   ; 8721: FD 50 40      \n");
                                      #endif // XT2
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x5040, A); // Care needed with I/O space and word fetches
    wr_mem(0x5041, B); 
    // End of function sub_86AE
    // ---------------------------------------------------------------------------
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 8724: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x8735:
L8735:
                                                     #ifdef DEBUG
                                      mon("L8735    LDU   $49AF                   ; 8735: FE 49 AF      \n");
                                      #endif
    PC = 0x8735; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x49af)<<8; 
    ea = ea | rd_mem(0x49b0); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   ,U                      ; 8738: E6 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(U); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$03                    ; 873A: C1 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x03; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   L873F                   ; 873C: 26 01         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L873F;
    }
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 873E: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
  case 0x873F:
L873F:
                                                     #ifdef DEBUG
                                      mon("L873F    CMPB  #$01                    ; 873F: C1 01         \n");
                                      #endif
    PC = 0x873f; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x01; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   L8748                   ; 8741: 26 05         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L8748;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0800                  ; 8743: CC 08 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x08; 
    B = 0x00; 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   L874B                   ; 8746: 20 03         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L874B;
    
    // ---------------------------------------------------------------------------
  case 0x8748:
L8748:
                                                     #ifdef DEBUG
                                      mon("L8748    LDD   #$1000                  ; 8748: CC 10 00      \n");
                                      #endif
    PC = 0x8748; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x10; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0x874B:
L874B:
                                                     #ifdef DEBUG
                                      mon("L874B    ADDD  $49B1                   ; 874B: F3 49 B1      \n");
                                      #endif
    PC = 0x874b; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x49b1)<<8; 
    ea = ea | rd_mem(0x49b2); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5040                   ; 874E: B3 50 40      \n");
                                      #endif // XT2
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5040)<<8; 
    ea = ea | rd_mem(0x5041); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BPL   L8786                   ; 8751: 2A 33         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto L8786;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   ,U                      ; 8753: E6 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(U); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0x8755:
L8755:
                                                     #ifdef DEBUG
                                      mon("L8755    CMPB  #$01                    ; 8755: C1 01         \n");
                                      #endif
    PC = 0x8755; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x01; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   L875E                   ; 8757: 26 05         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L875E;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0800                  ; 8759: CC 08 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x08; 
    B = 0x00; 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   L8761                   ; 875C: 20 03         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L8761;
    
    // ---------------------------------------------------------------------------
  case 0x875E:
L875E:
                                                     #ifdef DEBUG
                                      mon("L875E    LDD   #$1000                  ; 875E: CC 10 00      \n");
                                      #endif
    PC = 0x875e; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x10; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0x8761:
L8761:
                                                     #ifdef DEBUG
                                      mon("L8761    ADDD  $49B1                   ; 8761: F3 49 B1      \n");
                                      #endif
    PC = 0x8761; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x49b1)<<8; 
    ea = ea | rd_mem(0x49b2); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $49B1                   ; 8764: FD 49 B1      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x49b1, A); // Care needed with I/O space and word fetches
    wr_mem(0x49b2, B); 
                                                     #ifdef DEBUG
                                      mon("         LEAU  $03,U                   ; 8767: 33 43         \n");
                                      #endif
    clockticks = clockticks + 5; 
    U = (U + 0x0003); 
                                                     #ifdef DEBUG
                                      mon("         STU   $49AF                   ; 8769: FF 49 AF      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    wr_mem(0x49af, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem(0x49b0, (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         LDB   ,U                      ; 876C: E6 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(U); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$03                    ; 876E: C1 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x03; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   L8773                   ; 8770: 26 01         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L8773;
    }
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 8772: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
  case 0x8773:
L8773:
                                                     #ifdef DEBUG
                                      mon("L8773    LDB   ,U                      ; 8773: E6 C4         \n");
                                      #endif
    PC = 0x8773; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(U); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$05                    ; 8775: C1 05         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x05; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   L8783                   ; 8777: 26 0A         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L8783;
    }
                                                     #ifdef DEBUG
                                      mon("         LDU   $49A9                   ; 8779: FE 49 A9      \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x49a9)<<8; 
    ea = ea | rd_mem(0x49aa); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LEAU  $02,U                   ; 877C: 33 42         \n");
                                      #endif
    clockticks = clockticks + 5; 
    U = (U + 0x0002); 
                                                     #ifdef DEBUG
                                      mon("         STU   $49A9                   ; 877E: FF 49 A9      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    wr_mem(0x49a9, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem(0x49aa, (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         LDU   ,U                      ; 8781: EE C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(U)<<8; 
    ea = ea | rd_mem((UINT16)((U)+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0x8783:
L8783:
                                                     #ifdef DEBUG
                                      mon("L8783    STU   $49AF                   ; 8783: FF 49 AF      \n");
                                      #endif
    PC = 0x8783; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    wr_mem(0x49af, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem(0x49b0, (UINT8)val); 
  case 0x8786:
L8786:
                                                     #ifdef DEBUG
                                      mon("L8786    LDD   #$6260                  ; 8786: CC 62 60      \n");
                                      #endif
    PC = 0x8786; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x62; 
    B = 0x60; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 8789: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         JSR   L83CE                   ; 878B: BD 83 CE      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x8e); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x87); 
    clockticks = clockticks + 1; 
    goto L83CE;
  case 0x878E:
L878E:
                                                     #ifdef DEBUG
                                      mon("L878E    LDD   $49A9                   ; 878E: FC 49 A9      \n");
                                      #endif
    PC = 0x878e; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x49a9); // Care needed with I/O space and word fetches
    B = rd_mem(0x49aa); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $49AD                   ; 8791: FD 49 AD      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x49ad, A); // Care needed with I/O space and word fetches
    wr_mem(0x49ae, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $49AF                   ; 8794: FC 49 AF      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x49af); // Care needed with I/O space and word fetches
    B = rd_mem(0x49b0); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $49B9                   ; 8797: FD 49 B9      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x49b9, A); // Care needed with I/O space and word fetches
    wr_mem(0x49ba, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $49B1                   ; 879A: FC 49 B1      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x49b1); // Care needed with I/O space and word fetches
    B = rd_mem(0x49b2); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $49BB                   ; 879D: FD 49 BB      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x49bb, A); // Care needed with I/O space and word fetches
    wr_mem(0x49bc, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $5078                   ; 87A0: FD 50 78      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5078, A); // Care needed with I/O space and word fetches
    wr_mem(0x5079, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$FC00                  ; 87A3: CC FC 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xfc; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $507A                   ; 87A6: FD 50 7A      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x507a, A); // Care needed with I/O space and word fetches
    wr_mem(0x507b, B); 
  case 0x87A9:
L87A9:
                                                     #ifdef DEBUG
                                      mon("L87A9    JSR   L87CB                   ; 87A9: BD 87 CB      \n");
                                      #endif
    PC = 0x87a9; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xac); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x87); 
    clockticks = clockticks + 1; 
    goto L87CB;
  case 0x87AC:
L87AC:
                                                     #ifdef DEBUG
                                      mon("L87AC    LDD   $49A9                   ; 87AC: FC 49 A9      \n");
                                      #endif
    PC = 0x87ac; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x49a9); // Care needed with I/O space and word fetches
    B = rd_mem(0x49aa); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $49AD                   ; 87AF: FD 49 AD      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x49ad, A); // Care needed with I/O space and word fetches
    wr_mem(0x49ae, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $49AF                   ; 87B2: FC 49 AF      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x49af); // Care needed with I/O space and word fetches
    B = rd_mem(0x49b0); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $49B9                   ; 87B5: FD 49 B9      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x49b9, A); // Care needed with I/O space and word fetches
    wr_mem(0x49ba, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $49B1                   ; 87B8: FC 49 B1      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x49b1); // Care needed with I/O space and word fetches
    B = rd_mem(0x49b2); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $49BB                   ; 87BB: FD 49 BB      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x49bb, A); // Care needed with I/O space and word fetches
    wr_mem(0x49bc, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $5078                   ; 87BE: FD 50 78      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5078, A); // Care needed with I/O space and word fetches
    wr_mem(0x5079, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0400                  ; 87C1: CC 04 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x04; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $507A                   ; 87C4: FD 50 7A      \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x507a, A); // Care needed with I/O space and word fetches
    wr_mem(0x507b, B); 
                                                     #ifdef DEBUG
                                      mon("         JSR   L87CB                   ; 87C7: BD 87 CB      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xca); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x87); 
    clockticks = clockticks + 1; 
    goto L87CB;
    // End of function sub_8735
  case 0x87CA:
L87CA:
                                                     #ifdef DEBUG
                                      mon("L87CA    RTS                           ; 87CA: 39            \n");
                                      #endif
    PC = 0x87ca; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x87CB:
L87CB:
                                                     #ifdef DEBUG
                                      mon("L87CB    LDD   $49BB                   ; 87CB: FC 49 BB      \n");
                                      #endif
    PC = 0x87cb; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x49bb); // Care needed with I/O space and word fetches
    B = rd_mem(0x49bc); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5078                   ; 87CE: FD 50 78      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5078, A); // Care needed with I/O space and word fetches
    wr_mem(0x5079, B); 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5040                   ; 87D1: B3 50 40      \n");
                                      #endif // XT2
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5040)<<8; 
    ea = ea | rd_mem(0x5041); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         LBMI  L8866                   ; 87D4: 10 2B 00 8E   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if ((SINT8)N <  0) {
    clockticks = clockticks + 1; 
    goto L8866;
    }
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$0800                  ; 87D8: 10 83 08 00   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x0800; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BGE   L87F5                   ; 87DC: 2C 17         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) >= 0) {
    clockticks = clockticks + 3; 
    goto L87F5;
    }
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; 87DE: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLA                          ; 87DF: 49            \n");
                                      #endif
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; 87E0: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; 87E1: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SBCA  #$FF                    ; 87E2: 82 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xff; 
    res = val - (UINT8)arg - (C != 0 ? 1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $5044                   ; 87E4: F3 50 44      \n");
                                      #endif // ZT2
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5044)<<8; 
    ea = ea | rd_mem(0x5045); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$F000                  ; 87E7: 10 83 F0 00   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0xf000; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BGE   L87F0                   ; 87EB: 2C 03         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) >= 0) {
    clockticks = clockticks + 3; 
    goto L87F0;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$F000                  ; 87ED: CC F0 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xf0; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0x87F0:
L87F0:
                                                     #ifdef DEBUG
                                      mon("L87F0    STD   $507C                   ; 87F0: FD 50 7C      \n");
                                      #endif
    PC = 0x87f0; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x507c, A); // Care needed with I/O space and word fetches
    wr_mem(0x507d, B); 
                                                     #ifdef DEBUG
                                      mon("         BRA   L8801                   ; 87F3: 20 0C         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L8801;
    
    // ---------------------------------------------------------------------------
  case 0x87F5:
L87F5:
                                                     #ifdef DEBUG
                                      mon("L87F5    LDD   $49BB                   ; 87F5: FC 49 BB      \n");
                                      #endif
    PC = 0x87f5; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x49bb); // Care needed with I/O space and word fetches
    B = rd_mem(0x49bc); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5078                   ; 87F8: FD 50 78      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5078, A); // Care needed with I/O space and word fetches
    wr_mem(0x5079, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$F000                  ; 87FB: CC F0 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xf0; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $507C                   ; 87FE: FD 50 7C      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x507c, A); // Care needed with I/O space and word fetches
    wr_mem(0x507d, B); 
  case 0x8801:
L8801:
                                                     #ifdef DEBUG
                                      mon("L8801    LDA   <$92                    ; 8801: 96 92         \n");
                                      #endif
    PC = 0x8801; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x92); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L880E                   ; 8803: 27 09         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L880E;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $5078                   ; 8805: FC 50 78      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x5078); // Care needed with I/O space and word fetches
    B = rd_mem(0x5079); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  <$93                    ; 8808: 93 93         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x93)<<8; 
    ea = ea | rd_mem(DP|0x94); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         LBPL  locret_889E             ; 880A: 10 2A 00 90   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 1; 
    goto L889E;
    }
  case 0x880E:
L880E:
                                                     #ifdef DEBUG
                                      mon("L880E    LDD   $5078                   ; 880E: FC 50 78      \n");
                                      #endif
    PC = 0x880e; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x5078); // Care needed with I/O space and word fetches
    B = rd_mem(0x5079); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5098                   ; 8811: B3 50 98      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5098)<<8; 
    ea = ea | rd_mem(0x5099); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$7000                  ; 8814: 83 70 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x7000; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         LBPL  locret_889E             ; 8817: 10 2A 00 83   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 1; 
    goto L889E;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0F                    ; 881B: CC 00 0F      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x0f; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4701                   ; 881E: FD 47 01      \n");
                                      #endif // Point BIC to $5078 MReg3C
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4701, A); // Care needed with I/O space and word fetches
    wr_mem(0x4702, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$67                    ; 8821: 86 67         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x67; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCDBA                   ; 8823: BD CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x26); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x88); 
    clockticks = clockticks + 1; 
    goto LCDBA;
  case 0x8826:
L8826:
                                                     #ifdef DEBUG
                                      mon("L8826    LDD   $5002                   ; 8826: FC 50 02      \n");
                                      #endif // Math result Y
    PC = 0x8826; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x5002); // Care needed with I/O space and word fetches
    B = rd_mem(0x5003); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BPL   L882F                   ; 8829: 2A 04         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto L882F;
    }
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; 882B: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; 882C: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SBCA  #$FF                    ; 882D: 82 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xff; 
    res = val - (UINT8)arg - (C != 0 ? 1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)res; 
  case 0x882F:
L882F:
                                                     #ifdef DEBUG
                                      mon("L882F    SUBD  $5000                   ; 882F: B3 50 00      \n");
                                      #endif // Math result X
    PC = 0x882f; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5000)<<8; 
    ea = ea | rd_mem(0x5001); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BGT   L8866                   ; 8832: 2E 32         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto L8866;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $5000                   ; 8834: FC 50 00      \n");
                                      #endif // Math result X
    clockticks = clockticks + 5; 
    A = rd_mem(0x5000); // Care needed with I/O space and word fetches
    B = rd_mem(0x5001); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4704                   ; 8837: FD 47 04      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4704, A); // Care needed with I/O space and word fetches
    wr_mem(0x4705, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; 883A: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$D6                    ; 883D: DD D6         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0xd6; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$68                    ; 883F: CC 00 68      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x68; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$D8                    ; 8842: DD D8         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0xd8; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCD08                   ; 8844: BD CD 08      \n");
                                      #endif // Trench side vertical lines calcs
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x47); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x88); 
    clockticks = clockticks + 1; 
    goto LCD08;
  case 0x8847:
L8847:
                                                     #ifdef DEBUG
                                      mon("L8847    LDD   #$00                    ; 8847: CC 00 00      \n");
                                      #endif
    PC = 0x8847; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $507C                   ; 884A: FD 50 7C      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x507c, A); // Care needed with I/O space and word fetches
    wr_mem(0x507d, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0F                    ; 884D: CC 00 0F      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x0f; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4701                   ; 8850: FD 47 01      \n");
                                      #endif // Point BIC to $5078 MReg3C
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4701, A); // Care needed with I/O space and word fetches
    wr_mem(0x4702, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$67                    ; 8853: 86 67         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x67; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCDBA                   ; 8855: BD CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x58); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x88); 
    clockticks = clockticks + 1; 
    goto LCDBA;
  case 0x8858:
L8858:
                                                     #ifdef DEBUG
                                      mon("L8858    LDD   $5000                   ; 8858: FC 50 00      \n");
                                      #endif // Math result X
    PC = 0x8858; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x5000); // Care needed with I/O space and word fetches
    B = rd_mem(0x5001); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4704                   ; 885B: FD 47 04      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4704, A); // Care needed with I/O space and word fetches
    wr_mem(0x4705, B); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCCFC                   ; 885E: BD CC FC      \n");
                                      #endif // Trench floor lines calcs
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x61); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x88); 
    clockticks = clockticks + 1; 
    goto LCCFC;
  case 0x8861:
L8861:
                                                     #ifdef DEBUG
                                      mon("L8861    LDD   #$8040                  ; 8861: CC 80 40      \n");
                                      #endif
    PC = 0x8861; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 8864: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
  case 0x8866:
L8866:
                                                     #ifdef DEBUG
                                      mon("L8866    LDU   $49B9                   ; 8866: FE 49 B9      \n");
                                      #endif
    PC = 0x8866; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x49b9)<<8; 
    ea = ea | rd_mem(0x49ba); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   ,U                      ; 8869: E6 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(U); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$01                    ; 886B: C1 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x01; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   L8874                   ; 886D: 26 05         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L8874;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0800                  ; 886F: CC 08 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x08; 
    B = 0x00; 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   L8877                   ; 8872: 20 03         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L8877;
    
    // ---------------------------------------------------------------------------
  case 0x8874:
L8874:
                                                     #ifdef DEBUG
                                      mon("L8874    LDD   #$1000                  ; 8874: CC 10 00      \n");
                                      #endif
    PC = 0x8874; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x10; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0x8877:
L8877:
                                                     #ifdef DEBUG
                                      mon("L8877    ADDD  $49BB                   ; 8877: F3 49 BB      \n");
                                      #endif
    PC = 0x8877; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x49bb)<<8; 
    ea = ea | rd_mem(0x49bc); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $49BB                   ; 887A: FD 49 BB      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x49bb, A); // Care needed with I/O space and word fetches
    wr_mem(0x49bc, B); 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5040                   ; 887D: B3 50 40      \n");
                                      #endif // XT2
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5040)<<8; 
    ea = ea | rd_mem(0x5041); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BMI   locret_889E             ; 8880: 2B 1C         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto L889E;
    }
                                                     #ifdef DEBUG
                                      mon("         LEAU  $03,U                   ; 8882: 33 43         \n");
                                      #endif
    clockticks = clockticks + 5; 
    U = (U + 0x0003); 
                                                     #ifdef DEBUG
                                      mon("         LDB   ,U                      ; 8884: E6 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(U); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$03                    ; 8886: C1 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x03; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
  case 0x8888:
L8888:
                                                     #ifdef DEBUG
                                      mon("L8888    BEQ   locret_889E             ; 8888: 27 14         \n");
                                      #endif
    PC = 0x8888; 
    INSTRUCTION_START
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L889E;
    }
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$05                    ; 888A: C1 05         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x05; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   L8898                   ; 888C: 26 0A         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L8898;
    }
                                                     #ifdef DEBUG
                                      mon("         LDU   $49AD                   ; 888E: FE 49 AD      \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x49ad)<<8; 
    ea = ea | rd_mem(0x49ae); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LEAU  $02,U                   ; 8891: 33 42         \n");
                                      #endif
    clockticks = clockticks + 5; 
    U = (U + 0x0002); 
                                                     #ifdef DEBUG
                                      mon("         STU   $49AD                   ; 8893: FF 49 AD      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    wr_mem(0x49ad, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem(0x49ae, (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         LDU   ,U                      ; 8896: EE C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(U)<<8; 
    ea = ea | rd_mem((UINT16)((U)+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0x8898:
L8898:
                                                     #ifdef DEBUG
                                      mon("L8898    STU   $49B9                   ; 8898: FF 49 B9      \n");
                                      #endif
    PC = 0x8898; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = U; 
    Z = val; 
    N = (UINT8)(val >> 8); 
    V = 0; 
    wr_mem(0x49b9, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem(0x49ba, (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         JMP   L87F5                   ; 889B: 7E 87 F5      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto L87F5;
    
    // ---------------------------------------------------------------------------
    // End of function sub_87CB
  case 0x889E:
L889E:
locret_889E:
                                                     #ifdef DEBUG
                                      mon("locret_889E RTS                           ; 889E: 39            \n");
                                      #endif
    PC = 0x889e; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x889F:
L889F:
                                                     #ifdef DEBUG
                                      mon("L889F    LDB   #$10                    ; 889F: C6 10         \n");
                                      #endif
    PC = 0x889f; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x10; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STB   <$DC                    ; 88A1: D7 DC         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xdc; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCD38                   ; 88A3: BD CD 38      \n");
                                      #endif // Trench left side turret calcs
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xa6); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x88); 
    clockticks = clockticks + 1; 
    goto LCD38;
  case 0x88A6:
L88A6:
                                                     #ifdef DEBUG
                                      mon("L88A6    LDD   #$F000                  ; 88A6: CC F0 00      \n");
                                      #endif
    PC = 0x88a6; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0xf0; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5E04                   ; 88A9: FD 5E 04      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5e04, A); // Care needed with I/O space and word fetches
    wr_mem(0x5e05, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; 88AC: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5E02                   ; 88AF: FD 5E 02      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5e02, A); // Care needed with I/O space and word fetches
    wr_mem(0x5e03, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$96                    ; 88B2: DC 96         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x96); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x97); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5E00                   ; 88B4: FD 5E 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5e00, A); // Care needed with I/O space and word fetches
    wr_mem(0x5e01, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$01C0                  ; 88B7: CC 01 C0      \n");
                                      #endif // Point BIC to math $5E00
    clockticks = clockticks + 3; 
    A = 0x01; 
    B = 0xc0; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4701                   ; 88BA: FD 47 01      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4701, A); // Care needed with I/O space and word fetches
    wr_mem(0x4702, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$67                    ; 88BD: 86 67         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x67; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCDBA                   ; 88BF: BD CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xc2); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x88); 
    clockticks = clockticks + 1; 
    goto LCDBA;
  case 0x88C2:
L88C2:
                                                     #ifdef DEBUG
                                      mon("L88C2    LDD   $5000                   ; 88C2: FC 50 00      \n");
                                      #endif // Math result X
    PC = 0x88c2; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x5000); // Care needed with I/O space and word fetches
    B = rd_mem(0x5001); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$FE00                  ; 88C5: 10 83 FE 00   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0xfe00; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BGT   L88D0                   ; 88C9: 2E 05         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto L88D0;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; 88CB: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$95                    ; 88CD: 97 95         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0x95; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 88CF: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
  case 0x88D0:
L88D0:
                                                     #ifdef DEBUG
                                      mon("L88D0    SUBD  #$7000                  ; 88D0: 83 70 00      \n");
                                      #endif
    PC = 0x88d0; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = 0x7000; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BGT   locret_88F4             ; 88D3: 2E 1F         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto L88F4;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$A018                  ; 88D5: CC A0 18      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xa0; 
    B = 0x18; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5E00                   ; 88D8: FD 5E 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5e00, A); // Care needed with I/O space and word fetches
    wr_mem(0x5e01, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$7200                  ; 88DB: CC 72 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x72; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5E04                   ; 88DE: FD 5E 04      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5e04, A); // Care needed with I/O space and word fetches
    wr_mem(0x5e05, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $5000                   ; 88E1: FC 50 00      \n");
                                      #endif // Math result X
    clockticks = clockticks + 5; 
    A = rd_mem(0x5000); // Care needed with I/O space and word fetches
    B = rd_mem(0x5001); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$1000                  ; 88E4: 83 10 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x1000; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BGE   L88EE                   ; 88E7: 2C 05         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) >= 0) {
    clockticks = clockticks + 3; 
    goto L88EE;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   LCD5C                   ; 88E9: BD CD 5C      \n");
                                      #endif // Trench calcs
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xec); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x88); 
    clockticks = clockticks + 1; 
    goto LCD5C;
  case 0x88EC:
L88EC:
                                                     #ifdef DEBUG
                                      mon("L88EC    BRA   L88F1                   ; 88EC: 20 03         \n");
                                      #endif
    PC = 0x88ec; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto L88F1;
    
    // ---------------------------------------------------------------------------
  case 0x88EE:
L88EE:
                                                     #ifdef DEBUG
                                      mon("L88EE    JSR   LCD50                   ; 88EE: BD CD 50      \n");
                                      #endif
    PC = 0x88ee; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf1); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x88); 
    clockticks = clockticks + 1; 
    goto LCD50;
  case 0x88F1:
L88F1:
                                                     #ifdef DEBUG
                                      mon("L88F1    JSR   LCD74                   ; 88F1: BD CD 74      \n");
                                      #endif // Function select for an object
    PC = 0x88f1; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf4); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x88); 
    clockticks = clockticks + 1; 
    goto LCD74;
    // End of function sub_889F
  case 0x88F4:
L88F4:
locret_88F4:
                                                     #ifdef DEBUG
                                      mon("locret_88F4 RTS                           ; 88F4: 39            \n");
                                      #endif
    PC = 0x88f4; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x88F5:
L88F5:
                                                     #ifdef DEBUG
                                      mon("L88F5    LDD   #$6280                  ; 88F5: CC 62 80      \n");
                                      #endif
    PC = 0x88f5; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x62; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 88F8: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$92                    ; 88FA: 96 92         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x92); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   locret_8950             ; 88FC: 27 52         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L8950;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   <$93                    ; 88FE: DC 93         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x93); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x94); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5078                   ; 8900: FD 50 78      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5078, A); // Care needed with I/O space and word fetches
    wr_mem(0x5079, B); 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5098                   ; 8903: B3 50 98      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5098)<<8; 
    ea = ea | rd_mem(0x5099); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$7000                  ; 8906: 83 70 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x7000; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BMI   L8911                   ; 8909: 2B 06         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto L8911;
    }
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; 890B: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; 890C: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SBCA  #$FF                    ; 890D: 82 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xff; 
    res = val - (UINT8)arg - (C != 0 ? 1:0); 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BRA   L8914                   ; 890F: 20 03         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L8914;
    
    // ---------------------------------------------------------------------------
  case 0x8911:
L8911:
                                                     #ifdef DEBUG
                                      mon("L8911    LDD   #$00                    ; 8911: CC 00 00      \n");
                                      #endif
    PC = 0x8911; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0x8914:
L8914:
                                                     #ifdef DEBUG
                                      mon("L8914    STD   $507C                   ; 8914: FD 50 7C      \n");
                                      #endif
    PC = 0x8914; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x507c, A); // Care needed with I/O space and word fetches
    wr_mem(0x507d, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$FC00                  ; 8917: CC FC 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xfc; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $507A                   ; 891A: FD 50 7A      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x507a, A); // Care needed with I/O space and word fetches
    wr_mem(0x507b, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0F                    ; 891D: CC 00 0F      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x0f; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4701                   ; 8920: FD 47 01      \n");
                                      #endif // Point BIC to $5078 MReg3C
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4701, A); // Care needed with I/O space and word fetches
    wr_mem(0x4702, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$67                    ; 8923: 86 67         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x67; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCDBA                   ; 8925: BD CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x28); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x89); 
    clockticks = clockticks + 1; 
    goto LCDBA;
  case 0x8928:
L8928:
                                                     #ifdef DEBUG
                                      mon("L8928    LDD   $5000                   ; 8928: FC 50 00      \n");
                                      #endif // Math result X
    PC = 0x8928; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x5000); // Care needed with I/O space and word fetches
    B = rd_mem(0x5001); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4704                   ; 892B: FD 47 04      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4704, A); // Care needed with I/O space and word fetches
    wr_mem(0x4705, B); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCCE4                   ; 892E: BD CC E4      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x31); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x89); 
    clockticks = clockticks + 1; 
    goto LCCE4;
  case 0x8931:
L8931:
                                                     #ifdef DEBUG
                                      mon("L8931    LDD   #$0400                  ; 8931: CC 04 00      \n");
                                      #endif
    PC = 0x8931; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x04; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $507A                   ; 8934: FD 50 7A      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x507a, A); // Care needed with I/O space and word fetches
    wr_mem(0x507b, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0F                    ; 8937: CC 00 0F      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x0f; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4701                   ; 893A: FD 47 01      \n");
                                      #endif // Point BIC to $5078 MReg3C
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4701, A); // Care needed with I/O space and word fetches
    wr_mem(0x4702, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$67                    ; 893D: 86 67         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x67; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCDBA                   ; 893F: BD CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x42); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x89); 
    clockticks = clockticks + 1; 
    goto LCDBA;
  case 0x8942:
L8942:
                                                     #ifdef DEBUG
                                      mon("L8942    LDD   $5000                   ; 8942: FC 50 00      \n");
                                      #endif // Math result X
    PC = 0x8942; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x5000); // Care needed with I/O space and word fetches
    B = rd_mem(0x5001); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4704                   ; 8945: FD 47 04      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4704, A); // Care needed with I/O space and word fetches
    wr_mem(0x4705, B); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCCFC                   ; 8948: BD CC FC      \n");
                                      #endif // Trench floor lines calcs
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x4b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x89); 
    clockticks = clockticks + 1; 
    goto LCCFC;
  case 0x894B:
L894B:
                                                     #ifdef DEBUG
                                      mon("L894B    LDD   #$8040                  ; 894B: CC 80 40      \n");
                                      #endif
    PC = 0x894b; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 894E: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
    // End of function sub_88F5
  case 0x8950:
L8950:
locret_8950:
                                                     #ifdef DEBUG
                                      mon("locret_8950 RTS                           ; 8950: 39            \n");
                                      #endif
    PC = 0x8950; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Attributes: noreturn
  case 0x8951:
L8951:
                                                     #ifdef DEBUG
                                      mon("L8951    JSR   L8981                   ; 8951: BD 89 81      \n");
                                      #endif
    PC = 0x8951; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x54); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x89); 
    clockticks = clockticks + 1; 
    goto L8981;
  case 0x8954:
L8954:
                                                     #ifdef DEBUG
                                      mon("L8954    INC   <$4D                    ; 8954: 0C 4D         \n");
                                      #endif
    PC = 0x8954; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x4d); 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    wr_mem(DP|0x4d, res); 
    clockticks = clockticks + 2; 
    // End of function sub_8951
                                                     #ifdef DEBUG
                                      mon("         JMP   L89D3                   ; 8956: 7E 89 D3      \n");
                                      #endif // Space wave pitch
    clockticks = clockticks + 4; 
    goto L89D3;
    
    // =============== S U B R O U T I N E =======================================
    // Attributes: noreturn
  case 0x8959:
L8959:
                                                     #ifdef DEBUG
                                      mon("L8959    JSR   L8993                   ; 8959: BD 89 93      \n");
                                      #endif
    PC = 0x8959; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x5c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x89); 
    clockticks = clockticks + 1; 
    goto L8993;
  case 0x895C:
L895C:
                                                     #ifdef DEBUG
                                      mon("L895C    DEC   <$4D                    ; 895C: 0A 4D         \n");
                                      #endif
    PC = 0x895c; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x4d); 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    wr_mem(DP|0x4d, res); 
    clockticks = clockticks + 2; 
    // End of function sub_8959
                                                     #ifdef DEBUG
                                      mon("         JMP   L89D3                   ; 895E: 7E 89 D3      \n");
                                      #endif // Space wave pitch
    clockticks = clockticks + 4; 
    goto L89D3;
    
    // =============== S U B R O U T I N E =======================================
    // Attributes: noreturn
  case 0x8961:
L8961:
                                                     #ifdef DEBUG
                                      mon("L8961    JSR   L8993                   ; 8961: BD 89 93      \n");
                                      #endif
    PC = 0x8961; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x64); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x89); 
    clockticks = clockticks + 1; 
    goto L8993;
  case 0x8964:
L8964:
                                                     #ifdef DEBUG
                                      mon("L8964    DEC   <$4E                    ; 8964: 0A 4E         \n");
                                      #endif
    PC = 0x8964; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x4e); 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    wr_mem(DP|0x4e, res); 
    clockticks = clockticks + 2; 
    // End of function sub_8961
                                                     #ifdef DEBUG
                                      mon("         JMP   L89C8                   ; 8966: 7E 89 C8      \n");
                                      #endif // Space wave roll
    clockticks = clockticks + 4; 
    goto L89C8;
    
    // =============== S U B R O U T I N E =======================================
    // Attributes: noreturn
  case 0x8969:
L8969:
                                                     #ifdef DEBUG
                                      mon("L8969    JSR   L8981                   ; 8969: BD 89 81      \n");
                                      #endif
    PC = 0x8969; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x6c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x89); 
    clockticks = clockticks + 1; 
    goto L8981;
  case 0x896C:
L896C:
                                                     #ifdef DEBUG
                                      mon("L896C    INC   <$4E                    ; 896C: 0C 4E         \n");
                                      #endif
    PC = 0x896c; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x4e); 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    wr_mem(DP|0x4e, res); 
    clockticks = clockticks + 2; 
    // End of function sub_8969
                                                     #ifdef DEBUG
                                      mon("         JMP   L89C8                   ; 896E: 7E 89 C8      \n");
                                      #endif // Space wave roll
    clockticks = clockticks + 4; 
    goto L89C8;
    
    // =============== S U B R O U T I N E =======================================
    // Attributes: noreturn
  case 0x8971:
L8971:
                                                     #ifdef DEBUG
                                      mon("L8971    JSR   L8981                   ; 8971: BD 89 81      \n");
                                      #endif
    PC = 0x8971; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x89); 
    clockticks = clockticks + 1; 
    goto L8981;
  case 0x8974:
L8974:
                                                     #ifdef DEBUG
                                      mon("L8974    DEC   <$4F                    ; 8974: 0A 4F         \n");
                                      #endif
    PC = 0x8974; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x4f); 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    wr_mem(DP|0x4f, res); 
    clockticks = clockticks + 2; 
    // End of function sub_8971
                                                     #ifdef DEBUG
                                      mon("         JMP   L89DE                   ; 8976: 7E 89 DE      \n");
                                      #endif // Space wave yaw
    clockticks = clockticks + 4; 
    goto L89DE;
    
    // =============== S U B R O U T I N E =======================================
    // Attributes: noreturn
  case 0x8979:
L8979:
                                                     #ifdef DEBUG
                                      mon("L8979    JSR   L8993                   ; 8979: BD 89 93      \n");
                                      #endif
    PC = 0x8979; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x7c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x89); 
    clockticks = clockticks + 1; 
    goto L8993;
  case 0x897C:
L897C:
                                                     #ifdef DEBUG
                                      mon("L897C    INC   <$4F                    ; 897C: 0C 4F         \n");
                                      #endif
    PC = 0x897c; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x4f); 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    wr_mem(DP|0x4f, res); 
    clockticks = clockticks + 2; 
    // End of function sub_8979
                                                     #ifdef DEBUG
                                      mon("         JMP   L89DE                   ; 897E: 7E 89 DE      \n");
                                      #endif // Space wave yaw
    clockticks = clockticks + 4; 
    goto L89DE;
    
    // =============== S U B R O U T I N E =======================================
  case 0x8981:
L8981:
                                                     #ifdef DEBUG
                                      mon("L8981    LDA   #$14                    ; 8981: 86 14         \n");
                                      #endif
    PC = 0x8981; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x14; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #word_89A8              ; 8983: CE 89 A8      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x89a8; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LEAU  A,U                     ; 8986: 33 C6         \n");
                                      #endif
    clockticks = clockticks + 5; 
    U = (U + (SINT8)A); 
                                                     #ifdef DEBUG
                                      mon("         LDD   ,U                      ; 8988: EC C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(U); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(U+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5022                   ; 898A: FD 50 22      \n");
                                      #endif // Sine for rotation
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5022, A); // Care needed with I/O space and word fetches
    wr_mem(0x5023, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $02,U                   ; 898D: EC 42         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0x0002); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5024                   ; 898F: FD 50 24      \n");
                                      #endif // Cosine for rotation
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x5024, A); // Care needed with I/O space and word fetches
    wr_mem(0x5025, B); 
    // End of function sub_8981
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 8992: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x8993:
L8993:
                                                     #ifdef DEBUG
                                      mon("L8993    LDA   #$14                    ; 8993: 86 14         \n");
                                      #endif
    PC = 0x8993; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x14; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #word_89A8              ; 8995: CE 89 A8      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x89a8; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LEAU  A,U                     ; 8998: 33 C6         \n");
                                      #endif
    clockticks = clockticks + 5; 
    U = (U + (SINT8)A); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; 899A: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  ,U                      ; 899D: A3 C4         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(U)<<8; 
    ea = ea | rd_mem((UINT16)((U)+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5022                   ; 899F: FD 50 22      \n");
                                      #endif // Sine for rotation
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5022, A); // Care needed with I/O space and word fetches
    wr_mem(0x5023, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $02,U                   ; 89A2: EC 42         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0x0002); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5024                   ; 89A4: FD 50 24      \n");
                                      #endif // Cosine for rotation
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x5024, A); // Care needed with I/O space and word fetches
    wr_mem(0x5025, B); 
    // End of function sub_8993
    // ---------------------------------------------------------------------------
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 89A7: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Space wave roll
    // Attributes: noreturn
  case 0x89C8:
L89C8:
                                                     #ifdef DEBUG
                                      mon("L89C8    CLRA                          ; 89C8: 4F            \n");
                                      #endif
    PC = 0x89c8; 
    INSTRUCTION_START
    A = 0; // SEARCH_ME
 // V = 0; 
 // Z = 0; 
 // N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $02,X                   ; 89C9: E6 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0002)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4701                   ; 89CB: FD 47 01      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4701, A); // Care needed with I/O space and word fetches
    wr_mem(0x4702, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; 89CE: 86 00         \n");
                                      #endif // Roll
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function sub_89C8
                                                     #ifdef DEBUG
                                      mon("         JMP   LCDBA                   ; 89D0: 7E CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 4; 
    goto LCDBA;
    
    // =============== S U B R O U T I N E =======================================
    // Space wave pitch
  case 0x89D3:
L89D3:
                                                     #ifdef DEBUG
                                      mon("L89D3    CLRA                          ; 89D3: 4F            \n");
                                      #endif
    PC = 0x89d3; 
    INSTRUCTION_START
    A = 0; // SEARCH_ME
 // V = 0; 
 // Z = 0; 
 // N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $02,X                   ; 89D4: E6 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0002)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4701                   ; 89D6: FD 47 01      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4701, A); // Care needed with I/O space and word fetches
    wr_mem(0x4702, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$0E                    ; 89D9: 86 0E         \n");
                                      #endif // Pitch
    clockticks = clockticks + 2; 
    val = (UINT8)0x0e; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function sub_89D3
                                                     #ifdef DEBUG
                                      mon("         JMP   LCDBA                   ; 89DB: 7E CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 4; 
    goto LCDBA;
    
    // =============== S U B R O U T I N E =======================================
    // Space wave yaw
  case 0x89DE:
L89DE:
                                                     #ifdef DEBUG
                                      mon("L89DE    CLRA                          ; 89DE: 4F            \n");
                                      #endif
    PC = 0x89de; 
    INSTRUCTION_START
    A = 0; // SEARCH_ME
 // V = 0; 
 // Z = 0; 
 // N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $02,X                   ; 89DF: E6 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0002)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4701                   ; 89E1: FD 47 01      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4701, A); // Care needed with I/O space and word fetches
    wr_mem(0x4702, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$1C                    ; 89E4: 86 1C         \n");
                                      #endif // Yaw
    clockticks = clockticks + 2; 
    val = (UINT8)0x1c; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function sub_89DE
                                                     #ifdef DEBUG
                                      mon("         JMP   LCDBA                   ; 89E6: 7E CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 4; 
    goto LCDBA;
    
    // =============== S U B R O U T I N E =======================================
  case 0x89E9:
L89E9:
                                                     #ifdef DEBUG
                                      mon("L89E9    LDD   -16,U                   ; 89E9: EC 50         \n");
                                      #endif
    PC = 0x89e9; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0xfff0); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_5             ; 89EB: BD CD 9E      \n");
                                      #endif // Shift D register right
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xee); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x89); 
    clockticks = clockticks + 1; 
    goto LCD9E;
  case 0x89EE:
L89EE:
                                                     #ifdef DEBUG
                                      mon("L89EE    ADDD  -10,U                   ; 89EE: E3 56         \n");
                                      #endif
    PC = 0x89ee; 
    INSTRUCTION_START
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0xfff6))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0xfff6))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   -10,U                   ; 89F0: ED 56         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0xfff6); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   -8,U                    ; 89F2: EC 58         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0xfff8); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_5             ; 89F4: BD CD 9E      \n");
                                      #endif // Shift D register right
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf7); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x89); 
    clockticks = clockticks + 1; 
    goto LCD9E;
  case 0x89F7:
L89F7:
                                                     #ifdef DEBUG
                                      mon("L89F7    ADDD  -2,U                    ; 89F7: E3 5E         \n");
                                      #endif
    PC = 0x89f7; 
    INSTRUCTION_START
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0xfffe))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0xfffe))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   -2,U                    ; 89F9: ED 5E         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0xfffe); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   ,U                      ; 89FB: EC C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(U); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(U+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_5             ; 89FD: BD CD 9E      \n");
                                      #endif // Shift D register right
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x00); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8a); 
    clockticks = clockticks + 1; 
    goto LCD9E;
  case 0x8A00:
L8A00:
                                                     #ifdef DEBUG
                                      mon("L8A00    ADDD  $06,U                   ; 8A00: E3 46         \n");
                                      #endif
    PC = 0x8a00; 
    INSTRUCTION_START
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0006))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0006))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $06,U                   ; 8A02: ED 46         \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = (UINT16)(U + 0x0006); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    // End of function sub_89E9
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 8A04: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x8A05:
L8A05:
                                                     #ifdef DEBUG
                                      mon("L8A05    LDD   -16,U                   ; 8A05: EC 50         \n");
                                      #endif
    PC = 0x8a05; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0xfff0); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_6             ; 8A07: BD CD 9C      \n");
                                      #endif // Shift D register right
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x0a); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8a); 
    clockticks = clockticks + 1; 
    goto LCD9C;
  case 0x8A0A:
L8A0A:
                                                     #ifdef DEBUG
                                      mon("L8A0A    ADDD  -10,U                   ; 8A0A: E3 56         \n");
                                      #endif
    PC = 0x8a0a; 
    INSTRUCTION_START
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0xfff6))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0xfff6))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   -10,U                   ; 8A0C: ED 56         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0xfff6); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   -8,U                    ; 8A0E: EC 58         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0xfff8); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_6             ; 8A10: BD CD 9C      \n");
                                      #endif // Shift D register right
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x13); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8a); 
    clockticks = clockticks + 1; 
    goto LCD9C;
  case 0x8A13:
L8A13:
                                                     #ifdef DEBUG
                                      mon("L8A13    ADDD  -2,U                    ; 8A13: E3 5E         \n");
                                      #endif
    PC = 0x8a13; 
    INSTRUCTION_START
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0xfffe))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0xfffe))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   -2,U                    ; 8A15: ED 5E         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0xfffe); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   ,U                      ; 8A17: EC C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(U); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(U+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_6             ; 8A19: BD CD 9C      \n");
                                      #endif // Shift D register right
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x1c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8a); 
    clockticks = clockticks + 1; 
    goto LCD9C;
  case 0x8A1C:
L8A1C:
                                                     #ifdef DEBUG
                                      mon("L8A1C    ADDD  $06,U                   ; 8A1C: E3 46         \n");
                                      #endif
    PC = 0x8a1c; 
    INSTRUCTION_START
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0006))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0006))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $06,U                   ; 8A1E: ED 46         \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = (UINT16)(U + 0x0006); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    // End of function sub_8A05
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 8A20: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x8A21:
L8A21:
                                                     #ifdef DEBUG
                                      mon("L8A21    LDD   -12,U                   ; 8A21: EC 54         \n");
                                      #endif
    PC = 0x8a21; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0xfff4); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_6             ; 8A23: BD CD 9C      \n");
                                      #endif // Shift D register right
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x26); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8a); 
    clockticks = clockticks + 1; 
    goto LCD9C;
  case 0x8A26:
L8A26:
                                                     #ifdef DEBUG
                                      mon("L8A26    ADDD  -10,U                   ; 8A26: E3 56         \n");
                                      #endif
    PC = 0x8a26; 
    INSTRUCTION_START
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0xfff6))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0xfff6))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   -10,U                   ; 8A28: ED 56         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0xfff6); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   -4,U                    ; 8A2A: EC 5C         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0xfffc); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_6             ; 8A2C: BD CD 9C      \n");
                                      #endif // Shift D register right
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x2f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8a); 
    clockticks = clockticks + 1; 
    goto LCD9C;
  case 0x8A2F:
L8A2F:
                                                     #ifdef DEBUG
                                      mon("L8A2F    ADDD  -2,U                    ; 8A2F: E3 5E         \n");
                                      #endif
    PC = 0x8a2f; 
    INSTRUCTION_START
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0xfffe))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0xfffe))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   -2,U                    ; 8A31: ED 5E         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0xfffe); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $04,U                   ; 8A33: EC 44         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0x0004); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_6             ; 8A35: BD CD 9C      \n");
                                      #endif // Shift D register right
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x38); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8a); 
    clockticks = clockticks + 1; 
    goto LCD9C;
  case 0x8A38:
L8A38:
                                                     #ifdef DEBUG
                                      mon("L8A38    ADDD  $06,U                   ; 8A38: E3 46         \n");
                                      #endif
    PC = 0x8a38; 
    INSTRUCTION_START
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0006))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0006))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $06,U                   ; 8A3A: ED 46         \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = (UINT16)(U + 0x0006); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    // End of function sub_8A21
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 8A3C: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x8A3D:
L8A3D:
                                                     #ifdef DEBUG
                                      mon("L8A3D    LDD   -12,U                   ; 8A3D: EC 54         \n");
                                      #endif
    PC = 0x8a3d; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0xfff4); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_5             ; 8A3F: BD CD 9E      \n");
                                      #endif // Shift D register right
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x42); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8a); 
    clockticks = clockticks + 1; 
    goto LCD9E;
  case 0x8A42:
L8A42:
                                                     #ifdef DEBUG
                                      mon("L8A42    ADDD  -10,U                   ; 8A42: E3 56         \n");
                                      #endif
    PC = 0x8a42; 
    INSTRUCTION_START
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0xfff6))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0xfff6))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   -10,U                   ; 8A44: ED 56         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0xfff6); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   -4,U                    ; 8A46: EC 5C         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0xfffc); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_5             ; 8A48: BD CD 9E      \n");
                                      #endif // Shift D register right
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x4b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8a); 
    clockticks = clockticks + 1; 
    goto LCD9E;
  case 0x8A4B:
L8A4B:
                                                     #ifdef DEBUG
                                      mon("L8A4B    ADDD  -2,U                    ; 8A4B: E3 5E         \n");
                                      #endif
    PC = 0x8a4b; 
    INSTRUCTION_START
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0xfffe))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0xfffe))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   -2,U                    ; 8A4D: ED 5E         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0xfffe); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $04,U                   ; 8A4F: EC 44         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0x0004); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_5             ; 8A51: BD CD 9E      \n");
                                      #endif // Shift D register right
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x54); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8a); 
    clockticks = clockticks + 1; 
    goto LCD9E;
  case 0x8A54:
L8A54:
                                                     #ifdef DEBUG
                                      mon("L8A54    ADDD  $06,U                   ; 8A54: E3 46         \n");
                                      #endif
    PC = 0x8a54; 
    INSTRUCTION_START
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0006))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0006))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $06,U                   ; 8A56: ED 46         \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = (UINT16)(U + 0x0006); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    // End of function sub_8A3D
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 8A58: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x8A59:
L8A59:
                                                     #ifdef DEBUG
                                      mon("L8A59    LDD   #$00                    ; 8A59: CC 00 00      \n");
                                      #endif
    PC = 0x8a59; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  -12,U                   ; 8A5C: A3 54         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0xfff4))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0xfff4))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_6             ; 8A5E: BD CD 9C      \n");
                                      #endif // Shift D register right
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x61); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8a); 
    clockticks = clockticks + 1; 
    goto LCD9C;
  case 0x8A61:
L8A61:
                                                     #ifdef DEBUG
                                      mon("L8A61    ADDD  -10,U                   ; 8A61: E3 56         \n");
                                      #endif
    PC = 0x8a61; 
    INSTRUCTION_START
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0xfff6))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0xfff6))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   -10,U                   ; 8A63: ED 56         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0xfff6); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; 8A65: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  -4,U                    ; 8A68: A3 5C         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0xfffc))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0xfffc))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_6             ; 8A6A: BD CD 9C      \n");
                                      #endif // Shift D register right
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x6d); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8a); 
    clockticks = clockticks + 1; 
    goto LCD9C;
  case 0x8A6D:
L8A6D:
                                                     #ifdef DEBUG
                                      mon("L8A6D    ADDD  -2,U                    ; 8A6D: E3 5E         \n");
                                      #endif
    PC = 0x8a6d; 
    INSTRUCTION_START
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0xfffe))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0xfffe))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   -2,U                    ; 8A6F: ED 5E         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0xfffe); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; 8A71: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $04,U                   ; 8A74: A3 44         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0004))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0004))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_6             ; 8A76: BD CD 9C      \n");
                                      #endif // Shift D register right
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x79); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8a); 
    clockticks = clockticks + 1; 
    goto LCD9C;
  case 0x8A79:
L8A79:
                                                     #ifdef DEBUG
                                      mon("L8A79    ADDD  $06,U                   ; 8A79: E3 46         \n");
                                      #endif
    PC = 0x8a79; 
    INSTRUCTION_START
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0006))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0006))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $06,U                   ; 8A7B: ED 46         \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = (UINT16)(U + 0x0006); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    // End of function sub_8A59
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 8A7D: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x8A7E:
L8A7E:
                                                     #ifdef DEBUG
                                      mon("L8A7E    LDD   #$00                    ; 8A7E: CC 00 00      \n");
                                      #endif
    PC = 0x8a7e; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  -12,U                   ; 8A81: A3 54         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0xfff4))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0xfff4))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_5             ; 8A83: BD CD 9E      \n");
                                      #endif // Shift D register right
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x86); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8a); 
    clockticks = clockticks + 1; 
    goto LCD9E;
  case 0x8A86:
L8A86:
                                                     #ifdef DEBUG
                                      mon("L8A86    ADDD  -10,U                   ; 8A86: E3 56         \n");
                                      #endif
    PC = 0x8a86; 
    INSTRUCTION_START
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0xfff6))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0xfff6))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   -10,U                   ; 8A88: ED 56         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0xfff6); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; 8A8A: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  -4,U                    ; 8A8D: A3 5C         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0xfffc))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0xfffc))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_5             ; 8A8F: BD CD 9E      \n");
                                      #endif // Shift D register right
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x92); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8a); 
    clockticks = clockticks + 1; 
    goto LCD9E;
  case 0x8A92:
L8A92:
                                                     #ifdef DEBUG
                                      mon("L8A92    ADDD  -2,U                    ; 8A92: E3 5E         \n");
                                      #endif
    PC = 0x8a92; 
    INSTRUCTION_START
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0xfffe))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0xfffe))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   -2,U                    ; 8A94: ED 5E         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0xfffe); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; 8A96: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $04,U                   ; 8A99: A3 44         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0004))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0004))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_5             ; 8A9B: BD CD 9E      \n");
                                      #endif // Shift D register right
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x9e); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8a); 
    clockticks = clockticks + 1; 
    goto LCD9E;
  case 0x8A9E:
L8A9E:
                                                     #ifdef DEBUG
                                      mon("L8A9E    ADDD  $06,U                   ; 8A9E: E3 46         \n");
                                      #endif
    PC = 0x8a9e; 
    INSTRUCTION_START
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0006))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0006))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $06,U                   ; 8AA0: ED 46         \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = (UINT16)(U + 0x0006); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    // End of function sub_8A7E
    // ---------------------------------------------------------------------------
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 8AA2: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x8AB6:
L8AB6:
                                                     #ifdef DEBUG
                                      mon("L8AB6    LDD   -10,U                   ; 8AB6: EC 56         \n");
                                      #endif
    PC = 0x8ab6; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0xfff6); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $08,U                   ; 8AB8: E3 48         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0008))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0008))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ res) & (val ^ res)) >> 8; 
    N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BVS   L8ABE                   ; 8ABA: 29 02         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)V <  0) {
    clockticks = clockticks + 3; 
    goto L8ABE;
    }
                                                     #ifdef DEBUG
                                      mon("         STD   $08,U                   ; 8ABC: ED 48         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0x0008); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
  case 0x8ABE:
L8ABE:
                                                     #ifdef DEBUG
                                      mon("L8ABE    LDD   -2,U                    ; 8ABE: EC 5E         \n");
                                      #endif
    PC = 0x8abe; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0xfffe); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $0A,U                   ; 8AC0: E3 4A         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x000a))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x000a))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ res) & (val ^ res)) >> 8; 
    N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BVS   L8AC6                   ; 8AC2: 29 02         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)V <  0) {
    clockticks = clockticks + 3; 
    goto L8AC6;
    }
                                                     #ifdef DEBUG
                                      mon("         STD   $0A,U                   ; 8AC4: ED 4A         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0x000a); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
  case 0x8AC6:
L8AC6:
                                                     #ifdef DEBUG
                                      mon("L8AC6    LDD   $0C,U                   ; 8AC6: EC 4C         \n");
                                      #endif
    PC = 0x8ac6; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0x000c); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $06,U                   ; 8AC8: E3 46         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0006))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0006))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ res) & (val ^ res)) >> 8; 
    N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BVS   locret_8ACE             ; 8ACA: 29 02         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)V <  0) {
    clockticks = clockticks + 3; 
    goto L8ACE;
    }
                                                     #ifdef DEBUG
                                      mon("         STD   $0C,U                   ; 8ACC: ED 4C         \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = (UINT16)(U + 0x000c); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    // End of function sub_8AB6
  case 0x8ACE:
L8ACE:
locret_8ACE:
                                                     #ifdef DEBUG
                                      mon("locret_8ACE RTS                           ; 8ACE: 39            \n");
                                      #endif
    PC = 0x8ace; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
    // START OF FUNCTION CHUNK FOR sub_B32B
  case 0x8ACF:
L8ACF:
                                                     #ifdef DEBUG
                                      mon("L8ACF    LDX   <$C2                    ; 8ACF: 9E C2         \n");
                                      #endif
    PC = 0x8acf; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xc2)<<8; 
    ea = ea | rd_mem(DP|0xc3); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $03,X                   ; 8AD1: A6 03         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0003)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$01                    ; 8AD3: 81 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x01; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   locret_8ADB             ; 8AD5: 26 04         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L8ADB;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $06,X                   ; 8AD7: A6 06         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0006)); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L8ADC                   ; 8AD9: 27 01         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L8ADC;
    }
  case 0x8ADB:
L8ADB:
locret_8ADB:
                                                     #ifdef DEBUG
                                      mon("locret_8ADB RTS                           ; 8ADB: 39            \n");
                                      #endif
    PC = 0x8adb; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
  case 0x8ADC:
L8ADC:
                                                     #ifdef DEBUG
                                      mon("L8ADC    JSR   Gen_Random              ; 8ADC: BD CE 45      \n");
                                      #endif // Update random numbers
    PC = 0x8adc; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xdf); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8a); 
    clockticks = clockticks + 1; 
    goto LCE45;
  case 0x8ADF:
L8ADF:
                                                     #ifdef DEBUG
                                      mon("L8ADF    LDA   $03,X                   ; 8ADF: A6 03         \n");
                                      #endif
    PC = 0x8adf; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0003)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$01                    ; 8AE1: 81 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x01; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   L8AED                   ; 8AE3: 26 08         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L8AED;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $15,X                   ; 8AE5: EC 88 15      \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + (SINT8)0x15); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORB   #$01                    ; 8AE8: CA 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = B | (UINT8)0x01; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $15,X                   ; 8AEA: ED 88 15      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + (SINT8)0x15); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
  case 0x8AED:
L8AED:
                                                     #ifdef DEBUG
                                      mon("L8AED    LDX   <$C2                    ; 8AED: 9E C2         \n");
                                      #endif
    PC = 0x8aed; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xc2)<<8; 
    ea = ea | rd_mem(DP|0xc3); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         INC   $08,X                   ; 8AEF: 6C 08         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0008)); 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    wr_mem((UINT16)(X + 0x0008), res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         DEC   $07,X                   ; 8AF1: 6A 07         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0007)); 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    wr_mem((UINT16)(X + 0x0007), res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LBLE  L8B57                   ; 8AF3: 10 2F 00 60   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 1; 
    goto L8B57;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$05                    ; 8AF7: 86 05         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x05; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $07,X                   ; 8AF9: A7 07         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0007); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   L97ED                   ; 8AFB: BD 97 ED      \n");
                                      #endif // Vaders tie score
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xfe); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8a); 
    clockticks = clockticks + 1; 
    goto L97ED;
  case 0x8AFE:
L8AFE:
                                                     #ifdef DEBUG
                                      mon("L8AFE    LDA   #$1F                    ; 8AFE: 86 1F         \n");
                                      #endif
    PC = 0x8afe; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x1f; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $09,X                   ; 8B00: A7 09         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0009); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   $06,X                   ; 8B02: A7 06         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0006); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$5090                  ; 8B04: 8E 50 90      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x5090; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   <$C2                    ; 8B07: DE C2         \n");
                                      #endif
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xc2)<<8; 
    ea = ea | rd_mem(DP|0xc3); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   ,U                      ; 8B09: EE C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(U)<<8; 
    ea = ea | rd_mem((UINT16)((U)+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; 8B0B: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   -10,U                   ; 8B0E: ED 56         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0xfff6); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   -2,U                    ; 8B10: ED 5E         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0xfffe); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $06,U                   ; 8B12: ED 46         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0x0006); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$02                    ; 8B14: 86 02         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x02; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$01                    ; 8B16: 97 01         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x01; 
    wr_mem(ea, val); 
  case 0x8B18:
L8B18:
                                                     #ifdef DEBUG
                                      mon("L8B18    LDD   #$4000                  ; 8B18: CC 40 00      \n");
                                      #endif
    PC = 0x8b18; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x40; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  <$C4                    ; 8B1B: 93 C4         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xc4)<<8; 
    ea = ea | rd_mem(DP|0xc5); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         LDB   -16,X                   ; 8B1D: E6 10         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0xfff0)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         MUL                           ; 8B1F: 3D            \n");
                                      #endif
    res = (UINT16)(A * B); 
 // Z = res; 
 // C = res & 0x80; 
    A = res >> 8; 
    B = (UINT8)res; 
    clockticks = clockticks + 11; 
                                                     #ifdef DEBUG
                                      mon("         TFR   A,B                     ; 8B20: 1F 89         \n");
                                      #endif
    B = (UINT8)A; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; 8B22: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLA                          ; 8B23: 49            \n");
                                      #endif
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SEX                           ; 8B24: 1D            \n");
                                      #endif
 // Z = B; 
 // N = B; 
    A = ((SINT8)B < 0 ? 0xff : 0); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  -10,U                   ; 8B25: E3 56         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0xfff6))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0xfff6))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   -10,U                   ; 8B27: ED 56         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0xfff6); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$53                    ; 8B29: 96 53         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x53); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORA   #$80                    ; 8B2B: 8A 80         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A | (UINT8)0x80; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   -8,X                    ; 8B2D: E6 18         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0xfff8)); 
    B = val; 
    N = val; 
 // Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         MUL                           ; 8B2F: 3D            \n");
                                      #endif
    res = (UINT16)(A * B); 
    Z = res; 
    C = res & 0x80; 
    A = res >> 8; 
    B = (UINT8)res; 
    clockticks = clockticks + 11; 
                                                     #ifdef DEBUG
                                      mon("         BCS   L8B33                   ; 8B30: 25 01         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L8B33;
    }
                                                     #ifdef DEBUG
                                      mon("         NEGA                          ; 8B32: 40            \n");
                                      #endif
    val = (UINT8)A; 
    res = -val; 
 // V = val & (UINT8)res; 
 // C = res & 0x100; 
    val = (UINT8)res; 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
  case 0x8B33:
L8B33:
                                                     #ifdef DEBUG
                                      mon("L8B33    TFR   A,B                     ; 8B33: 1F 89         \n");
                                      #endif
    PC = 0x8b33; 
    INSTRUCTION_START
    B = (UINT8)A; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         NOP                           ; 8B35: 12            \n");
                                      #endif
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SEX                           ; 8B36: 1D            \n");
                                      #endif
 // Z = B; 
 // N = B; 
    A = ((SINT8)B < 0 ? 0xff : 0); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  -2,U                    ; 8B37: E3 5E         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0xfffe))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0xfffe))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   -2,U                    ; 8B39: ED 5E         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0xfffe); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$54                    ; 8B3B: 96 54         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x54); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORA   #$80                    ; 8B3D: 8A 80         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A | (UINT8)0x80; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   ,X                      ; 8B3F: E6 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(X); 
    B = val; 
    N = val; 
 // Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         MUL                           ; 8B41: 3D            \n");
                                      #endif
    res = (UINT16)(A * B); 
    Z = res; 
    C = res & 0x80; 
    A = res >> 8; 
    B = (UINT8)res; 
    clockticks = clockticks + 11; 
                                                     #ifdef DEBUG
                                      mon("         BCS   L8B45                   ; 8B42: 25 01         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L8B45;
    }
                                                     #ifdef DEBUG
                                      mon("         NEGA                          ; 8B44: 40            \n");
                                      #endif
    val = (UINT8)A; 
    res = -val; 
 // V = val & (UINT8)res; 
 // C = res & 0x100; 
    val = (UINT8)res; 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
  case 0x8B45:
L8B45:
                                                     #ifdef DEBUG
                                      mon("L8B45    TFR   A,B                     ; 8B45: 1F 89         \n");
                                      #endif
    PC = 0x8b45; 
    INSTRUCTION_START
    B = (UINT8)A; 
    clockticks = clockticks + 6; 
  case 0x8B47:
L8B47:
                                                     #ifdef DEBUG
                                      mon("L8B47    NOP                           ; 8B47: 12            \n");
                                      #endif
    PC = 0x8b47; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SEX                           ; 8B48: 1D            \n");
                                      #endif
 // Z = B; 
 // N = B; 
    A = ((SINT8)B < 0 ? 0xff : 0); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $06,U                   ; 8B49: E3 46         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0006))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0006))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $06,U                   ; 8B4B: ED 46         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0x0006); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LEAX  $02,X                   ; 8B4D: 30 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + 0x0002); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         DEC   <$01                    ; 8B4F: 0A 01         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x01); 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    wr_mem(DP|0x01, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BPL   L8B18                   ; 8B51: 2A C5         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto L8B18;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   Sound_35                ; 8B53: BD BD FD      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x56); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8b); 
    clockticks = clockticks + 1; 
    goto LBDFD;
  case 0x8B56:
L8B56:
                                                     #ifdef DEBUG
                                      mon("L8B56    RTS                           ; 8B56: 39            \n");
                                      #endif
    PC = 0x8b56; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
  case 0x8B57:
L8B57:
                                                     #ifdef DEBUG
                                      mon("L8B57    LDX   <$C2                    ; 8B57: 9E C2         \n");
                                      #endif
    PC = 0x8b57; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xc2)<<8; 
    ea = ea | rd_mem(DP|0xc3); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Sound_35                ; 8B59: BD BD FD      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x5c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8b); 
    clockticks = clockticks + 1; 
    goto LBDFD;
  case 0x8B5C:
L8B5C:
                                                     #ifdef DEBUG
                                      mon("L8B5C    LDA   $02,X                   ; 8B5C: A6 02         \n");
                                      #endif
    PC = 0x8b5c; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0002)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  $4B38                   ; 8B5E: B1 4B 38      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    arg = rd_mem(0x4b38); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   L8B66                   ; 8B61: 26 03         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L8B66;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   Sound_2B                ; 8B63: BD BD CB      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x66); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8b); 
    clockticks = clockticks + 1; 
    goto LBDCB;
  case 0x8B66:
L8B66:
                                                     #ifdef DEBUG
                                      mon("L8B66    JSR   LB739                   ; 8B66: BD B7 39      \n");
                                      #endif
    PC = 0x8b66; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x69); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8b); 
    clockticks = clockticks + 1; 
    goto LB739;
  case 0x8B69:
L8B69:
                                                     #ifdef DEBUG
                                      mon("L8B69    JSR   L97E8                   ; 8B69: BD 97 E8      \n");
                                      #endif // Tie fighter score
    PC = 0x8b69; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x6c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8b); 
    clockticks = clockticks + 1; 
    goto L97E8;
    // END OF FUNCTION CHUNK FOR sub_B32B
  case 0x8B6C:
L8B6C:
                                                     #ifdef DEBUG
                                      mon("L8B6C    RTS                           ; 8B6C: 39            \n");
                                      #endif
    PC = 0x8b6c; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x8B6D:
L8B6D:
                                                     #ifdef DEBUG
                                      mon("L8B6D    LDX   #$4900                  ; 8B6D: 8E 49 00      \n");
                                      #endif // 3x Tie fighter data structure ($19 bytes per Tie)
    PC = 0x8b6d; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x4900; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0x8B70:
L8B70:
                                                     #ifdef DEBUG
                                      mon("L8B70    STX   <$5A                    ; 8B70: 9F 5A         \n");
                                      #endif
    PC = 0x8b70; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = X; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = DP|0x5a; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         LDU   ,X                      ; 8B72: EE 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $03,X                   ; 8B74: A6 03         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0003)); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L8B7B                   ; 8B76: 27 03         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L8B7B;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   L8BE1                   ; 8B78: BD 8B E1      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x7b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8b); 
    clockticks = clockticks + 1; 
    goto L8BE1;
  case 0x8B7B:
L8B7B:
                                                     #ifdef DEBUG
                                      mon("L8B7B    LDX   <$5A                    ; 8B7B: 9E 5A         \n");
                                      #endif
    PC = 0x8b7b; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x5a)<<8; 
    ea = ea | rd_mem(DP|0x5b); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LEAX  $19,X                   ; 8B7D: 30 88 19      \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + (SINT8)0x19); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$494B                  ; 8B80: 8C 49 4B      \n");
                                      #endif // 3x Tie fighter data structure ($19 bytes per Tie)
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x494b; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   L8B70                   ; 8B83: 25 EB         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L8B70;
    }
    // End of function sub_8B6D
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 8B85: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x8B86:
L8B86:
                                                     #ifdef DEBUG
                                      mon("L8B86    LDX   #$4900                  ; 8B86: 8E 49 00      \n");
                                      #endif // 3x Tie fighter data structure ($19 bytes per Tie)
    PC = 0x8b86; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x4900; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0x8B89:
L8B89:
                                                     #ifdef DEBUG
                                      mon("L8B89    STX   <$5A                    ; 8B89: 9F 5A         \n");
                                      #endif
    PC = 0x8b89; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = X; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = DP|0x5a; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         LDU   ,X                      ; 8B8B: EE 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $03,X                   ; 8B8D: A6 03         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0003)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$01                    ; 8B8F: 81 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x01; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   L8BD6                   ; 8B91: 26 43         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L8BD6;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $0A,U                   ; 8B93: A6 4A         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(U + 0x000a)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$09                    ; 8B95: 81 09         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x09; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BLT   L8B9B                   ; 8B97: 2D 02         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 3; 
    goto L8B9B;
    }
                                                     #ifdef DEBUG
                                      mon("         SUBA  #$02                    ; 8B99: 80 02         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x02; 
    res = val - (UINT8)arg; 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)(res); 
  case 0x8B9B:
L8B9B:
                                                     #ifdef DEBUG
                                      mon("L8B9B    CMPA  #$F7                    ; 8B9B: 81 F7         \n");
                                      #endif
    PC = 0x8b9b; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xf7; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BGT   L8BA1                   ; 8B9D: 2E 02         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto L8BA1;
    }
                                                     #ifdef DEBUG
                                      mon("         ADDA  #$02                    ; 8B9F: 8B 02         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x02; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
  case 0x8BA1:
L8BA1:
                                                     #ifdef DEBUG
                                      mon("L8BA1    STA   $0A,U                   ; 8BA1: A7 4A         \n");
                                      #endif
    PC = 0x8ba1; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(U + 0x000a); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $0C,U                   ; 8BA3: A6 4C         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(U + 0x000c)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$09                    ; 8BA5: 81 09         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x09; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BLT   L8BAB                   ; 8BA7: 2D 02         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 3; 
    goto L8BAB;
    }
                                                     #ifdef DEBUG
                                      mon("         SUBA  #$03                    ; 8BA9: 80 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x03; 
    res = val - (UINT8)arg; 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)(res); 
  case 0x8BAB:
L8BAB:
                                                     #ifdef DEBUG
                                      mon("L8BAB    CMPA  #$F7                    ; 8BAB: 81 F7         \n");
                                      #endif
    PC = 0x8bab; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xf7; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BGT   L8BB1                   ; 8BAD: 2E 02         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto L8BB1;
    }
                                                     #ifdef DEBUG
                                      mon("         ADDA  #$03                    ; 8BAF: 8B 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x03; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
  case 0x8BB1:
L8BB1:
                                                     #ifdef DEBUG
                                      mon("L8BB1    STA   $0C,U                   ; 8BB1: A7 4C         \n");
                                      #endif
    PC = 0x8bb1; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(U + 0x000c); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $08,U                   ; 8BB3: EC 48         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0x0008); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$0400                  ; 8BB5: C3 04 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0400; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ res) & (val ^ res)) >> 8; 
    N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BVS   L8BBE                   ; 8BB8: 29 04         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)V <  0) {
    clockticks = clockticks + 3; 
    goto L8BBE;
    }
                                                     #ifdef DEBUG
                                      mon("         STD   $08,U                   ; 8BBA: ED 48         \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = (UINT16)(U + 0x0008); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         BRA   L8BD6                   ; 8BBC: 20 18         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L8BD6;
    
    // ---------------------------------------------------------------------------
  case 0x8BBE:
L8BBE:
                                                     #ifdef DEBUG
                                      mon("L8BBE    LDA   $0A,U                   ; 8BBE: A6 4A         \n");
                                      #endif
    PC = 0x8bbe; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(U + 0x000a)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         TSTA                          ; 8BC0: 4D            \n");
                                      #endif
    val = (UINT8)A; 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BPL   L8BC4                   ; 8BC1: 2A 01         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto L8BC4;
    }
                                                     #ifdef DEBUG
                                      mon("         NEGA                          ; 8BC3: 40            \n");
                                      #endif
    val = (UINT8)A; 
    res = -val; 
 // V = val & (UINT8)res; 
 // C = res & 0x100; 
    val = (UINT8)res; 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
  case 0x8BC4:
L8BC4:
                                                     #ifdef DEBUG
                                      mon("L8BC4    CMPA  #$08                    ; 8BC4: 81 08         \n");
                                      #endif
    PC = 0x8bc4; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x08; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BGT   L8BD6                   ; 8BC6: 2E 0E         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto L8BD6;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $0C,U                   ; 8BC8: A6 4C         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(U + 0x000c)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         TSTA                          ; 8BCA: 4D            \n");
                                      #endif
    val = (UINT8)A; 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BPL   L8BCE                   ; 8BCB: 2A 01         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto L8BCE;
    }
                                                     #ifdef DEBUG
                                      mon("         NEGA                          ; 8BCD: 40            \n");
                                      #endif
    val = (UINT8)A; 
    res = -val; 
 // V = val & (UINT8)res; 
 // C = res & 0x100; 
    val = (UINT8)res; 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
  case 0x8BCE:
L8BCE:
                                                     #ifdef DEBUG
                                      mon("L8BCE    CMPA  #$08                    ; 8BCE: 81 08         \n");
                                      #endif
    PC = 0x8bce; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x08; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BGT   L8BD6                   ; 8BD0: 2E 04         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto L8BD6;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; 8BD2: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $03,X                   ; 8BD4: A7 03         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0003); 
    wr_mem(ea, val); 
  case 0x8BD6:
L8BD6:
                                                     #ifdef DEBUG
                                      mon("L8BD6    LDX   <$5A                    ; 8BD6: 9E 5A         \n");
                                      #endif
    PC = 0x8bd6; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x5a)<<8; 
    ea = ea | rd_mem(DP|0x5b); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LEAX  $19,X                   ; 8BD8: 30 88 19      \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + (SINT8)0x19); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$494B                  ; 8BDB: 8C 49 4B      \n");
                                      #endif // 3x Tie fighter data structure ($19 bytes per Tie)
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x494b; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   L8B89                   ; 8BDE: 25 A9         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L8B89;
    }
    // End of function sub_8B86
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 8BE0: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x8BE1:
L8BE1:
                                                     #ifdef DEBUG
                                      mon("L8BE1    JSR   L8E3A                   ; 8BE1: BD 8E 3A      \n");
                                      #endif
    PC = 0x8be1; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xe4); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8b); 
    clockticks = clockticks + 1; 
    goto L8E3A;
  case 0x8BE4:
L8BE4:
                                                     #ifdef DEBUG
                                      mon("L8BE4    LDD   #$00                    ; 8BE4: CC 00 00      \n");
                                      #endif
    PC = 0x8be4; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$4C                    ; 8BE7: 97 4C         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x4c; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   <$4E                    ; 8BE9: 97 4E         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x4e; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   <$4D                    ; 8BEB: 97 4D         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x4d; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   <$4F                    ; 8BED: 97 4F         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x4f; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $15,X                   ; 8BEF: A6 88 15      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + (SINT8)0x15)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$10                    ; 8BF2: 84 10         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x10; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $4703                   ; 8BF4: F6 47 03      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$30                    ; 8BF7: C4 30         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x30; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $15,X                   ; 8BF9: ED 88 15      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + (SINT8)0x15); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $09,X                   ; 8BFC: A6 09         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0009)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         DECA                          ; 8BFE: 4A            \n");
                                      #endif
    val = (UINT8)A; 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BMI   L8C15                   ; 8BFF: 2B 14         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto L8C15;
    }
                                                     #ifdef DEBUG
                                      mon("         STA   $09,X                   ; 8C01: A7 09         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0009); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$1640                  ; 8C03: CC 16 40      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x16; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5022                   ; 8C06: FD 50 22      \n");
                                      #endif // Sine for rotation
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5022, A); // Care needed with I/O space and word fetches
    wr_mem(0x5023, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$3C02                  ; 8C09: CC 3C 02      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x3c; 
    B = 0x02; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5024                   ; 8C0C: FD 50 24      \n");
                                      #endif // Cosine for rotation
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x5024, A); // Care needed with I/O space and word fetches
    wr_mem(0x5025, B); 
                                                     #ifdef DEBUG
                                      mon("         JSR   L89C8                   ; 8C0F: BD 89 C8      \n");
                                      #endif // Space wave roll
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x12); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8c); 
    clockticks = clockticks + 1; 
    goto L89C8;
    // ---------------------------------------------------------------------------
  case 0x8C12:
L8C12:
                                                     #ifdef DEBUG
                                      mon("L8C12    JMP   L8C44                   ; 8C12: 7E 8C 44      \n");
                                      #endif
    PC = 0x8c12; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    goto L8C44;
    
    // ---------------------------------------------------------------------------
  case 0x8C15:
L8C15:
                                                     #ifdef DEBUG
                                      mon("L8C15    LDB   $11,X                   ; 8C15: E6 88 11      \n");
                                      #endif
    PC = 0x8c15; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + (SINT8)0x11)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STB   <$50                    ; 8C18: D7 50         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
    V = 0; 
    ea = DP|0x50; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LSR   <$50                    ; 8C1A: 04 50         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x50); 
    C = val & 1; 
    val = val >> 1; 
    wr_mem(DP|0x50, val); 
    N = 0; 
    Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BCC   L8C21                   ; 8C1C: 24 03         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto L8C21;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   L8961                   ; 8C1E: BD 89 61      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x21); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8c); 
    clockticks = clockticks + 1; 
    goto L8961;
    // ---------------------------------------------------------------------------
  case 0x8C21:
L8C21:
                                                     #ifdef DEBUG
                                      mon("L8C21    LSR   <$50                    ; 8C21: 04 50         \n");
                                      #endif
    PC = 0x8c21; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x50); 
    C = val & 1; 
    val = val >> 1; 
    wr_mem(DP|0x50, val); 
    N = 0; 
    Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BCC   L8C28                   ; 8C23: 24 03         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto L8C28;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   L8969                   ; 8C25: BD 89 69      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x28); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8c); 
    clockticks = clockticks + 1; 
    goto L8969;
    // ---------------------------------------------------------------------------
  case 0x8C28:
L8C28:
                                                     #ifdef DEBUG
                                      mon("L8C28    LSR   <$50                    ; 8C28: 04 50         \n");
                                      #endif
    PC = 0x8c28; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x50); 
    C = val & 1; 
    val = val >> 1; 
    wr_mem(DP|0x50, val); 
    N = 0; 
    Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BCC   L8C2F                   ; 8C2A: 24 03         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto L8C2F;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   L8951                   ; 8C2C: BD 89 51      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x2f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8c); 
    clockticks = clockticks + 1; 
    goto L8951;
    // ---------------------------------------------------------------------------
  case 0x8C2F:
L8C2F:
                                                     #ifdef DEBUG
                                      mon("L8C2F    LSR   <$50                    ; 8C2F: 04 50         \n");
                                      #endif
    PC = 0x8c2f; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x50); 
    C = val & 1; 
    val = val >> 1; 
    wr_mem(DP|0x50, val); 
    N = 0; 
    Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BCC   L8C36                   ; 8C31: 24 03         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto L8C36;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   L8959                   ; 8C33: BD 89 59      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x36); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8c); 
    clockticks = clockticks + 1; 
    goto L8959;
    // ---------------------------------------------------------------------------
  case 0x8C36:
L8C36:
                                                     #ifdef DEBUG
                                      mon("L8C36    LSR   <$50                    ; 8C36: 04 50         \n");
                                      #endif
    PC = 0x8c36; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x50); 
    C = val & 1; 
    val = val >> 1; 
    wr_mem(DP|0x50, val); 
    N = 0; 
    Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BCC   L8C3D                   ; 8C38: 24 03         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto L8C3D;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   L8979                   ; 8C3A: BD 89 79      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x3d); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8c); 
    clockticks = clockticks + 1; 
    goto L8979;
    // ---------------------------------------------------------------------------
  case 0x8C3D:
L8C3D:
                                                     #ifdef DEBUG
                                      mon("L8C3D    LSR   <$50                    ; 8C3D: 04 50         \n");
                                      #endif
    PC = 0x8c3d; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x50); 
    C = val & 1; 
    val = val >> 1; 
    wr_mem(DP|0x50, val); 
    N = 0; 
    Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BCC   L8C44                   ; 8C3F: 24 03         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto L8C44;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   L8971                   ; 8C41: BD 89 71      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x44); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8c); 
    clockticks = clockticks + 1; 
    goto L8971;
    // ---------------------------------------------------------------------------
  case 0x8C44:
L8C44:
                                                     #ifdef DEBUG
                                      mon("L8C44    JSR   L8D9D                   ; 8C44: BD 8D 9D      \n");
                                      #endif // Some tie fighters process
    PC = 0x8c44; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x47); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8c); 
    clockticks = clockticks + 1; 
    goto L8D9D;
  case 0x8C47:
L8C47:
                                                     #ifdef DEBUG
                                      mon("L8C47    JSR   L8DE3                   ; 8C47: BD 8D E3      \n");
                                      #endif
    PC = 0x8c47; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x4a); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8c); 
    clockticks = clockticks + 1; 
    goto L8DE3;
  case 0x8C4A:
L8C4A:
                                                     #ifdef DEBUG
                                      mon("L8C4A    LDA   $03,X                   ; 8C4A: A6 03         \n");
                                      #endif
    PC = 0x8c4a; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0003)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$01                    ; 8C4C: 81 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x01; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         LBNE  L8D66                   ; 8C4E: 10 26 01 14   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if (Z) {
    clockticks = clockticks + 1; 
    goto L8D66;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $02,X                   ; 8C52: A6 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0002)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCE0C                   ; 8C54: BD CE 0C      \n");
                                      #endif // Copy transform data from [BIC] to matrix 2
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x57); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8c); 
    clockticks = clockticks + 1; 
    goto LCE0C;
  case 0x8C57:
L8C57:
                                                     #ifdef DEBUG
                                      mon("L8C57    LDX   <$5A                    ; 8C57: 9E 5A         \n");
                                      #endif
    PC = 0x8c57; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x5a)<<8; 
    ea = ea | rd_mem(DP|0x5b); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CLR   $0A,X                   ; 8C59: 6F 0A         \n");
                                      #endif
    clockticks = clockticks + 5; 
    wr_mem((UINT16)(X + 0x000a), 0); 
 // V = 0; 
 // Z = 0; 
 // N = 0; 
 // C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         CLRA                          ; 8C5B: 4F            \n");
                                      #endif
    A = 0; // SEARCH_ME
 // V = 0; 
 // Z = 0; 
 // N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$13                    ; 8C5C: C6 13         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x13; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4701                   ; 8C5E: FD 47 01      \n");
                                      #endif // Point BIC to $5098 MReg4C
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4701, A); // Care needed with I/O space and word fetches
    wr_mem(0x4702, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $11,X                   ; 8C61: A6 88 11      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + (SINT8)0x11)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BITA  #$40                    ; 8C64: 85 40         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A & (SINT8)0x40; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L8C81                   ; 8C66: 27 19         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L8C81;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $5098                   ; 8C68: FC 50 98      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x5098); // Care needed with I/O space and word fetches
    B = rd_mem(0x5099); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$1000                  ; 8C6B: C3 10 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x1000; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5098                   ; 8C6E: FD 50 98      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5098, A); // Care needed with I/O space and word fetches
    wr_mem(0x5099, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$67                    ; 8C71: 86 67         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x67; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCDBA                   ; 8C73: BD CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x76); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8c); 
    clockticks = clockticks + 1; 
    goto LCDBA;
  case 0x8C76:
L8C76:
                                                     #ifdef DEBUG
                                      mon("L8C76    LDD   $5098                   ; 8C76: FC 50 98      \n");
                                      #endif
    PC = 0x8c76; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x5098); // Care needed with I/O space and word fetches
    B = rd_mem(0x5099); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$1000                  ; 8C79: 83 10 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x1000; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5098                   ; 8C7C: FD 50 98      \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x5098, A); // Care needed with I/O space and word fetches
    wr_mem(0x5099, B); 
                                                     #ifdef DEBUG
                                      mon("         BRA   L8C86                   ; 8C7F: 20 05         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L8C86;
    
    // ---------------------------------------------------------------------------
  case 0x8C81:
L8C81:
                                                     #ifdef DEBUG
                                      mon("L8C81    LDA   #$67                    ; 8C81: 86 67         \n");
                                      #endif
    PC = 0x8c81; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x67; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCDBA                   ; 8C83: BD CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x86); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8c); 
    clockticks = clockticks + 1; 
    goto LCDBA;
  case 0x8C86:
L8C86:
                                                     #ifdef DEBUG
                                      mon("L8C86    LDD   $5000                   ; 8C86: FC 50 00      \n");
                                      #endif // Math result X
    PC = 0x8c86; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x5000); // Care needed with I/O space and word fetches
    B = rd_mem(0x5001); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BMI   L8CAE                   ; 8C89: 2B 23         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto L8CAE;
    }
                                                     #ifdef DEBUG
                                      mon("         INC   $0A,X                   ; 8C8B: 6C 0A         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x000a)); 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    wr_mem((UINT16)(X + 0x000a), res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$4000                  ; 8C8D: 83 40 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x4000; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BGE   L8CAE                   ; 8C90: 2C 1C         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) >= 0) {
    clockticks = clockticks + 3; 
    goto L8CAE;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $15,X                   ; 8C92: EC 88 15      \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + (SINT8)0x15); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORB   #$08                    ; 8C95: CA 08         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = B | (UINT8)0x08; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $15,X                   ; 8C97: ED 88 15      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + (SINT8)0x15); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $5072                   ; 8C9A: FC 50 72      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x5072); // Care needed with I/O space and word fetches
    B = rd_mem(0x5073); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $5074                   ; 8C9D: F3 50 74      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5074)<<8; 
    ea = ea | rd_mem(0x5075); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$20                    ; 8CA0: 10 83 00 20   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x0020; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BHI   L8CAE                   ; 8CA4: 22 08         \n");
                                      #endif
    // temp hack to force a flush
    if (Z && (!C)) {
    clockticks = clockticks + 3; 
    goto L8CAE;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $15,X                   ; 8CA6: EC 88 15      \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + (SINT8)0x15); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORB   #$04                    ; 8CA9: CA 04         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = B | (UINT8)0x04; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $15,X                   ; 8CAB: ED 88 15      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + (SINT8)0x15); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
  case 0x8CAE:
L8CAE:
                                                     #ifdef DEBUG
                                      mon("L8CAE    LDD   $15,X                   ; 8CAE: EC 88 15      \n");
                                      #endif
    PC = 0x8cae; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + (SINT8)0x15); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BITA  #$10                    ; 8CB1: 85 10         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A & (SINT8)0x10; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L8D05                   ; 8CB3: 27 50         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L8D05;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $11,X                   ; 8CB5: EC 88 11      \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + (SINT8)0x11); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BITA  #$40                    ; 8CB8: 85 40         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A & (SINT8)0x40; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L8D05                   ; 8CBA: 26 49         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L8D05;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $5000                   ; 8CBC: FC 50 00      \n");
                                      #endif // Math result X
    clockticks = clockticks + 5; 
    A = rd_mem(0x5000); // Care needed with I/O space and word fetches
    B = rd_mem(0x5001); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$0800                  ; 8CBF: 83 08 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0800; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BLE   L8D05                   ; 8CC2: 2F 41         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto L8D05;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $06,X                   ; 8CC4: A6 06         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0006)); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L8D05                   ; 8CC6: 26 3D         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L8D05;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   $4B19                   ; 8CC8: F6 4B 19      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b19); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$0B                    ; 8CCB: C1 0B         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x0b; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   L8CD4                   ; 8CCD: 25 05         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L8CD4;
    }
                                                     #ifdef DEBUG
                                      mon("         LDU   #byte_8D99              ; 8CCF: CE 8D 99      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x8d99; 
    Z = U; 
    N = (U) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   L8CDB                   ; 8CD2: 20 07         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L8CDB;
    
    // ---------------------------------------------------------------------------
  case 0x8CD4:
L8CD4:
                                                     #ifdef DEBUG
                                      mon("L8CD4    ASLB                          ; 8CD4: 58            \n");
                                      #endif
    PC = 0x8cd4; 
    INSTRUCTION_START
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; 8CD5: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #byte_8D71              ; 8CD6: CE 8D 71      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x8d71; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LEAU  B,U                     ; 8CD9: 33 C5         \n");
                                      #endif
    clockticks = clockticks + 5; 
    U = (U + (SINT8)B); 
  case 0x8CDB:
L8CDB:
                                                     #ifdef DEBUG
                                      mon("L8CDB    LDA   <$43                    ; 8CDB: 96 43         \n");
                                      #endif // Game over/insert coins timer
    PC = 0x8cdb; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x43); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  ,U                      ; 8CDD: A4 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)A; 
    res = val & rd_mem(U); 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L8D05                   ; 8CDF: 26 24         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L8D05;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4703                   ; 8CE1: B6 47 03      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  $01,U                   ; 8CE4: A1 41         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    arg = rd_mem((UINT16)(U + 0x0001)); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BLS   L8D05                   ; 8CE6: 23 1D         \n");
                                      #endif
    // temp hack to force a flush
    if ((!Z) || C) {
    clockticks = clockticks + 3; 
    goto L8D05;
    }
                                                     #ifdef DEBUG
                                      mon("         LDU   $02,U                   ; 8CE8: EE 42         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0002))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0002))+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0x8CEA:
L8CEA:
                                                     #ifdef DEBUG
                                      mon("L8CEA    LDA   $03,U                   ; 8CEA: A6 43         \n");
                                      #endif
    PC = 0x8cea; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(U + 0x0003)); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L8CFD                   ; 8CEC: 26 0F         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L8CFD;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   <$5A                    ; 8CEE: 9E 5A         \n");
                                      #endif
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x5a)<<8; 
    ea = ea | rd_mem(DP|0x5b); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   $15,X                   ; 8CF0: EC 88 15      \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + (SINT8)0x15); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORB   #$40                    ; 8CF3: CA 40         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = B | (UINT8)0x40; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $15,X                   ; 8CF5: ED 88 15      \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = (UINT16)(X + (SINT8)0x15); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LA68B                   ; 8CF8: BD A6 8B      \n");
                                      #endif // Emit fireballs from tie fighters
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xfb); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8c); 
    clockticks = clockticks + 1; 
    goto LA68B;
  case 0x8CFB:
L8CFB:
                                                     #ifdef DEBUG
                                      mon("L8CFB    BRA   L8D05                   ; 8CFB: 20 08         \n");
                                      #endif
    PC = 0x8cfb; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto L8D05;
    
    // ---------------------------------------------------------------------------
  case 0x8CFD:
L8CFD:
                                                     #ifdef DEBUG
                                      mon("L8CFD    LEAU  $06,U                   ; 8CFD: 33 46         \n");
                                      #endif
    PC = 0x8cfd; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    U = (U + 0x0006); 
                                                     #ifdef DEBUG
                                      mon("         CMPU  #$496F                  ; 8CFF: 11 83 49 6F   \n");
                                      #endif // 6x Fireball data structure 2 ($6 bytes per fireball)
    clockticks = clockticks + 5; 
    val = U; 
    arg = 0x496f; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   L8CEA                   ; 8D03: 25 E5         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L8CEA;
    }
  case 0x8D05:
L8D05:
                                                     #ifdef DEBUG
                                      mon("L8D05    LDX   <$5A                    ; 8D05: 9E 5A         \n");
                                      #endif
    PC = 0x8d05; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x5a)<<8; 
    ea = ea | rd_mem(DP|0x5b); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $11,X                   ; 8D07: A6 88 11      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + (SINT8)0x11)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BITA  #$80                    ; 8D0A: 85 80         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A & (SINT8)0x80; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L8D66                   ; 8D0C: 27 58         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L8D66;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   <$4F                    ; 8D0E: 96 4F         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x4f); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L8D3A                   ; 8D10: 26 28         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L8D3A;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $5002                   ; 8D12: B6 50 02      \n");
                                      #endif // Math result Y
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x5002); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BMI   L8D1C                   ; 8D15: 2B 05         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto L8D1C;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   L8979                   ; 8D17: BD 89 79      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x1a); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8d); 
    clockticks = clockticks + 1; 
    goto L8979;
    // ---------------------------------------------------------------------------
  case 0x8D1A:
L8D1A:
                                                     #ifdef DEBUG
                                      mon("L8D1A    BRA   L8D1F                   ; 8D1A: 20 03         \n");
                                      #endif
    PC = 0x8d1a; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto L8D1F;
    
    // ---------------------------------------------------------------------------
  case 0x8D1C:
L8D1C:
                                                     #ifdef DEBUG
                                      mon("L8D1C    JSR   L8971                   ; 8D1C: BD 89 71      \n");
                                      #endif
    PC = 0x8d1c; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x1f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8d); 
    clockticks = clockticks + 1; 
    goto L8971;
    // ---------------------------------------------------------------------------
  case 0x8D1F:
L8D1F:
                                                     #ifdef DEBUG
                                      mon("L8D1F    LDA   <$4E                    ; 8D1F: 96 4E         \n");
                                      #endif
    PC = 0x8d1f; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x4e); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L8D3A                   ; 8D21: 26 17         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L8D3A;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   $5004                   ; 8D23: F6 50 04      \n");
                                      #endif // Math result Z
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x5004); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SEX                           ; 8D26: 1D            \n");
                                      #endif
 // Z = B; 
 // N = B; 
    A = ((SINT8)B < 0 ? 0xff : 0); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ADDB  #$01                    ; 8D27: CB 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x01; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$01                    ; 8D29: C1 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x01; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BLS   L8D3A                   ; 8D2B: 23 0D         \n");
                                      #endif
    // temp hack to force a flush
    if ((!Z) || C) {
    clockticks = clockticks + 3; 
    goto L8D3A;
    }
                                                     #ifdef DEBUG
                                      mon("         EORA  $5002                   ; 8D2D: B8 50 02      \n");
                                      #endif // Math result Y
    clockticks = clockticks + 5; 
    res = A ^ rd_mem(0x5002); 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BMI   L8D37                   ; 8D30: 2B 05         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto L8D37;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   L8961                   ; 8D32: BD 89 61      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x35); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8d); 
    clockticks = clockticks + 1; 
    goto L8961;
    // ---------------------------------------------------------------------------
  case 0x8D35:
L8D35:
                                                     #ifdef DEBUG
                                      mon("L8D35    BRA   L8D3A                   ; 8D35: 20 03         \n");
                                      #endif
    PC = 0x8d35; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto L8D3A;
    
    // ---------------------------------------------------------------------------
  case 0x8D37:
L8D37:
                                                     #ifdef DEBUG
                                      mon("L8D37    JSR   L8969                   ; 8D37: BD 89 69      \n");
                                      #endif
    PC = 0x8d37; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x3a); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8d); 
    clockticks = clockticks + 1; 
    goto L8969;
    // ---------------------------------------------------------------------------
  case 0x8D3A:
L8D3A:
                                                     #ifdef DEBUG
                                      mon("L8D3A    LDA   <$4D                    ; 8D3A: 96 4D         \n");
                                      #endif
    PC = 0x8d3a; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x4d); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L8D66                   ; 8D3C: 26 28         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L8D66;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $5004                   ; 8D3E: B6 50 04      \n");
                                      #endif // Math result Z
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x5004); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BMI   L8D48                   ; 8D41: 2B 05         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto L8D48;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   L8951                   ; 8D43: BD 89 51      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x46); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8d); 
    clockticks = clockticks + 1; 
    goto L8951;
    // ---------------------------------------------------------------------------
  case 0x8D46:
L8D46:
                                                     #ifdef DEBUG
                                      mon("L8D46    BRA   L8D4B                   ; 8D46: 20 03         \n");
                                      #endif
    PC = 0x8d46; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto L8D4B;
    
    // ---------------------------------------------------------------------------
  case 0x8D48:
L8D48:
                                                     #ifdef DEBUG
                                      mon("L8D48    JSR   L8959                   ; 8D48: BD 89 59      \n");
                                      #endif
    PC = 0x8d48; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x4b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8d); 
    clockticks = clockticks + 1; 
    goto L8959;
    // ---------------------------------------------------------------------------
  case 0x8D4B:
L8D4B:
                                                     #ifdef DEBUG
                                      mon("L8D4B    LDA   <$4E                    ; 8D4B: 96 4E         \n");
                                      #endif
    PC = 0x8d4b; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x4e); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L8D66                   ; 8D4D: 26 17         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L8D66;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   $5002                   ; 8D4F: F6 50 02      \n");
                                      #endif // Math result Y
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x5002); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SEX                           ; 8D52: 1D            \n");
                                      #endif
 // Z = B; 
 // N = B; 
    A = ((SINT8)B < 0 ? 0xff : 0); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ADDB  #$01                    ; 8D53: CB 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x01; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$01                    ; 8D55: C1 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x01; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BLS   L8D66                   ; 8D57: 23 0D         \n");
                                      #endif
    // temp hack to force a flush
    if ((!Z) || C) {
    clockticks = clockticks + 3; 
    goto L8D66;
    }
                                                     #ifdef DEBUG
                                      mon("         EORA  $5004                   ; 8D59: B8 50 04      \n");
                                      #endif // Math result Z
    clockticks = clockticks + 5; 
    res = A ^ rd_mem(0x5004); 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BMI   L8D63                   ; 8D5C: 2B 05         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto L8D63;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   L8969                   ; 8D5E: BD 89 69      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x61); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8d); 
    clockticks = clockticks + 1; 
    goto L8969;
    // ---------------------------------------------------------------------------
  case 0x8D61:
L8D61:
                                                     #ifdef DEBUG
                                      mon("L8D61    BRA   L8D66                   ; 8D61: 20 03         \n");
                                      #endif
    PC = 0x8d61; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto L8D66;
    
    // ---------------------------------------------------------------------------
  case 0x8D63:
L8D63:
                                                     #ifdef DEBUG
                                      mon("L8D63    JSR   L8961                   ; 8D63: BD 89 61      \n");
                                      #endif
    PC = 0x8d63; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x66); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8d); 
    clockticks = clockticks + 1; 
    goto L8961;
    // ---------------------------------------------------------------------------
  case 0x8D66:
L8D66:
                                                     #ifdef DEBUG
                                      mon("L8D66    LDX   <$5A                    ; 8D66: 9E 5A         \n");
                                      #endif
    PC = 0x8d66; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x5a)<<8; 
    ea = ea | rd_mem(DP|0x5b); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   $15,X                   ; 8D68: EC 88 15      \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + (SINT8)0x15); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$EF                    ; 8D6B: 84 EF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0xef; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $15,X                   ; 8D6D: ED 88 15      \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = (UINT16)(X + (SINT8)0x15); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    // End of function sub_8BE1
    // ---------------------------------------------------------------------------
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 8D70: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Some tie fighters process
  case 0x8D9D:
L8D9D:
                                                     #ifdef DEBUG
                                      mon("L8D9D    LDX   <$5A                    ; 8D9D: 9E 5A         \n");
                                      #endif
    PC = 0x8d9d; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x5a)<<8; 
    ea = ea | rd_mem(DP|0x5b); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   ,X                      ; 8D9F: EE 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $06,X                   ; 8DA1: A6 06         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0006)); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L8DDF                   ; 8DA3: 26 3A         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L8DDF;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   $12,X                   ; 8DA5: E6 88 12      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + (SINT8)0x12)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STB   <$50                    ; 8DA8: D7 50         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x50; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDU   ,X                      ; 8DAA: EE 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; 8DAC: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   -10,U                   ; 8DAF: ED 56         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0xfff6); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   -2,U                    ; 8DB1: ED 5E         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0xfffe); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $06,U                   ; 8DB3: ED 46         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
    V = 0; 
    ea = (UINT16)(U + 0x0006); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LSR   <$50                    ; 8DB5: 04 50         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x50); 
    C = val & 1; 
    val = val >> 1; 
    wr_mem(DP|0x50, val); 
    N = 0; 
    Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BCC   L8DBC                   ; 8DB7: 24 03         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto L8DBC;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   L8A59                   ; 8DB9: BD 8A 59      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xbc); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8d); 
    clockticks = clockticks + 1; 
    goto L8A59;
  case 0x8DBC:
L8DBC:
                                                     #ifdef DEBUG
                                      mon("L8DBC    LSR   <$50                    ; 8DBC: 04 50         \n");
                                      #endif
    PC = 0x8dbc; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x50); 
    C = val & 1; 
    val = val >> 1; 
    wr_mem(DP|0x50, val); 
    N = 0; 
    Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BCC   L8DC3                   ; 8DBE: 24 03         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto L8DC3;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   L8A7E                   ; 8DC0: BD 8A 7E      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xc3); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8d); 
    clockticks = clockticks + 1; 
    goto L8A7E;
  case 0x8DC3:
L8DC3:
                                                     #ifdef DEBUG
                                      mon("L8DC3    LSR   <$50                    ; 8DC3: 04 50         \n");
                                      #endif
    PC = 0x8dc3; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x50); 
    C = val & 1; 
    val = val >> 1; 
    wr_mem(DP|0x50, val); 
    N = 0; 
    Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BCC   L8DCA                   ; 8DC5: 24 03         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto L8DCA;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   L8A21                   ; 8DC7: BD 8A 21      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xca); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8d); 
    clockticks = clockticks + 1; 
    goto L8A21;
  case 0x8DCA:
L8DCA:
                                                     #ifdef DEBUG
                                      mon("L8DCA    LSR   <$50                    ; 8DCA: 04 50         \n");
                                      #endif
    PC = 0x8dca; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x50); 
    C = val & 1; 
    val = val >> 1; 
    wr_mem(DP|0x50, val); 
    N = 0; 
    Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BCC   L8DD1                   ; 8DCC: 24 03         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto L8DD1;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   L8A3D                   ; 8DCE: BD 8A 3D      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xd1); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8d); 
    clockticks = clockticks + 1; 
    goto L8A3D;
  case 0x8DD1:
L8DD1:
                                                     #ifdef DEBUG
                                      mon("L8DD1    LSR   <$50                    ; 8DD1: 04 50         \n");
                                      #endif
    PC = 0x8dd1; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x50); 
    C = val & 1; 
    val = val >> 1; 
    wr_mem(DP|0x50, val); 
    N = 0; 
    Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BCC   L8DD8                   ; 8DD3: 24 03         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto L8DD8;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   L8A05                   ; 8DD5: BD 8A 05      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xd8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8d); 
    clockticks = clockticks + 1; 
    goto L8A05;
  case 0x8DD8:
L8DD8:
                                                     #ifdef DEBUG
                                      mon("L8DD8    LSR   <$50                    ; 8DD8: 04 50         \n");
                                      #endif
    PC = 0x8dd8; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x50); 
    C = val & 1; 
    val = val >> 1; 
    wr_mem(DP|0x50, val); 
    N = 0; 
    Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BCC   L8DDF                   ; 8DDA: 24 03         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto L8DDF;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   L89E9                   ; 8DDC: BD 89 E9      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xdf); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8d); 
    clockticks = clockticks + 1; 
    goto L89E9;
  case 0x8DDF:
L8DDF:
                                                     #ifdef DEBUG
                                      mon("L8DDF    JSR   L8AB6                   ; 8DDF: BD 8A B6      \n");
                                      #endif
    PC = 0x8ddf; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xe2); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8d); 
    clockticks = clockticks + 1; 
    goto L8AB6;
    // End of function sub_8D9D
  case 0x8DE2:
L8DE2:
                                                     #ifdef DEBUG
                                      mon("L8DE2    RTS                           ; 8DE2: 39            \n");
                                      #endif
    PC = 0x8de2; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x8DE3:
L8DE3:
                                                     #ifdef DEBUG
                                      mon("L8DE3    LDU   ,X                      ; 8DE3: EE 84         \n");
                                      #endif
    PC = 0x8de3; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   $08,U                   ; 8DE5: EC 48         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0x0008); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$7D                    ; 8DE7: 81 7D         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x7d; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BLT   L8DEE                   ; 8DE9: 2D 03         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 3; 
    goto L8DEE;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$7CFF                  ; 8DEB: CC 7C FF      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x7c; 
    B = 0xff; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0x8DEE:
L8DEE:
                                                     #ifdef DEBUG
                                      mon("L8DEE    CMPA  #$82                    ; 8DEE: 81 82         \n");
                                      #endif
    PC = 0x8dee; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x82; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BGT   L8DF5                   ; 8DF0: 2E 03         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto L8DF5;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$8300                  ; 8DF2: CC 83 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x83; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0x8DF5:
L8DF5:
                                                     #ifdef DEBUG
                                      mon("L8DF5    STD   $08,U                   ; 8DF5: ED 48         \n");
                                      #endif
    PC = 0x8df5; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0x0008); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $0A,U                   ; 8DF7: EC 4A         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0x000a); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$7D                    ; 8DF9: 81 7D         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x7d; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BLT   L8E00                   ; 8DFB: 2D 03         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 3; 
    goto L8E00;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$7CFF                  ; 8DFD: CC 7C FF      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x7c; 
    B = 0xff; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0x8E00:
L8E00:
                                                     #ifdef DEBUG
                                      mon("L8E00    CMPA  #$82                    ; 8E00: 81 82         \n");
                                      #endif
    PC = 0x8e00; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x82; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BGT   L8E07                   ; 8E02: 2E 03         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto L8E07;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$8300                  ; 8E04: CC 83 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x83; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0x8E07:
L8E07:
                                                     #ifdef DEBUG
                                      mon("L8E07    STD   $0A,U                   ; 8E07: ED 4A         \n");
                                      #endif
    PC = 0x8e07; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0x000a); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $0C,U                   ; 8E09: EC 4C         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0x000c); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$7D                    ; 8E0B: 81 7D         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x7d; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BLT   L8E12                   ; 8E0D: 2D 03         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 3; 
    goto L8E12;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$7CFF                  ; 8E0F: CC 7C FF      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x7c; 
    B = 0xff; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0x8E12:
L8E12:
                                                     #ifdef DEBUG
                                      mon("L8E12    CMPA  #$82                    ; 8E12: 81 82         \n");
                                      #endif
    PC = 0x8e12; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x82; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BGT   L8E19                   ; 8E14: 2E 03         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto L8E19;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$8300                  ; 8E16: CC 83 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x83; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0x8E19:
L8E19:
                                                     #ifdef DEBUG
                                      mon("L8E19    STD   $0C,U                   ; 8E19: ED 4C         \n");
                                      #endif
    PC = 0x8e19; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = (UINT16)(U + 0x000c); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    // End of function sub_8DE3
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 8E1B: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x8E1C:
L8E1C:
                                                     #ifdef DEBUG
                                      mon("L8E1C    DEC   <$E6                    ; 8E1C: 0A E6         \n");
                                      #endif
    PC = 0x8e1c; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xe6); 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    wr_mem(DP|0xe6, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BGT   locret_8E22             ; 8E1E: 2E 02         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto L8E22;
    }
                                                     #ifdef DEBUG
                                      mon("         CLR   <$E6                    ; 8E20: 0F E6         \n");
                                      #endif
    clockticks = clockticks + 4; 
    wr_mem(DP|0xe6, 0); 
    V = 0; 
    Z = 0; 
    N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
    // End of function sub_8E1C
  case 0x8E22:
L8E22:
locret_8E22:
                                                     #ifdef DEBUG
                                      mon("locret_8E22 RTS                           ; 8E22: 39            \n");
                                      #endif
    PC = 0x8e22; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x8E23:
L8E23:
                                                     #ifdef DEBUG
                                      mon("L8E23    LDD   #$00                    ; 8E23: CC 00 00      \n");
                                      #endif
    PC = 0x8e23; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $11,X                   ; 8E26: ED 88 11      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + (SINT8)0x11); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STA   $10,X                   ; 8E29: A7 88 10      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + (SINT8)0x10); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STD   $13,X                   ; 8E2C: ED 88 13      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + (SINT8)0x13); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $15,X                   ; 8E2F: ED 88 15      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + (SINT8)0x15); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
  case 0x8E32:
L8E32:
                                                     #ifdef DEBUG
                                      mon("L8E32    LDU   $0D,X                   ; 8E32: EE 0D         \n");
                                      #endif
    PC = 0x8e32; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(X + 0x000d))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(X + 0x000d))+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   ,U                      ; 8E34: A6 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(U); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $0F,X                   ; 8E36: A7 0F         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = (UINT16)(X + 0x000f); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L8E51                   ; 8E38: 27 17         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L8E51;
    }
  case 0x8E3A:
L8E3A:
                                                     #ifdef DEBUG
                                      mon("L8E3A    LDD   $15,X                   ; 8E3A: EC 88 15      \n");
                                      #endif
    PC = 0x8e3a; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + (SINT8)0x15); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  $13,X                   ; 8E3D: A4 88 13      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    res = val & rd_mem((UINT16)(X + (SINT8)0x13)); 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L8E5C                   ; 8E40: 26 1A         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L8E5C;
    }
                                                     #ifdef DEBUG
                                      mon("         ANDB  $14,X                   ; 8E42: E4 88 14      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)B; 
    res = val & rd_mem((UINT16)(X + (SINT8)0x14)); 
    B = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L8E5C                   ; 8E45: 26 15         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L8E5C;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $0F,X                   ; 8E47: A6 0F         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x000f)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$07                    ; 8E49: 84 07         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x07; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLA                          ; 8E4B: 48            \n");
                                      #endif
    val = (UINT8)A; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #JumpTable8E68          ; 8E4C: CE 8E 68      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x8e68; 
    Z = U; 
    N = (U) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JMP   [A,U]                   ; 8E4F: 6E D6         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 2; 
    ea = rd_mem((UINT16)(U + (SINT8)A))<<8; 
    ea = ea | rd_mem((UINT16)(U + (SINT8)A + 1)); 
    PC = ea; 
    JUMP;
    
    // ---------------------------------------------------------------------------
  case 0x8E51:
L8E51:
                                                     #ifdef DEBUG
                                      mon("L8E51    LDD   $01,U                   ; 8E51: EC 41         \n");
                                      #endif
    PC = 0x8e51; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0x0001); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $13,X                   ; 8E53: ED 88 13      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + (SINT8)0x13); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LEAU  $03,U                   ; 8E56: 33 43         \n");
                                      #endif
    clockticks = clockticks + 5; 
    U = (U + 0x0003); 
                                                     #ifdef DEBUG
                                      mon("         STU   $0D,X                   ; 8E58: EF 0D         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
    Z = val; 
    N = (UINT8)(val >> 8); 
    V = 0; 
    ea = (X + 0x000d); 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         BRA   L8E32                   ; 8E5A: 20 D6         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L8E32;
    
    // ---------------------------------------------------------------------------
  case 0x8E5C:
L8E5C:
                                                     #ifdef DEBUG
                                      mon("L8E5C    LDU   $0D,X                   ; 8E5C: EE 0D         \n");
                                      #endif
    PC = 0x8e5c; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(X + 0x000d))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(X + 0x000d))+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0x8E5E:
L8E5E:
                                                     #ifdef DEBUG
                                      mon("L8E5E    LDA   ,U                      ; 8E5E: A6 C4         \n");
                                      #endif
    PC = 0x8e5e; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(U); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L8E32                   ; 8E60: 27 D0         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L8E32;
    }
                                                     #ifdef DEBUG
                                      mon("         LEAU  $03,U                   ; 8E62: 33 43         \n");
                                      #endif
    clockticks = clockticks + 5; 
    U = (U + 0x0003); 
                                                     #ifdef DEBUG
                                      mon("         STU   $0D,X                   ; 8E64: EF 0D         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
    Z = val; 
    N = (UINT8)(val >> 8); 
    V = 0; 
    ea = (X + 0x000d); 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
    // End of function sub_8E23
    // ---------------------------------------------------------------------------
                                                     #ifdef DEBUG
                                      mon("         BRA   L8E5E                   ; 8E66: 20 F6         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L8E5E;
    
    // =============== S U B R O U T I N E =======================================
    // End of function sub_8E78
  case 0x8E78:
L8E78:
                                                     #ifdef DEBUG
                                      mon("L8E78    SWI                           ; 8E78: 3F            \n");
                                      #endif
    PC = 0x8e78; 
    INSTRUCTION_START
    clockticks = clockticks + 19; 
    --S;
    wr_mem(S, 0x79); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8e); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, U); 
    --S;
    wr_mem(S, U >> 8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, Y); 
    --S;
    wr_mem(S, Y >> 8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, X); 
    --S;
    wr_mem(S, X >> 8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, (DP >> 8)); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, B); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, A); 
    clockticks = clockticks + 1; 
    simplify_flags();
    CC = (((((((((((((E<<1) | F)<<1) | H)<<1) |I)<<1) | N)<<1) | Z)<<1) | V)<<1) | C; // Placeholder for now
    restore_flags();
    --S;
    wr_mem(S, CC); 
    clockticks = clockticks + 1; 
    PC = (rd_mem(0xfffa)<<8)|rd_mem(0xfffb); 
    JUMP;
    // =============== S U B R O U T I N E =======================================
  case 0x8E79:
L8E79:
                                                     #ifdef DEBUG
                                      mon("L8E79    LDU   $0D,X                   ; 8E79: EE 0D         \n");
                                      #endif
    PC = 0x8e79; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(X + 0x000d))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(X + 0x000d))+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0x8E7B:
L8E7B:
                                                     #ifdef DEBUG
                                      mon("L8E7B    LDD   $01,U                   ; 8E7B: EC 41         \n");
                                      #endif
    PC = 0x8e7b; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0x0001); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L8E94                   ; 8E7D: 27 15         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L8E94;
    }
                                                     #ifdef DEBUG
                                      mon("         ANDA  $15,X                   ; 8E7F: A4 88 15      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    res = val & rd_mem((UINT16)(X + (SINT8)0x15)); 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L8E94                   ; 8E82: 26 10         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L8E94;
    }
                                                     #ifdef DEBUG
                                      mon("         ANDB  $16,X                   ; 8E84: E4 88 16      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)B; 
    res = val & rd_mem((UINT16)(X + (SINT8)0x16)); 
    B = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L8E94                   ; 8E87: 26 0B         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L8E94;
    }
  case 0x8E89:
L8E89:
                                                     #ifdef DEBUG
                                      mon("L8E89    LEAU  $03,U                   ; 8E89: 33 43         \n");
                                      #endif
    PC = 0x8e89; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    U = (U + 0x0003); 
                                                     #ifdef DEBUG
                                      mon("         LDA   ,U                      ; 8E8B: A6 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(U); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLA                          ; 8E8D: 48            \n");
                                      #endif
    val = (UINT8)A; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
    Z = res; 
    N = res; 
    V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L8E89                   ; 8E8E: 26 F9         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L8E89;
    }
                                                     #ifdef DEBUG
                                      mon("         BCC   L8E89                   ; 8E90: 24 F7         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto L8E89;
    }
                                                     #ifdef DEBUG
                                      mon("         BRA   L8E7B                   ; 8E92: 20 E7         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L8E7B;
    
    // ---------------------------------------------------------------------------
  case 0x8E94:
L8E94:
                                                     #ifdef DEBUG
                                      mon("L8E94    LEAU  $03,U                   ; 8E94: 33 43         \n");
                                      #endif
    PC = 0x8e94; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    U = (U + 0x0003); 
                                                     #ifdef DEBUG
                                      mon("         STU   $0D,X                   ; 8E96: EF 0D         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
    Z = val; 
    N = (UINT8)(val >> 8); 
    V = 0; 
    ea = (X + 0x000d); 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
    // End of function sub_8E79
                                                     #ifdef DEBUG
                                      mon("         JMP   L8E32                   ; 8E98: 7E 8E 32      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto L8E32;
    
    // =============== S U B R O U T I N E =======================================
  case 0x8E9B:
L8E9B:
                                                     #ifdef DEBUG
                                      mon("L8E9B    LDU   $0D,X                   ; 8E9B: EE 0D         \n");
                                      #endif
    PC = 0x8e9b; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(X + 0x000d))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(X + 0x000d))+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   $01,U                   ; 8E9D: EE 41         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0001))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0001))+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STU   $0D,X                   ; 8E9F: EF 0D         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
    Z = val; 
    N = (UINT8)(val >> 8); 
    V = 0; 
    ea = (X + 0x000d); 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
    // End of function sub_8E9B
                                                     #ifdef DEBUG
                                      mon("         JMP   L8E32                   ; 8EA1: 7E 8E 32      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto L8E32;
    
    // =============== S U B R O U T I N E =======================================
  case 0x8EA4:
L8EA4:
                                                     #ifdef DEBUG
                                      mon("L8EA4    LDU   $0D,X                   ; 8EA4: EE 0D         \n");
                                      #endif
    PC = 0x8ea4; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(X + 0x000d))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(X + 0x000d))+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LEAU  $03,U                   ; 8EA6: 33 43         \n");
                                      #endif
    clockticks = clockticks + 5; 
    U = (U + 0x0003); 
                                                     #ifdef DEBUG
                                      mon("         STU   $17,X                   ; 8EA8: EF 88 17      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = (X + (SINT8)0x17); 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         LDU   -2,U                    ; 8EAB: EE 5E         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0xfffe))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0xfffe))+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STU   $0D,X                   ; 8EAD: EF 0D         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
    Z = val; 
    N = (UINT8)(val >> 8); 
    V = 0; 
    ea = (X + 0x000d); 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
    // End of function sub_8EA4
                                                     #ifdef DEBUG
                                      mon("         JMP   L8E32                   ; 8EAF: 7E 8E 32      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto L8E32;
    
    // =============== S U B R O U T I N E =======================================
  case 0x8EB2:
L8EB2:
                                                     #ifdef DEBUG
                                      mon("L8EB2    LDU   $17,X                   ; 8EB2: EE 88 17      \n");
                                      #endif
    PC = 0x8eb2; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(X + (SINT8)0x17))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(X + (SINT8)0x17))+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STU   $0D,X                   ; 8EB5: EF 0D         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
    Z = val; 
    N = (UINT8)(val >> 8); 
    V = 0; 
    ea = (X + 0x000d); 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
    // End of function sub_8EB2
                                                     #ifdef DEBUG
                                      mon("         JMP   L8E32                   ; 8EB7: 7E 8E 32      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto L8E32;
    
    // =============== S U B R O U T I N E =======================================
  case 0x8EBA:
L8EBA:
                                                     #ifdef DEBUG
                                      mon("L8EBA    LDU   $0D,X                   ; 8EBA: EE 0D         \n");
                                      #endif
    PC = 0x8eba; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(X + 0x000d))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(X + 0x000d))+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   ,U                      ; 8EBC: E6 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(U); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LSRB                          ; 8EBE: 54            \n");
                                      #endif
    val = (UINT8)B; 
    C = val & 1; 
    val = val >> 1; 
    B = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STB   $10,X                   ; 8EBF: E7 88 10      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + (SINT8)0x10); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $01,U                   ; 8EC2: EC 41         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0x0001); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $11,X                   ; 8EC4: ED 88 11      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + (SINT8)0x11); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LEAU  $03,U                   ; 8EC7: 33 43         \n");
                                      #endif
    clockticks = clockticks + 5; 
    U = (U + 0x0003); 
                                                     #ifdef DEBUG
                                      mon("         STU   $0D,X                   ; 8EC9: EF 0D         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = (X + 0x000d); 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         INC   $0F,X                   ; 8ECB: 6C 0F         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x000f)); 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    wr_mem((UINT16)(X + 0x000f), res); 
    clockticks = clockticks + 2; 
    // End of function sub_8EBA
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 8ECD: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x8ECE:
L8ECE:
                                                     #ifdef DEBUG
                                      mon("L8ECE    DEC   $10,X                   ; 8ECE: 6A 88 10      \n");
                                      #endif
    PC = 0x8ece; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + (SINT8)0x10)); 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    wr_mem((UINT16)(X + (SINT8)0x10), res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LBMI  L8E32                   ; 8ED1: 10 2B FF 5D   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if ((SINT8)N <  0) {
    clockticks = clockticks + 1; 
    goto L8E32;
    }
    // End of function sub_8ECE
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 8ED5: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x8ED6:
L8ED6:
                                                     #ifdef DEBUG
                                      mon("L8ED6    JSR   LCCC0                   ; 8ED6: BD CC C0      \n");
                                      #endif // Initialise object?
    PC = 0x8ed6; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xd9); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8e); 
    clockticks = clockticks + 1; 
    goto LCCC0;
  case 0x8ED9:
L8ED9:
                                                     #ifdef DEBUG
                                      mon("L8ED9    LDB   $4B14                   ; 8ED9: F6 4B 14      \n");
                                      #endif
    PC = 0x8ed9; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b14); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; 8EDC: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #off_9070               ; 8EDD: 8E 90 70      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x9070; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; 8EE0: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #byte_907C              ; 8EE1: 8C 90 7C      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x907c; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   L8EF4                   ; 8EE4: 25 0E         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L8EF4;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B14                   ; 8EE6: B6 4B 14      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b14); 
    A = val; 
 // N = val; 
 // Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; 8EE9: 44            \n");
                                      #endif
    val = (UINT8)A; 
    C = val & 1; 
    val = val >> 1; 
    A = val; 
    N = 0; 
    Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BCS   L8EF1                   ; 8EEA: 25 05         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L8EF1;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   #off_9078               ; 8EEC: 8E 90 78      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x9078; 
    Z = X; 
    N = (X) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   L8EF4                   ; 8EEF: 20 03         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L8EF4;
    
    // ---------------------------------------------------------------------------
  case 0x8EF1:
L8EF1:
                                                     #ifdef DEBUG
                                      mon("L8EF1    LDX   #off_907A               ; 8EF1: 8E 90 7A      \n");
                                      #endif
    PC = 0x8ef1; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x907a; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0x8EF4:
L8EF4:
                                                     #ifdef DEBUG
                                      mon("L8EF4    LDX   ,X                      ; 8EF4: AE 84         \n");
                                      #endif
    PC = 0x8ef4; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   <$DD                    ; 8EF6: D6 DD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xdd); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  ,X+                     ; 8EF8: E1 80         \n");
                                      #endif
    clockticks = clockticks + 6; 
    val = (UINT8)B; 
    arg = rd_mem(X); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
    X = X + 1; 
                                                     #ifdef DEBUG
                                      mon("         BLS   L8EFE                   ; 8EFA: 23 02         \n");
                                      #endif
    // temp hack to force a flush
    if ((!Z) || C) {
    clockticks = clockticks + 3; 
    goto L8EFE;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   -1,X                    ; 8EFC: E6 1F         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0xffff)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0x8EFE:
L8EFE:
                                                     #ifdef DEBUG
                                      mon("L8EFE    ASLB                          ; 8EFE: 58            \n");
                                      #endif
    PC = 0x8efe; 
    INSTRUCTION_START
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   B,X                     ; 8EFF: EC 85         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + (SINT8)B); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$E4                    ; 8F01: DD E4         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0xe4; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         CLR   <$E6                    ; 8F03: 0F E6         \n");
                                      #endif
    clockticks = clockticks + 4; 
    wr_mem(DP|0xe6, 0); 
 // V = 0; 
 // Z = 0; 
 // N = 0; 
 // C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4900                  ; 8F05: 8E 49 00      \n");
                                      #endif // 3x Tie fighter data structure ($19 bytes per Tie)
    clockticks = clockticks + 3; 
    X = 0x4900; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0x8F08:
L8F08:
                                                     #ifdef DEBUG
                                      mon("L8F08    STX   <$5A                    ; 8F08: 9F 5A         \n");
                                      #endif
    PC = 0x8f08; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = X; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = DP|0x5a; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         CLR   $03,X                   ; 8F0A: 6F 03         \n");
                                      #endif
    clockticks = clockticks + 5; 
    wr_mem((UINT16)(X + 0x0003), 0); 
 // V = 0; 
 // Z = 0; 
 // N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDU   <$E4                    ; 8F0C: DE E4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xe4)<<8; 
    ea = ea | rd_mem(DP|0xe5); 
    U = ea; 
    Z = U; 
    N = (U) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L8F29                   ; 8F0E: 27 19         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L8F29;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   ,U                      ; 8F10: A6 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(U); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L8F29                   ; 8F12: 27 15         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L8F29;
    }
                                                     #ifdef DEBUG
                                      mon("         INC   <$E6                    ; 8F14: 0C E6         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xe6); 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    wr_mem(DP|0xe6, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   ,U                      ; 8F16: EC C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(U); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(U+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$E0                    ; 8F18: DD E0         \n");
                                      #endif // Pointer to 3D object index
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0xe0; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $02,U                   ; 8F1A: EC 42         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0x0002); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$DE                    ; 8F1C: DD DE         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0xde; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $04,U                   ; 8F1E: EC 44         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0x0004); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$E2                    ; 8F20: DD E2         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0xe2; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LEAU  $06,U                   ; 8F22: 33 46         \n");
                                      #endif
    clockticks = clockticks + 5; 
    U = (U + 0x0006); 
                                                     #ifdef DEBUG
                                      mon("         STU   <$E4                    ; 8F24: DF E4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = DP|0xe4; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   L8F34                   ; 8F26: BD 8F 34      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x29); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8f); 
    clockticks = clockticks + 1; 
    goto L8F34;
  case 0x8F29:
L8F29:
                                                     #ifdef DEBUG
                                      mon("L8F29    LDX   <$5A                    ; 8F29: 9E 5A         \n");
                                      #endif
    PC = 0x8f29; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x5a)<<8; 
    ea = ea | rd_mem(DP|0x5b); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LEAX  $19,X                   ; 8F2B: 30 88 19      \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + (SINT8)0x19); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$494B                  ; 8F2E: 8C 49 4B      \n");
                                      #endif // 3x Tie fighter data structure ($19 bytes per Tie)
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x494b; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   L8F08                   ; 8F31: 25 D5         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L8F08;
    }
    // End of function sub_8ED6
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 8F33: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x8F34:
L8F34:
                                                     #ifdef DEBUG
                                      mon("L8F34    LDA   #$01                    ; 8F34: 86 01         \n");
                                      #endif // Called 3 times at start of attract screen 1 and 2
    PC = 0x8f34; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x01; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $03,X                   ; 8F36: A7 03         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0003); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDU   ,X                      ; 8F38: EE 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCDC3                   ; 8F3A: BD CD C3      \n");
                                      #endif // Initialise math registers matrix
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x3d); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8f); 
    clockticks = clockticks + 1; 
    goto LCDC3;
  case 0x8F3D:
L8F3D:
                                                     #ifdef DEBUG
                                      mon("L8F3D    LDU   ,X                      ; 8F3D: EE 84         \n");
                                      #endif
    PC = 0x8f3d; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$C0                    ; 8F3F: 86 C0         \n");
                                      #endif // Matrix -1.000 constant
    clockticks = clockticks + 2; 
    val = (UINT8)0xc0; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   -16,U                   ; 8F41: A7 50         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(U + 0xfff0); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   -6,U                    ; 8F43: A7 5A         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(U + 0xfffa); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         CLRA                          ; 8F45: 4F            \n");
                                      #endif
    A = 0; // SEARCH_ME
 // V = 0; 
 // Z = 0; 
 // N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $09,X                   ; 8F46: A7 09         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0009); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   $08,X                   ; 8F48: A7 08         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0008); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   $06,X                   ; 8F4A: A7 06         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0006); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   $05,X                   ; 8F4C: A7 05         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0005); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   $0B,X                   ; 8F4E: A7 0B         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x000b); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDU   <$E0                    ; 8F50: DE E0         \n");
                                      #endif // Pointer to 3D object index
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xe0)<<8; 
    ea = ea | rd_mem(DP|0xe1); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $01,U                   ; 8F52: A6 41         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(U + 0x0001)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $07,X                   ; 8F54: A7 07         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0007); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDU   ,X                      ; 8F56: EE 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDX   <$E2                    ; 8F58: 9E E2         \n");
                                      #endif
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xe2)<<8; 
    ea = ea | rd_mem(DP|0xe3); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   ,X                      ; 8F5A: EC 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(X); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(X+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $08,U                   ; 8F5C: ED 48         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0x0008); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $02,X                   ; 8F5E: EC 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + 0x0002); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $0A,U                   ; 8F60: ED 4A         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0x000a); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $04,X                   ; 8F62: EC 04         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + 0x0004); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $0C,U                   ; 8F64: ED 4C         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0x000c); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDX   <$5A                    ; 8F66: 9E 5A         \n");
                                      #endif
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x5a)<<8; 
    ea = ea | rd_mem(DP|0x5b); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$DE                    ; 8F68: DC DE         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0xde); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0xdf); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $0D,X                   ; 8F6A: ED 0D         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x000d); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         JSR   L8E23                   ; 8F6C: BD 8E 23      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x6f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8f); 
    clockticks = clockticks + 1; 
    goto L8E23;
  case 0x8F6F:
L8F6F:
                                                     #ifdef DEBUG
                                      mon("L8F6F    LDX   <$5A                    ; 8F6F: 9E 5A         \n");
                                      #endif
    PC = 0x8f6f; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x5a)<<8; 
    ea = ea | rd_mem(DP|0x5b); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   [$48E0]                 ; 8F71: E6 9F 48 E0   \n");
                                      #endif // Pointer to 3D object index
    clockticks = clockticks + 6; 
    clockticks = clockticks + 2; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x48e0)<<8; 
    ea = ea | rd_mem(0x48e1); 
    val = (UINT8)rd_mem(ea); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STB   $04,X                   ; 8F75: E7 04         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = B; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = (UINT16)(X + 0x0004); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCCCC                   ; 8F77: BD CC CC      \n");
                                      #endif // Copy XYZ data to math RAM
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x7a); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8f); 
    clockticks = clockticks + 1; 
    goto LCCCC;
    // End of function sub_8F34
  case 0x8F7A:
L8F7A:
                                                     #ifdef DEBUG
                                      mon("L8F7A    RTS                           ; 8F7A: 39            \n");
                                      #endif
    PC = 0x8f7a; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x8F7B:
L8F7B:
                                                     #ifdef DEBUG
                                      mon("L8F7B    LDU   <$E4                    ; 8F7B: DE E4         \n");
                                      #endif
    PC = 0x8f7b; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xe4)<<8; 
    ea = ea | rd_mem(DP|0xe5); 
    U = ea; 
    Z = U; 
    N = (U) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L8F83                   ; 8F7D: 27 04         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L8F83;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   ,U                      ; 8F7F: A6 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(U); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L8FB1                   ; 8F81: 26 2E         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L8FB1;
    }
  case 0x8F83:
L8F83:
                                                     #ifdef DEBUG
                                      mon("L8F83    INC   <$DD                    ; 8F83: 0C DD         \n");
                                      #endif
    PC = 0x8f83; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xdd); 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    wr_mem(DP|0xdd, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $4B14                   ; 8F85: F6 4B 14      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b14); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; 8F88: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #off_9070               ; 8F89: 8E 90 70      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x9070; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; 8F8C: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #byte_907C              ; 8F8D: 8C 90 7C      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x907c; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   L8FA0                   ; 8F90: 25 0E         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L8FA0;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B14                   ; 8F92: B6 4B 14      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b14); 
    A = val; 
 // N = val; 
 // Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; 8F95: 44            \n");
                                      #endif
    val = (UINT8)A; 
    C = val & 1; 
    val = val >> 1; 
    A = val; 
    N = 0; 
    Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BCS   L8F9D                   ; 8F96: 25 05         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L8F9D;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   #off_9078               ; 8F98: 8E 90 78      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x9078; 
    Z = X; 
    N = (X) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   L8FA0                   ; 8F9B: 20 03         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L8FA0;
    
    // ---------------------------------------------------------------------------
  case 0x8F9D:
L8F9D:
                                                     #ifdef DEBUG
                                      mon("L8F9D    LDX   #off_907A               ; 8F9D: 8E 90 7A      \n");
                                      #endif
    PC = 0x8f9d; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x907a; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0x8FA0:
L8FA0:
                                                     #ifdef DEBUG
                                      mon("L8FA0    LDX   ,X                      ; 8FA0: AE 84         \n");
                                      #endif
    PC = 0x8fa0; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   <$DD                    ; 8FA2: D6 DD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xdd); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  ,X+                     ; 8FA4: E1 80         \n");
                                      #endif
    clockticks = clockticks + 6; 
    val = (UINT8)B; 
    arg = rd_mem(X); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
    X = X + 1; 
                                                     #ifdef DEBUG
                                      mon("         BLS   L8FAA                   ; 8FA6: 23 02         \n");
                                      #endif
    // temp hack to force a flush
    if ((!Z) || C) {
    clockticks = clockticks + 3; 
    goto L8FAA;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   -1,X                    ; 8FA8: E6 1F         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0xffff)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0x8FAA:
L8FAA:
                                                     #ifdef DEBUG
                                      mon("L8FAA    STB   <$DD                    ; 8FAA: D7 DD         \n");
                                      #endif
    PC = 0x8faa; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xdd; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; 8FAC: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   B,X                     ; 8FAD: EC 85         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + (SINT8)B); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$E4                    ; 8FAF: DD E4         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0xe4; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
  case 0x8FB1:
L8FB1:
                                                     #ifdef DEBUG
                                      mon("L8FB1    LDX   #$4900                  ; 8FB1: 8E 49 00      \n");
                                      #endif // 3x Tie fighter data structure ($19 bytes per Tie)
    PC = 0x8fb1; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x4900; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0x8FB4:
L8FB4:
                                                     #ifdef DEBUG
                                      mon("L8FB4    STX   <$5A                    ; 8FB4: 9F 5A         \n");
                                      #endif
    PC = 0x8fb4; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = X; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = DP|0x5a; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $03,X                   ; 8FB6: A6 03         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0003)); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L8FC6                   ; 8FB8: 27 0C         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L8FC6;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   <$5A                    ; 8FBA: 9E 5A         \n");
                                      #endif
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x5a)<<8; 
    ea = ea | rd_mem(DP|0x5b); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LEAX  $19,X                   ; 8FBC: 30 88 19      \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + (SINT8)0x19); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$494B                  ; 8FBF: 8C 49 4B      \n");
                                      #endif // 3x Tie fighter data structure ($19 bytes per Tie)
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x494b; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   L8FB4                   ; 8FC2: 25 F0         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L8FB4;
    }
                                                     #ifdef DEBUG
                                      mon("         BRA   locret_9023             ; 8FC4: 20 5D         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L9023;
    
    // ---------------------------------------------------------------------------
  case 0x8FC6:
L8FC6:
                                                     #ifdef DEBUG
                                      mon("L8FC6    LDU   <$E4                    ; 8FC6: DE E4         \n");
                                      #endif
    PC = 0x8fc6; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xe4)<<8; 
    ea = ea | rd_mem(DP|0xe5); 
    U = ea; 
    Z = U; 
    N = (U) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   locret_9023             ; 8FC8: 27 59         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L9023;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   ,U                      ; 8FCA: A6 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(U); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   locret_9023             ; 8FCC: 27 55         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L9023;
    }
                                                     #ifdef DEBUG
                                      mon("         INC   <$E6                    ; 8FCE: 0C E6         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xe6); 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    wr_mem(DP|0xe6, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   ,U                      ; 8FD0: EC C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(U); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(U+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$E0                    ; 8FD2: DD E0         \n");
                                      #endif // Pointer to 3D object index
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0xe0; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $02,U                   ; 8FD4: EC 42         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0x0002); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$DE                    ; 8FD6: DD DE         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0xde; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $04,U                   ; 8FD8: EC 44         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0x0004); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$E2                    ; 8FDA: DD E2         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0xe2; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LEAU  $06,U                   ; 8FDC: 33 46         \n");
                                      #endif
    clockticks = clockticks + 5; 
    U = (U + 0x0006); 
                                                     #ifdef DEBUG
                                      mon("         STU   <$E4                    ; 8FDE: DF E4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = DP|0xe4; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$01                    ; 8FE0: 86 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x01; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $03,X                   ; 8FE2: A7 03         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0003); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDU   ,X                      ; 8FE4: EE 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCDC3                   ; 8FE6: BD CD C3      \n");
                                      #endif // Initialise math registers matrix
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xe9); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x8f); 
    clockticks = clockticks + 1; 
    goto LCDC3;
  case 0x8FE9:
L8FE9:
                                                     #ifdef DEBUG
                                      mon("L8FE9    LDU   ,X                      ; 8FE9: EE 84         \n");
                                      #endif
    PC = 0x8fe9; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$C0                    ; 8FEB: 86 C0         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xc0; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   -16,U                   ; 8FED: A7 50         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(U + 0xfff0); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   -6,U                    ; 8FEF: A7 5A         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(U + 0xfffa); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         CLRA                          ; 8FF1: 4F            \n");
                                      #endif
    A = 0; // SEARCH_ME
 // V = 0; 
 // Z = 0; 
 // N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $09,X                   ; 8FF2: A7 09         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0009); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   $08,X                   ; 8FF4: A7 08         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0008); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   $06,X                   ; 8FF6: A7 06         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0006); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   $05,X                   ; 8FF8: A7 05         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0005); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   $0B,X                   ; 8FFA: A7 0B         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x000b); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDU   <$E0                    ; 8FFC: DE E0         \n");
                                      #endif // Pointer to 3D object index
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xe0)<<8; 
    ea = ea | rd_mem(DP|0xe1); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $01,U                   ; 8FFE: A6 41         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(U + 0x0001)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $07,X                   ; 9000: A7 07         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0007); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDU   ,X                      ; 9002: EE 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDX   <$E2                    ; 9004: 9E E2         \n");
                                      #endif
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xe2)<<8; 
    ea = ea | rd_mem(DP|0xe3); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   ,X                      ; 9006: EC 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(X); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(X+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $08,U                   ; 9008: ED 48         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0x0008); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $02,X                   ; 900A: EC 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + 0x0002); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $0A,U                   ; 900C: ED 4A         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0x000a); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $04,X                   ; 900E: EC 04         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + 0x0004); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $0C,U                   ; 9010: ED 4C         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0x000c); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDX   <$5A                    ; 9012: 9E 5A         \n");
                                      #endif
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x5a)<<8; 
    ea = ea | rd_mem(DP|0x5b); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$DE                    ; 9014: DC DE         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0xde); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0xdf); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $0D,X                   ; 9016: ED 0D         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x000d); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         JSR   L8E23                   ; 9018: BD 8E 23      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x1b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x90); 
    clockticks = clockticks + 1; 
    goto L8E23;
  case 0x901B:
L901B:
                                                     #ifdef DEBUG
                                      mon("L901B    LDX   <$5A                    ; 901B: 9E 5A         \n");
                                      #endif
    PC = 0x901b; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x5a)<<8; 
    ea = ea | rd_mem(DP|0x5b); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   [$48E0]                 ; 901D: E6 9F 48 E0   \n");
                                      #endif // Pointer to 3D object index
    clockticks = clockticks + 6; 
    clockticks = clockticks + 2; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x48e0)<<8; 
    ea = ea | rd_mem(0x48e1); 
    val = (UINT8)rd_mem(ea); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STB   $04,X                   ; 9021: E7 04         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = B; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = (UINT16)(X + 0x0004); 
    wr_mem(ea, val); 
    // End of function sub_8F7B
    // ---------------------------------------------------------------------------
  case 0x9023:
L9023:
locret_9023:
                                                     #ifdef DEBUG
                                      mon("locret_9023 RTS                           ; 9023: 39            \n");
                                      #endif
    PC = 0x9023; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x953B:
L953B:
                                                     #ifdef DEBUG
                                      mon("L953B    LDA   $4592                   ; 953B: B6 45 92      \n");
                                      #endif
    PC = 0x953b; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4592); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$03                    ; 953E: 84 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x03; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   locret_9557             ; 9540: 27 15         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L9557;
    }
                                                     #ifdef DEBUG
                                      mon("         ADDA  <$60                    ; 9542: 9B 60         \n");
                                      #endif // Shield count
    clockticks = clockticks + 4; 
    val = (UINT8)A; 
    arg = rd_mem(DP|0x60); 
    res = val + (UINT8)arg; 
 // C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$60                    ; 9544: 97 60         \n");
                                      #endif // Shield count
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x60; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4593                   ; 9546: B6 45 93      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4593); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$03                    ; 9549: 84 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x03; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDA  #$06                    ; 954B: 8B 06         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x06; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  <$60                    ; 954D: 91 60         \n");
                                      #endif // Shield count
    clockticks = clockticks + 4; 
    val = (UINT8)A; 
    arg = rd_mem(DP|0x60); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCC   L9553                   ; 954F: 24 02         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto L9553;
    }
                                                     #ifdef DEBUG
                                      mon("         STA   <$60                    ; 9551: 97 60         \n");
                                      #endif // Shield count
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x60; 
    wr_mem(ea, val); 
  case 0x9553:
L9553:
                                                     #ifdef DEBUG
                                      mon("L9553    LDA   #$14                    ; 9553: 86 14         \n");
                                      #endif
    PC = 0x9553; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x14; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$61                    ; 9555: 97 61         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0x61; 
    wr_mem(ea, val); 
    // End of function sub_953B
  case 0x9557:
L9557:
locret_9557:
                                                     #ifdef DEBUG
                                      mon("locret_9557 RTS                           ; 9557: 39            \n");
                                      #endif
    PC = 0x9557; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Process shields
  case 0x9558:
L9558:
                                                     #ifdef DEBUG
                                      mon("L9558    LDA   <$8B                    ; 9558: 96 8B         \n");
                                      #endif
    PC = 0x9558; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x8b); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BLE   L95A0                   ; 955A: 2F 44         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto L95A0;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   <$8C                    ; 955C: 96 8C         \n");
                                      #endif // Sheild being depleted
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x8c); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BGT   L95A0                   ; 955E: 2E 40         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto L95A0;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$01                    ; 9560: 86 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x01; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$8C                    ; 9562: 97 8C         \n");
                                      #endif // Sheild being depleted
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x8c; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$60                    ; 9564: 96 60         \n");
                                      #endif // Shield count
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x60); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$8E                    ; 9566: 97 8E         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x8e; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$F6                    ; 9568: 86 F6         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xf6; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDA  <$60                    ; 956A: 9B 60         \n");
                                      #endif // Shield count
    clockticks = clockticks + 4; 
    val = (UINT8)A; 
    arg = rd_mem(DP|0x60); 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$8D                    ; 956C: 97 8D         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x8d; 
    wr_mem(ea, val); 
  case 0x956E:
L956E:
                                                     #ifdef DEBUG
                                      mon("L956E    DEC   <$60                    ; 956E: 0A 60         \n");
                                      #endif // Shield count
    PC = 0x956e; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x60); 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    wr_mem(DP|0x60, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BGE   L9578                   ; 9570: 2C 06         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) >= 0) {
    clockticks = clockticks + 3; 
    goto L9578;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$FF                    ; 9572: 86 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xff; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$60                    ; 9574: 97 60         \n");
                                      #endif // Shield count
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x60; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         CLR   <$8C                    ; 9576: 0F 8C         \n");
                                      #endif // Sheild being depleted
    clockticks = clockticks + 4; 
    wr_mem(DP|0x8c, 0); 
 // V = 0; 
 // Z = 0; 
 // N = 0; 
 // C = 0; 
    clockticks = clockticks + 2; 
  case 0x9578:
L9578:
                                                     #ifdef DEBUG
                                      mon("L9578    LDA   <$60                    ; 9578: 96 60         \n");
                                      #endif // Shield count
    PC = 0x9578; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x60); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$00                    ; 957A: 81 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x00; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   L9586                   ; 957C: 26 08         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L9586;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   Sound_D                 ; 957E: BD BD 35      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x81); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x95); 
    clockticks = clockticks + 1; 
    goto LBD35;
  case 0x9581:
L9581:
                                                     #ifdef DEBUG
                                      mon("L9581    JSR   Sound_28                ; 9581: BD BD BC      \n");
                                      #endif
    PC = 0x9581; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x84); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x95); 
    clockticks = clockticks + 1; 
    goto LBDBC;
  case 0x9584:
L9584:
                                                     #ifdef DEBUG
                                      mon("L9584    BRA   L9599                   ; 9584: 20 13         \n");
                                      #endif
    PC = 0x9584; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto L9599;
    
    // ---------------------------------------------------------------------------
  case 0x9586:
L9586:
                                                     #ifdef DEBUG
                                      mon("L9586    CMPA  #$01                    ; 9586: 81 01         \n");
                                      #endif
    PC = 0x9586; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x01; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   L958F                   ; 9588: 26 05         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L958F;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   Sound_2F                ; 958A: BD BD DF      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x8d); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x95); 
    clockticks = clockticks + 1; 
    goto LBDDF;
  case 0x958D:
L958D:
                                                     #ifdef DEBUG
                                      mon("L958D    BRA   L9599                   ; 958D: 20 0A         \n");
                                      #endif
    PC = 0x958d; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto L9599;
    
    // ---------------------------------------------------------------------------
  case 0x958F:
L958F:
                                                     #ifdef DEBUG
                                      mon("L958F    CMPA  #$02                    ; 958F: 81 02         \n");
                                      #endif
    PC = 0x958f; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x02; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   L9599                   ; 9591: 26 06         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L9599;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   Sound_F                 ; 9593: BD BD 3F      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x96); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x95); 
    clockticks = clockticks + 1; 
    goto LBD3F;
  case 0x9596:
L9596:
                                                     #ifdef DEBUG
                                      mon("L9596    JSR   Sound_30                ; 9596: BD BD E4      \n");
                                      #endif
    PC = 0x9596; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x99); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x95); 
    clockticks = clockticks + 1; 
    goto LBDE4;
  case 0x9599:
L9599:
                                                     #ifdef DEBUG
                                      mon("L9599    CLRB                          ; 9599: 5F            \n");
                                      #endif
    PC = 0x9599; 
    INSTRUCTION_START
    B = 0; // SEARCH_ME
 // V = 0; 
 // Z = 0; 
 // N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STB   <$91                    ; 959A: D7 91         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x91; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STB   <$90                    ; 959C: D7 90         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x90; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STB   <$8F                    ; 959E: D7 8F         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x8f; 
    wr_mem(ea, val); 
  case 0x95A0:
L95A0:
                                                     #ifdef DEBUG
                                      mon("L95A0    LDA   <$61                    ; 95A0: 96 61         \n");
                                      #endif
    PC = 0x95a0; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x61); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   locret_95A6             ; 95A2: 27 02         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L95A6;
    }
                                                     #ifdef DEBUG
                                      mon("         DEC   <$61                    ; 95A4: 0A 61         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x61); 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    wr_mem(DP|0x61, res); 
    clockticks = clockticks + 2; 
    // End of function sub_9558
  case 0x95A6:
L95A6:
locret_95A6:
                                                     #ifdef DEBUG
                                      mon("locret_95A6 RTS                           ; 95A6: 39            \n");
                                      #endif
    PC = 0x95a6; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Insert vector instructions for shields
  case 0x95A7:
L95A7:
                                                     #ifdef DEBUG
                                      mon("L95A7    LDA   <$8C                    ; 95A7: 96 8C         \n");
                                      #endif // Sheild being depleted
    PC = 0x95a7; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x8c); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L95B2                   ; 95A9: 26 07         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L95B2;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   <$60                    ; 95AB: 96 60         \n");
                                      #endif // Shield count
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x60); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BGT   L95B2                   ; 95AD: 2E 03         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto L95B2;
    }
                                                     #ifdef DEBUG
                                      mon("         JMP   L9604                   ; 95AF: 7E 96 04      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto L9604;
    
    // ---------------------------------------------------------------------------
  case 0x95B2:
L95B2:
                                                     #ifdef DEBUG
                                      mon("L95B2    LDB   <$60                    ; 95B2: D6 60         \n");
                                      #endif // Shield count
    PC = 0x95b2; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x60); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; 95B4: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #word_96B6              ; 95B5: 8E 96 B6      \n");
                                      #endif // Shield colour table
    clockticks = clockticks + 3; 
    X = 0x96b6; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   B,X                     ; 95B8: EE 85         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(X + (SINT8)B))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(X + (SINT8)B))+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STU   ,Y++                    ; 95BA: EF A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$BA03                  ; 95BC: CC BA 03      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xba; 
    B = 0x03; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 95BF: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0228                  ; 95C1: CC 02 28      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x02; 
    B = 0x28; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 95C4: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; 95C6: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 95C9: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$8C                    ; 95CB: 96 8C         \n");
                                      #endif // Sheild being depleted
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x8c); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L95D4                   ; 95CD: 27 05         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L95D4;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   L962A                   ; 95CF: BD 96 2A      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xd2); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x95); 
    clockticks = clockticks + 1; 
    goto L962A;
  case 0x95D2:
L95D2:
                                                     #ifdef DEBUG
                                      mon("L95D2    BRA   L95D7                   ; 95D2: 20 03         \n");
                                      #endif
    PC = 0x95d2; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto L95D7;
    
    // ---------------------------------------------------------------------------
  case 0x95D4:
L95D4:
                                                     #ifdef DEBUG
                                      mon("L95D4    JSR   L960F                   ; 95D4: BD 96 0F      \n");
                                      #endif
    PC = 0x95d4; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xd7); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x95); 
    clockticks = clockticks + 1; 
    goto L960F;
  case 0x95D7:
L95D7:
                                                     #ifdef DEBUG
                                      mon("L95D7    LDD   #$1FD0                  ; 95D7: CC 1F D0      \n");
                                      #endif
    PC = 0x95d7; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x1f; 
    B = 0xd0; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 95DA: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$1FF4                  ; 95DC: CC 1F F4      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x1f; 
    B = 0xf4; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 95DF: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$8C                    ; 95E1: 96 8C         \n");
                                      #endif // Sheild being depleted
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x8c); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BLE   L95EA                   ; 95E3: 2F 05         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto L95EA;
    }
                                                     #ifdef DEBUG
                                      mon("         LDU   #$A018                  ; 95E5: CE A0 18      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0xa018; 
    Z = U; 
    N = (U) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   L95F2                   ; 95E8: 20 08         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L95F2;
    
    // ---------------------------------------------------------------------------
  case 0x95EA:
L95EA:
                                                     #ifdef DEBUG
                                      mon("L95EA    LDB   <$60                    ; 95EA: D6 60         \n");
                                      #endif // Shield count
    PC = 0x95ea; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x60); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; 95EC: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #word_96B6              ; 95ED: 8E 96 B6      \n");
                                      #endif // Shield colour table
    clockticks = clockticks + 3; 
    X = 0x96b6; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   B,X                     ; 95F0: EE 85         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(X + (SINT8)B))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(X + (SINT8)B))+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0x95F2:
L95F2:
                                                     #ifdef DEBUG
                                      mon("L95F2    STU   ,Y++                    ; 95F2: EF A1         \n");
                                      #endif
    PC = 0x95f2; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         CLR   <$AD                    ; 95F4: 0F AD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    wr_mem(DP|0xad, 0); 
 // V = 0; 
 // Z = 0; 
 // N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$60                    ; 95F6: 96 60         \n");
                                      #endif // Shield count
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x60); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BGE   L95FB                   ; 95F8: 2C 01         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) >= 0) {
    clockticks = clockticks + 3; 
    goto L95FB;
    }
                                                     #ifdef DEBUG
                                      mon("         CLRA                          ; 95FA: 4F            \n");
                                      #endif
    A = 0; // SEARCH_ME
 // V = 0; 
 // Z = 0; 
 // N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
  case 0x95FB:
L95FB:
                                                     #ifdef DEBUG
                                      mon("L95FB    JSR   LE7AD                   ; 95FB: BD E7 AD      \n");
                                      #endif
    PC = 0x95fb; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xfe); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x95); 
    clockticks = clockticks + 1; 
    goto LE7AD;
  case 0x95FE:
L95FE:
                                                     #ifdef DEBUG
                                      mon("L95FE    LDD   #$8040                  ; 95FE: CC 80 40      \n");
                                      #endif
    PC = 0x95fe; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 9601: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 9603: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
  case 0x9604:
L9604:
                                                     #ifdef DEBUG
                                      mon("L9604    LDD   #$7100                  ; 9604: CC 71 00      \n");
                                      #endif
    PC = 0x9604; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x71; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 9607: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$0E                    ; 9609: C6 0E         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x0e; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LE7C7                   ; 960B: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x0e); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x96); 
    clockticks = clockticks + 1; 
    goto LE7C7;
    // End of function sub_95A7
  case 0x960E:
L960E:
                                                     #ifdef DEBUG
                                      mon("L960E    RTS                           ; 960E: 39            \n");
                                      #endif
    PC = 0x960e; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x960F:
L960F:
                                                     #ifdef DEBUG
                                      mon("L960F    LDB   <$60                    ; 960F: D6 60         \n");
                                      #endif // Shield count
    PC = 0x960f; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x60); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; 9611: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #word_96B6              ; 9612: 8E 96 B6      \n");
                                      #endif // Shield colour table
    clockticks = clockticks + 3; 
    X = 0x96b6; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   B,X                     ; 9615: EC 85         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + (SINT8)B); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         TST   <$61                    ; 9617: 0D 61         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x61); 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L961D                   ; 9619: 27 02         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L961D;
    }
                                                     #ifdef DEBUG
                                      mon("         ORB   #$FF                    ; 961B: CA FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = B | (UINT8)0xff; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
  case 0x961D:
L961D:
                                                     #ifdef DEBUG
                                      mon("L961D    STD   ,Y++                    ; 961D: ED A1         \n");
                                      #endif
    PC = 0x961d; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   <$60                    ; 961F: D6 60         \n");
                                      #endif // Shield count
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x60); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; 9621: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #word_96CA              ; 9622: 8E 96 CA      \n");
                                      #endif // Shield vector table
    clockticks = clockticks + 3; 
    X = 0x96ca; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   B,X                     ; 9625: EE 85         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(X + (SINT8)B))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(X + (SINT8)B))+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STU   ,Y++                    ; 9627: EF A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    val = U; 
    Z = val; 
    N = (UINT8)(val >> 8); 
    V = 0; 
    ea = Y; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
    Y = Y + 2; 
    // End of function sub_960F
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 9629: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x962A:
L962A:
                                                     #ifdef DEBUG
                                      mon("L962A    LDA   <$91                    ; 962A: 96 91         \n");
                                      #endif
    PC = 0x962a; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x91); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L964B                   ; 962C: 26 1D         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L964B;
    }
                                                     #ifdef DEBUG
                                      mon("         LDU   #$A018                  ; 962E: CE A0 18      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0xa018; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STU   ,Y++                    ; 9631: EF A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   <$8E                    ; 9633: D6 8E         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x8e); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; 9635: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #word_96CA              ; 9636: 8E 96 CA      \n");
                                      #endif // Shield vector table
    clockticks = clockticks + 3; 
    X = 0x96ca; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   B,X                     ; 9639: EE 85         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(X + (SINT8)B))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(X + (SINT8)B))+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STU   ,Y++                    ; 963B: EF A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$43                    ; 963D: 96 43         \n");
                                      #endif // Game over/insert coins timer
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x43); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$00                    ; 963F: 84 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x00; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L9649                   ; 9641: 26 06         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L9649;
    }
  case 0x9643:
L9643:
                                                     #ifdef DEBUG
                                      mon("L9643    INC   <$8D                    ; 9643: 0C 8D         \n");
                                      #endif
    PC = 0x9643; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x8d); 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    wr_mem(DP|0x8d, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BLT   L9649                   ; 9645: 2D 02         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 3; 
    goto L9649;
    }
                                                     #ifdef DEBUG
                                      mon("         INC   <$91                    ; 9647: 0C 91         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x91); 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    wr_mem(DP|0x91, res); 
    clockticks = clockticks + 2; 
  case 0x9649:
L9649:
                                                     #ifdef DEBUG
                                      mon("L9649    BRA   locret_96A0             ; 9649: 20 55         \n");
                                      #endif
    PC = 0x9649; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto L96A0;
    
    // ---------------------------------------------------------------------------
  case 0x964B:
L964B:
                                                     #ifdef DEBUG
                                      mon("L964B    JSR   L96A1                   ; 964B: BD 96 A1      \n");
                                      #endif
    PC = 0x964b; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x4e); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x96); 
    clockticks = clockticks + 1; 
    goto L96A1;
  case 0x964E:
L964E:
                                                     #ifdef DEBUG
                                      mon("L964E    LDU   #$A018                  ; 964E: CE A0 18      \n");
                                      #endif
    PC = 0x964e; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0xa018; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STU   ,Y++                    ; 9651: EF A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$90                    ; 9653: 96 90         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x90); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L9674                   ; 9655: 26 1D         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L9674;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   <$8E                    ; 9657: D6 8E         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x8e); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; 9659: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #word_96DE              ; 965A: 8E 96 DE      \n");
                                      #endif // Another copy of shield vector table??
    clockticks = clockticks + 3; 
    X = 0x96de; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   B,X                     ; 965D: EE 85         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(X + (SINT8)B))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(X + (SINT8)B))+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STU   ,Y++                    ; 965F: EF A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$43                    ; 9661: 96 43         \n");
                                      #endif // Game over/insert coins timer
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x43); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$00                    ; 9663: 84 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x00; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L9672                   ; 9665: 26 0B         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L9672;
    }
                                                     #ifdef DEBUG
                                      mon("         INC   <$90                    ; 9667: 0C 90         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x90); 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    wr_mem(DP|0x90, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   <$60                    ; 9669: D6 60         \n");
                                      #endif // Shield count
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x60); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #byte_9718              ; 966B: 8E 97 18      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x9718; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   B,X                     ; 966E: A6 85         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + (SINT8)B)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$8D                    ; 9670: 97 8D         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0x8d; 
    wr_mem(ea, val); 
  case 0x9672:
L9672:
                                                     #ifdef DEBUG
                                      mon("L9672    BRA   locret_96A0             ; 9672: 20 2C         \n");
                                      #endif
    PC = 0x9672; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto L96A0;
    
    // ---------------------------------------------------------------------------
  case 0x9674:
L9674:
                                                     #ifdef DEBUG
                                      mon("L9674    LDA   <$8F                    ; 9674: 96 8F         \n");
                                      #endif
    PC = 0x9674; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x8f); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L9690                   ; 9676: 26 18         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L9690;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   <$8D                    ; 9678: D6 8D         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x8d); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; 967A: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #word_96F2              ; 967B: 8E 96 F2      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x96f2; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   B,X                     ; 967E: EE 85         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(X + (SINT8)B))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(X + (SINT8)B))+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STU   ,Y++                    ; 9680: EF A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$43                    ; 9682: 96 43         \n");
                                      #endif // Game over/insert coins timer
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x43); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$00                    ; 9684: 84 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x00; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L968E                   ; 9686: 26 06         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L968E;
    }
                                                     #ifdef DEBUG
                                      mon("         DEC   <$8D                    ; 9688: 0A 8D         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x8d); 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    wr_mem(DP|0x8d, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BGT   L968E                   ; 968A: 2E 02         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto L968E;
    }
                                                     #ifdef DEBUG
                                      mon("         INC   <$8F                    ; 968C: 0C 8F         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x8f); 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    wr_mem(DP|0x8f, res); 
    clockticks = clockticks + 2; 
  case 0x968E:
L968E:
                                                     #ifdef DEBUG
                                      mon("L968E    BRA   locret_96A0             ; 968E: 20 10         \n");
                                      #endif
    PC = 0x968e; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto L96A0;
    
    // ---------------------------------------------------------------------------
  case 0x9690:
L9690:
                                                     #ifdef DEBUG
                                      mon("L9690    LDA   <$43                    ; 9690: 96 43         \n");
                                      #endif // Game over/insert coins timer
    PC = 0x9690; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x43); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$00                    ; 9692: 84 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x00; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   locret_96A0             ; 9694: 26 0A         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L96A0;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; 9696: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$8C                    ; 9698: 97 8C         \n");
                                      #endif // Sheild being depleted
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x8c; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   <$8B                    ; 969A: 97 8B         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x8b; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$60                    ; 969C: 96 60         \n");
                                      #endif // Shield count
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x60); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$8E                    ; 969E: 97 8E         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0x8e; 
    wr_mem(ea, val); 
    // End of function sub_962A
  case 0x96A0:
L96A0:
locret_96A0:
                                                     #ifdef DEBUG
                                      mon("locret_96A0 RTS                           ; 96A0: 39            \n");
                                      #endif
    PC = 0x96a0; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x96A1:
L96A1:
                                                     #ifdef DEBUG
                                      mon("L96A1    LDB   <$60                    ; 96A1: D6 60         \n");
                                      #endif // Shield count
    PC = 0x96a1; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x60); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; 96A3: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #word_96B6              ; 96A4: 8E 96 B6      \n");
                                      #endif // Shield colour table
    clockticks = clockticks + 3; 
    X = 0x96b6; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   B,X                     ; 96A7: EC 85         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + (SINT8)B); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 96A9: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   <$60                    ; 96AB: D6 60         \n");
                                      #endif // Shield count
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x60); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; 96AD: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #word_96CA              ; 96AE: 8E 96 CA      \n");
                                      #endif // Shield vector table
    clockticks = clockticks + 3; 
    X = 0x96ca; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   B,X                     ; 96B1: EE 85         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(X + (SINT8)B))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(X + (SINT8)B))+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STU   ,Y++                    ; 96B3: EF A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    val = U; 
    Z = val; 
    N = (UINT8)(val >> 8); 
    V = 0; 
    ea = Y; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
    Y = Y + 2; 
    // End of function sub_96A1
    // ---------------------------------------------------------------------------
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 96B5: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Death Star starting wave bonus score
  case 0x9722:
L9722:
                                                     #ifdef DEBUG
                                      mon("L9722    LDA   $4B2D                   ; 9722: B6 4B 2D      \n");
                                      #endif
    PC = 0x9722; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b2d); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   locret_9739             ; 9725: 26 12         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L9739;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   $4B15                   ; 9727: F6 4B 15      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b15); 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   locret_9739             ; 972A: 27 0D         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L9739;
    }
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; 972C: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ADDB  $4B15                   ; 972D: FB 4B 15      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)B; 
    arg = rd_mem(0x4b15); 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #byte_9865              ; 9730: 8E 98 65      \n");
                                      #endif // Death Star destroyed  incrementing score value, Also has unused starting wave bonus scores of 200,000 and 600,000, for waves 2 and 4
    clockticks = clockticks + 3; 
    X = 0x9865; 
    Z = X; 
    N = (X) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; 9733: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         TFR   X,U                     ; 9734: 1F 13         \n");
                                      #endif
    U = X; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         JSR   L9810                   ; 9736: BD 98 10      \n");
                                      #endif // Add to score total
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x39); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x97); 
    clockticks = clockticks + 1; 
    goto L9810;
    // End of function sub_9722
  case 0x9739:
L9739:
locret_9739:
                                                     #ifdef DEBUG
                                      mon("locret_9739 RTS                           ; 9739: 39            \n");
                                      #endif
    PC = 0x9739; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Towers incrementing score
  case 0x973A:
L973A:
                                                     #ifdef DEBUG
                                      mon("L973A    LDU   #$4B2E                  ; 973A: CE 4B 2E      \n");
                                      #endif // Temporary score adder towers 1
    PC = 0x973a; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0x4b2e; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   L9810                   ; 973D: BD 98 10      \n");
                                      #endif // Add to score total
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x40); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x97); 
    clockticks = clockticks + 1; 
    goto L9810;
  case 0x9740:
L9740:
                                                     #ifdef DEBUG
                                      mon("L9740    LDX   #word_9856              ; 9740: 8E 98 56      \n");
                                      #endif
    PC = 0x9740; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x9856; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B30                   ; 9743: B6 4B 30      \n");
                                      #endif // Temporary score adder towers 3
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b30); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDA  $02,X                   ; 9746: AB 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    arg = rd_mem((UINT16)(X + 0x0002)); 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         DAA                           ; 9748: 19            \n");
                                      #endif
    res = A; 
    msn = res & 0xf0; 
    lsn = res & 0x0f; 
    res = res + (((lsn > 0x09) || (H & 0x10)) ? 0x06 : 0); 
    res = res + ((((UINT8)msn > 0x80U) && ((UINT8)lsn > 0x09U)) || (((UINT8)msn > 0x90U) || (C != 0)) ? 0x60 : 0); 
    C = C | (res & 0x100); 
    res = (UINT8)res; 
    A = res; 
 // N = res; 
 // Z = res; 
 // V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B30                   ; 9749: B7 4B 30      \n");
                                      #endif // Temporary score adder towers 3
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b30, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B2F                   ; 974C: B6 4B 2F      \n");
                                      #endif // Temporary score adder towers 2
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b2f); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADCA  $01,X                   ; 974F: A9 01         \n");
                                      #endif
    clockticks = clockticks + 5; 
    arg = A; 
    val = rd_mem((UINT16)(X + 0x0001)); 
    res = arg + val + (C != 0 ? 1:0); 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = arg ^ val ^ (UINT8)res ^ C; 
 // V = arg ^ val ^ (UINT8)res ^ C; 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         DAA                           ; 9751: 19            \n");
                                      #endif
    res = A; 
    msn = res & 0xf0; 
    lsn = res & 0x0f; 
    res = res + (((lsn > 0x09) || (H & 0x10)) ? 0x06 : 0); 
    res = res + ((((UINT8)msn > 0x80U) && ((UINT8)lsn > 0x09U)) || (((UINT8)msn > 0x90U) || (C != 0)) ? 0x60 : 0); 
    C = C | (res & 0x100); 
    res = (UINT8)res; 
    A = res; 
 // N = res; 
 // Z = res; 
 // V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B2F                   ; 9752: B7 4B 2F      \n");
                                      #endif // Temporary score adder towers 2
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b2f, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B2E                   ; 9755: B6 4B 2E      \n");
                                      #endif // Temporary score adder towers 1
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b2e); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADCA  ,X                      ; 9758: A9 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    arg = A; 
    val = rd_mem(X); 
    res = arg + val + (C != 0 ? 1:0); 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = arg ^ val ^ (UINT8)res ^ C; 
 // V = arg ^ val ^ (UINT8)res ^ C; 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         DAA                           ; 975A: 19            \n");
                                      #endif
    res = A; 
    msn = res & 0xf0; 
    lsn = res & 0x0f; 
    res = res + (((lsn > 0x09) || (H & 0x10)) ? 0x06 : 0); 
    res = res + ((((UINT8)msn > 0x80U) && ((UINT8)lsn > 0x09U)) || (((UINT8)msn > 0x90U) || (C != 0)) ? 0x60 : 0); 
    C = C | (res & 0x100); 
    res = (UINT8)res; 
    A = res; 
 // N = res; 
 // Z = res; 
 // V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B2E                   ; 975B: B7 4B 2E      \n");
                                      #endif // Temporary score adder towers 1
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b2e, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B1A                   ; 975E: B6 4B 1A      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b1a); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   locret_9774             ; 9761: 27 11         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L9774;
    }
                                                     #ifdef DEBUG
                                      mon("         ADDA  #$99                    ; 9763: 8B 99         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x99; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         DAA                           ; 9765: 19            \n");
                                      #endif
    res = A; 
    msn = res & 0xf0; 
    lsn = res & 0x0f; 
    res = res + (((lsn > 0x09) || (H & 0x10)) ? 0x06 : 0); 
    res = res + ((((UINT8)msn > 0x80U) && ((UINT8)lsn > 0x09U)) || (((UINT8)msn > 0x90U) || (C != 0)) ? 0x60 : 0); 
    C = C | (res & 0x100); 
    res = (UINT8)res; 
    A = res; 
 // N = res; 
 // Z = res; 
 // V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B1A                   ; 9766: B7 4B 1A      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x4b1a, val); 
                                                     #ifdef DEBUG
                                      mon("         BNE   locret_9774             ; 9769: 26 09         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L9774;
    }
                                                     #ifdef DEBUG
                                      mon("         LDU   #byte_9862              ; 976B: CE 98 62      \n");
                                      #endif // Cleared all towers score value
    clockticks = clockticks + 3; 
    U = 0x9862; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   L9810                   ; 976E: BD 98 10      \n");
                                      #endif // Add to score total
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x71); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x97); 
    clockticks = clockticks + 1; 
    goto L9810;
  case 0x9771:
L9771:
                                                     #ifdef DEBUG
                                      mon("L9771    INC   $4B35                   ; 9771: 7C 4B 35      \n");
                                      #endif
    PC = 0x9771; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b35); 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    wr_mem(0x4b35, res); 
    clockticks = clockticks + 2; 
    // End of function sub_973A
  case 0x9774:
L9774:
locret_9774:
                                                     #ifdef DEBUG
                                      mon("locret_9774 RTS                           ; 9774: 39            \n");
                                      #endif
    PC = 0x9774; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Shield bonus score
  case 0x9775:
L9775:
                                                     #ifdef DEBUG
                                      mon("L9775    LDB   <$60                    ; 9775: D6 60         \n");
                                      #endif // Shield count
    PC = 0x9775; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x60); 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   locret_97AB             ; 9777: 27 32         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L97AB;
    }
                                                     #ifdef DEBUG
                                      mon("         LDU   #byte_9865              ; 9779: CE 98 65      \n");
                                      #endif // Death Star destroyed  incrementing score value, Also has unused starting wave bonus scores of 200,000 and 600,000, for waves 2 and 4
    clockticks = clockticks + 3; 
    U = 0x9865; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; 977C: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B29                   ; 977E: B7 4B 29      \n");
                                      #endif // Temporary score adder 1
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b29, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B2A                   ; 9781: B7 4B 2A      \n");
                                      #endif // Temporary score adder 1
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b2a, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B2B                   ; 9784: B7 4B 2B      \n");
                                      #endif // Temporary score adder 2
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b2b, val); 
  case 0x9787:
L9787:
                                                     #ifdef DEBUG
                                      mon("L9787    LDA   $02,U                   ; 9787: A6 42         \n");
                                      #endif
    PC = 0x9787; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(U + 0x0002)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDA  $4B2B                   ; 9789: BB 4B 2B      \n");
                                      #endif // Temporary score adder 2
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    arg = rd_mem(0x4b2b); 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         DAA                           ; 978C: 19            \n");
                                      #endif
    res = A; 
    msn = res & 0xf0; 
    lsn = res & 0x0f; 
    res = res + (((lsn > 0x09) || (H & 0x10)) ? 0x06 : 0); 
    res = res + ((((UINT8)msn > 0x80U) && ((UINT8)lsn > 0x09U)) || (((UINT8)msn > 0x90U) || (C != 0)) ? 0x60 : 0); 
    C = C | (res & 0x100); 
    res = (UINT8)res; 
    A = res; 
 // N = res; 
 // Z = res; 
 // V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B2B                   ; 978D: B7 4B 2B      \n");
                                      #endif // Temporary score adder 2
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b2b, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $01,U                   ; 9790: A6 41         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(U + 0x0001)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADCA  $4B2A                   ; 9792: B9 4B 2A      \n");
                                      #endif // Temporary score adder 1
    clockticks = clockticks + 5; 
    arg = A; 
    val = rd_mem(0x4b2a); 
    res = arg + val + (C != 0 ? 1:0); 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = arg ^ val ^ (UINT8)res ^ C; 
 // V = arg ^ val ^ (UINT8)res ^ C; 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         DAA                           ; 9795: 19            \n");
                                      #endif
    res = A; 
    msn = res & 0xf0; 
    lsn = res & 0x0f; 
    res = res + (((lsn > 0x09) || (H & 0x10)) ? 0x06 : 0); 
    res = res + ((((UINT8)msn > 0x80U) && ((UINT8)lsn > 0x09U)) || (((UINT8)msn > 0x90U) || (C != 0)) ? 0x60 : 0); 
    C = C | (res & 0x100); 
    res = (UINT8)res; 
    A = res; 
 // N = res; 
 // Z = res; 
 // V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B2A                   ; 9796: B7 4B 2A      \n");
                                      #endif // Temporary score adder 1
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b2a, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   ,U                      ; 9799: A6 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(U); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADCA  $4B29                   ; 979B: B9 4B 29      \n");
                                      #endif // Temporary score adder 1
    clockticks = clockticks + 5; 
    arg = A; 
    val = rd_mem(0x4b29); 
    res = arg + val + (C != 0 ? 1:0); 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = arg ^ val ^ (UINT8)res ^ C; 
 // V = arg ^ val ^ (UINT8)res ^ C; 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         DAA                           ; 979E: 19            \n");
                                      #endif
    res = A; 
    msn = res & 0xf0; 
    lsn = res & 0x0f; 
    res = res + (((lsn > 0x09) || (H & 0x10)) ? 0x06 : 0); 
    res = res + ((((UINT8)msn > 0x80U) && ((UINT8)lsn > 0x09U)) || (((UINT8)msn > 0x90U) || (C != 0)) ? 0x60 : 0); 
    C = C | (res & 0x100); 
    res = (UINT8)res; 
    A = res; 
 // N = res; 
 // Z = res; 
 // V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B29                   ; 979F: B7 4B 29      \n");
                                      #endif // Temporary score adder 1
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b29, val); 
                                                     #ifdef DEBUG
                                      mon("         DECB                          ; 97A2: 5A            \n");
                                      #endif
    val = (UINT8)B; 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L9787                   ; 97A3: 26 E2         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L9787;
    }
                                                     #ifdef DEBUG
                                      mon("         LDU   #$4B29                  ; 97A5: CE 4B 29      \n");
                                      #endif // Temporary score adder 1
    clockticks = clockticks + 3; 
    U = 0x4b29; 
    Z = U; 
    N = (U) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   L9810                   ; 97A8: BD 98 10      \n");
                                      #endif // Add to score total
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xab); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x97); 
    clockticks = clockticks + 1; 
    goto L9810;
    // End of function sub_9775
  case 0x97AB:
L97AB:
locret_97AB:
                                                     #ifdef DEBUG
                                      mon("locret_97AB RTS                           ; 97AB: 39            \n");
                                      #endif
    PC = 0x97ab; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Used the force score
  case 0x97AC:
L97AC:
                                                     #ifdef DEBUG
                                      mon("L97AC    LDB   $4B15                   ; 97AC: F6 4B 15      \n");
                                      #endif
    PC = 0x97ac; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b15); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$05                    ; 97AF: C1 05         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x05; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   L97B8                   ; 97B1: 25 05         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L97B8;
    }
                                                     #ifdef DEBUG
                                      mon("         LDU   #byte_9847              ; 97B3: CE 98 47      \n");
                                      #endif // Using Force score value
    clockticks = clockticks + 3; 
    U = 0x9847; 
    Z = U; 
    N = (U) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   locret_97C1             ; 97B6: 20 09         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L97C1;
    
    // ---------------------------------------------------------------------------
  case 0x97B8:
L97B8:
                                                     #ifdef DEBUG
                                      mon("L97B8    ASLB                          ; 97B8: 58            \n");
                                      #endif
    PC = 0x97b8; 
    INSTRUCTION_START
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ADDB  $4B15                   ; 97B9: FB 4B 15      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)B; 
    arg = rd_mem(0x4b15); 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #byte_983B              ; 97BC: CE 98 3B      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x983b; 
    Z = U; 
    N = (U) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LEAU  B,U                     ; 97BF: 33 C5         \n");
                                      #endif
    clockticks = clockticks + 5; 
    U = (U + (SINT8)B); 
    // End of function sub_97AC
  case 0x97C1:
L97C1:
locret_97C1:
                                                     #ifdef DEBUG
                                      mon("locret_97C1 RTS                           ; 97C1: 39            \n");
                                      #endif
    PC = 0x97c1; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x97C2:
L97C2:
                                                     #ifdef DEBUG
                                      mon("L97C2    LDD   #$A01A                  ; 97C2: CC A0 1A      \n");
                                      #endif
    PC = 0x97c2; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0xa0; 
    B = 0x1a; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 97C5: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0180                  ; 97C7: CC 01 80      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x01; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 97CA: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$1EC0                  ; 97CC: CC 1E C0      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x1e; 
    B = 0xc0; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 97CF: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$04                    ; 97D1: 86 04         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x04; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$AD                    ; 97D3: 97 AD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xad; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   L97AC                   ; 97D5: BD 97 AC      \n");
                                      #endif // Used the force score
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xd8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x97); 
    clockticks = clockticks + 1; 
    goto L97AC;
  case 0x97D8:
L97D8:
                                                     #ifdef DEBUG
                                      mon("L97D8    LEAX  -1,U                    ; 97D8: 30 5F         \n");
                                      #endif
    PC = 0x97d8; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    X = (U + 0xffff); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LE772                   ; 97DA: BD E7 72      \n");
                                      #endif // Display BCD number text
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xdd); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x97); 
    clockticks = clockticks + 1; 
    goto LE772;
  case 0x97DD:
L97DD:
                                                     #ifdef DEBUG
                                      mon("L97DD    LDB   #$50                    ; 97DD: C6 50         \n");
                                      #endif // 'For using the Force' text
    PC = 0x97dd; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x50; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LE7C7                   ; 97DF: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xe2); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x97); 
    clockticks = clockticks + 1; 
    goto LE7C7;
    // End of function sub_97C2
  case 0x97E2:
L97E2:
                                                     #ifdef DEBUG
                                      mon("L97E2    RTS                           ; 97E2: 39            \n");
                                      #endif
    PC = 0x97e2; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x97E3:
L97E3:
                                                     #ifdef DEBUG
                                      mon("L97E3    JSR   L97AC                   ; 97E3: BD 97 AC      \n");
                                      #endif // Used the force score
    PC = 0x97e3; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xe6); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x97); 
    clockticks = clockticks + 1; 
    goto L97AC;
    // End of function sub_97E3
  case 0x97E6:
L97E6:
                                                     #ifdef DEBUG
                                      mon("L97E6    BRA   L9810                   ; 97E6: 20 28         \n");
                                      #endif // Add to score total
    PC = 0x97e6; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto L9810;
    
    // =============== S U B R O U T I N E =======================================
    // Tie fighter score
  case 0x97E8:
L97E8:
                                                     #ifdef DEBUG
                                      mon("L97E8    LDU   #byte_984A              ; 97E8: CE 98 4A      \n");
                                      #endif // Tie fighter score value
    PC = 0x97e8; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0x984a; 
    Z = U; 
    N = (U) >> 8; 
    V = 0; 
    // End of function sub_97E8
                                                     #ifdef DEBUG
                                      mon("         BRA   L9810                   ; 97EB: 20 23         \n");
                                      #endif // Add to score total
    clockticks = clockticks + 3; 
    goto L9810;
    
    // =============== S U B R O U T I N E =======================================
    // Vaders tie score
  case 0x97ED:
L97ED:
                                                     #ifdef DEBUG
                                      mon("L97ED    LDU   #byte_984D              ; 97ED: CE 98 4D      \n");
                                      #endif // Vaders tie score value
    PC = 0x97ed; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0x984d; 
    Z = U; 
    N = (U) >> 8; 
    V = 0; 
    // End of function sub_97ED
                                                     #ifdef DEBUG
                                      mon("         BRA   L9810                   ; 97F0: 20 1E         \n");
                                      #endif // Add to score total
    clockticks = clockticks + 3; 
    goto L9810;
    
    // =============== S U B R O U T I N E =======================================
    // Trench green squares score
  case 0x97F2:
L97F2:
                                                     #ifdef DEBUG
                                      mon("L97F2    LDU   #byte_9850              ; 97F2: CE 98 50      \n");
                                      #endif // Trench green squares score value
    PC = 0x97f2; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0x9850; 
    Z = U; 
    N = (U) >> 8; 
    V = 0; 
    // End of function sub_97F2
                                                     #ifdef DEBUG
                                      mon("         BRA   L9810                   ; 97F5: 20 19         \n");
                                      #endif // Add to score total
    clockticks = clockticks + 3; 
    goto L9810;
    
    // =============== S U B R O U T I N E =======================================
    // Laser tower score
  case 0x97F7:
L97F7:
                                                     #ifdef DEBUG
                                      mon("L97F7    LDU   #byte_9859              ; 97F7: CE 98 59      \n");
                                      #endif // Laser tower score value
    PC = 0x97f7; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0x9859; 
    Z = U; 
    N = (U) >> 8; 
    V = 0; 
    // End of function sub_97F7
                                                     #ifdef DEBUG
                                      mon("         BRA   L9810                   ; 97FA: 20 14         \n");
                                      #endif // Add to score total
    clockticks = clockticks + 3; 
    goto L9810;
    
    // =============== S U B R O U T I N E =======================================
    // Trench turrets score
  case 0x97FC:
L97FC:
                                                     #ifdef DEBUG
                                      mon("L97FC    LDU   #byte_9853              ; 97FC: CE 98 53      \n");
                                      #endif // Trench turrets score value
    PC = 0x97fc; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0x9853; 
    Z = U; 
    N = (U) >> 8; 
    V = 0; 
    // End of function sub_97FC
                                                     #ifdef DEBUG
                                      mon("         BRA   L9810                   ; 97FF: 20 0F         \n");
                                      #endif // Add to score total
    clockticks = clockticks + 3; 
    goto L9810;
    
    // =============== S U B R O U T I N E =======================================
    // Fireball score
  case 0x9801:
L9801:
                                                     #ifdef DEBUG
                                      mon("L9801    LDU   #byte_985C              ; 9801: CE 98 5C      \n");
                                      #endif // Fireball score value
    PC = 0x9801; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0x985c; 
    Z = U; 
    N = (U) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   L9810                   ; 9804: 20 0A         \n");
                                      #endif // Add to score total
    clockticks = clockticks + 3; 
    goto L9810;
    
    // ---------------------------------------------------------------------------
  case 0x9806:
L9806:
                                                     #ifdef DEBUG
                                      mon("L9806    LDU   #byte_985F              ; 9806: CE 98 5F      \n");
                                      #endif // Exhaust port score
    PC = 0x9806; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0x985f; 
    Z = U; 
    N = (U) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   L9810                   ; 9809: 20 05         \n");
                                      #endif // Add to score total
    clockticks = clockticks + 3; 
    goto L9810;
    
    // ---------------------------------------------------------------------------
                   // FCB   $CE                     ; 980B:  ' ' CE 98 62       LDU   #$9862 ; Cleared all towers score value
                   // FCB   $98                     ; 980C:  ' ' 98 62          EORA  <$62 ; 
                   // FCB   $62                     ; 980D:  'b' 62             Invalid ; 
                   // FCB   $20                     ; 980E:  ' ' 20 00          BRA   $9810 ; 
                   // FCB   $00                     ; 980F:  ' ' 00 A6          NEG   <$A6 ; 
  case 0x9810:
L9810:
                                                     #ifdef DEBUG
                                      mon("L9810    LDA   $02,U                   ; 9810: A6 42         \n");
                                      #endif // Add to score total
    PC = 0x9810; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(U + 0x0002)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B2B                   ; 9812: B7 4B 2B      \n");
                                      #endif // Temporary score adder 2
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b2b, val); 
                                                     #ifdef DEBUG
                                      mon("         ADDA  <$5F                    ; 9815: 9B 5F         \n");
                                      #endif // Score
    clockticks = clockticks + 4; 
    val = (UINT8)A; 
    arg = rd_mem(DP|0x5f); 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         DAA                           ; 9817: 19            \n");
                                      #endif
    res = A; 
    msn = res & 0xf0; 
    lsn = res & 0x0f; 
    res = res + (((lsn > 0x09) || (H & 0x10)) ? 0x06 : 0); 
    res = res + ((((UINT8)msn > 0x80U) && ((UINT8)lsn > 0x09U)) || (((UINT8)msn > 0x90U) || (C != 0)) ? 0x60 : 0); 
    C = C | (res & 0x100); 
    res = (UINT8)res; 
    A = res; 
 // N = res; 
 // Z = res; 
 // V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$5F                    ; 9818: 97 5F         \n");
                                      #endif // Score
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x5f; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $01,U                   ; 981A: A6 41         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(U + 0x0001)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B2A                   ; 981C: B7 4B 2A      \n");
                                      #endif // Temporary score adder 1
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b2a, val); 
                                                     #ifdef DEBUG
                                      mon("         ADCA  <$5E                    ; 981F: 99 5E         \n");
                                      #endif // Score thousands
    clockticks = clockticks + 4; 
    arg = A; 
    val = rd_mem(DP|0x5e); 
    res = arg + val + (C != 0 ? 1:0); 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = arg ^ val ^ (UINT8)res ^ C; 
 // V = arg ^ val ^ (UINT8)res ^ C; 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         DAA                           ; 9821: 19            \n");
                                      #endif
    res = A; 
    msn = res & 0xf0; 
    lsn = res & 0x0f; 
    res = res + (((lsn > 0x09) || (H & 0x10)) ? 0x06 : 0); 
    res = res + ((((UINT8)msn > 0x80U) && ((UINT8)lsn > 0x09U)) || (((UINT8)msn > 0x90U) || (C != 0)) ? 0x60 : 0); 
    C = C | (res & 0x100); 
    res = (UINT8)res; 
    A = res; 
 // N = res; 
 // Z = res; 
 // V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$5E                    ; 9822: 97 5E         \n");
                                      #endif // Score thousands
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x5e; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   ,U                      ; 9824: A6 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(U); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B29                   ; 9826: B7 4B 29      \n");
                                      #endif // Temporary score adder 1
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b29, val); 
                                                     #ifdef DEBUG
                                      mon("         ADCA  <$5D                    ; 9829: 99 5D         \n");
                                      #endif // Score hundred thousands
    clockticks = clockticks + 4; 
    arg = A; 
    val = rd_mem(DP|0x5d); 
    res = arg + val + (C != 0 ? 1:0); 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = arg ^ val ^ (UINT8)res ^ C; 
 // V = arg ^ val ^ (UINT8)res ^ C; 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         DAA                           ; 982B: 19            \n");
                                      #endif
    res = A; 
    msn = res & 0xf0; 
    lsn = res & 0x0f; 
    res = res + (((lsn > 0x09) || (H & 0x10)) ? 0x06 : 0); 
    res = res + ((((UINT8)msn > 0x80U) && ((UINT8)lsn > 0x09U)) || (((UINT8)msn > 0x90U) || (C != 0)) ? 0x60 : 0); 
    C = C | (res & 0x100); 
    res = (UINT8)res; 
    A = res; 
 // N = res; 
 // Z = res; 
 // V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$5D                    ; 982C: 97 5D         \n");
                                      #endif // Score hundred thousands
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x5d; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$5C                    ; 982E: 96 5C         \n");
                                      #endif // Score millions
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x5c); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADCA  #$00                    ; 9830: 89 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    arg = A; 
    val = (SINT8)0x00; 
    res = arg + val + (C != 0 ? 1:0); 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = arg ^ val ^ (UINT8)res ^ C; 
 // V = arg ^ val ^ (UINT8)res ^ C; 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         DAA                           ; 9832: 19            \n");
                                      #endif
    res = A; 
    msn = res & 0xf0; 
    lsn = res & 0x0f; 
    res = res + (((lsn > 0x09) || (H & 0x10)) ? 0x06 : 0); 
    res = res + ((((UINT8)msn > 0x80U) && ((UINT8)lsn > 0x09U)) || (((UINT8)msn > 0x90U) || (C != 0)) ? 0x60 : 0); 
    C = C | (res & 0x100); 
    res = (UINT8)res; 
    A = res; 
 // N = res; 
 // Z = res; 
 // V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$5C                    ; 9833: 97 5C         \n");
                                      #endif // Score millions
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x5c; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$FF                    ; 9835: 86 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xff; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B2C                   ; 9837: B7 4B 2C      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x4b2c, val); 
    // End of function sub_9801
    // ---------------------------------------------------------------------------
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 983A: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x9874:
L9874:
                                                     #ifdef DEBUG
                                      mon("L9874    LDA   <$8B                    ; 9874: 96 8B         \n");
                                      #endif
    PC = 0x9874; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x8b); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   locret_987E             ; 9876: 26 06         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L987E;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$10                    ; 9878: 86 10         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x10; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$62                    ; 987A: 97 62         \n");
                                      #endif // Timer for fireball hit?
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x62; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         INC   <$8B                    ; 987C: 0C 8B         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x8b); 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    wr_mem(DP|0x8b, res); 
    clockticks = clockticks + 2; 
    // End of function sub_9874
  case 0x987E:
L987E:
locret_987E:
                                                     #ifdef DEBUG
                                      mon("locret_987E RTS                           ; 987E: 39            \n");
                                      #endif
    PC = 0x987e; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Fireball timer
  case 0x987F:
L987F:
                                                     #ifdef DEBUG
                                      mon("L987F    LDA   <$43                    ; 987F: 96 43         \n");
                                      #endif // Game over/insert coins timer
    PC = 0x987f; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x43); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$03                    ; 9881: 84 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x03; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$62                    ; 9883: 97 62         \n");
                                      #endif // Timer for fireball hit?
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0x62; 
    wr_mem(ea, val); 
    // End of function sub_987F
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 9885: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Fireball timer 2
  case 0x9886:
L9886:
                                                     #ifdef DEBUG
                                      mon("L9886    LDB   <$62                    ; 9886: D6 62         \n");
                                      #endif // Timer for fireball hit?
    PC = 0x9886; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x62); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$08                    ; 9888: C1 08         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x08; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BLS   L9890                   ; 988A: 23 04         \n");
                                      #endif // Fireball timer 3
    // temp hack to force a flush
    if ((!Z) || C) {
    clockticks = clockticks + 3; 
    goto L9890;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   #$08                    ; 988C: C6 08         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x08; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
    // End of function sub_9886
                                                     #ifdef DEBUG
                                      mon("         STB   <$62                    ; 988E: D7 62         \n");
                                      #endif // Timer for fireball hit?
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x62; 
    wr_mem(ea, val); 
    // =============== S U B R O U T I N E =======================================
    // Fireball timer 3
  case 0x9890:
L9890:
                                                     #ifdef DEBUG
                                      mon("L9890    LDB   <$62                    ; 9890: D6 62         \n");
                                      #endif // Timer for fireball hit?
    PC = 0x9890; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x62); 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   locret_9897             ; 9892: 27 03         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L9897;
    }
                                                     #ifdef DEBUG
                                      mon("         DECB                          ; 9894: 5A            \n");
                                      #endif
    val = (UINT8)B; 
    res = (UINT8)(val - 1); 
 // N = res; 
 // Z = res; 
 // V = val & ~res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STB   <$62                    ; 9895: D7 62         \n");
                                      #endif // Timer for fireball hit?
    clockticks = clockticks + 4; 
    val = B; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0x62; 
    wr_mem(ea, val); 
    // End of function sub_9890
  case 0x9897:
L9897:
locret_9897:
                                                     #ifdef DEBUG
                                      mon("locret_9897 RTS                           ; 9897: 39            \n");
                                      #endif
    PC = 0x9897; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x9898:
L9898:
                                                     #ifdef DEBUG
                                      mon("L9898    LDA   <$43                    ; 9898: 96 43         \n");
                                      #endif // Game over/insert coins timer
    PC = 0x9898; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x43); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$00                    ; 989A: 84 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x00; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   locret_98AF             ; 989C: 26 11         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L98AF;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4900                  ; 989E: 8E 49 00      \n");
                                      #endif // 3x Tie fighter data structure ($19 bytes per Tie)
    clockticks = clockticks + 3; 
    X = 0x4900; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0x98A1:
L98A1:
                                                     #ifdef DEBUG
                                      mon("L98A1    DEC   $06,X                   ; 98A1: 6A 06         \n");
                                      #endif
    PC = 0x98a1; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0006)); 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    wr_mem((UINT16)(X + 0x0006), res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BPL   L98A7                   ; 98A3: 2A 02         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto L98A7;
    }
                                                     #ifdef DEBUG
                                      mon("         CLR   $06,X                   ; 98A5: 6F 06         \n");
                                      #endif
    clockticks = clockticks + 5; 
    wr_mem((UINT16)(X + 0x0006), 0); 
 // V = 0; 
 // Z = 0; 
 // N = 0; 
 // C = 0; 
    clockticks = clockticks + 2; 
  case 0x98A7:
L98A7:
                                                     #ifdef DEBUG
                                      mon("L98A7    LEAX  $19,X                   ; 98A7: 30 88 19      \n");
                                      #endif
    PC = 0x98a7; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    X = (X + (SINT8)0x19); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$494B                  ; 98AA: 8C 49 4B      \n");
                                      #endif // 3x Tie fighter data structure ($19 bytes per Tie)
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x494b; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   L98A1                   ; 98AD: 25 F2         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L98A1;
    }
    // End of function sub_9898
  case 0x98AF:
L98AF:
locret_98AF:
                                                     #ifdef DEBUG
                                      mon("locret_98AF RTS                           ; 98AF: 39            \n");
                                      #endif
    PC = 0x98af; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Insert vector laser explosion small circle
  case 0x98B0:
L98B0:
                                                     #ifdef DEBUG
                                      mon("L98B0    LDB   <$62                    ; 98B0: D6 62         \n");
                                      #endif // Timer for fireball hit?
    PC = 0x98b0; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x62); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$03                    ; 98B2: C4 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x03; 
    B = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   locret_98CA             ; 98B4: 27 14         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L98CA;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$7100                  ; 98B6: CC 71 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x71; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 98B9: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$67FF                  ; 98BB: CC 67 FF      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x67; 
    B = 0xff; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 98BE: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$B9B3                  ; 98C0: CC B9 B3      \n");
                                      #endif // Vector JSRL 19B3 Laser explosion small circle
    clockticks = clockticks + 3; 
    A = 0xb9; 
    B = 0xb3; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 98C3: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$7200                  ; 98C5: CC 72 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x72; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 98C8: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
    // End of function sub_98B0
    // ---------------------------------------------------------------------------
  case 0x98CA:
L98CA:
locret_98CA:
                                                     #ifdef DEBUG
                                      mon("locret_98CA RTS                           ; 98CA: 39            \n");
                                      #endif
    PC = 0x98ca; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xA1CE:
LA1CE:
                                                     #ifdef DEBUG
                                      mon("LA1CE    LDU   #$49C2                  ; A1CE: CE 49 C2      \n");
                                      #endif // Tie fighter data 1
    PC = 0xa1ce; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0x49c2; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0xA1D1:
LA1D1:
                                                     #ifdef DEBUG
                                      mon("LA1D1    LDA   #$00                    ; A1D1: 86 00         \n");
                                      #endif
    PC = 0xa1d1; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   ,U                      ; A1D3: A7 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LEAU  $01,U                   ; A1D5: 33 41         \n");
                                      #endif
    clockticks = clockticks + 5; 
    U = (U + 0x0001); 
                                                     #ifdef DEBUG
                                      mon("         CMPU  #$49E2                  ; A1D7: 11 83 49 E2   \n");
                                      #endif // Tie fighter data 1
    clockticks = clockticks + 5; 
    val = U; 
    arg = 0x49e2; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LA1D1                   ; A1DB: 25 F4         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LA1D1;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B13                   ; A1DD: B6 4B 13      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b13); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$13                    ; A1E0: 81 13         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x13; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   LA1EF                   ; A1E2: 25 0B         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LA1EF;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   #$06                    ; A1E4: C6 06         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x06; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4703                   ; A1E6: B6 47 03      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         MUL                           ; A1E9: 3D            \n");
                                      #endif
    res = (UINT16)(A * B); 
 // Z = res; 
 // C = res & 0x80; 
    A = res >> 8; 
    B = (UINT8)res; 
    clockticks = clockticks + 11; 
                                                     #ifdef DEBUG
                                      mon("         ADDA  #$0D                    ; A1EA: 8B 0D         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x0d; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B13                   ; A1EC: B7 4B 13      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b13, val); 
  case 0xA1EF:
LA1EF:
                                                     #ifdef DEBUG
                                      mon("LA1EF    LDB   $4B13                   ; A1EF: F6 4B 13      \n");
                                      #endif
    PC = 0xa1ef; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b13); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #byte_98CB              ; A1F2: 8E 98 CB      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x98cb; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; A1F5: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #byte_98DE              ; A1F6: 8C 98 DE      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x98de; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LA1FE                   ; A1F9: 25 03         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LA1FE;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   #byte_98DD              ; A1FB: 8E 98 DD      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x98dd; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xA1FE:
LA1FE:
                                                     #ifdef DEBUG
                                      mon("LA1FE    LDA   ,X                      ; A1FE: A6 84         \n");
                                      #endif
    PC = 0xa1fe; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(X); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B1A                   ; A200: B7 4B 1A      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b1a, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   word_9856               ; A203: FC 98 56      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x9856); // Care needed with I/O space and word fetches
    B = rd_mem(0x9857); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B2E                   ; A206: FD 4B 2E      \n");
                                      #endif // Temporary score adder towers 1
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4b2e, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b2f, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   byte_9858               ; A209: B6 98 58      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x9858); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B30                   ; A20C: B7 4B 30      \n");
                                      #endif // Temporary score adder towers 3
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b30, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; A20F: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$A7                    ; A211: 97 A7         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0xa7; 
    wr_mem(ea, val); 
    // End of function sub_A1CE
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; A213: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xA214:
LA214:
                                                     #ifdef DEBUG
                                      mon("LA214    LDB   #$07                    ; A214: C6 07         \n");
                                      #endif
    PC = 0xa214; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x07; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STB   <$DC                    ; A216: D7 DC         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xdc; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCD38                   ; A218: BD CD 38      \n");
                                      #endif // Trench left side turret calcs
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x1b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa2); 
    clockticks = clockticks + 1; 
    goto LCD38;
  case 0xA21B:
LA21B:
                                                     #ifdef DEBUG
                                      mon("LA21B    LDD   #$00                    ; A21B: CC 00 00      \n");
                                      #endif
    PC = 0xa21b; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5040                   ; A21E: FD 50 40      \n");
                                      #endif // XT2
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5040, A); // Care needed with I/O space and word fetches
    wr_mem(0x5041, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $5042                   ; A221: FD 50 42      \n");
                                      #endif // YT2
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5042, A); // Care needed with I/O space and word fetches
    wr_mem(0x5043, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $5044                   ; A224: FD 50 44      \n");
                                      #endif // ZT2
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5044, A); // Care needed with I/O space and word fetches
    wr_mem(0x5045, B); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LA40A                   ; A227: BD A4 0A      \n");
                                      #endif // Some Towers code
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x2a); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa2); 
    clockticks = clockticks + 1; 
    goto LA40A;
  case 0xA22A:
LA22A:
                                                     #ifdef DEBUG
                                      mon("LA22A    LDD   $5098                   ; A22A: FC 50 98      \n");
                                      #endif
    PC = 0xa22a; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x5098); // Care needed with I/O space and word fetches
    B = rd_mem(0x5099); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5040                   ; A22D: FD 50 40      \n");
                                      #endif // XT2
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5040, A); // Care needed with I/O space and word fetches
    wr_mem(0x5041, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $509A                   ; A230: FC 50 9A      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x509a); // Care needed with I/O space and word fetches
    B = rd_mem(0x509b); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5042                   ; A233: FD 50 42      \n");
                                      #endif // YT2
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5042, A); // Care needed with I/O space and word fetches
    wr_mem(0x5043, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $509C                   ; A236: FC 50 9C      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x509c); // Care needed with I/O space and word fetches
    B = rd_mem(0x509d); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5044                   ; A239: FD 50 44      \n");
                                      #endif // ZT2
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5044, A); // Care needed with I/O space and word fetches
    wr_mem(0x5045, B); 
                                                     #ifdef DEBUG
                                      mon("         LDB   $4B13                   ; A23C: F6 4B 13      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b13); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; A23F: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; A240: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #off_A182               ; A241: 8E A1 82      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0xa182; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; A244: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #LA1CE                  ; A245: 8C A1 CE      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0xa1ce; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LA24D                   ; A248: 25 03         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LA24D;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   #off_A1CA               ; A24A: 8E A1 CA      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0xa1ca; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xA24D:
LA24D:
                                                     #ifdef DEBUG
                                      mon("LA24D    LDX   ,X                      ; A24D: AE 84         \n");
                                      #endif
    PC = 0xa24d; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xA24F:
LA24F:
                                                     #ifdef DEBUG
                                      mon("LA24F    STX   <$64                    ; A24F: 9F 64         \n");
                                      #endif // Pointer to Tie fighter data
    PC = 0xa24f; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = X; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = DP|0x64; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$A7                    ; A251: 96 A7         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xa7); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  $05,X                   ; A253: A1 05         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    arg = rd_mem((UINT16)(X + 0x0005)); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         LBLT  LA2DA                   ; A255: 10 2D 00 81   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 1; 
    goto LA2DA;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   ,X                      ; A259: EC 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(X); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(X+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5E00                   ; A25B: FD 5E 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5e00, A); // Care needed with I/O space and word fetches
    wr_mem(0x5e01, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $02,X                   ; A25E: EC 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + 0x0002); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5E02                   ; A260: FD 5E 02      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5e02, A); // Care needed with I/O space and word fetches
    wr_mem(0x5e03, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$1E00                  ; A263: CC 1E 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x1e; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5E04                   ; A266: FD 5E 04      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5e04, A); // Care needed with I/O space and word fetches
    wr_mem(0x5e05, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$01C0                  ; A269: CC 01 C0      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x01; 
    B = 0xc0; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4701                   ; A26C: FD 47 01      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4701, A); // Care needed with I/O space and word fetches
    wr_mem(0x4702, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$67                    ; A26F: 86 67         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x67; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCDBA                   ; A271: BD CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa2); 
    clockticks = clockticks + 1; 
    goto LCDBA;
  case 0xA274:
LA274:
                                                     #ifdef DEBUG
                                      mon("LA274    LDD   $5000                   ; A274: FC 50 00      \n");
                                      #endif // Math result X
    PC = 0xa274; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x5000); // Care needed with I/O space and word fetches
    B = rd_mem(0x5001); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LA27E                   ; A277: 2A 05         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LA27E;
    }
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$3F                    ; A279: 84 3F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x3f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5000                   ; A27B: FD 50 00      \n");
                                      #endif // Math result X
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5000, A); // Care needed with I/O space and word fetches
    wr_mem(0x5001, B); 
  case 0xA27E:
LA27E:
                                                     #ifdef DEBUG
                                      mon("LA27E    STD   $507C                   ; A27E: FD 50 7C      \n");
                                      #endif
    PC = 0xa27e; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x507c, A); // Care needed with I/O space and word fetches
    wr_mem(0x507d, B); 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$0100                  ; A281: 10 83 01 00   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x0100; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BLT   LA2B0                   ; A285: 2D 29         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 3; 
    goto LA2B0;
    }
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$3C00                  ; A287: 10 83 3C 00   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x3c00; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCC   LA2B0                   ; A28B: 24 23         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LA2B0;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $5002                   ; A28D: FC 50 02      \n");
                                      #endif // Math result Y
    clockticks = clockticks + 5; 
    A = rd_mem(0x5002); // Care needed with I/O space and word fetches
    B = rd_mem(0x5003); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LA296                   ; A290: 2A 04         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LA296;
    }
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; A292: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; A293: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SBCA  #$FF                    ; A294: 82 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xff; 
    res = val - (UINT8)arg - (C != 0 ? 1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)res; 
  case 0xA296:
LA296:
                                                     #ifdef DEBUG
                                      mon("LA296    SUBD  $5000                   ; A296: B3 50 00      \n");
                                      #endif // Math result X
    PC = 0xa296; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5000)<<8; 
    ea = ea | rd_mem(0x5001); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BCC   LA2B0                   ; A299: 24 15         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LA2B0;
    }
                                                     #ifdef DEBUG
                                      mon("         LDU   #$49C2                  ; A29B: CE 49 C2      \n");
                                      #endif // Tie fighter data 1
    clockticks = clockticks + 3; 
    U = 0x49c2; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $06,X                   ; A29E: E6 06         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0006)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LEAU  B,U                     ; A2A0: 33 C5         \n");
                                      #endif
    clockticks = clockticks + 5; 
    U = (U + (SINT8)B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   ,U                      ; A2A2: A6 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(U); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BITA  #$02                    ; A2A4: 85 02         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A & (SINT8)0x02; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LA2AE                   ; A2A6: 27 06         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LA2AE;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   LA2F8                   ; A2A8: BD A2 F8      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xab); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa2); 
    clockticks = clockticks + 1; 
    goto LA2F8;
  case 0xA2AB:
LA2AB:
                                                     #ifdef DEBUG
                                      mon("LA2AB    JSR   LA591                   ; A2AB: BD A5 91      \n");
                                      #endif
    PC = 0xa2ab; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xae); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa2); 
    clockticks = clockticks + 1; 
    goto LA591;
  case 0xA2AE:
LA2AE:
                                                     #ifdef DEBUG
                                      mon("LA2AE    BRA   LA2DA                   ; A2AE: 20 2A         \n");
                                      #endif
    PC = 0xa2ae; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto LA2DA;
    
    // ---------------------------------------------------------------------------
  case 0xA2B0:
LA2B0:
                                                     #ifdef DEBUG
                                      mon("LA2B0    LDX   <$64                    ; A2B0: 9E 64         \n");
                                      #endif // Pointer to Tie fighter data
    PC = 0xa2b0; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x64)<<8; 
    ea = ea | rd_mem(DP|0x65); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #$49C2                  ; A2B2: CE 49 C2      \n");
                                      #endif // Tie fighter data 1
    clockticks = clockticks + 3; 
    U = 0x49c2; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $06,X                   ; A2B5: E6 06         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0006)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LEAU  B,U                     ; A2B7: 33 C5         \n");
                                      #endif
    clockticks = clockticks + 5; 
    U = (U + (SINT8)B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B3D                   ; A2B9: B6 4B 3D      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b3d); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LA2C2                   ; A2BC: 27 04         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LA2C2;
    }
                                                     #ifdef DEBUG
                                      mon("         CLR   ,U                      ; A2BE: 6F C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    wr_mem(U, 0); 
    V = 0; 
    Z = 0; 
    N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LA2DA                   ; A2C0: 20 18         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LA2DA;
    
    // ---------------------------------------------------------------------------
  case 0xA2C2:
LA2C2:
                                                     #ifdef DEBUG
                                      mon("LA2C2    LDA   #$0B                    ; A2C2: 86 0B         \n");
                                      #endif
    PC = 0xa2c2; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x0b; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   ,U                      ; A2C4: E6 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(U); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BITB  #$04                    ; A2C6: C5 04         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = B & (SINT8)0x04; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LA2D6                   ; A2C8: 27 0C         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LA2D6;
    }
                                                     #ifdef DEBUG
                                      mon("         ORA   #$04                    ; A2CA: 8A 04         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A | (UINT8)0x04; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $04,X                   ; A2CC: E6 04         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0004)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$03                    ; A2CE: C1 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x03; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   LA2D4                   ; A2D0: 26 02         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LA2D4;
    }
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$FD                    ; A2D2: 84 FD         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0xfd; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
  case 0xA2D4:
LA2D4:
                                                     #ifdef DEBUG
                                      mon("LA2D4    BRA   LA2D8                   ; A2D4: 20 02         \n");
                                      #endif
    PC = 0xa2d4; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto LA2D8;
    
    // ---------------------------------------------------------------------------
  case 0xA2D6:
LA2D6:
                                                     #ifdef DEBUG
                                      mon("LA2D6    ORA   #$10                    ; A2D6: 8A 10         \n");
                                      #endif
    PC = 0xa2d6; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    res = A | (UINT8)0x10; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
  case 0xA2D8:
LA2D8:
                                                     #ifdef DEBUG
                                      mon("LA2D8    STA   ,U                      ; A2D8: A7 C4         \n");
                                      #endif
    PC = 0xa2d8; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, val); 
  case 0xA2DA:
LA2DA:
                                                     #ifdef DEBUG
                                      mon("LA2DA    LDB   $4B13                   ; A2DA: F6 4B 13      \n");
                                      #endif
    PC = 0xa2da; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b13); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; A2DD: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; A2DE: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #off_A182               ; A2DF: 8E A1 82      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0xa182; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; A2E2: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #LA1CE                  ; A2E3: 8C A1 CE      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0xa1ce; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LA2EB                   ; A2E6: 25 03         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LA2EB;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   #off_A1CA               ; A2E8: 8E A1 CA      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0xa1ca; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xA2EB:
LA2EB:
                                                     #ifdef DEBUG
                                      mon("LA2EB    TFR   X,U                     ; A2EB: 1F 13         \n");
                                      #endif
    PC = 0xa2eb; 
    INSTRUCTION_START
    U = X; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         LDX   <$64                    ; A2ED: 9E 64         \n");
                                      #endif // Pointer to Tie fighter data
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x64)<<8; 
    ea = ea | rd_mem(DP|0x65); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LEAX  $07,X                   ; A2EF: 30 07         \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + 0x0007); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         CPX   $02,U                   ; A2F1: AC 42         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0002))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0002))+1)); 
    val = X; 
    arg = ea; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         LBCS  LA24F                   ; A2F3: 10 25 FF 58   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if (C) {
    clockticks = clockticks + 1; 
    goto LA24F;
    }
    // End of function sub_A214
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; A2F7: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xA2F8:
LA2F8:
                                                     #ifdef DEBUG
                                      mon("LA2F8    LDX   <$64                    ; A2F8: 9E 64         \n");
                                      #endif // Pointer to Tie fighter data
    PC = 0xa2f8; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x64)<<8; 
    ea = ea | rd_mem(DP|0x65); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $04,X                   ; A2FA: E6 04         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0004)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$03                    ; A2FC: C1 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x03; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   LA304                   ; A2FE: 26 04         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LA304;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   #$09                    ; A300: C6 09         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x09; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LA306                   ; A302: 20 02         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LA306;
    
    // ---------------------------------------------------------------------------
  case 0xA304:
LA304:
                                                     #ifdef DEBUG
                                      mon("LA304    LDB   #$08                    ; A304: C6 08         \n");
                                      #endif
    PC = 0xa304; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x08; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xA306:
LA306:
                                                     #ifdef DEBUG
                                      mon("LA306    STB   <$DC                    ; A306: D7 DC         \n");
                                      #endif
    PC = 0xa306; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xdc; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$6680                  ; A308: CC 66 80      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x66; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5E02                   ; A30B: FD 5E 02      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5e02, A); // Care needed with I/O space and word fetches
    wr_mem(0x5e03, B); 
                                                     #ifdef DEBUG
                                      mon("         LDU   #$49C2                  ; A30E: CE 49 C2      \n");
                                      #endif // Tie fighter data 1
    clockticks = clockticks + 3; 
    U = 0x49c2; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $06,X                   ; A311: E6 06         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0006)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LEAU  B,U                     ; A313: 33 C5         \n");
                                      #endif
    clockticks = clockticks + 5; 
    U = (U + (SINT8)B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   ,U                      ; A315: A6 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(U); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $04,X                   ; A317: E6 04         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0004)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$03                    ; A319: C1 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x03; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LA333                   ; A31B: 27 16         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LA333;
    }
                                                     #ifdef DEBUG
                                      mon("         BITA  #$04                    ; A31D: 85 04         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A & (SINT8)0x04; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LA325                   ; A31F: 26 04         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LA325;
    }
                                                     #ifdef DEBUG
                                      mon("         BITA  #$10                    ; A321: 85 10         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A & (SINT8)0x10; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LA32E                   ; A323: 26 09         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LA32E;
    }
  case 0xA325:
LA325:
                                                     #ifdef DEBUG
                                      mon("LA325    LDB   #$0A                    ; A325: C6 0A         \n");
                                      #endif
    PC = 0xa325; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x0a; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STB   <$DC                    ; A327: D7 DC         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xdc; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$6080                  ; A329: CC 60 80      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x60; 
    B = 0x80; 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LA331                   ; A32C: 20 03         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LA331;
    
    // ---------------------------------------------------------------------------
  case 0xA32E:
LA32E:
                                                     #ifdef DEBUG
                                      mon("LA32E    LDD   #$6780                  ; A32E: CC 67 80      \n");
                                      #endif
    PC = 0xa32e; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x67; 
    B = 0x80; 
    Z = A|B; 
    N = A; 
    V = 0; 
  case 0xA331:
LA331:
                                                     #ifdef DEBUG
                                      mon("LA331    BRA   LA33F                   ; A331: 20 0C         \n");
                                      #endif
    PC = 0xa331; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto LA33F;
    
    // ---------------------------------------------------------------------------
  case 0xA333:
LA333:
                                                     #ifdef DEBUG
                                      mon("LA333    BITA  #$04                    ; A333: 85 04         \n");
                                      #endif
    PC = 0xa333; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    res = A & (SINT8)0x04; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LA33C                   ; A335: 26 05         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LA33C;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$6460                  ; A337: CC 64 60      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x64; 
    B = 0x60; 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LA33F                   ; A33A: 20 03         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LA33F;
    
    // ---------------------------------------------------------------------------
  case 0xA33C:
LA33C:
                                                     #ifdef DEBUG
                                      mon("LA33C    LDD   #$6080                  ; A33C: CC 60 80      \n");
                                      #endif
    PC = 0xa33c; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x60; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0xA33F:
LA33F:
                                                     #ifdef DEBUG
                                      mon("LA33F    STD   $5E00                   ; A33F: FD 5E 00      \n");
                                      #endif
    PC = 0xa33f; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5e00, A); // Care needed with I/O space and word fetches
    wr_mem(0x5e01, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$72                    ; A342: 86 72         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x72; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $5E04                   ; A344: B7 5E 04      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x5e04, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $5000                   ; A347: B6 50 00      \n");
                                      #endif // Math result X
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x5000); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLA                          ; A34A: 48            \n");
                                      #endif
    val = (UINT8)A; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLA                          ; A34B: 48            \n");
                                      #endif
    val = (UINT8)A; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $5E05                   ; A34C: B7 5E 05      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x5e05, val); 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$40                    ; A34F: C6 40         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x40; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; A351: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         MUL                           ; A352: 3D            \n");
                                      #endif
    res = (UINT16)(A * B); 
 // Z = res; 
 // C = res & 0x80; 
    A = res >> 8; 
    B = (UINT8)res; 
    clockticks = clockticks + 11; 
                                                     #ifdef DEBUG
                                      mon("         ADDA  #$40                    ; A353: 8B 40         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x40; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STA   $5E03                   ; A355: B7 5E 03      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x5e03, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $5086                   ; A358: FC 50 86      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x5086); // Care needed with I/O space and word fetches
    B = rd_mem(0x5087); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; A35B: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLA                          ; A35C: 49            \n");
                                      #endif
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$0400                  ; A35D: C3 04 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0400; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5000                   ; A360: B3 50 00      \n");
                                      #endif // Math result X
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5000)<<8; 
    ea = ea | rd_mem(0x5001); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         LBLT  LA3F4                   ; A363: 10 2D 00 8D   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 1; 
    goto LA3F4;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $04,X                   ; A367: A6 04         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0004)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$03                    ; A369: 81 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x03; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LA3A7                   ; A36B: 27 3A         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LA3A7;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   <$60                    ; A36D: 96 60         \n");
                                      #endif // Shield count
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x60); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BLT   LA374                   ; A36F: 2D 03         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 3; 
    goto LA374;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   Sound_2C                ; A371: BD BD D0      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa3); 
    clockticks = clockticks + 1; 
    goto LBDD0;
  case 0xA374:
LA374:
                                                     #ifdef DEBUG
                                      mon("LA374    LDD   $5000                   ; A374: FC 50 00      \n");
                                      #endif // Math result X
    PC = 0xa374; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x5000); // Care needed with I/O space and word fetches
    B = rd_mem(0x5001); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$0200                  ; A377: 83 02 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0200; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5086                   ; A37A: B3 50 86      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5086)<<8; 
    ea = ea | rd_mem(0x5087); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BGT   LA3A5                   ; A37D: 2E 26         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto LA3A5;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$A018                  ; A37F: CC A0 18      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xa0; 
    B = 0x18; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5E02                   ; A382: FD 5E 02      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5e02, A); // Care needed with I/O space and word fetches
    wr_mem(0x5e03, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$6080                  ; A385: CC 60 80      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x60; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5E00                   ; A388: FD 5E 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5e00, A); // Care needed with I/O space and word fetches
    wr_mem(0x5e01, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$60                    ; A38B: 96 60         \n");
                                      #endif // Shield count
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x60); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BLT   LA395                   ; A38D: 2D 06         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 3; 
    goto LA395;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   L9874                   ; A38F: BD 98 74      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x92); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa3); 
    clockticks = clockticks + 1; 
    goto L9874;
  case 0xA392:
LA392:
                                                     #ifdef DEBUG
                                      mon("LA392    JSR   Sound_26                ; A392: BD BD B2      \n");
                                      #endif // Explosion
    PC = 0xa392; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x95); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa3); 
    clockticks = clockticks + 1; 
    goto LBDB2;
  case 0xA395:
LA395:
                                                     #ifdef DEBUG
                                      mon("LA395    LDA   <$63                    ; A395: 96 63         \n");
                                      #endif
    PC = 0xa395; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x63); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LA39D                   ; A397: 26 04         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LA39D;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $5002                   ; A399: B6 50 02      \n");
                                      #endif // Math result Y
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x5002); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         NEGA                          ; A39C: 40            \n");
                                      #endif
    val = (UINT8)A; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
  case 0xA39D:
LA39D:
                                                     #ifdef DEBUG
                                      mon("LA39D    LDB   #$20                    ; A39D: C6 20         \n");
                                      #endif
    PC = 0xa39d; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x20; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         TSTA                          ; A39F: 4D            \n");
                                      #endif
    val = (UINT8)A; 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LA3A3                   ; A3A0: 2A 01         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LA3A3;
    }
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; A3A2: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
  case 0xA3A3:
LA3A3:
                                                     #ifdef DEBUG
                                      mon("LA3A3    STB   <$63                    ; A3A3: D7 63         \n");
                                      #endif
    PC = 0xa3a3; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = B; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0x63; 
    wr_mem(ea, val); 
  case 0xA3A5:
LA3A5:
                                                     #ifdef DEBUG
                                      mon("LA3A5    BRA   LA3F4                   ; A3A5: 20 4D         \n");
                                      #endif
    PC = 0xa3a5; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto LA3F4;
    
    // ---------------------------------------------------------------------------
  case 0xA3A7:
LA3A7:
                                                     #ifdef DEBUG
                                      mon("LA3A7    LDD   $5044                   ; A3A7: FC 50 44      \n");
                                      #endif // ZT2
    PC = 0xa3a7; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x5044); // Care needed with I/O space and word fetches
    B = rd_mem(0x5045); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$07A0                  ; A3AA: 83 07 A0      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x07a0; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BGT   LA3F4                   ; A3AD: 2E 45         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto LA3F4;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   Sound_2C                ; A3AF: BD BD D0      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xb2); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa3); 
    clockticks = clockticks + 1; 
    goto LBDD0;
  case 0xA3B2:
LA3B2:
                                                     #ifdef DEBUG
                                      mon("LA3B2    LDX   <$64                    ; A3B2: 9E 64         \n");
                                      #endif // Pointer to Tie fighter data
    PC = 0xa3b2; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x64)<<8; 
    ea = ea | rd_mem(DP|0x65); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #$49C2                  ; A3B4: CE 49 C2      \n");
                                      #endif // Tie fighter data 1
    clockticks = clockticks + 3; 
    U = 0x49c2; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $06,X                   ; A3B7: E6 06         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0006)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LEAU  B,U                     ; A3B9: 33 C5         \n");
                                      #endif
    clockticks = clockticks + 5; 
    U = (U + (SINT8)B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   ,U                      ; A3BB: A6 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(U); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BITA  #$04                    ; A3BD: 85 04         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A & (SINT8)0x04; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LA3F4                   ; A3BF: 26 33         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LA3F4;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $5044                   ; A3C1: FC 50 44      \n");
                                      #endif // ZT2
    clockticks = clockticks + 5; 
    A = rd_mem(0x5044); // Care needed with I/O space and word fetches
    B = rd_mem(0x5045); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$05A0                  ; A3C4: 83 05 A0      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x05a0; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BGE   LA3F4                   ; A3C7: 2C 2B         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) >= 0) {
    clockticks = clockticks + 3; 
    goto LA3F4;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $5000                   ; A3C9: FC 50 00      \n");
                                      #endif // Math result X
    clockticks = clockticks + 5; 
    A = rd_mem(0x5000); // Care needed with I/O space and word fetches
    B = rd_mem(0x5001); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$0400                  ; A3CC: 83 04 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0400; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5086                   ; A3CF: B3 50 86      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5086)<<8; 
    ea = ea | rd_mem(0x5087); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BGT   LA3F4                   ; A3D2: 2E 20         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto LA3F4;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$A018                  ; A3D4: CC A0 18      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xa0; 
    B = 0x18; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5E00                   ; A3D7: FD 5E 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5e00, A); // Care needed with I/O space and word fetches
    wr_mem(0x5e01, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$60                    ; A3DA: 96 60         \n");
                                      #endif // Shield count
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x60); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BLT   LA3E4                   ; A3DC: 2D 06         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 3; 
    goto LA3E4;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   L9874                   ; A3DE: BD 98 74      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xe1); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa3); 
    clockticks = clockticks + 1; 
    goto L9874;
  case 0xA3E1:
LA3E1:
                                                     #ifdef DEBUG
                                      mon("LA3E1    JSR   Sound_26                ; A3E1: BD BD B2      \n");
                                      #endif // Explosion
    PC = 0xa3e1; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xe4); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa3); 
    clockticks = clockticks + 1; 
    goto LBDB2;
  case 0xA3E4:
LA3E4:
                                                     #ifdef DEBUG
                                      mon("LA3E4    LDA   <$63                    ; A3E4: 96 63         \n");
                                      #endif
    PC = 0xa3e4; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x63); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LA3F4                   ; A3E6: 26 0C         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LA3F4;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$13                    ; A3E8: 86 13         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x13; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $5002                   ; A3EA: F6 50 02      \n");
                                      #endif // Math result Y
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x5002); 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BMI   LA3F0                   ; A3ED: 2B 01         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LA3F0;
    }
                                                     #ifdef DEBUG
                                      mon("         NEGA                          ; A3EF: 40            \n");
                                      #endif
    val = (UINT8)A; 
    res = -val; 
 // V = val & (UINT8)res; 
 // C = res & 0x100; 
    val = (UINT8)res; 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
  case 0xA3F0:
LA3F0:
                                                     #ifdef DEBUG
                                      mon("LA3F0    ADDA  <$63                    ; A3F0: 9B 63         \n");
                                      #endif
    PC = 0xa3f0; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)A; 
    arg = rd_mem(DP|0x63); 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$63                    ; A3F2: 97 63         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x63; 
    wr_mem(ea, val); 
  case 0xA3F4:
LA3F4:
                                                     #ifdef DEBUG
                                      mon("LA3F4    LDA   $5000                   ; A3F4: B6 50 00      \n");
                                      #endif // Math result X
    PC = 0xa3f4; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x5000); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBA  #$08                    ; A3F7: 80 08         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x08; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)(res); 
                                                     #ifdef DEBUG
                                      mon("         BGT   LA400                   ; A3F9: 2E 05         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto LA400;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   LCD68                   ; A3FB: BD CD 68      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xfe); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa3); 
    clockticks = clockticks + 1; 
    goto LCD68;
  case 0xA3FE:
LA3FE:
                                                     #ifdef DEBUG
                                      mon("LA3FE    BRA   LA403                   ; A3FE: 20 03         \n");
                                      #endif
    PC = 0xa3fe; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto LA403;
    
    // ---------------------------------------------------------------------------
  case 0xA400:
LA400:
                                                     #ifdef DEBUG
                                      mon("LA400    JSR   LCD50                   ; A400: BD CD 50      \n");
                                      #endif
    PC = 0xa400; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x03); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa4); 
    clockticks = clockticks + 1; 
    goto LCD50;
  case 0xA403:
LA403:
                                                     #ifdef DEBUG
                                      mon("LA403    JSR   LCD74                   ; A403: BD CD 74      \n");
                                      #endif // Function select for an object
    PC = 0xa403; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x06); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa4); 
    clockticks = clockticks + 1; 
    goto LCD74;
  case 0xA406:
LA406:
                                                     #ifdef DEBUG
                                      mon("LA406    JSR   LA459                   ; A406: BD A4 59      \n");
                                      #endif // Some Towers code
    PC = 0xa406; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x09); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa4); 
    clockticks = clockticks + 1; 
    goto LA459;
    // End of function sub_A2F8
  case 0xA409:
LA409:
                                                     #ifdef DEBUG
                                      mon("LA409    RTS                           ; A409: 39            \n");
                                      #endif
    PC = 0xa409; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Some Towers code
  case 0xA40A:
LA40A:
                                                     #ifdef DEBUG
                                      mon("LA40A    JSR   LCDE7                   ; A40A: BD CD E7      \n");
                                      #endif // Swap Matrix 2  x, y, z to  x, y, z
    PC = 0xa40a; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x0d); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa4); 
    clockticks = clockticks + 1; 
    goto LCDE7;
  case 0xA40D:
LA40D:
                                                     #ifdef DEBUG
                                      mon("LA40D    LDD   #$00                    ; A40D: CC 00 00      \n");
                                      #endif
    PC = 0xa40d; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5078                   ; A410: FD 50 78      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5078, A); // Care needed with I/O space and word fetches
    wr_mem(0x5079, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$B3                    ; A413: DC B3         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0xb3); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0xb4); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $507A                   ; A415: FD 50 7A      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x507a, A); // Care needed with I/O space and word fetches
    wr_mem(0x507b, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$B5                    ; A418: DC B5         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0xb5); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0xb6); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $507C                   ; A41A: FD 50 7C      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x507c, A); // Care needed with I/O space and word fetches
    wr_mem(0x507d, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0F                    ; A41D: CC 00 0F      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x0f; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4701                   ; A420: FD 47 01      \n");
                                      #endif // Point BIC to $5078 MReg3C
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4701, A); // Care needed with I/O space and word fetches
    wr_mem(0x4702, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$2A                    ; A423: 86 2A         \n");
                                      #endif // Reg00 = (([BIC,0] - XT) x Ax2)  +  (([BIC,1] - YT) x Bx2)  +  (([BIC,2] - ZT) x Cx2), Reg01 = (([BIC,0] - XT) x Ay2)  +  (([BIC,1] - YT) x By2)  +  (([BIC,2] - ZT) x Cy2), Reg02 = (([BIC,0] - XT) x Az2)  +  (([BIC,1] - YT) x Bz2)  +  (([BIC,2] - ZT) x Cz2), BIC++
    clockticks = clockticks + 2; 
    val = (UINT8)0x2a; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCDBA                   ; A425: BD CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x28); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa4); 
    clockticks = clockticks + 1; 
    goto LCDBA;
  case 0xA428:
LA428:
                                                     #ifdef DEBUG
                                      mon("LA428    LDD   $5002                   ; A428: FC 50 02      \n");
                                      #endif // Math result Y
    PC = 0xa428; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x5002); // Care needed with I/O space and word fetches
    B = rd_mem(0x5003); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5078                   ; A42B: FD 50 78      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5078, A); // Care needed with I/O space and word fetches
    wr_mem(0x5079, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $5004                   ; A42E: FC 50 04      \n");
                                      #endif // Math result Z
    clockticks = clockticks + 5; 
    A = rd_mem(0x5004); // Care needed with I/O space and word fetches
    B = rd_mem(0x5005); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $507A                   ; A431: FD 50 7A      \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x507a, A); // Care needed with I/O space and word fetches
    wr_mem(0x507b, B); 
                                                     #ifdef DEBUG
                                      mon("         BPL   LA455                   ; A434: 2A 1F         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LA455;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   <$BC                    ; A436: 96 BC         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xbc); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LA455                   ; A438: 27 1B         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LA455;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$FF                    ; A43A: 86 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xff; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$BD                    ; A43C: 97 BD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xbd; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$03                    ; A43E: 86 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x03; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B23                   ; A440: B7 4B 23      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b23, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$6280                  ; A443: CC 62 80      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x62; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B20                   ; A446: FD 4B 20      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4b20, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b21, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $5004                   ; A449: FC 50 04      \n");
                                      #endif // Math result Z
    clockticks = clockticks + 5; 
    A = rd_mem(0x5004); // Care needed with I/O space and word fetches
    B = rd_mem(0x5005); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; A44C: 44            \n");
                                      #endif
    val = (UINT8)A; 
    C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         RORB                          ; A44D: 56            \n");
                                      #endif
    res = ((UINT8)B) | ((C != 0) ? 0x100 : 0); 
 // C = res & 1; 
    res = (UINT8)(res >> 1); 
 // Z = res; 
 // N = res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; A44E: 44            \n");
                                      #endif
    val = (UINT8)A; 
    C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         RORB                          ; A44F: 56            \n");
                                      #endif
    res = ((UINT8)B) | ((C != 0) ? 0x100 : 0); 
 // C = res & 1; 
    res = (UINT8)(res >> 1); 
 // Z = res; 
 // N = res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ADDB  #$C0                    ; A450: CB C0         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0xc0; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STB   $4B22                   ; A452: F7 4B 22      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = B; 
    Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x4b22, val); 
  case 0xA455:
LA455:
                                                     #ifdef DEBUG
                                      mon("LA455    JSR   LCDE7                   ; A455: BD CD E7      \n");
                                      #endif // Called during towers phase only
    PC = 0xa455; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x58); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa4); 
    clockticks = clockticks + 1; 
    goto LCDE7;
    // End of function sub_A40A
  case 0xA458:
LA458:
                                                     #ifdef DEBUG
                                      mon("LA458    RTS                           ; A458: 39            \n");
                                      #endif
    PC = 0xa458; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Some Towers code
  case 0xA459:
LA459:
                                                     #ifdef DEBUG
                                      mon("LA459    LDX   <$64                    ; A459: 9E 64         \n");
                                      #endif // Pointer to Tie fighter data
    PC = 0xa459; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x64)<<8; 
    ea = ea | rd_mem(DP|0x65); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   $507C                   ; A45B: FC 50 7C      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x507c); // Care needed with I/O space and word fetches
    B = rd_mem(0x507d); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; A45E: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLA                          ; A45F: 49            \n");
                                      #endif
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4704                   ; A460: FD 47 04      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4704, A); // Care needed with I/O space and word fetches
    wr_mem(0x4705, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $02,X                   ; A463: EC 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + 0x0002); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5042                   ; A465: B3 50 42      \n");
                                      #endif // YT2
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5042)<<8; 
    ea = ea | rd_mem(0x5043); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5002                   ; A468: FD 50 02      \n");
                                      #endif // Math result Y
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5002, A); // Care needed with I/O space and word fetches
    wr_mem(0x5003, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; A46B: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5044                   ; A46E: B3 50 44      \n");
                                      #endif // ZT2
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5044)<<8; 
    ea = ea | rd_mem(0x5045); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5004                   ; A471: FD 50 04      \n");
                                      #endif // Math result Z
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5004, A); // Care needed with I/O space and word fetches
    wr_mem(0x5005, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $4700                   ; A474: FC 47 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x4700); // Care needed with I/O space and word fetches
    B = rd_mem(0x4701); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5000                   ; A477: FD 50 00      \n");
                                      #endif // Math result X
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5000, A); // Care needed with I/O space and word fetches
    wr_mem(0x5001, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$86                    ; A47A: 86 86         \n");
                                      #endif // MReg02 = MReg02 x MReg00
    clockticks = clockticks + 2; 
    val = (UINT8)0x86; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCDBA                   ; A47C: BD CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x7f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa4); 
    clockticks = clockticks + 1; 
    goto LCDBA;
  case 0xA47F:
LA47F:
                                                     #ifdef DEBUG
                                      mon("LA47F    LDD   $5002                   ; A47F: FC 50 02      \n");
                                      #endif // Math result Y
    PC = 0xa47f; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x5002); // Care needed with I/O space and word fetches
    B = rd_mem(0x5003); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $501A                   ; A482: FD 50 1A      \n");
                                      #endif // YT
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x501a, A); // Care needed with I/O space and word fetches
    wr_mem(0x501b, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $5004                   ; A485: FC 50 04      \n");
                                      #endif // Math result Z
    clockticks = clockticks + 5; 
    A = rd_mem(0x5004); // Care needed with I/O space and word fetches
    B = rd_mem(0x5005); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $501C                   ; A488: FD 50 1C      \n");
                                      #endif // ZT
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x501c, A); // Care needed with I/O space and word fetches
    wr_mem(0x501d, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $04,X                   ; A48B: A6 04         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0004)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$03                    ; A48D: 81 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x03; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LA49F                   ; A48F: 27 0E         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LA49F;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$03C0                  ; A491: CC 03 C0      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x03; 
    B = 0xc0; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5002                   ; A494: FD 50 02      \n");
                                      #endif // Math result Y
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5002, A); // Care needed with I/O space and word fetches
    wr_mem(0x5003, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$5280                  ; A497: CC 52 80      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x52; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5004                   ; A49A: FD 50 04      \n");
                                      #endif // Math result Z
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x5004, A); // Care needed with I/O space and word fetches
    wr_mem(0x5005, B); 
                                                     #ifdef DEBUG
                                      mon("         BRA   LA4BA                   ; A49D: 20 1B         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LA4BA;
    
    // ---------------------------------------------------------------------------
  case 0xA49F:
LA49F:
                                                     #ifdef DEBUG
                                      mon("LA49F    LDU   #$49C2                  ; A49F: CE 49 C2      \n");
                                      #endif // Tie fighter data 1
    PC = 0xa49f; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0x49c2; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $06,X                   ; A4A2: E6 06         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0006)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LEAU  B,U                     ; A4A4: 33 C5         \n");
                                      #endif
    clockticks = clockticks + 5; 
    U = (U + (SINT8)B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   ,U                      ; A4A6: A6 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(U); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BITA  #$04                    ; A4A8: 85 04         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A & (SINT8)0x04; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LBNE  locret_A54A             ; A4AA: 10 26 00 9C   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if (Z) {
    clockticks = clockticks + 1; 
    goto LA54A;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0690                  ; A4AE: CC 06 90      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x06; 
    B = 0x90; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5002                   ; A4B1: FD 50 02      \n");
                                      #endif // Math result Y
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5002, A); // Care needed with I/O space and word fetches
    wr_mem(0x5003, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$05A0                  ; A4B4: CC 05 A0      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x05; 
    B = 0xa0; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5004                   ; A4B7: FD 50 04      \n");
                                      #endif // Math result Z
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5004, A); // Care needed with I/O space and word fetches
    wr_mem(0x5005, B); 
  case 0xA4BA:
LA4BA:
                                                     #ifdef DEBUG
                                      mon("LA4BA    LDD   $5000                   ; A4BA: FC 50 00      \n");
                                      #endif // Math result X
    PC = 0xa4ba; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x5000); // Care needed with I/O space and word fetches
    B = rd_mem(0x5001); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$0100                  ; A4BD: 83 01 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0100; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LA4C5                   ; A4C0: 2A 03         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LA4C5;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; A4C2: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0xA4C5:
LA4C5:
                                                     #ifdef DEBUG
                                      mon("LA4C5    STD   $5000                   ; A4C5: FD 50 00      \n");
                                      #endif // Math result X
    PC = 0xa4c5; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5000, A); // Care needed with I/O space and word fetches
    wr_mem(0x5001, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$86                    ; A4C8: 86 86         \n");
                                      #endif // MReg02 = MReg02 x MReg00
    clockticks = clockticks + 2; 
    val = (UINT8)0x86; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCDBA                   ; A4CA: BD CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xcd); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa4); 
    clockticks = clockticks + 1; 
    goto LCDBA;
  case 0xA4CD:
LA4CD:
                                                     #ifdef DEBUG
                                      mon("LA4CD    LDD   $501A                   ; A4CD: FC 50 1A      \n");
                                      #endif // YT
    PC = 0xa4cd; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x501a); // Care needed with I/O space and word fetches
    B = rd_mem(0x501b); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $5002                   ; A4D0: F3 50 02      \n");
                                      #endif // Math result Y
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5002)<<8; 
    ea = ea | rd_mem(0x5003); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$0A                    ; A4D3: C3 00 0A      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x000a; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5078                   ; A4D6: B3 50 78      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5078)<<8; 
    ea = ea | rd_mem(0x5079); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         LBLT  locret_A54A             ; A4D9: 10 2D 00 6D   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 1; 
    goto LA54A;
    }
                                                     #ifdef DEBUG
                                      mon("         ASRA                          ; A4DD: 47            \n");
                                      #endif
    val = (UINT8)A; 
    C = val & 1; 
    val = (UINT8)((SINT8)val >> 1); 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         RORB                          ; A4DE: 56            \n");
                                      #endif
    res = ((UINT8)B) | ((C != 0) ? 0x100 : 0); 
 // C = res & 1; 
    res = (UINT8)(res >> 1); 
 // Z = res; 
 // N = res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$0A                    ; A4DF: 83 00 0A      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x000a; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5002                   ; A4E2: B3 50 02      \n");
                                      #endif // Math result Y
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5002)<<8; 
    ea = ea | rd_mem(0x5003); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         LBGT  locret_A54A             ; A4E5: 10 2E 00 61   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 1; 
    goto LA54A;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $507A                   ; A4E9: FC 50 7A      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x507a); // Care needed with I/O space and word fetches
    B = rd_mem(0x507b); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $501C                   ; A4EC: B3 50 1C      \n");
                                      #endif // ZT
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x501c)<<8; 
    ea = ea | rd_mem(0x501d); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BMI   locret_A54A             ; A4EF: 2B 59         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LA54A;
    }
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5004                   ; A4F1: B3 50 04      \n");
                                      #endif // Math result Z
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5004)<<8; 
    ea = ea | rd_mem(0x5005); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BGT   locret_A54A             ; A4F4: 2E 54         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto LA54A;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $04,X                   ; A4F6: A6 04         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0004)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$03                    ; A4F8: 81 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x03; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   LA50A                   ; A4FA: 26 0E         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LA50A;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $507C                   ; A4FC: FC 50 7C      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x507c); // Care needed with I/O space and word fetches
    B = rd_mem(0x507d); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  <$C8                    ; A4FF: 10 93 C8      \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xc8)<<8; 
    ea = ea | rd_mem(DP|0xc9); 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = ea; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
    clockticks = clockticks + 1; 
                                                     #ifdef DEBUG
                                      mon("         BCC   LA508                   ; A502: 24 04         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LA508;
    }
                                                     #ifdef DEBUG
                                      mon("         STD   <$C8                    ; A504: DD C8         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0xc8; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STX   <$C6                    ; A506: 9F C6         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    Z = val; 
    N = (UINT8)(val >> 8); 
    V = 0; 
    ea = DP|0xc6; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
  case 0xA508:
LA508:
                                                     #ifdef DEBUG
                                      mon("LA508    BRA   locret_A54A             ; A508: 20 40         \n");
                                      #endif
    PC = 0xa508; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto LA54A;
    
    // ---------------------------------------------------------------------------
  case 0xA50A:
LA50A:
                                                     #ifdef DEBUG
                                      mon("LA50A    LDD   #$4CE0                  ; A50A: CC 4C E0      \n");
                                      #endif
    PC = 0xa50a; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x4c; 
    B = 0xe0; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5002                   ; A50D: FD 50 02      \n");
                                      #endif // Math result Y
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5002, A); // Care needed with I/O space and word fetches
    wr_mem(0x5003, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$86                    ; A510: 86 86         \n");
                                      #endif // MReg02 = MReg02 x MReg00
    clockticks = clockticks + 2; 
    val = (UINT8)0x86; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCDBA                   ; A512: BD CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x15); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa5); 
    clockticks = clockticks + 1; 
    goto LCDBA;
  case 0xA515:
LA515:
                                                     #ifdef DEBUG
                                      mon("LA515    LDD   $507A                   ; A515: FC 50 7A      \n");
                                      #endif
    PC = 0xa515; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x507a); // Care needed with I/O space and word fetches
    B = rd_mem(0x507b); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$0A                    ; A518: C3 00 0A      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x000a; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $501C                   ; A51B: B3 50 1C      \n");
                                      #endif // ZT
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x501c)<<8; 
    ea = ea | rd_mem(0x501d); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5002                   ; A51E: B3 50 02      \n");
                                      #endif // Math result Y
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5002)<<8; 
    ea = ea | rd_mem(0x5003); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BLT   LA53E                   ; A521: 2D 1B         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 3; 
    goto LA53E;
    }
                                                     #ifdef DEBUG
                                      mon("         LDU   #$49C2                  ; A523: CE 49 C2      \n");
                                      #endif // Tie fighter data 1
    clockticks = clockticks + 3; 
    U = 0x49c2; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $06,X                   ; A526: E6 06         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0006)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LEAU  B,U                     ; A528: 33 C5         \n");
                                      #endif
    clockticks = clockticks + 5; 
    U = (U + (SINT8)B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   ,U                      ; A52A: A6 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(U); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BITA  #$04                    ; A52C: 85 04         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A & (SINT8)0x04; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   locret_A54A             ; A52E: 26 1A         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LA54A;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $507C                   ; A530: FC 50 7C      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x507c); // Care needed with I/O space and word fetches
    B = rd_mem(0x507d); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  <$C8                    ; A533: 10 93 C8      \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xc8)<<8; 
    ea = ea | rd_mem(DP|0xc9); 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = ea; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
    clockticks = clockticks + 1; 
                                                     #ifdef DEBUG
                                      mon("         BCC   LA53C                   ; A536: 24 04         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LA53C;
    }
                                                     #ifdef DEBUG
                                      mon("         STD   <$C8                    ; A538: DD C8         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0xc8; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STX   <$C6                    ; A53A: 9F C6         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    Z = val; 
    N = (UINT8)(val >> 8); 
    V = 0; 
    ea = DP|0xc6; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
  case 0xA53C:
LA53C:
                                                     #ifdef DEBUG
                                      mon("LA53C    BRA   locret_A54A             ; A53C: 20 0C         \n");
                                      #endif
    PC = 0xa53c; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto LA54A;
    
    // ---------------------------------------------------------------------------
  case 0xA53E:
LA53E:
                                                     #ifdef DEBUG
                                      mon("LA53E    LDD   $507C                   ; A53E: FC 50 7C      \n");
                                      #endif
    PC = 0xa53e; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x507c); // Care needed with I/O space and word fetches
    B = rd_mem(0x507d); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  <$D0                    ; A541: 10 93 D0      \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xd0)<<8; 
    ea = ea | rd_mem(DP|0xd1); 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = ea; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
    clockticks = clockticks + 1; 
                                                     #ifdef DEBUG
                                      mon("         BCC   locret_A54A             ; A544: 24 04         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LA54A;
    }
                                                     #ifdef DEBUG
                                      mon("         STD   <$D0                    ; A546: DD D0         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0xd0; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STX   <$CE                    ; A548: 9F CE         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    Z = val; 
    N = (UINT8)(val >> 8); 
    V = 0; 
    ea = DP|0xce; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
    // End of function sub_A459
  case 0xA54A:
LA54A:
locret_A54A:
                                                     #ifdef DEBUG
                                      mon("locret_A54A RTS                           ; A54A: 39            \n");
                                      #endif
    PC = 0xa54a; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
    // START OF FUNCTION CHUNK FOR sub_B2D2
  case 0xA54B:
LA54B:
                                                     #ifdef DEBUG
                                      mon("LA54B    LDX   <$C6                    ; A54B: 9E C6         \n");
                                      #endif
    PC = 0xa54b; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xc6)<<8; 
    ea = ea | rd_mem(DP|0xc7); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   ,X                      ; A54D: EC 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(X); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(X+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5098                   ; A54F: B3 50 98      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5098)<<8; 
    ea = ea | rd_mem(0x5099); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$7F                    ; A552: 84 7F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x7f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $5098                   ; A554: F3 50 98      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5098)<<8; 
    ea = ea | rd_mem(0x5099); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5018                   ; A557: FD 50 18      \n");
                                      #endif // XT
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5018, A); // Care needed with I/O space and word fetches
    wr_mem(0x5019, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $02,X                   ; A55A: EC 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + 0x0002); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $501A                   ; A55C: FD 50 1A      \n");
                                      #endif // YT
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x501a, A); // Care needed with I/O space and word fetches
    wr_mem(0x501b, B); 
                                                     #ifdef DEBUG
                                      mon("         LDU   #$49C2                  ; A55F: CE 49 C2      \n");
                                      #endif // Tie fighter data 1
    clockticks = clockticks + 3; 
    U = 0x49c2; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $06,X                   ; A562: E6 06         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0006)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LEAU  B,U                     ; A564: 33 C5         \n");
                                      #endif
    clockticks = clockticks + 5; 
    U = (U + (SINT8)B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   ,U                      ; A566: A6 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(U); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORA   #$04                    ; A568: 8A 04         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A | (UINT8)0x04; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   ,U                      ; A56A: A7 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $04,X                   ; A56C: A6 04         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0004)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$03                    ; A56E: 81 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x03; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   LA580                   ; A570: 26 0E         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LA580;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$02D0                  ; A572: CC 02 D0      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x02; 
    B = 0xd0; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $501C                   ; A575: FD 50 1C      \n");
                                      #endif // ZT
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x501c, A); // Care needed with I/O space and word fetches
    wr_mem(0x501d, B); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LB852                   ; A578: BD B8 52      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x7b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa5); 
    clockticks = clockticks + 1; 
    goto LB852;
  case 0xA57B:
LA57B:
                                                     #ifdef DEBUG
                                      mon("LA57B    JSR   L97F7                   ; A57B: BD 97 F7      \n");
                                      #endif // Laser tower score
    PC = 0xa57b; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x7e); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa5); 
    clockticks = clockticks + 1; 
    goto L97F7;
  case 0xA57E:
LA57E:
                                                     #ifdef DEBUG
                                      mon("LA57E    BRA   LA58C                   ; A57E: 20 0C         \n");
                                      #endif
    PC = 0xa57e; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto LA58C;
    
    // ---------------------------------------------------------------------------
  case 0xA580:
LA580:
                                                     #ifdef DEBUG
                                      mon("LA580    LDD   #$5460                  ; A580: CC 54 60      \n");
                                      #endif
    PC = 0xa580; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x54; 
    B = 0x60; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $501C                   ; A583: FD 50 1C      \n");
                                      #endif // ZT
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x501c, A); // Care needed with I/O space and word fetches
    wr_mem(0x501d, B); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LB85E                   ; A586: BD B8 5E      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x89); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa5); 
    clockticks = clockticks + 1; 
    goto LB85E;
  case 0xA589:
LA589:
                                                     #ifdef DEBUG
                                      mon("LA589    JSR   L973A                   ; A589: BD 97 3A      \n");
                                      #endif // Towers incrementing score
    PC = 0xa589; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x8c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa5); 
    clockticks = clockticks + 1; 
    goto L973A;
  case 0xA58C:
LA58C:
                                                     #ifdef DEBUG
                                      mon("LA58C    JSR   Sound_35                ; A58C: BD BD FD      \n");
                                      #endif
    PC = 0xa58c; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x8f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa5); 
    clockticks = clockticks + 1; 
    goto LBDFD;
    // END OF FUNCTION CHUNK FOR sub_B2D2
    // ---------------------------------------------------------------------------
  case 0xA58F:
LA58F:
                                                     #ifdef DEBUG
                                      mon("LA58F    RTS                           ; A58F: 39            \n");
                                      #endif
    PC = 0xa58f; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // FUNCTION CHUNK AT ROM:A728 SIZE 0000008E BYTES
  case 0xA591:
LA591:
                                                     #ifdef DEBUG
                                      mon("LA591    LDA   <$60                    ; A591: 96 60         \n");
                                      #endif // Shield count
    PC = 0xa591; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x60); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BLT   locret_A5B2             ; A593: 2D 1D         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 3; 
    goto LA5B2;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   <$64                    ; A595: 9E 64         \n");
                                      #endif // Pointer to Tie fighter data
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x64)<<8; 
    ea = ea | rd_mem(DP|0x65); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #$49C2                  ; A597: CE 49 C2      \n");
                                      #endif // Tie fighter data 1
    clockticks = clockticks + 3; 
    U = 0x49c2; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $06,X                   ; A59A: E6 06         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0006)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LEAU  B,U                     ; A59C: 33 C5         \n");
                                      #endif
    clockticks = clockticks + 5; 
    U = (U + (SINT8)B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   ,U                      ; A59E: A6 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(U); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BITA  #$04                    ; A5A0: 85 04         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A & (SINT8)0x04; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   locret_A5B2             ; A5A2: 26 0E         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LA5B2;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $04,X                   ; A5A4: A6 04         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0004)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$02                    ; A5A6: 81 02         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x02; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         LBEQ  LA608                   ; A5A8: 10 27 00 5C   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if (!Z) {
    clockticks = clockticks + 1; 
    goto LA608;
    }
                                                     #ifdef DEBUG
                                      mon("         LBHI  LA655                   ; A5AC: 10 22 00 A5   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if (Z && (!C)) {
    clockticks = clockticks + 1; 
    goto LA655;
    }
                                                     #ifdef DEBUG
                                      mon("         BRA   LA5B3                   ; A5B0: 20 01         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LA5B3;
    
    // ---------------------------------------------------------------------------
  case 0xA5B2:
LA5B2:
locret_A5B2:
                                                     #ifdef DEBUG
                                      mon("locret_A5B2 RTS                           ; A5B2: 39            \n");
                                      #endif
    PC = 0xa5b2; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
  case 0xA5B3:
LA5B3:
                                                     #ifdef DEBUG
                                      mon("LA5B3    LDD   #$4000                  ; A5B3: CC 40 00      \n");
                                      #endif
    PC = 0xa5b3; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x40; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $507C                   ; A5B6: B3 50 7C      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x507c)<<8; 
    ea = ea | rd_mem(0x507d); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; A5B9: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLA                          ; A5BA: 49            \n");
                                      #endif
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5000                   ; A5BB: FD 50 00      \n");
                                      #endif // Math result X
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5000, A); // Care needed with I/O space and word fetches
    wr_mem(0x5001, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$2940                  ; A5BE: CC 29 40      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x29; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5004                   ; A5C1: FD 50 04      \n");
                                      #endif // Math result Z
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5004, A); // Care needed with I/O space and word fetches
    wr_mem(0x5005, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$02D0                  ; A5C4: CC 02 D0      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x02; 
    B = 0xd0; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5002                   ; A5C7: FD 50 02      \n");
                                      #endif // Math result Y
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5002, A); // Care needed with I/O space and word fetches
    wr_mem(0x5003, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$86                    ; A5CA: 86 86         \n");
                                      #endif // MReg02 = MReg02 x MReg00
    clockticks = clockticks + 2; 
    val = (UINT8)0x86; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCDBA                   ; A5CC: BD CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xcf); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa5); 
    clockticks = clockticks + 1; 
    goto LCDBA;
  case 0xA5CF:
LA5CF:
                                                     #ifdef DEBUG
                                      mon("LA5CF    LDD   $5004                   ; A5CF: FC 50 04      \n");
                                      #endif // Math result Z
    PC = 0xa5cf; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x5004); // Care needed with I/O space and word fetches
    B = rd_mem(0x5005); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5044                   ; A5D2: B3 50 44      \n");
                                      #endif // ZT2
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5044)<<8; 
    ea = ea | rd_mem(0x5045); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BGE   LA5DE                   ; A5D5: 2C 07         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) >= 0) {
    clockticks = clockticks + 3; 
    goto LA5DE;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   ,U                      ; A5D7: A6 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(U); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORA   #$08                    ; A5D9: 8A 08         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A | (UINT8)0x08; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   ,U                      ; A5DB: A7 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = U; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; A5DD: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
  case 0xA5DE:
LA5DE:
                                                     #ifdef DEBUG
                                      mon("LA5DE    SUBD  $5002                   ; A5DE: B3 50 02      \n");
                                      #endif // Math result Y
    PC = 0xa5de; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5002)<<8; 
    ea = ea | rd_mem(0x5003); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BLE   LA5E9                   ; A5E1: 2F 06         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto LA5E9;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   ,U                      ; A5E3: A6 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(U); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BITA  #$08                    ; A5E5: 85 08         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A & (SINT8)0x08; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   locret_A607             ; A5E7: 27 1E         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LA607;
    }
  case 0xA5E9:
LA5E9:
                                                     #ifdef DEBUG
                                      mon("LA5E9    LDA   ,U                      ; A5E9: A6 C4         \n");
                                      #endif
    PC = 0xa5e9; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(U); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$F7                    ; A5EB: 84 F7         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0xf7; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   ,U                      ; A5ED: A7 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4703                   ; A5EF: B6 47 03      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LA5F7                   ; A5F2: 2A 03         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LA5F7;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   LA7B6                   ; A5F4: BD A7 B6      \n");
                                      #endif // Emit fireballs from towers/bunkers
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf7); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa5); 
    clockticks = clockticks + 1; 
    goto LA7B6;
  case 0xA5F7:
LA5F7:
                                                     #ifdef DEBUG
                                      mon("LA5F7    LDA   $4703                   ; A5F7: B6 47 03      \n");
                                      #endif
    PC = 0xa5f7; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LA5FF                   ; A5FA: 2A 03         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LA5FF;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   LA7C8                   ; A5FC: BD A7 C8      \n");
                                      #endif // Emit fireballs from towers/bunkers 2
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xff); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa5); 
    clockticks = clockticks + 1; 
    goto LA7C8;
  case 0xA5FF:
LA5FF:
                                                     #ifdef DEBUG
                                      mon("LA5FF    LDA   $4703                   ; A5FF: B6 47 03      \n");
                                      #endif
    PC = 0xa5ff; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BPL   locret_A607             ; A602: 2A 03         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LA607;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   LA7BF                   ; A604: BD A7 BF      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x07); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa6); 
    clockticks = clockticks + 1; 
    goto LA7BF;
  case 0xA607:
LA607:
locret_A607:
                                                     #ifdef DEBUG
                                      mon("locret_A607 RTS                           ; A607: 39            \n");
                                      #endif
    PC = 0xa607; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
  case 0xA608:
LA608:
                                                     #ifdef DEBUG
                                      mon("LA608    LDD   #$4000                  ; A608: CC 40 00      \n");
                                      #endif
    PC = 0xa608; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x40; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $507C                   ; A60B: B3 50 7C      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x507c)<<8; 
    ea = ea | rd_mem(0x507d); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; A60E: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLA                          ; A60F: 49            \n");
                                      #endif
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5000                   ; A610: FD 50 00      \n");
                                      #endif // Math result X
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5000, A); // Care needed with I/O space and word fetches
    wr_mem(0x5001, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$2940                  ; A613: CC 29 40      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x29; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5004                   ; A616: FD 50 04      \n");
                                      #endif // Math result Z
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5004, A); // Care needed with I/O space and word fetches
    wr_mem(0x5005, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$02D0                  ; A619: CC 02 D0      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x02; 
    B = 0xd0; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5002                   ; A61C: FD 50 02      \n");
                                      #endif // Math result Y
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5002, A); // Care needed with I/O space and word fetches
    wr_mem(0x5003, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$86                    ; A61F: 86 86         \n");
                                      #endif // MReg02 = MReg02 x MReg00
    clockticks = clockticks + 2; 
    val = (UINT8)0x86; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCDBA                   ; A621: BD CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x24); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa6); 
    clockticks = clockticks + 1; 
    goto LCDBA;
  case 0xA624:
LA624:
                                                     #ifdef DEBUG
                                      mon("LA624    LDD   $5004                   ; A624: FC 50 04      \n");
                                      #endif // Math result Z
    PC = 0xa624; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x5004); // Care needed with I/O space and word fetches
    B = rd_mem(0x5005); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5044                   ; A627: B3 50 44      \n");
                                      #endif // ZT2
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5044)<<8; 
    ea = ea | rd_mem(0x5045); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BGE   LA633                   ; A62A: 2C 07         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) >= 0) {
    clockticks = clockticks + 3; 
    goto LA633;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   ,U                      ; A62C: A6 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(U); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORA   #$08                    ; A62E: 8A 08         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A | (UINT8)0x08; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   ,U                      ; A630: A7 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = U; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; A632: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
  case 0xA633:
LA633:
                                                     #ifdef DEBUG
                                      mon("LA633    SUBD  $5002                   ; A633: B3 50 02      \n");
                                      #endif // Math result Y
    PC = 0xa633; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5002)<<8; 
    ea = ea | rd_mem(0x5003); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BLE   LA63E                   ; A636: 2F 06         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto LA63E;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   ,U                      ; A638: A6 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(U); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BITA  #$08                    ; A63A: 85 08         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A & (SINT8)0x08; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   locret_A654             ; A63C: 27 16         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LA654;
    }
  case 0xA63E:
LA63E:
                                                     #ifdef DEBUG
                                      mon("LA63E    LDA   ,U                      ; A63E: A6 C4         \n");
                                      #endif
    PC = 0xa63e; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(U); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$F7                    ; A640: 84 F7         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0xf7; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   ,U                      ; A642: A7 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4703                   ; A644: B6 47 03      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LA64C                   ; A647: 2A 03         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LA64C;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   LA7C8                   ; A649: BD A7 C8      \n");
                                      #endif // Emit fireballs from towers/bunkers 2
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x4c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa6); 
    clockticks = clockticks + 1; 
    goto LA7C8;
  case 0xA64C:
LA64C:
                                                     #ifdef DEBUG
                                      mon("LA64C    LDA   $4703                   ; A64C: B6 47 03      \n");
                                      #endif
    PC = 0xa64c; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BPL   locret_A654             ; A64F: 2A 03         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LA654;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   LA7BF                   ; A651: BD A7 BF      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x54); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa6); 
    clockticks = clockticks + 1; 
    goto LA7BF;
  case 0xA654:
LA654:
locret_A654:
                                                     #ifdef DEBUG
                                      mon("locret_A654 RTS                           ; A654: 39            \n");
                                      #endif
    PC = 0xa654; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
  case 0xA655:
LA655:
                                                     #ifdef DEBUG
                                      mon("LA655    LDA   #$40                    ; A655: 86 40         \n");
                                      #endif
    PC = 0xa655; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x40; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBA  $507C                   ; A657: B0 50 7C      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    arg = rd_mem(0x507c); 
    res = val - (UINT8)arg; 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)(res); 
                                                     #ifdef DEBUG
                                      mon("         CMPA  $4703                   ; A65A: B1 47 03      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    arg = rd_mem(0x4703); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   locret_A674             ; A65D: 25 15         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LA674;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4703                   ; A65F: B6 47 03      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$50                    ; A662: 81 50         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x50; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCC   LA669                   ; A664: 24 03         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LA669;
    }
                                                     #ifdef DEBUG
                                      mon("         JMP   LA728                   ; A666: 7E A7 28      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LA728;
    
    // ---------------------------------------------------------------------------
  case 0xA669:
LA669:
                                                     #ifdef DEBUG
                                      mon("LA669    LDA   $4703                   ; A669: B6 47 03      \n");
                                      #endif
    PC = 0xa669; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LA671                   ; A66C: 2A 03         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LA671;
    }
                                                     #ifdef DEBUG
                                      mon("         JMP   LA728                   ; A66E: 7E A7 28      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LA728;
    
    // ---------------------------------------------------------------------------
  case 0xA671:
LA671:
                                                     #ifdef DEBUG
                                      mon("LA671    JMP   LA728                   ; A671: 7E A7 28      \n");
                                      #endif
    PC = 0xa671; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    goto LA728;
    
    // ---------------------------------------------------------------------------
    // End of function sub_A591
    // ---------------------------------------------------------------------------
  case 0xA674:
LA674:
locret_A674:
                                                     #ifdef DEBUG
                                      mon("locret_A674 RTS                           ; A674: 39            \n");
                                      #endif
    PC = 0xa674; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Emit fireballs from tie fighters
  case 0xA68B:
LA68B:
                                                     #ifdef DEBUG
                                      mon("LA68B    STU   <$A8                    ; A68B: DF A8         \n");
                                      #endif // Fireball data pointer
    PC = 0xa68b; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = DP|0xa8; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$40                    ; A68D: C6 40         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x40; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STB   $05,U                   ; A68F: E7 45         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(U + 0x0005); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$01                    ; A691: C6 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x01; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STB   $03,U                   ; A693: E7 43         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(U + 0x0003); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$01                    ; A695: C6 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x01; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STB   $04,U                   ; A697: E7 44         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(U + 0x0004); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B3C                   ; A699: B6 4B 3C      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b3c); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BLE   LA6AB                   ; A69C: 2F 0D         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto LA6AB;
    }
                                                     #ifdef DEBUG
                                      mon("         CPX   $4B32                   ; A69E: BC 4B 32      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4b32)<<8; 
    ea = ea | rd_mem(0x4b33); 
    val = X; 
    arg = ea; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LA6AB                   ; A6A1: 26 08         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LA6AB;
    }
                                                     #ifdef DEBUG
                                      mon("         DEC   $4B3C                   ; A6A3: 7A 4B 3C      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b3c); 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    wr_mem(0x4b3c, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LA6AB                   ; A6A6: 26 03         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LA6AB;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   Sound_12                ; A6A8: BD BD 4E      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xab); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa6); 
    clockticks = clockticks + 1; 
    goto LBD4E;
  case 0xA6AB:
LA6AB:
                                                     #ifdef DEBUG
                                      mon("LA6AB    LDU   ,U                      ; A6AB: EE C4         \n");
                                      #endif
    PC = 0xa6ab; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(U)<<8; 
    ea = ea | rd_mem((UINT16)((U)+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDX   ,X                      ; A6AD: AE 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   $08,X                   ; A6AF: EC 08         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + 0x0008); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5098                   ; A6B1: B3 50 98      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5098)<<8; 
    ea = ea | rd_mem(0x5099); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,U                      ; A6B4: ED C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $0A,X                   ; A6B6: EC 0A         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + 0x000a); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $509A                   ; A6B8: B3 50 9A      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x509a)<<8; 
    ea = ea | rd_mem(0x509b); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $02,U                   ; A6BB: ED 42         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0x0002); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $0C,X                   ; A6BD: EC 0C         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + 0x000c); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $509C                   ; A6BF: B3 50 9C      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x509c)<<8; 
    ea = ea | rd_mem(0x509d); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $04,U                   ; A6C2: ED 44         \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = (UINT16)(U + 0x0004); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         JSR   Sound_36                ; A6C4: BD BE 02      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xc7); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa6); 
    clockticks = clockticks + 1; 
    goto LBE02;
    // End of function sub_A68B
    // ---------------------------------------------------------------------------
  case 0xA6C7:
LA6C7:
                                                     #ifdef DEBUG
                                      mon("LA6C7    RTS                           ; A6C7: 39            \n");
                                      #endif
    PC = 0xa6c7; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Emit fireballs from towers 4
  case 0xA6E0:
LA6E0:
                                                     #ifdef DEBUG
                                      mon("LA6E0    LDB   $4B19                   ; A6E0: F6 4B 19      \n");
                                      #endif
    PC = 0xa6e0; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b19); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$0C                    ; A6E3: C1 0C         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x0c; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   LA6EC                   ; A6E5: 25 05         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LA6EC;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   #off_A6DE               ; A6E7: 8E A6 DE      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0xa6de; 
    Z = X; 
    N = (X) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LA6F2                   ; A6EA: 20 06         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LA6F2;
    
    // ---------------------------------------------------------------------------
  case 0xA6EC:
LA6EC:
                                                     #ifdef DEBUG
                                      mon("LA6EC    ASLB                          ; A6EC: 58            \n");
                                      #endif
    PC = 0xa6ec; 
    INSTRUCTION_START
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #off_A6C8               ; A6ED: 8E A6 C8      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0xa6c8; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDX   B,X                     ; A6F0: AE 85         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(X + (SINT8)B))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(X + (SINT8)B))+1)); 
    X = ea; 
    Z = X; 
    N = (X) >> 8; 
    V = 0; 
    // End of function sub_A6E0
  case 0xA6F2:
LA6F2:
                                                     #ifdef DEBUG
                                      mon("LA6F2    BRA   LA708                   ; A6F2: 20 14         \n");
                                      #endif
    PC = 0xa6f2; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto LA708;
    
    // =============== S U B R O U T I N E =======================================
  case 0xA6F4:
LA6F4:
                                                     #ifdef DEBUG
                                      mon("LA6F4    LDB   $4B19                   ; A6F4: F6 4B 19      \n");
                                      #endif
    PC = 0xa6f4; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b19); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$07                    ; A6F7: C1 07         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x07; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BLS   LA6FD                   ; A6F9: 23 02         \n");
                                      #endif
    // temp hack to force a flush
    if ((!Z) || C) {
    clockticks = clockticks + 3; 
    goto LA6FD;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   #$07                    ; A6FB: C6 07         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x07; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xA6FD:
LA6FD:
                                                     #ifdef DEBUG
                                      mon("LA6FD    ASLB                          ; A6FD: 58            \n");
                                      #endif
    PC = 0xa6fd; 
    INSTRUCTION_START
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #off_A718               ; A6FE: 8E A7 18      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0xa718; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDX   B,X                     ; A701: AE 85         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(X + (SINT8)B))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(X + (SINT8)B))+1)); 
    X = ea; 
    Z = X; 
    N = (X) >> 8; 
    V = 0; 
    // End of function sub_A6F4
                                                     #ifdef DEBUG
                                      mon("         BRA   LA708                   ; A703: 20 03         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LA708;
    
    // =============== S U B R O U T I N E =======================================
    // Emit fireballs from towers 3
  case 0xA705:
LA705:
                                                     #ifdef DEBUG
                                      mon("LA705    LDX   #$494B                  ; A705: 8E 49 4B      \n");
                                      #endif // 6x Fireball data structure 2 ($6 bytes per fireball)
    PC = 0xa705; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x494b; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xA708:
LA708:
                                                     #ifdef DEBUG
                                      mon("LA708    STX   <$A8                    ; A708: 9F A8         \n");
                                      #endif // Fireball data pointer
    PC = 0xa708; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = X; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = DP|0xa8; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $03,X                   ; A70A: A6 03         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0003)); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   locret_A717             ; A70C: 27 09         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LA717;
    }
                                                     #ifdef DEBUG
                                      mon("         LEAX  $06,X                   ; A70E: 30 06         \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + 0x0006); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$496F                  ; A710: 8C 49 6F      \n");
                                      #endif // 6x Fireball data structure 2 ($6 bytes per fireball)
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x496f; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LA708                   ; A713: 25 F3         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LA708;
    }
                                                     #ifdef DEBUG
                                      mon("         LEAS  $02,S                   ; A715: 32 62         \n");
                                      #endif // Do not return to last function call ?
    clockticks = clockticks + 5; 
    S = (S + 0x0002); 
    // End of function sub_A705
    // ---------------------------------------------------------------------------
  case 0xA717:
LA717:
locret_A717:
                                                     #ifdef DEBUG
                                      mon("locret_A717 RTS                           ; A717: 39            \n");
                                      #endif
    PC = 0xa717; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
    // START OF FUNCTION CHUNK FOR sub_A591
  case 0xA728:
LA728:
                                                     #ifdef DEBUG
                                      mon("LA728    JSR   LA6E0                   ; A728: BD A6 E0      \n");
                                      #endif // Emit fireballs from towers 4
    PC = 0xa728; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x2b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa7); 
    clockticks = clockticks + 1; 
    goto LA6E0;
  case 0xA72B:
LA72B:
                                                     #ifdef DEBUG
                                      mon("LA72B    LDA   #$70                    ; A72B: 86 70         \n");
                                      #endif
    PC = 0xa72b; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x70; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $05,X                   ; A72D: A7 05         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0005); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$05                    ; A72F: 86 05         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x05; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $03,X                   ; A731: A7 03         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0003); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDU   <$64                    ; A733: DE 64         \n");
                                      #endif // Pointer to Tie fighter data
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x64)<<8; 
    ea = ea | rd_mem(DP|0x65); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STX   <$01                    ; A735: 9F 01         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = DP|0x01; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $02,U                   ; A737: EC 42         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0x0002); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $509A                   ; A739: B3 50 9A      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x509a)<<8; 
    ea = ea | rd_mem(0x509b); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BMI   LA742                   ; A73C: 2B 04         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LA742;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$08                    ; A73E: 86 08         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x08; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LA744                   ; A740: 20 02         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LA744;
    
    // ---------------------------------------------------------------------------
  case 0xA742:
LA742:
                                                     #ifdef DEBUG
                                      mon("LA742    LDA   #$07                    ; A742: 86 07         \n");
                                      #endif
    PC = 0xa742; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x07; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xA744:
LA744:
                                                     #ifdef DEBUG
                                      mon("LA744    STA   $04,X                   ; A744: A7 04         \n");
                                      #endif
    PC = 0xa744; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0004); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDX   ,X                      ; A746: AE 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   ,U                      ; A748: A6 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(U); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBA  $5098                   ; A74A: B0 50 98      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    arg = rd_mem(0x5098); 
    res = val - (UINT8)arg; 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)(res); 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$80                    ; A74D: 84 80         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x80; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         EORA  ,U                      ; A74F: A8 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    res = A ^ rd_mem(U); 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $01,U                   ; A751: E6 41         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(U + 0x0001)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,X                      ; A753: ED 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $02,U                   ; A755: EC 42         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0x0002); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $02,X                   ; A757: ED 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x0002); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0200                  ; A759: CC 02 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x02; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $04,X                   ; A75C: ED 04         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x0004); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $02,X                   ; A75E: EC 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + 0x0002); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $509A                   ; A760: B3 50 9A      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x509a)<<8; 
    ea = ea | rd_mem(0x509b); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STA   $06,X                   ; A763: A7 06         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = (UINT16)(X + 0x0006); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         BPL   LA76B                   ; A765: 2A 04         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LA76B;
    }
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; A767: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; A768: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SBCA  #$FF                    ; A769: 82 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xff; 
    res = val - (UINT8)arg - (C != 0 ? 1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)res; 
  case 0xA76B:
LA76B:
                                                     #ifdef DEBUG
                                      mon("LA76B    STD   $4706                   ; A76B: FD 47 06      \n");
                                      #endif
    PC = 0xa76b; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4706, A); // Care needed with I/O space and word fetches
    wr_mem(0x4707, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   ,X                      ; A76E: EC 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(X); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(X+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5098                   ; A770: B3 50 98      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5098)<<8; 
    ea = ea | rd_mem(0x5099); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4704                   ; A773: FD 47 04      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4704, A); // Care needed with I/O space and word fetches
    wr_mem(0x4705, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0200                  ; A776: CC 02 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x02; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4706                   ; A779: FD 47 06      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4706, A); // Care needed with I/O space and word fetches
    wr_mem(0x4707, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4700                   ; A77C: B6 47 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4700); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLA                          ; A77F: 48            \n");
                                      #endif
    val = (UINT8)A; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLA                          ; A780: 48            \n");
                                      #endif
    val = (UINT8)A; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
    Z = res; 
    N = res; 
    V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BCC   LA784                   ; A781: 24 01         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LA784;
    }
                                                     #ifdef DEBUG
                                      mon("         CLRA                          ; A783: 4F            \n");
                                      #endif
    A = 0; // SEARCH_ME
 // V = 0; 
 // Z = 0; 
 // N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
  case 0xA784:
LA784:
                                                     #ifdef DEBUG
                                      mon("LA784    STA   $07,X                   ; A784: A7 07         \n");
                                      #endif
    PC = 0xa784; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0007); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$7D                    ; A786: 96 7D         \n");
                                      #endif // Joystick X
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x7d); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         EORA  $06,X                   ; A788: A8 06         \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = A ^ rd_mem((UINT16)(X + 0x0006)); 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LA790                   ; A78A: 2A 04         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LA790;
    }
                                                     #ifdef DEBUG
                                      mon("         CLR   $06,X                   ; A78C: 6F 06         \n");
                                      #endif
    clockticks = clockticks + 5; 
    wr_mem((UINT16)(X + 0x0006), 0); 
    V = 0; 
    Z = 0; 
    N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LA7B2                   ; A78E: 20 22         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LA7B2;
    
    // ---------------------------------------------------------------------------
  case 0xA790:
LA790:
                                                     #ifdef DEBUG
                                      mon("LA790    LDA   <$7D                    ; A790: 96 7D         \n");
                                      #endif // Joystick X
    PC = 0xa790; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x7d); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LA795                   ; A792: 2A 01         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LA795;
    }
                                                     #ifdef DEBUG
                                      mon("         NEGA                          ; A794: 40            \n");
                                      #endif
    val = (UINT8)A; 
    res = -val; 
 // V = val & (UINT8)res; 
 // C = res & 0x100; 
    val = (UINT8)res; 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
  case 0xA795:
LA795:
                                                     #ifdef DEBUG
                                      mon("LA795    ASLA                          ; A795: 48            \n");
                                      #endif
    PC = 0xa795; 
    INSTRUCTION_START
    val = (UINT8)A; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  $07,X                   ; A796: A1 07         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    arg = rd_mem((UINT16)(X + 0x0007)); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BHI   LA79E                   ; A798: 22 04         \n");
                                      #endif
    // temp hack to force a flush
    if (Z && (!C)) {
    clockticks = clockticks + 3; 
    goto LA79E;
    }
                                                     #ifdef DEBUG
                                      mon("         CLR   $06,X                   ; A79A: 6F 06         \n");
                                      #endif
    clockticks = clockticks + 5; 
    wr_mem((UINT16)(X + 0x0006), 0); 
    V = 0; 
    Z = 0; 
    N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LA7B2                   ; A79C: 20 14         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LA7B2;
    
    // ---------------------------------------------------------------------------
  case 0xA79E:
LA79E:
                                                     #ifdef DEBUG
                                      mon("LA79E    LDA   #$FF                    ; A79E: 86 FF         \n");
                                      #endif
    PC = 0xa79e; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0xff; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $06,X                   ; A7A0: A7 06         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0006); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDX   <$01                    ; A7A2: 9E 01         \n");
                                      #endif
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x01)<<8; 
    ea = ea | rd_mem(DP|0x02); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $04,X                   ; A7A4: A6 04         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0004)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$08                    ; A7A6: 81 08         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x08; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   LA7AE                   ; A7A8: 26 04         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LA7AE;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$07                    ; A7AA: 86 07         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x07; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LA7B0                   ; A7AC: 20 02         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LA7B0;
    
    // ---------------------------------------------------------------------------
  case 0xA7AE:
LA7AE:
                                                     #ifdef DEBUG
                                      mon("LA7AE    LDA   #$08                    ; A7AE: 86 08         \n");
                                      #endif
    PC = 0xa7ae; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x08; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xA7B0:
LA7B0:
                                                     #ifdef DEBUG
                                      mon("LA7B0    STA   $04,X                   ; A7B0: A7 04         \n");
                                      #endif
    PC = 0xa7b0; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = (UINT16)(X + 0x0004); 
    wr_mem(ea, val); 
  case 0xA7B2:
LA7B2:
                                                     #ifdef DEBUG
                                      mon("LA7B2    JSR   Sound_39                ; A7B2: BD BE 11      \n");
                                      #endif
    PC = 0xa7b2; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xb5); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa7); 
    clockticks = clockticks + 1; 
    goto LBE11;
    // END OF FUNCTION CHUNK FOR sub_A591
  case 0xA7B5:
LA7B5:
                                                     #ifdef DEBUG
                                      mon("LA7B5    RTS                           ; A7B5: 39            \n");
                                      #endif
    PC = 0xa7b5; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Emit fireballs from towers/bunkers
    // FUNCTION CHUNK AT ROM:A7D1 SIZE 0000000E BYTES
  case 0xA7B6:
LA7B6:
                                                     #ifdef DEBUG
                                      mon("LA7B6    JSR   LA705                   ; A7B6: BD A7 05      \n");
                                      #endif // Emit fireballs from towers 3
    PC = 0xa7b6; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xb9); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa7); 
    clockticks = clockticks + 1; 
    goto LA705;
  case 0xA7B9:
LA7B9:
                                                     #ifdef DEBUG
                                      mon("LA7B9    LDA   #$03                    ; A7B9: 86 03         \n");
                                      #endif
    PC = 0xa7b9; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x03; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $04,X                   ; A7BB: A7 04         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = (UINT16)(X + 0x0004); 
    wr_mem(ea, val); 
    // End of function sub_A7B6
                                                     #ifdef DEBUG
                                      mon("         BRA   LA7D1                   ; A7BD: 20 12         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LA7D1;
    
    // =============== S U B R O U T I N E =======================================
  case 0xA7BF:
LA7BF:
                                                     #ifdef DEBUG
                                      mon("LA7BF    JSR   LA705                   ; A7BF: BD A7 05      \n");
                                      #endif // Emit fireballs from towers 3
    PC = 0xa7bf; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xc2); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa7); 
    clockticks = clockticks + 1; 
    goto LA705;
  case 0xA7C2:
LA7C2:
                                                     #ifdef DEBUG
                                      mon("LA7C2    LDA   #$04                    ; A7C2: 86 04         \n");
                                      #endif
    PC = 0xa7c2; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x04; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $04,X                   ; A7C4: A7 04         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = (UINT16)(X + 0x0004); 
    wr_mem(ea, val); 
    // End of function sub_A7BF
                                                     #ifdef DEBUG
                                      mon("         BRA   LA7D1                   ; A7C6: 20 09         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LA7D1;
    
    // =============== S U B R O U T I N E =======================================
    // Emit fireballs from towers/bunkers 2
  case 0xA7C8:
LA7C8:
                                                     #ifdef DEBUG
                                      mon("LA7C8    JSR   LA705                   ; A7C8: BD A7 05      \n");
                                      #endif // Emit fireballs from towers 3
    PC = 0xa7c8; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xcb); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa7); 
    clockticks = clockticks + 1; 
    goto LA705;
  case 0xA7CB:
LA7CB:
                                                     #ifdef DEBUG
                                      mon("LA7CB    LDA   #$05                    ; A7CB: 86 05         \n");
                                      #endif
    PC = 0xa7cb; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x05; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $04,X                   ; A7CD: A7 04         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = (UINT16)(X + 0x0004); 
    wr_mem(ea, val); 
    // End of function sub_A7C8
                                                     #ifdef DEBUG
                                      mon("         BRA   LA7D1                   ; A7CF: 20 00         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LA7D1;
    
    // START OF FUNCTION CHUNK FOR sub_A7B6
  case 0xA7D1:
LA7D1:
                                                     #ifdef DEBUG
                                      mon("LA7D1    LDA   #$70                    ; A7D1: 86 70         \n");
                                      #endif
    PC = 0xa7d1; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x70; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $05,X                   ; A7D3: A7 05         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0005); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$05                    ; A7D5: 86 05         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x05; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $03,X                   ; A7D7: A7 03         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0003); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDU   <$64                    ; A7D9: DE 64         \n");
                                      #endif // Pointer to Tie fighter data
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x64)<<8; 
    ea = ea | rd_mem(DP|0x65); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDX   ,X                      ; A7DB: AE 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
    // END OF FUNCTION CHUNK FOR sub_A7B6
                                                     #ifdef DEBUG
                                      mon("         LDA   ,U                      ; A7DD: A6 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(U); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
    // =============== S U B R O U T I N E =======================================
  case 0xA7DF:
LA7DF:
                                                     #ifdef DEBUG
                                      mon("LA7DF    SUBA  $5098                   ; A7DF: B0 50 98      \n");
                                      #endif
    PC = 0xa7df; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    arg = rd_mem(0x5098); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)(res); 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$80                    ; A7E2: 84 80         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x80; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         EORA  ,U                      ; A7E4: A8 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    res = A ^ rd_mem(U); 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $01,U                   ; A7E6: E6 41         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(U + 0x0001)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,X                      ; A7E8: ED 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $02,U                   ; A7EA: EC 42         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0x0002); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $02,X                   ; A7EC: ED 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x0002); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $5044                   ; A7EE: FC 50 44      \n");
                                      #endif // ZT2
    clockticks = clockticks + 5; 
    A = rd_mem(0x5044); // Care needed with I/O space and word fetches
    B = rd_mem(0x5045); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $04,X                   ; A7F1: ED 04         \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = (UINT16)(X + 0x0004); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         JSR   Sound_39                ; A7F3: BD BE 11      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf6); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa7); 
    clockticks = clockticks + 1; 
    goto LBE11;
    // End of function sub_A7DF
  case 0xA7F6:
LA7F6:
                                                     #ifdef DEBUG
                                      mon("LA7F6    RTS                           ; A7F6: 39            \n");
                                      #endif
    PC = 0xa7f6; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xA7F7:
LA7F7:
                                                     #ifdef DEBUG
                                      mon("LA7F7    LDA   <$95                    ; A7F7: 96 95         \n");
                                      #endif
    PC = 0xa7f7; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x95); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LA800                   ; A7F9: 27 05         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LA800;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   LA705                   ; A7FB: BD A7 05      \n");
                                      #endif // Emit fireballs from towers 3
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xfe); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa7); 
    clockticks = clockticks + 1; 
    goto LA705;
  case 0xA7FE:
LA7FE:
                                                     #ifdef DEBUG
                                      mon("LA7FE    BRA   LA803                   ; A7FE: 20 03         \n");
                                      #endif
    PC = 0xa7fe; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto LA803;
    
    // ---------------------------------------------------------------------------
  case 0xA800:
LA800:
                                                     #ifdef DEBUG
                                      mon("LA800    JSR   LA6F4                   ; A800: BD A6 F4      \n");
                                      #endif
    PC = 0xa800; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x03); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa8); 
    clockticks = clockticks + 1; 
    goto LA6F4;
  case 0xA803:
LA803:
                                                     #ifdef DEBUG
                                      mon("LA803    LDA   #$09                    ; A803: 86 09         \n");
                                      #endif
    PC = 0xa803; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x09; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $04,X                   ; A805: A7 04         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0004); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDU   ,X                      ; A807: EE 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    U = ea; 
    Z = U; 
    N = (U) >> 8; 
    V = 0; 
    // End of function sub_A7F7
                                                     #ifdef DEBUG
                                      mon("         BRA   LA81F                   ; A809: 20 14         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LA81F;
    
    // =============== S U B R O U T I N E =======================================
  case 0xA80B:
LA80B:
                                                     #ifdef DEBUG
                                      mon("LA80B    LDA   <$95                    ; A80B: 96 95         \n");
                                      #endif
    PC = 0xa80b; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x95); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LA814                   ; A80D: 27 05         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LA814;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   LA705                   ; A80F: BD A7 05      \n");
                                      #endif // Emit fireballs from towers 3
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x12); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa8); 
    clockticks = clockticks + 1; 
    goto LA705;
  case 0xA812:
LA812:
                                                     #ifdef DEBUG
                                      mon("LA812    BRA   LA817                   ; A812: 20 03         \n");
                                      #endif
    PC = 0xa812; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto LA817;
    
    // ---------------------------------------------------------------------------
  case 0xA814:
LA814:
                                                     #ifdef DEBUG
                                      mon("LA814    JSR   LA6F4                   ; A814: BD A6 F4      \n");
                                      #endif
    PC = 0xa814; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x17); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa8); 
    clockticks = clockticks + 1; 
    goto LA6F4;
  case 0xA817:
LA817:
                                                     #ifdef DEBUG
                                      mon("LA817    LDA   #$0A                    ; A817: 86 0A         \n");
                                      #endif
    PC = 0xa817; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x0a; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $04,X                   ; A819: A7 04         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0004); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDU   ,X                      ; A81B: EE 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    U = ea; 
    Z = U; 
    N = (U) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LA81F                   ; A81D: 20 00         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LA81F;
    
  case 0xA81F:
LA81F:
                                                     #ifdef DEBUG
                                      mon("LA81F    LDD   $5078                   ; A81F: FC 50 78      \n");
                                      #endif
    PC = 0xa81f; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x5078); // Care needed with I/O space and word fetches
    B = rd_mem(0x5079); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,U                      ; A822: ED C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $507A                   ; A824: FC 50 7A      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x507a); // Care needed with I/O space and word fetches
    B = rd_mem(0x507b); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $02,U                   ; A827: ED 42         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0x0002); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $507C                   ; A829: FC 50 7C      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x507c); // Care needed with I/O space and word fetches
    B = rd_mem(0x507d); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $04,U                   ; A82C: ED 44         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0x0004); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$40                    ; A82E: 86 40         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x40; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $05,X                   ; A830: A7 05         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0005); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$05                    ; A832: 86 05         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x05; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $03,X                   ; A834: A7 03         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0003); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4703                   ; A836: B6 47 03      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; A839: 44            \n");
                                      #endif
    val = (UINT8)A; 
 // C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $507C                   ; A83A: F6 50 7C      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x507c); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$FC                    ; A83D: C1 FC         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0xfc; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BLT   LA843                   ; A83F: 2D 02         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 3; 
    goto LA843;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; A841: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xA843:
LA843:
                                                     #ifdef DEBUG
                                      mon("LA843    STA   $06,U                   ; A843: A7 46         \n");
                                      #endif
    PC = 0xa843; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = (UINT16)(U + 0x0006); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   Sound_39                ; A845: BD BE 11      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x48); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa8); 
    clockticks = clockticks + 1; 
    goto LBE11;
    // End of function sub_A80B
  case 0xA848:
LA848:
                                                     #ifdef DEBUG
                                      mon("LA848    RTS                           ; A848: 39            \n");
                                      #endif
    PC = 0xa848; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Fireball movement
  case 0xA849:
LA849:
                                                     #ifdef DEBUG
                                      mon("LA849    LDX   #$494B                  ; A849: 8E 49 4B      \n");
                                      #endif // 6x Fireball data structure 2 ($6 bytes per fireball)
    PC = 0xa849; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x494b; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xA84C:
LA84C:
                                                     #ifdef DEBUG
                                      mon("LA84C    STX   <$A8                    ; A84C: 9F A8         \n");
                                      #endif // Fireball data pointer
    PC = 0xa84c; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = X; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = DP|0xa8; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $03,X                   ; A84E: A6 03         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0003)); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LA861                   ; A850: 27 0F         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LA861;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   $04,X                   ; A852: E6 04         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0004)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; A854: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$16                    ; A855: C1 16         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x16; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCC   LA860                   ; A857: 24 07         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LA860;
    }
                                                     #ifdef DEBUG
                                      mon("         LDU   #JumpTableA675          ; A859: CE A6 75      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0xa675; 
    Z = U; 
    N = (U) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   [B,U]                   ; A85C: AD D5         \n");
                                      #endif // Fireball movement processing
    clockticks = clockticks + 3; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 2; 
    ea = rd_mem((UINT16)(U + (SINT8)B))<<8; 
    ea = ea | rd_mem((UINT16)(U + (SINT8)B + 1)); 
    --S;
    wr_mem(S, 0x5e); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa8); 
    clockticks = clockticks + 1; 
    PC = ea; 
    JUMP;
  case 0xA85E:
LA85E:
                                                     #ifdef DEBUG
                                      mon("LA85E    BRA   LA861                   ; A85E: 20 01         \n");
                                      #endif
    PC = 0xa85e; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto LA861;
    
    // ---------------------------------------------------------------------------
  case 0xA860:
LA860:
                                                     #ifdef DEBUG
                                      mon("LA860    SWI                           ; A860: 3F            \n");
                                      #endif
    PC = 0xa860; 
    INSTRUCTION_START
    clockticks = clockticks + 19; 
    --S;
    wr_mem(S, 0x61); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, U); 
    --S;
    wr_mem(S, U >> 8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, Y); 
    --S;
    wr_mem(S, Y >> 8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, X); 
    --S;
    wr_mem(S, X >> 8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, (DP >> 8)); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, B); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, A); 
    clockticks = clockticks + 1; 
    simplify_flags();
    CC = (((((((((((((E<<1) | F)<<1) | H)<<1) |I)<<1) | N)<<1) | Z)<<1) | V)<<1) | C; // Placeholder for now
    restore_flags();
    --S;
    wr_mem(S, CC); 
    clockticks = clockticks + 1; 
    PC = (rd_mem(0xfffa)<<8)|rd_mem(0xfffb); 
    JUMP;
  case 0xA861:
LA861:
                                                     #ifdef DEBUG
                                      mon("LA861    LDX   <$A8                    ; A861: 9E A8         \n");
                                      #endif // Fireball data pointer
    PC = 0xa861; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xa8)<<8; 
    ea = ea | rd_mem(DP|0xa9); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LEAX  $06,X                   ; A863: 30 06         \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + 0x0006); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$496F                  ; A865: 8C 49 6F      \n");
                                      #endif // 6x Fireball data structure 2 ($6 bytes per fireball)
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x496f; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LA84C                   ; A868: 25 E2         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LA84C;
    }
    // End of function sub_A849
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; A86A: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xA86B:
LA86B:
                                                     #ifdef DEBUG
                                      mon("LA86B    DEC   $05,X                   ; A86B: 6A 05         \n");
                                      #endif
    PC = 0xa86b; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0005)); 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    wr_mem((UINT16)(X + 0x0005), res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BGT   locret_A874             ; A86D: 2E 05         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto LA874;
    }
                                                     #ifdef DEBUG
                                      mon("         CLRB                          ; A86F: 5F            \n");
                                      #endif
    B = 0; // SEARCH_ME
 // V = 0; 
 // Z = 0; 
 // N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STB   $03,X                   ; A870: E7 03         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0003); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STB   $05,X                   ; A872: E7 05         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = B; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = (UINT16)(X + 0x0005); 
    wr_mem(ea, val); 
    // End of function sub_A86B
  case 0xA874:
LA874:
locret_A874:
                                                     #ifdef DEBUG
                                      mon("locret_A874 RTS                           ; A874: 39            \n");
                                      #endif
    PC = 0xa874; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xA875:
LA875:
                                                     #ifdef DEBUG
                                      mon("LA875    DEC   $05,X                   ; A875: 6A 05         \n");
                                      #endif
    PC = 0xa875; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0005)); 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    wr_mem((UINT16)(X + 0x0005), res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BGT   LA880                   ; A877: 2E 07         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto LA880;
    }
                                                     #ifdef DEBUG
                                      mon("         CLRB                          ; A879: 5F            \n");
                                      #endif
    B = 0; // SEARCH_ME
 // V = 0; 
 // Z = 0; 
 // N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STB   $03,X                   ; A87A: E7 03         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0003); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STB   $05,X                   ; A87C: E7 05         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = B; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = (UINT16)(X + 0x0005); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         BRA   locret_A8A6             ; A87E: 20 26         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LA8A6;
    
    // ---------------------------------------------------------------------------
  case 0xA880:
LA880:
                                                     #ifdef DEBUG
                                      mon("LA880    LDU   ,X                      ; A880: EE 84         \n");
                                      #endif
    PC = 0xa880; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; A882: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  ,U                      ; A885: A3 C4         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(U)<<8; 
    ea = ea | rd_mem((UINT16)((U)+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_3             ; A887: BD CD A2      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x8a); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa8); 
    clockticks = clockticks + 1; 
    goto LCDA2;
  case 0xA88A:
LA88A:
                                                     #ifdef DEBUG
                                      mon("LA88A    ADDD  ,U                      ; A88A: E3 C4         \n");
                                      #endif
    PC = 0xa88a; 
    INSTRUCTION_START
    clockticks = clockticks + 1; 
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(U)<<8; 
    ea = ea | rd_mem((UINT16)((U)+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,U                      ; A88C: ED C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; A88E: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $02,U                   ; A891: A3 42         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0002))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0002))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_3             ; A893: BD CD A2      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x96); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa8); 
    clockticks = clockticks + 1; 
    goto LCDA2;
  case 0xA896:
LA896:
                                                     #ifdef DEBUG
                                      mon("LA896    ADDD  $02,U                   ; A896: E3 42         \n");
                                      #endif
    PC = 0xa896; 
    INSTRUCTION_START
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0002))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0002))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $02,U                   ; A898: ED 42         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0x0002); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; A89A: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $04,U                   ; A89D: A3 44         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0004))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0004))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_3             ; A89F: BD CD A2      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xa2); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa8); 
    clockticks = clockticks + 1; 
    goto LCDA2;
  case 0xA8A2:
LA8A2:
                                                     #ifdef DEBUG
                                      mon("LA8A2    ADDD  $04,U                   ; A8A2: E3 44         \n");
                                      #endif
    PC = 0xa8a2; 
    INSTRUCTION_START
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0004))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0004))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $04,U                   ; A8A4: ED 44         \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = (UINT16)(U + 0x0004); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    // End of function sub_A875
  case 0xA8A6:
LA8A6:
locret_A8A6:
                                                     #ifdef DEBUG
                                      mon("locret_A8A6 RTS                           ; A8A6: 39            \n");
                                      #endif
    PC = 0xa8a6; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xA8A7:
LA8A7:
                                                     #ifdef DEBUG
                                      mon("LA8A7    DEC   $05,X                   ; A8A7: 6A 05         \n");
                                      #endif
    PC = 0xa8a7; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0005)); 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    wr_mem((UINT16)(X + 0x0005), res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BGT   LA8B2                   ; A8A9: 2E 07         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto LA8B2;
    }
                                                     #ifdef DEBUG
                                      mon("         CLRB                          ; A8AB: 5F            \n");
                                      #endif
    B = 0; // SEARCH_ME
 // V = 0; 
 // Z = 0; 
 // N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STB   $03,X                   ; A8AC: E7 03         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0003); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STB   $05,X                   ; A8AE: E7 05         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = B; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = (UINT16)(X + 0x0005); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         BRA   locret_A8D5             ; A8B0: 20 23         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LA8D5;
    
    // ---------------------------------------------------------------------------
  case 0xA8B2:
LA8B2:
                                                     #ifdef DEBUG
                                      mon("LA8B2    LDU   ,X                      ; A8B2: EE 84         \n");
                                      #endif
    PC = 0xa8b2; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   ,U                      ; A8B4: EC C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(U); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(U+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_3             ; A8B6: BD CD A2      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xb9); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa8); 
    clockticks = clockticks + 1; 
    goto LCDA2;
  case 0xA8B9:
LA8B9:
                                                     #ifdef DEBUG
                                      mon("LA8B9    ADDD  ,U                      ; A8B9: E3 C4         \n");
                                      #endif
    PC = 0xa8b9; 
    INSTRUCTION_START
    clockticks = clockticks + 1; 
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(U)<<8; 
    ea = ea | rd_mem((UINT16)((U)+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ res) & (val ^ res)) >> 8; 
    N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BVS   LA8D6                   ; A8BB: 29 19         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)V <  0) {
    clockticks = clockticks + 3; 
    goto LA8D6;
    }
                                                     #ifdef DEBUG
                                      mon("         STD   ,U                      ; A8BD: ED C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $02,U                   ; A8BF: EC 42         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0x0002); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_3             ; A8C1: BD CD A2      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xc4); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa8); 
    clockticks = clockticks + 1; 
    goto LCDA2;
  case 0xA8C4:
LA8C4:
                                                     #ifdef DEBUG
                                      mon("LA8C4    ADDD  $02,U                   ; A8C4: E3 42         \n");
                                      #endif
    PC = 0xa8c4; 
    INSTRUCTION_START
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0002))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0002))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ res) & (val ^ res)) >> 8; 
    N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BVS   LA8D6                   ; A8C6: 29 0E         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)V <  0) {
    clockticks = clockticks + 3; 
    goto LA8D6;
    }
                                                     #ifdef DEBUG
                                      mon("         STD   $02,U                   ; A8C8: ED 42         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0x0002); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $04,U                   ; A8CA: EC 44         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0x0004); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_3             ; A8CC: BD CD A2      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xcf); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa8); 
    clockticks = clockticks + 1; 
    goto LCDA2;
  case 0xA8CF:
LA8CF:
                                                     #ifdef DEBUG
                                      mon("LA8CF    ADDD  $04,U                   ; A8CF: E3 44         \n");
                                      #endif
    PC = 0xa8cf; 
    INSTRUCTION_START
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0004))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0004))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ res) & (val ^ res)) >> 8; 
    N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BVS   LA8D6                   ; A8D1: 29 03         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)V <  0) {
    clockticks = clockticks + 3; 
    goto LA8D6;
    }
                                                     #ifdef DEBUG
                                      mon("         STD   $04,U                   ; A8D3: ED 44         \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = (UINT16)(U + 0x0004); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
  case 0xA8D5:
LA8D5:
locret_A8D5:
                                                     #ifdef DEBUG
                                      mon("locret_A8D5 RTS                           ; A8D5: 39            \n");
                                      #endif
    PC = 0xa8d5; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
  case 0xA8D6:
LA8D6:
                                                     #ifdef DEBUG
                                      mon("LA8D6    CLRB                          ; A8D6: 5F            \n");
                                      #endif
    PC = 0xa8d6; 
    INSTRUCTION_START
    B = 0; // SEARCH_ME
 // V = 0; 
 // Z = 0; 
 // N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STB   $03,X                   ; A8D7: E7 03         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = B; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = (UINT16)(X + 0x0003); 
    wr_mem(ea, val); 
    // End of function sub_A8A7
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; A8D9: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Some towers processing
  case 0xA8DA:
LA8DA:
                                                     #ifdef DEBUG
                                      mon("LA8DA    LDU   ,X                      ; A8DA: EE 84         \n");
                                      #endif
    PC = 0xa8da; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$FF00                  ; A8DC: CC FF 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xff; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  ,U                      ; A8DF: E3 C4         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(U)<<8; 
    ea = ea | rd_mem((UINT16)((U)+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,U                      ; A8E1: ED C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = U; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         JMP   LAA7D                   ; A8E3: 7E AA 7D      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LAA7D;
    
    // ---------------------------------------------------------------------------
  case 0xA8E6:
LA8E6:
                                                     #ifdef DEBUG
                                      mon("LA8E6    LDU   ,X                      ; A8E6: EE 84         \n");
                                      #endif
    PC = 0xa8e6; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$FF00                  ; A8E8: CC FF 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xff; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  ,U                      ; A8EB: E3 C4         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(U)<<8; 
    ea = ea | rd_mem((UINT16)((U)+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,U                      ; A8ED: ED C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$FF00                  ; A8EF: CC FF 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xff; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $02,U                   ; A8F2: E3 42         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0002))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0002))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $02,U                   ; A8F4: ED 42         \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = (UINT16)(U + 0x0002); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         JMP   LAA7D                   ; A8F6: 7E AA 7D      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LAA7D;
    
    // ---------------------------------------------------------------------------
  case 0xA8F9:
LA8F9:
                                                     #ifdef DEBUG
                                      mon("LA8F9    LDU   ,X                      ; A8F9: EE 84         \n");
                                      #endif
    PC = 0xa8f9; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$FF00                  ; A8FB: CC FF 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xff; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  ,U                      ; A8FE: E3 C4         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(U)<<8; 
    ea = ea | rd_mem((UINT16)((U)+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,U                      ; A900: ED C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0100                  ; A902: CC 01 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x01; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $02,U                   ; A905: E3 42         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0002))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0002))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $02,U                   ; A907: ED 42         \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = (UINT16)(U + 0x0002); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         JMP   LAA7D                   ; A909: 7E AA 7D      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LAA7D;
    
    // ---------------------------------------------------------------------------
  case 0xA90C:
LA90C:
                                                     #ifdef DEBUG
                                      mon("LA90C    LDB   ,U                      ; A90C: E6 C4         \n");
                                      #endif
    PC = 0xa90c; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(U); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBB  $5098                   ; A90E: F0 50 98      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)B; 
    arg = rd_mem(0x5098); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
    B = (UINT8)(res); 
                                                     #ifdef DEBUG
                                      mon("         BMI   locret_A91F             ; A911: 2B 0C         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LA91F;
    }
                                                     #ifdef DEBUG
                                      mon("         CLRA                          ; A913: 4F            \n");
                                      #endif
    A = 0; // SEARCH_ME
 // V = 0; 
 // Z = 0; 
 // N = 0; 
 // C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_L_2             ; A914: BD CD B5      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x17); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa9); 
    clockticks = clockticks + 1; 
    goto LCDB5;
  case 0xA917:
LA917:
                                                     #ifdef DEBUG
                                      mon("LA917    COMA                          ; A917: 43            \n");
                                      #endif
    PC = 0xa917; 
    INSTRUCTION_START
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; A918: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SBCA  #$FF                    ; A919: 82 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xff; 
    res = val - (UINT8)arg - (C != 0 ? 1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  ,U                      ; A91B: E3 C4         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(U)<<8; 
    ea = ea | rd_mem((UINT16)((U)+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,U                      ; A91D: ED C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = U; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
  case 0xA91F:
LA91F:
locret_A91F:
                                                     #ifdef DEBUG
                                      mon("locret_A91F RTS                           ; A91F: 39            \n");
                                      #endif
    PC = 0xa91f; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
  case 0xA920:
LA920:
                                                     #ifdef DEBUG
                                      mon("LA920    LDD   #$00                    ; A920: CC 00 00      \n");
                                      #endif
    PC = 0xa920; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $508E                   ; A923: B3 50 8E      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x508e)<<8; 
    ea = ea | rd_mem(0x508f); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_3             ; A926: BD CD A2      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x29); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa9); 
    clockticks = clockticks + 1; 
    goto LCDA2;
  case 0xA929:
LA929:
                                                     #ifdef DEBUG
                                      mon("LA929    ADDD  $508E                   ; A929: F3 50 8E      \n");
                                      #endif
    PC = 0xa929; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x508e)<<8; 
    ea = ea | rd_mem(0x508f); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ res) & (val ^ res)) >> 8; 
    N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BPL   locret_A932             ; A92C: 2A 04         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LA932;
    }
                                                     #ifdef DEBUG
                                      mon("         ADDD  $02,U                   ; A92E: E3 42         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0002))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0002))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $02,U                   ; A930: ED 42         \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = (UINT16)(U + 0x0002); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
  case 0xA932:
LA932:
locret_A932:
                                                     #ifdef DEBUG
                                      mon("locret_A932 RTS                           ; A932: 39            \n");
                                      #endif
    PC = 0xa932; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
  case 0xA933:
LA933:
                                                     #ifdef DEBUG
                                      mon("LA933    LDD   #$00                    ; A933: CC 00 00      \n");
                                      #endif
    PC = 0xa933; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $508E                   ; A936: B3 50 8E      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x508e)<<8; 
    ea = ea | rd_mem(0x508f); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_3             ; A939: BD CD A2      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x3c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa9); 
    clockticks = clockticks + 1; 
    goto LCDA2;
  case 0xA93C:
LA93C:
                                                     #ifdef DEBUG
                                      mon("LA93C    ADDD  $508E                   ; A93C: F3 50 8E      \n");
                                      #endif
    PC = 0xa93c; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x508e)<<8; 
    ea = ea | rd_mem(0x508f); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ res) & (val ^ res)) >> 8; 
    N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BMI   locret_A945             ; A93F: 2B 04         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LA945;
    }
                                                     #ifdef DEBUG
                                      mon("         ADDD  $02,U                   ; A941: E3 42         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0002))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0002))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $02,U                   ; A943: ED 42         \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = (UINT16)(U + 0x0002); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
  case 0xA945:
LA945:
locret_A945:
                                                     #ifdef DEBUG
                                      mon("locret_A945 RTS                           ; A945: 39            \n");
                                      #endif
    PC = 0xa945; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
  case 0xA946:
LA946:
                                                     #ifdef DEBUG
                                      mon("LA946    LDU   ,X                      ; A946: EE 84         \n");
                                      #endif
    PC = 0xa946; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LA933                   ; A948: BD A9 33      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x4b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa9); 
    clockticks = clockticks + 1; 
    goto LA933;
  case 0xA94B:
LA94B:
                                                     #ifdef DEBUG
                                      mon("LA94B    JSR   LA90C                   ; A94B: BD A9 0C      \n");
                                      #endif
    PC = 0xa94b; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x4e); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa9); 
    clockticks = clockticks + 1; 
    goto LA90C;
  case 0xA94E:
LA94E:
                                                     #ifdef DEBUG
                                      mon("LA94E    LDD   ,U                      ; A94E: EC C4         \n");
                                      #endif
    PC = 0xa94e; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(U); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(U+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5098                   ; A950: B3 50 98      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5098)<<8; 
    ea = ea | rd_mem(0x5099); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $07,U                   ; A953: E6 47         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(U + 0x0007)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         MUL                           ; A955: 3D            \n");
                                      #endif
    res = (UINT16)(A * B); 
 // Z = res; 
    C = res & 0x80; 
    A = res >> 8; 
    B = (UINT8)res; 
    clockticks = clockticks + 11; 
                                                     #ifdef DEBUG
                                      mon("         TST   $06,U                   ; A956: 6D 46         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(U + 0x0006)); 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LA95E                   ; A958: 26 04         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LA95E;
    }
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; A95A: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; A95B: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SBCA  #$FF                    ; A95C: 82 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xff; 
    res = val - (UINT8)arg - (C != 0 ? 1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)res; 
  case 0xA95E:
LA95E:
                                                     #ifdef DEBUG
                                      mon("LA95E    ADDD  $509A                   ; A95E: F3 50 9A      \n");
                                      #endif
    PC = 0xa95e; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x509a)<<8; 
    ea = ea | rd_mem(0x509b); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $02,U                   ; A961: A3 42         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0002))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0002))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$0100                  ; A963: C3 01 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0100; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ res) & (val ^ res)) >> 8; 
    N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BMI   LA978                   ; A966: 2B 10         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LA978;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_3             ; A968: BD CD A2      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x6b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa9); 
    clockticks = clockticks + 1; 
    goto LCDA2;
  case 0xA96B:
LA96B:
                                                     #ifdef DEBUG
                                      mon("LA96B    CMPD  #$0180                  ; A96B: 10 83 01 80   \n");
                                      #endif
    PC = 0xa96b; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x0180; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BLE   LA974                   ; A96F: 2F 03         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto LA974;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0180                  ; A971: CC 01 80      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x01; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0xA974:
LA974:
                                                     #ifdef DEBUG
                                      mon("LA974    ADDD  $02,U                   ; A974: E3 42         \n");
                                      #endif
    PC = 0xa974; 
    INSTRUCTION_START
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0002))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0002))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ res) & (val ^ res)) >> 8; 
    N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LA986                   ; A976: 20 0E         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LA986;
    
    // ---------------------------------------------------------------------------
  case 0xA978:
LA978:
                                                     #ifdef DEBUG
                                      mon("LA978    JSR   Shift_D_R_5             ; A978: BD CD 9E      \n");
                                      #endif // Shift D register right
    PC = 0xa978; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x7b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa9); 
    clockticks = clockticks + 1; 
    goto LCD9E;
  case 0xA97B:
LA97B:
                                                     #ifdef DEBUG
                                      mon("LA97B    CMPD  #$FE80                  ; A97B: 10 83 FE 80   \n");
                                      #endif
    PC = 0xa97b; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0xfe80; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BGE   LA984                   ; A97F: 2C 03         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) >= 0) {
    clockticks = clockticks + 3; 
    goto LA984;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$FE80                  ; A981: CC FE 80      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xfe; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0xA984:
LA984:
                                                     #ifdef DEBUG
                                      mon("LA984    ADDD  $02,U                   ; A984: E3 42         \n");
                                      #endif
    PC = 0xa984; 
    INSTRUCTION_START
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0002))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0002))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
  case 0xA986:
LA986:
                                                     #ifdef DEBUG
                                      mon("LA986    STD   $02,U                   ; A986: ED 42         \n");
                                      #endif
    PC = 0xa986; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0x0002); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $509C                   ; A988: FC 50 9C      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x509c); // Care needed with I/O space and word fetches
    B = rd_mem(0x509d); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$0100                  ; A98B: C3 01 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0100; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $04,U                   ; A98E: A3 44         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0004))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0004))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BMI   locret_A9A2             ; A990: 2B 10         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LA9A2;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_3             ; A992: BD CD A2      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x95); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa9); 
    clockticks = clockticks + 1; 
    goto LCDA2;
  case 0xA995:
LA995:
                                                     #ifdef DEBUG
                                      mon("LA995    CMPD  #$0200                  ; A995: 10 83 02 00   \n");
                                      #endif
    PC = 0xa995; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x0200; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BLE   LA99E                   ; A999: 2F 03         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto LA99E;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0200                  ; A99B: CC 02 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x02; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0xA99E:
LA99E:
                                                     #ifdef DEBUG
                                      mon("LA99E    ADDD  $04,U                   ; A99E: E3 44         \n");
                                      #endif
    PC = 0xa99e; 
    INSTRUCTION_START
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0004))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0004))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $04,U                   ; A9A0: ED 44         \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = (UINT16)(U + 0x0004); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
  case 0xA9A2:
LA9A2:
locret_A9A2:
                                                     #ifdef DEBUG
                                      mon("locret_A9A2 RTS                           ; A9A2: 39            \n");
                                      #endif
    PC = 0xa9a2; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
  case 0xA9A3:
LA9A3:
                                                     #ifdef DEBUG
                                      mon("LA9A3    LDU   ,X                      ; A9A3: EE 84         \n");
                                      #endif
    PC = 0xa9a3; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LA920                   ; A9A5: BD A9 20      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xa8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa9); 
    clockticks = clockticks + 1; 
    goto LA920;
  case 0xA9A8:
LA9A8:
                                                     #ifdef DEBUG
                                      mon("LA9A8    JSR   LA90C                   ; A9A8: BD A9 0C      \n");
                                      #endif
    PC = 0xa9a8; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xab); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa9); 
    clockticks = clockticks + 1; 
    goto LA90C;
  case 0xA9AB:
LA9AB:
                                                     #ifdef DEBUG
                                      mon("LA9AB    LDD   ,U                      ; A9AB: EC C4         \n");
                                      #endif
    PC = 0xa9ab; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(U); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(U+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5098                   ; A9AD: B3 50 98      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5098)<<8; 
    ea = ea | rd_mem(0x5099); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $07,U                   ; A9B0: E6 47         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(U + 0x0007)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         MUL                           ; A9B2: 3D            \n");
                                      #endif
    res = (UINT16)(A * B); 
 // Z = res; 
    C = res & 0x80; 
    A = res >> 8; 
    B = (UINT8)res; 
    clockticks = clockticks + 11; 
                                                     #ifdef DEBUG
                                      mon("         TST   $06,U                   ; A9B3: 6D 46         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(U + 0x0006)); 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LA9BB                   ; A9B5: 27 04         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LA9BB;
    }
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; A9B7: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; A9B8: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SBCA  #$FF                    ; A9B9: 82 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xff; 
    res = val - (UINT8)arg - (C != 0 ? 1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)res; 
  case 0xA9BB:
LA9BB:
                                                     #ifdef DEBUG
                                      mon("LA9BB    ADDD  $509A                   ; A9BB: F3 50 9A      \n");
                                      #endif
    PC = 0xa9bb; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x509a)<<8; 
    ea = ea | rd_mem(0x509b); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$FF00                  ; A9BE: C3 FF 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0xff00; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $02,U                   ; A9C1: A3 42         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0002))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0002))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BMI   LA9D5                   ; A9C3: 2B 10         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LA9D5;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_5             ; A9C5: BD CD 9E      \n");
                                      #endif // Shift D register right
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xc8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa9); 
    clockticks = clockticks + 1; 
    goto LCD9E;
  case 0xA9C8:
LA9C8:
                                                     #ifdef DEBUG
                                      mon("LA9C8    CMPD  #$0180                  ; A9C8: 10 83 01 80   \n");
                                      #endif
    PC = 0xa9c8; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x0180; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BLE   LA9D1                   ; A9CC: 2F 03         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto LA9D1;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0180                  ; A9CE: CC 01 80      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x01; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0xA9D1:
LA9D1:
                                                     #ifdef DEBUG
                                      mon("LA9D1    ADDD  $02,U                   ; A9D1: E3 42         \n");
                                      #endif
    PC = 0xa9d1; 
    INSTRUCTION_START
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0002))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0002))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ res) & (val ^ res)) >> 8; 
    N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LA9E3                   ; A9D3: 20 0E         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LA9E3;
    
    // ---------------------------------------------------------------------------
  case 0xA9D5:
LA9D5:
                                                     #ifdef DEBUG
                                      mon("LA9D5    JSR   Shift_D_R_3             ; A9D5: BD CD A2      \n");
                                      #endif
    PC = 0xa9d5; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xd8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa9); 
    clockticks = clockticks + 1; 
    goto LCDA2;
  case 0xA9D8:
LA9D8:
                                                     #ifdef DEBUG
                                      mon("LA9D8    CMPD  #$FE80                  ; A9D8: 10 83 FE 80   \n");
                                      #endif
    PC = 0xa9d8; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0xfe80; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BGE   LA9E1                   ; A9DC: 2C 03         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) >= 0) {
    clockticks = clockticks + 3; 
    goto LA9E1;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$FE80                  ; A9DE: CC FE 80      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xfe; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0xA9E1:
LA9E1:
                                                     #ifdef DEBUG
                                      mon("LA9E1    ADDD  $02,U                   ; A9E1: E3 42         \n");
                                      #endif
    PC = 0xa9e1; 
    INSTRUCTION_START
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0002))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0002))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
  case 0xA9E3:
LA9E3:
                                                     #ifdef DEBUG
                                      mon("LA9E3    STD   $02,U                   ; A9E3: ED 42         \n");
                                      #endif
    PC = 0xa9e3; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0x0002); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $509C                   ; A9E5: FC 50 9C      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x509c); // Care needed with I/O space and word fetches
    B = rd_mem(0x509d); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$0100                  ; A9E8: C3 01 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0100; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $04,U                   ; A9EB: A3 44         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0004))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0004))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BMI   locret_A9FF             ; A9ED: 2B 10         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LA9FF;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_3             ; A9EF: BD CD A2      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf2); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xa9); 
    clockticks = clockticks + 1; 
    goto LCDA2;
  case 0xA9F2:
LA9F2:
                                                     #ifdef DEBUG
                                      mon("LA9F2    CMPD  #$0200                  ; A9F2: 10 83 02 00   \n");
                                      #endif
    PC = 0xa9f2; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x0200; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BLE   LA9FB                   ; A9F6: 2F 03         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto LA9FB;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0200                  ; A9F8: CC 02 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x02; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0xA9FB:
LA9FB:
                                                     #ifdef DEBUG
                                      mon("LA9FB    ADDD  $04,U                   ; A9FB: E3 44         \n");
                                      #endif
    PC = 0xa9fb; 
    INSTRUCTION_START
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0004))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0004))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $04,U                   ; A9FD: ED 44         \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = (UINT16)(U + 0x0004); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
  case 0xA9FF:
LA9FF:
locret_A9FF:
                                                     #ifdef DEBUG
                                      mon("locret_A9FF RTS                           ; A9FF: 39            \n");
                                      #endif
    PC = 0xa9ff; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
  case 0xAA00:
LAA00:
                                                     #ifdef DEBUG
                                      mon("LAA00    LDU   ,X                      ; AA00: EE 84         \n");
                                      #endif
    PC = 0xaa00; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$FF00                  ; AA02: CC FF 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xff; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  ,U                      ; AA05: E3 C4         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(U)<<8; 
    ea = ea | rd_mem((UINT16)((U)+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,U                      ; AA07: ED C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $509C                   ; AA09: FC 50 9C      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x509c); // Care needed with I/O space and word fetches
    B = rd_mem(0x509d); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$80                    ; AA0C: C3 00 80      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0080; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $04,U                   ; AA0F: A3 44         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0004))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0004))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BMI   LAA23                   ; AA11: 2B 10         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LAA23;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_3             ; AA13: BD CD A2      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x16); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xaa); 
    clockticks = clockticks + 1; 
    goto LCDA2;
  case 0xAA16:
LAA16:
                                                     #ifdef DEBUG
                                      mon("LAA16    CMPD  #$0180                  ; AA16: 10 83 01 80   \n");
                                      #endif
    PC = 0xaa16; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x0180; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BLE   LAA1F                   ; AA1A: 2F 03         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto LAA1F;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0180                  ; AA1C: CC 01 80      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x01; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0xAA1F:
LAA1F:
                                                     #ifdef DEBUG
                                      mon("LAA1F    ADDD  $04,U                   ; AA1F: E3 44         \n");
                                      #endif
    PC = 0xaa1f; 
    INSTRUCTION_START
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0004))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0004))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $04,U                   ; AA21: ED 44         \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = (UINT16)(U + 0x0004); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    // ---------------------------------------------------------------------------
  case 0xAA23:
LAA23:
                                                     #ifdef DEBUG
                                      mon("LAA23    BRA   LAA7D                   ; AA23: 20 58         \n");
                                      #endif
    PC = 0xaa23; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto LAA7D;
    
    // ---------------------------------------------------------------------------
  case 0xAA7D:
LAA7D:
                                                     #ifdef DEBUG
                                      mon("LAA7D    LDA   $03,X                   ; AA7D: A6 03         \n");
                                      #endif
    PC = 0xaa7d; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0003)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BITA  #$02                    ; AA7F: 85 02         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A & (SINT8)0x02; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   locret_AA85             ; AA81: 27 02         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LAA85;
    }
                                                     #ifdef DEBUG
                                      mon("         CLR   $03,X                   ; AA83: 6F 03         \n");
                                      #endif
    clockticks = clockticks + 5; 
    wr_mem((UINT16)(X + 0x0003), 0); 
    V = 0; 
    Z = 0; 
    N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
    // End of function sub_A8DA
  case 0xAA85:
LAA85:
locret_AA85:
                                                     #ifdef DEBUG
                                      mon("locret_AA85 RTS                           ; AA85: 39            \n");
                                      #endif
    PC = 0xaa85; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Exhaust port processing
  case 0xAA86:
LAA86:
                                                     #ifdef DEBUG
                                      mon("LAA86    LDU   ,X                      ; AA86: EE 84         \n");
                                      #endif
    PC = 0xaa86; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LA90C                   ; AA88: BD A9 0C      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x8b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xaa); 
    clockticks = clockticks + 1; 
    goto LA90C;
  case 0xAA8B:
LAA8B:
                                                     #ifdef DEBUG
                                      mon("LAA8B    LDD   $509C                   ; AA8B: FC 50 9C      \n");
                                      #endif
    PC = 0xaa8b; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x509c); // Care needed with I/O space and word fetches
    B = rd_mem(0x509d); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $04,U                   ; AA8E: A3 44         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0004))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0004))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BMI   LAA99                   ; AA90: 2B 07         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LAA99;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_4             ; AA92: BD CD A0      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x95); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xaa); 
    clockticks = clockticks + 1; 
    goto LCDA0;
  case 0xAA95:
LAA95:
                                                     #ifdef DEBUG
                                      mon("LAA95    ADDD  $04,U                   ; AA95: E3 44         \n");
                                      #endif
    PC = 0xaa95; 
    INSTRUCTION_START
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0004))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0004))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $04,U                   ; AA97: ED 44         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0x0004); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
  case 0xAA99:
LAA99:
                                                     #ifdef DEBUG
                                      mon("LAA99    LDA   $4B19                   ; AA99: B6 4B 19      \n");
                                      #endif
    PC = 0xaa99; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b19); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$01                    ; AA9C: 81 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x01; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   LAAA5                   ; AA9E: 25 05         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LAAA5;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $509A                   ; AAA0: FC 50 9A      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x509a); // Care needed with I/O space and word fetches
    B = rd_mem(0x509b); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LAAA8                   ; AAA3: 20 03         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LAAA8;
    
    // ---------------------------------------------------------------------------
  case 0xAAA5:
LAAA5:
                                                     #ifdef DEBUG
                                      mon("LAAA5    LDD   #$FE80                  ; AAA5: CC FE 80      \n");
                                      #endif
    PC = 0xaaa5; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0xfe; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0xAAA8:
LAAA8:
                                                     #ifdef DEBUG
                                      mon("LAAA8    SUBD  $02,U                   ; AAA8: A3 42         \n");
                                      #endif
    PC = 0xaaa8; 
    INSTRUCTION_START
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0002))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0002))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BMI   LAAB3                   ; AAAA: 2B 07         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LAAB3;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_4             ; AAAC: BD CD A0      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xaf); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xaa); 
    clockticks = clockticks + 1; 
    goto LCDA0;
  case 0xAAAF:
LAAAF:
                                                     #ifdef DEBUG
                                      mon("LAAAF    ADDD  $02,U                   ; AAAF: E3 42         \n");
                                      #endif
    PC = 0xaaaf; 
    INSTRUCTION_START
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0002))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0002))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $02,U                   ; AAB1: ED 42         \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = (UINT16)(U + 0x0002); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    // End of function sub_AA86
  case 0xAAB3:
LAAB3:
                                                     #ifdef DEBUG
                                      mon("LAAB3    BRA   LAA7D                   ; AAB3: 20 C8         \n");
                                      #endif
    PC = 0xaab3; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto LAA7D;
    
    // =============== S U B R O U T I N E =======================================
  case 0xAAB5:
LAAB5:
                                                     #ifdef DEBUG
                                      mon("LAAB5    LDU   ,X                      ; AAB5: EE 84         \n");
                                      #endif
    PC = 0xaab5; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LA90C                   ; AAB7: BD A9 0C      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xba); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xaa); 
    clockticks = clockticks + 1; 
    goto LA90C;
  case 0xAABA:
LAABA:
                                                     #ifdef DEBUG
                                      mon("LAABA    LDD   $509C                   ; AABA: FC 50 9C      \n");
                                      #endif
    PC = 0xaaba; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x509c); // Care needed with I/O space and word fetches
    B = rd_mem(0x509d); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $04,U                   ; AABD: A3 44         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0004))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0004))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BMI   LAAC8                   ; AABF: 2B 07         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LAAC8;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_4             ; AAC1: BD CD A0      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xc4); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xaa); 
    clockticks = clockticks + 1; 
    goto LCDA0;
  case 0xAAC4:
LAAC4:
                                                     #ifdef DEBUG
                                      mon("LAAC4    ADDD  $04,U                   ; AAC4: E3 44         \n");
                                      #endif
    PC = 0xaac4; 
    INSTRUCTION_START
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0004))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0004))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $04,U                   ; AAC6: ED 44         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0x0004); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
  case 0xAAC8:
LAAC8:
                                                     #ifdef DEBUG
                                      mon("LAAC8    LDA   $4B19                   ; AAC8: B6 4B 19      \n");
                                      #endif
    PC = 0xaac8; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b19); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$01                    ; AACB: 81 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x01; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   LAAD4                   ; AACD: 25 05         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LAAD4;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $509A                   ; AACF: FC 50 9A      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x509a); // Care needed with I/O space and word fetches
    B = rd_mem(0x509b); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LAAD7                   ; AAD2: 20 03         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LAAD7;
    
    // ---------------------------------------------------------------------------
  case 0xAAD4:
LAAD4:
                                                     #ifdef DEBUG
                                      mon("LAAD4    LDD   #$0180                  ; AAD4: CC 01 80      \n");
                                      #endif
    PC = 0xaad4; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x01; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0xAAD7:
LAAD7:
                                                     #ifdef DEBUG
                                      mon("LAAD7    SUBD  $02,U                   ; AAD7: A3 42         \n");
                                      #endif
    PC = 0xaad7; 
    INSTRUCTION_START
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0002))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0002))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LAAE2                   ; AAD9: 2A 07         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LAAE2;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_4             ; AADB: BD CD A0      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xde); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xaa); 
    clockticks = clockticks + 1; 
    goto LCDA0;
  case 0xAADE:
LAADE:
                                                     #ifdef DEBUG
                                      mon("LAADE    ADDD  $02,U                   ; AADE: E3 42         \n");
                                      #endif
    PC = 0xaade; 
    INSTRUCTION_START
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0002))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0002))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $02,U                   ; AAE0: ED 42         \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = (UINT16)(U + 0x0002); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    // End of function sub_AAB5
  case 0xAAE2:
LAAE2:
                                                     #ifdef DEBUG
                                      mon("LAAE2    BRA   LAA7D                   ; AAE2: 20 99         \n");
                                      #endif
    PC = 0xaae2; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto LAA7D;
    
    // =============== S U B R O U T I N E =======================================
    // Fireball processing
  case 0xAAE4:
LAAE4:
                                                     #ifdef DEBUG
                                      mon("LAAE4    LDX   #$494B                  ; AAE4: 8E 49 4B      \n");
                                      #endif // 6x Fireball data structure 2 ($6 bytes per fireball)
    PC = 0xaae4; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x494b; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xAAE7:
LAAE7:
                                                     #ifdef DEBUG
                                      mon("LAAE7    STX   <$A8                    ; AAE7: 9F A8         \n");
                                      #endif // Fireball data pointer
    PC = 0xaae7; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = X; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = DP|0xa8; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $03,X                   ; AAE9: A6 03         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0003)); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LBEQ  LAC34                   ; AAEB: 10 27 01 45   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if (!Z) {
    clockticks = clockticks + 1; 
    goto LAC34;
    }
                                                     #ifdef DEBUG
                                      mon("         BITA  #$10                    ; AAEF: 85 10         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A & (SINT8)0x10; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LAAF9                   ; AAF1: 27 06         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LAAF9;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   LACB1                   ; AAF3: BD AC B1      \n");
                                      #endif // Shield lost by fireball animation
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf6); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xaa); 
    clockticks = clockticks + 1; 
    goto LACB1;
  case 0xAAF6:
LAAF6:
                                                     #ifdef DEBUG
                                      mon("LAAF6    JMP   LAC34                   ; AAF6: 7E AC 34      \n");
                                      #endif
    PC = 0xaaf6; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    goto LAC34;
    
    // ---------------------------------------------------------------------------
  case 0xAAF9:
LAAF9:
                                                     #ifdef DEBUG
                                      mon("LAAF9    BITA  #$04                    ; AAF9: 85 04         \n");
                                      #endif
    PC = 0xaaf9; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    res = A & (SINT8)0x04; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LAB11                   ; AAFB: 27 14         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LAB11;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $5098                   ; AAFD: FC 50 98      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x5098); // Care needed with I/O space and word fetches
    B = rd_mem(0x5099); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5040                   ; AB00: FD 50 40      \n");
                                      #endif // XT2
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5040, A); // Care needed with I/O space and word fetches
    wr_mem(0x5041, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $509A                   ; AB03: FC 50 9A      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x509a); // Care needed with I/O space and word fetches
    B = rd_mem(0x509b); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5042                   ; AB06: FD 50 42      \n");
                                      #endif // YT2
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5042, A); // Care needed with I/O space and word fetches
    wr_mem(0x5043, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $509C                   ; AB09: FC 50 9C      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x509c); // Care needed with I/O space and word fetches
    B = rd_mem(0x509d); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5044                   ; AB0C: FD 50 44      \n");
                                      #endif // ZT2
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x5044, A); // Care needed with I/O space and word fetches
    wr_mem(0x5045, B); 
                                                     #ifdef DEBUG
                                      mon("         BRA   LAB1D                   ; AB0F: 20 0C         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LAB1D;
    
    // ---------------------------------------------------------------------------
  case 0xAB11:
LAB11:
                                                     #ifdef DEBUG
                                      mon("LAB11    LDD   #$00                    ; AB11: CC 00 00      \n");
                                      #endif
    PC = 0xab11; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5040                   ; AB14: FD 50 40      \n");
                                      #endif // XT2
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5040, A); // Care needed with I/O space and word fetches
    wr_mem(0x5041, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $5042                   ; AB17: FD 50 42      \n");
                                      #endif // YT2
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5042, A); // Care needed with I/O space and word fetches
    wr_mem(0x5043, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $5044                   ; AB1A: FD 50 44      \n");
                                      #endif // ZT2
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5044, A); // Care needed with I/O space and word fetches
    wr_mem(0x5045, B); 
  case 0xAB1D:
LAB1D:
                                                     #ifdef DEBUG
                                      mon("LAB1D    CLRA                          ; AB1D: 4F            \n");
                                      #endif
    PC = 0xab1d; 
    INSTRUCTION_START
    A = 0; // SEARCH_ME
 // V = 0; 
 // Z = 0; 
 // N = 0; 
 // C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $02,X                   ; AB1E: E6 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0002)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4701                   ; AB20: FD 47 01      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4701, A); // Care needed with I/O space and word fetches
    wr_mem(0x4702, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$67                    ; AB23: 86 67         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x67; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCDBA                   ; AB25: BD CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x28); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xab); 
    clockticks = clockticks + 1; 
    goto LCDBA;
  case 0xAB28:
LAB28:
                                                     #ifdef DEBUG
                                      mon("LAB28    LDD   $5000                   ; AB28: FC 50 00      \n");
                                      #endif // Math result X
    PC = 0xab28; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x5000); // Care needed with I/O space and word fetches
    B = rd_mem(0x5001); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$01                    ; AB2B: 10 83 00 01   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x0001; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         LBLE  LAC27                   ; AB2F: 10 2F 00 F4   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 1; 
    goto LAC27;
    }
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$7F00                  ; AB33: 10 83 7F 00   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x7f00; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         LBHI  LAC27                   ; AB37: 10 22 00 EC   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if (Z && (!C)) {
    clockticks = clockticks + 1; 
    goto LAC27;
    }
                                                     #ifdef DEBUG
                                      mon("         STD   $4704                   ; AB3B: FD 47 04      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4704, A); // Care needed with I/O space and word fetches
    wr_mem(0x4705, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $5018                   ; AB3E: FD 50 18      \n");
                                      #endif // XT
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5018, A); // Care needed with I/O space and word fetches
    wr_mem(0x5019, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $5002                   ; AB41: FC 50 02      \n");
                                      #endif // Math result Y
    clockticks = clockticks + 5; 
    A = rd_mem(0x5002); // Care needed with I/O space and word fetches
    B = rd_mem(0x5003); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $501A                   ; AB44: FD 50 1A      \n");
                                      #endif // YT
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x501a, A); // Care needed with I/O space and word fetches
    wr_mem(0x501b, B); 
                                                     #ifdef DEBUG
                                      mon("         BPL   LAB4D                   ; AB47: 2A 04         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LAB4D;
    }
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; AB49: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; AB4A: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SBCA  #$FF                    ; AB4B: 82 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xff; 
    res = val - (UINT8)arg - (C != 0 ? 1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)res; 
  case 0xAB4D:
LAB4D:
                                                     #ifdef DEBUG
                                      mon("LAB4D    SUBD  $5000                   ; AB4D: B3 50 00      \n");
                                      #endif // Math result X
    PC = 0xab4d; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5000)<<8; 
    ea = ea | rd_mem(0x5001); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         LBCC  LAC27                   ; AB50: 10 24 00 D3   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if (!C) {
    clockticks = clockticks + 1; 
    goto LAC27;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $5004                   ; AB54: FC 50 04      \n");
                                      #endif // Math result Z
    clockticks = clockticks + 5; 
    A = rd_mem(0x5004); // Care needed with I/O space and word fetches
    B = rd_mem(0x5005); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $501C                   ; AB57: FD 50 1C      \n");
                                      #endif // ZT
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x501c, A); // Care needed with I/O space and word fetches
    wr_mem(0x501d, B); 
                                                     #ifdef DEBUG
                                      mon("         BPL   LAB60                   ; AB5A: 2A 04         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LAB60;
    }
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; AB5C: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; AB5D: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SBCA  #$FF                    ; AB5E: 82 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xff; 
    res = val - (UINT8)arg - (C != 0 ? 1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)res; 
  case 0xAB60:
LAB60:
                                                     #ifdef DEBUG
                                      mon("LAB60    SUBD  $5000                   ; AB60: B3 50 00      \n");
                                      #endif // Math result X
    PC = 0xab60; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5000)<<8; 
    ea = ea | rd_mem(0x5001); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         LBCC  LAC27                   ; AB63: 10 24 00 C0   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if (!C) {
    clockticks = clockticks + 1; 
    goto LAC27;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   LCCF0                   ; AB67: BD CC F0      \n");
                                      #endif // Get divider result and multiply by Math result Z, insert VCTR instruction
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x6a); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xab); 
    clockticks = clockticks + 1; 
    goto LCCF0;
  case 0xAB6A:
LAB6A:
                                                     #ifdef DEBUG
                                      mon("LAB6A    LDX   <$A8                    ; AB6A: 9E A8         \n");
                                      #endif // Fireball data pointer
    PC = 0xab6a; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xa8)<<8; 
    ea = ea | rd_mem(DP|0xa9); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $03,X                   ; AB6C: A6 03         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0003)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BITA  #$03                    ; AB6E: 85 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A & (SINT8)0x03; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LABC0                   ; AB70: 27 4E         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LABC0;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$80                    ; AB72: CC 00 80      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5002                   ; AB75: FD 50 02      \n");
                                      #endif // Math result Y
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5002, A); // Care needed with I/O space and word fetches
    wr_mem(0x5003, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$86                    ; AB78: 86 86         \n");
                                      #endif // Reg02 = Reg02 x Reg00
    clockticks = clockticks + 2; 
    val = (UINT8)0x86; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCDBA                   ; AB7A: BD CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x7d); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xab); 
    clockticks = clockticks + 1; 
    goto LCDBA;
  case 0xAB7D:
LAB7D:
                                                     #ifdef DEBUG
                                      mon("LAB7D    LDD   $5002                   ; AB7D: FC 50 02      \n");
                                      #endif // Math result Y
    PC = 0xab7d; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x5002); // Care needed with I/O space and word fetches
    B = rd_mem(0x5003); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$0A                    ; AB80: C3 00 0A      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x000a; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$03                    ; AB83: DD 03         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x03; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$D6                    ; AB85: DC D6         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0xd6); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0xd7); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  <$B3                    ; AB87: 93 B3         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xb3)<<8; 
    ea = ea | rd_mem(DP|0xb4); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LAB8F                   ; AB89: 2A 04         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LAB8F;
    }
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; AB8B: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; AB8C: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SBCA  #$FF                    ; AB8D: 82 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xff; 
    res = val - (UINT8)arg - (C != 0 ? 1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)res; 
  case 0xAB8F:
LAB8F:
                                                     #ifdef DEBUG
                                      mon("LAB8F    STD   <$01                    ; AB8F: DD 01         \n");
                                      #endif
    PC = 0xab8f; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x01; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         SUBD  <$03                    ; AB91: 93 03         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x03)<<8; 
    ea = ea | rd_mem(DP|0x04); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BGT   LABC0                   ; AB93: 2E 2B         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto LABC0;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   <$D8                    ; AB95: DC D8         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0xd8); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0xd9); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  <$B5                    ; AB97: 93 B5         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xb5)<<8; 
    ea = ea | rd_mem(DP|0xb6); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LAB9F                   ; AB99: 2A 04         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LAB9F;
    }
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; AB9B: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; AB9C: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SBCA  #$FF                    ; AB9D: 82 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xff; 
    res = val - (UINT8)arg - (C != 0 ? 1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)res; 
  case 0xAB9F:
LAB9F:
                                                     #ifdef DEBUG
                                      mon("LAB9F    CMPD  <$03                    ; AB9F: 10 93 03      \n");
                                      #endif
    PC = 0xab9f; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x03)<<8; 
    ea = ea | rd_mem(DP|0x04); 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = ea; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
    clockticks = clockticks + 1; 
                                                     #ifdef DEBUG
                                      mon("         BGT   LABC0                   ; ABA2: 2E 1C         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto LABC0;
    }
                                                     #ifdef DEBUG
                                      mon("         ADDD  <$01                    ; ABA4: D3 01         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x01)<<8; 
    ea = ea | rd_mem(DP|0x02); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$01                    ; ABA6: DD 01         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x01; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$03                    ; ABA8: DC 03         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x03); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x04); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; ABAA: 44            \n");
                                      #endif
    val = (UINT8)A; 
    C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         RORB                          ; ABAB: 56            \n");
                                      #endif
    res = ((UINT8)B) | ((C != 0) ? 0x100 : 0); 
 // C = res & 1; 
    res = (UINT8)(res >> 1); 
 // Z = res; 
 // N = res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  <$03                    ; ABAC: D3 03         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x03)<<8; 
    ea = ea | rd_mem(DP|0x04); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  <$01                    ; ABAE: 93 01         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x01)<<8; 
    ea = ea | rd_mem(DP|0x02); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BLT   LABC0                   ; ABB0: 2D 0E         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 3; 
    goto LABC0;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $5018                   ; ABB2: FC 50 18      \n");
                                      #endif // XT
    clockticks = clockticks + 5; 
    A = rd_mem(0x5018); // Care needed with I/O space and word fetches
    B = rd_mem(0x5019); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  <$CC                    ; ABB5: 10 93 CC      \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xcc)<<8; 
    ea = ea | rd_mem(DP|0xcd); 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = ea; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
    clockticks = clockticks + 1; 
                                                     #ifdef DEBUG
                                      mon("         BCC   LABC0                   ; ABB8: 24 06         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LABC0;
    }
                                                     #ifdef DEBUG
                                      mon("         STD   <$CC                    ; ABBA: DD CC         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0xcc; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDX   <$A8                    ; ABBC: 9E A8         \n");
                                      #endif // Fireball data pointer
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xa8)<<8; 
    ea = ea | rd_mem(DP|0xa9); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STX   <$CA                    ; ABBE: 9F CA         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = DP|0xca; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
  case 0xABC0:
LABC0:
                                                     #ifdef DEBUG
                                      mon("LABC0    LDA   $03,X                   ; ABC0: A6 03         \n");
                                      #endif
    PC = 0xabc0; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0003)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BITA  #$01                    ; ABC2: 85 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A & (SINT8)0x01; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LAC22                   ; ABC4: 27 5C         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LAC22;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $5018                   ; ABC6: FC 50 18      \n");
                                      #endif // XT
    clockticks = clockticks + 5; 
    A = rd_mem(0x5018); // Care needed with I/O space and word fetches
    B = rd_mem(0x5019); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; ABC9: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLA                          ; ABCA: 49            \n");
                                      #endif
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BMI   LAC22                   ; ABCB: 2B 55         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LAC22;
    }
                                                     #ifdef DEBUG
                                      mon("         LDU   $5086                   ; ABCD: FE 50 86      \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5086)<<8; 
    ea = ea | rd_mem(0x5087); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPU  #$0200                  ; ABD0: 11 83 02 00   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
    arg = 0x0200; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BLT   LABDB                   ; ABD4: 2D 05         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 3; 
    goto LABDB;
    }
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5086                   ; ABD6: B3 50 86      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5086)<<8; 
    ea = ea | rd_mem(0x5087); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LABDE                   ; ABD9: 20 03         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LABDE;
    
    // ---------------------------------------------------------------------------
  case 0xABDB:
LABDB:
                                                     #ifdef DEBUG
                                      mon("LABDB    SUBD  #$0200                  ; ABDB: 83 02 00      \n");
                                      #endif
    PC = 0xabdb; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = 0x0200; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
  case 0xABDE:
LABDE:
                                                     #ifdef DEBUG
                                      mon("LABDE    BLE   LABE5                   ; ABDE: 2F 05         \n");
                                      #endif
    PC = 0xabde; 
    INSTRUCTION_START
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto LABE5;
    }
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$0110                  ; ABE0: 83 01 10      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0110; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BGT   LAC22                   ; ABE3: 2E 3D         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto LAC22;
    }
  case 0xABE5:
LABE5:
                                                     #ifdef DEBUG
                                      mon("LABE5    LDD   <$D6                    ; ABE5: DC D6         \n");
                                      #endif
    PC = 0xabe5; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0xd6); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0xd7); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BMI   LABF0                   ; ABE7: 2B 07         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LABF0;
    }
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$01C0                  ; ABE9: 83 01 C0      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x01c0; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BGE   LAC22                   ; ABEC: 2C 34         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) >= 0) {
    clockticks = clockticks + 3; 
    goto LAC22;
    }
                                                     #ifdef DEBUG
                                      mon("         BRA   LABF5                   ; ABEE: 20 05         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LABF5;
    
    // ---------------------------------------------------------------------------
  case 0xABF0:
LABF0:
                                                     #ifdef DEBUG
                                      mon("LABF0    SUBD  #$FE40                  ; ABF0: 83 FE 40      \n");
                                      #endif
    PC = 0xabf0; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = 0xfe40; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BLE   LAC22                   ; ABF3: 2F 2D         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto LAC22;
    }
  case 0xABF5:
LABF5:
                                                     #ifdef DEBUG
                                      mon("LABF5    LDD   <$D8                    ; ABF5: DC D8         \n");
                                      #endif
    PC = 0xabf5; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0xd8); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0xd9); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BMI   LAC00                   ; ABF7: 2B 07         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LAC00;
    }
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$01E0                  ; ABF9: 83 01 E0      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x01e0; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BGE   LAC22                   ; ABFC: 2C 24         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) >= 0) {
    clockticks = clockticks + 3; 
    goto LAC22;
    }
                                                     #ifdef DEBUG
                                      mon("         BRA   LAC05                   ; ABFE: 20 05         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LAC05;
    
    // ---------------------------------------------------------------------------
  case 0xAC00:
LAC00:
                                                     #ifdef DEBUG
                                      mon("LAC00    SUBD  #LFE60                  ; AC00: 83 FE 60      \n");
                                      #endif
    PC = 0xac00; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = 0xfe60; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BLE   LAC22                   ; AC03: 2F 1D         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto LAC22;
    }
  case 0xAC05:
LAC05:
                                                     #ifdef DEBUG
                                      mon("LAC05    CPX   <$CA                    ; AC05: 9C CA         \n");
                                      #endif
    PC = 0xac05; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xca)<<8; 
    ea = ea | rd_mem(DP|0xcb); 
    val = X; 
    arg = ea; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LAC14                   ; AC07: 26 0B         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LAC14;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   <$BC                    ; AC09: 96 BC         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xbc); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LAC14                   ; AC0B: 27 07         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LAC14;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   LAD20                   ; AC0D: BD AD 20      \n");
                                      #endif // Fireball destroyed
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x10); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xac); 
    clockticks = clockticks + 1; 
    goto LAD20;
  case 0xAC10:
LAC10:
                                                     #ifdef DEBUG
                                      mon("LAC10    LDX   <$A8                    ; AC10: 9E A8         \n");
                                      #endif // Fireball data pointer
    PC = 0xac10; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xa8)<<8; 
    ea = ea | rd_mem(DP|0xa9); 
    X = ea; 
    Z = X; 
    N = (X) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LAC22                   ; AC12: 20 0E         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LAC22;
    
    // ---------------------------------------------------------------------------
  case 0xAC14:
LAC14:
                                                     #ifdef DEBUG
                                      mon("LAC14    JSR   LACE0                   ; AC14: BD AC E0      \n");
                                      #endif // Shield lost by fireball hit
    PC = 0xac14; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x17); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xac); 
    clockticks = clockticks + 1; 
    goto LACE0;
  case 0xAC17:
LAC17:
                                                     #ifdef DEBUG
                                      mon("LAC17    LDD   #$8040                  ; AC17: CC 80 40      \n");
                                      #endif
    PC = 0xac17; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; AC1A: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LACB1                   ; AC1C: BD AC B1      \n");
                                      #endif // Shield lost by fireball animation
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x1f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xac); 
    clockticks = clockticks + 1; 
    goto LACB1;
  case 0xAC1F:
LAC1F:
                                                     #ifdef DEBUG
                                      mon("LAC1F    JMP   LAC34                   ; AC1F: 7E AC 34      \n");
                                      #endif
    PC = 0xac1f; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    goto LAC34;
    
    // ---------------------------------------------------------------------------
  case 0xAC22:
LAC22:
                                                     #ifdef DEBUG
                                      mon("LAC22    JSR   LAC52                   ; AC22: BD AC 52      \n");
                                      #endif // Fireball animation
    PC = 0xac22; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x25); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xac); 
    clockticks = clockticks + 1; 
    goto LAC52;
  case 0xAC25:
LAC25:
                                                     #ifdef DEBUG
                                      mon("LAC25    BRA   LAC34                   ; AC25: 20 0D         \n");
                                      #endif
    PC = 0xac25; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto LAC34;
    
    // ---------------------------------------------------------------------------
  case 0xAC27:
LAC27:
                                                     #ifdef DEBUG
                                      mon("LAC27    LDA   $03,X                   ; AC27: A6 03         \n");
                                      #endif
    PC = 0xac27; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0003)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BITA  #$01                    ; AC29: 85 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A & (SINT8)0x01; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LAC31                   ; AC2B: 27 04         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LAC31;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; AC2D: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LAC32                   ; AC2F: 20 01         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LAC32;
    
    // ---------------------------------------------------------------------------
  case 0xAC31:
LAC31:
                                                     #ifdef DEBUG
                                      mon("LAC31    CLRA                          ; AC31: 4F            \n");
                                      #endif
    PC = 0xac31; 
    INSTRUCTION_START
    A = 0; // SEARCH_ME
 // V = 0; 
 // Z = 0; 
 // N = 0; 
 // C = 0; 
    clockticks = clockticks + 2; 
  case 0xAC32:
LAC32:
                                                     #ifdef DEBUG
                                      mon("LAC32    STA   $03,X                   ; AC32: A7 03         \n");
                                      #endif
    PC = 0xac32; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0003); 
    wr_mem(ea, val); 
  case 0xAC34:
LAC34:
                                                     #ifdef DEBUG
                                      mon("LAC34    LDX   <$A8                    ; AC34: 9E A8         \n");
                                      #endif // Fireball data pointer
    PC = 0xac34; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xa8)<<8; 
    ea = ea | rd_mem(DP|0xa9); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LEAX  $06,X                   ; AC36: 30 06         \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + 0x0006); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$496F                  ; AC38: 8C 49 6F      \n");
                                      #endif // Check for all 6 fireball slots
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x496f; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         LBCS  LAAE7                   ; AC3B: 10 25 FE A8   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if (C) {
    clockticks = clockticks + 1; 
    goto LAAE7;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $5098                   ; AC3F: FC 50 98      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x5098); // Care needed with I/O space and word fetches
    B = rd_mem(0x5099); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5040                   ; AC42: FD 50 40      \n");
                                      #endif // XT2
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5040, A); // Care needed with I/O space and word fetches
    wr_mem(0x5041, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $509A                   ; AC45: FC 50 9A      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x509a); // Care needed with I/O space and word fetches
    B = rd_mem(0x509b); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5042                   ; AC48: FD 50 42      \n");
                                      #endif // YT2
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5042, A); // Care needed with I/O space and word fetches
    wr_mem(0x5043, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $509C                   ; AC4B: FC 50 9C      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x509c); // Care needed with I/O space and word fetches
    B = rd_mem(0x509d); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5044                   ; AC4E: FD 50 44      \n");
                                      #endif // ZT2
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x5044, A); // Care needed with I/O space and word fetches
    wr_mem(0x5045, B); 
    // End of function sub_AAE4
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; AC51: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Fireball animation
  case 0xAC52:
LAC52:
                                                     #ifdef DEBUG
                                      mon("LAC52    LDX   <$A8                    ; AC52: 9E A8         \n");
                                      #endif // Fireball data pointer
    PC = 0xac52; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xa8)<<8; 
    ea = ea | rd_mem(DP|0xa9); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$08                    ; AC54: 86 08         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x08; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$01                    ; AC56: 97 01         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x01; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $5018                   ; AC58: FC 50 18      \n");
                                      #endif // XT
    clockticks = clockticks + 5; 
    A = rd_mem(0x5018); // Care needed with I/O space and word fetches
    B = rd_mem(0x5019); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0xAC5B:
LAC5B:
                                                     #ifdef DEBUG
                                      mon("LAC5B    DEC   <$01                    ; AC5B: 0A 01         \n");
                                      #endif
    PC = 0xac5b; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x01); 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    wr_mem(DP|0x01, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LAC65                   ; AC5D: 27 06         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LAC65;
    }
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; AC5F: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLA                          ; AC60: 49            \n");
                                      #endif
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LAC5B                   ; AC61: 2A F8         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LAC5B;
    }
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$7F                    ; AC63: 84 7F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x7f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
  case 0xAC65:
LAC65:
                                                     #ifdef DEBUG
                                      mon("LAC65    STA   <$02                    ; AC65: 97 02         \n");
                                      #endif
    PC = 0xac65; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x02; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $03,X                   ; AC67: A6 03         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0003)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$20                    ; AC69: 84 20         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x20; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LAC7C                   ; AC6B: 26 0F         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LAC7C;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   <$01                    ; AC6D: 96 01         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x01); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORA   #$70                    ; AC6F: 8A 70         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A | (UINT8)0x70; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   <$02                    ; AC71: D6 02         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x02); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; AC73: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$A015                  ; AC75: CC A0 15      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xa0; 
    B = 0x15; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; AC78: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LACA6                   ; AC7A: 20 2A         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LACA6;
    
    // ---------------------------------------------------------------------------
  case 0xAC7C:
LAC7C:
                                                     #ifdef DEBUG
                                      mon("LAC7C    LDB   <$02                    ; AC7C: D6 02         \n");
                                      #endif
    PC = 0xac7c; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x02); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$01                    ; AC7E: 96 01         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x01); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         INCA                          ; AC80: 4C            \n");
                                      #endif
    val = (UINT8)A; 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$03                    ; AC81: 81 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x03; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCC   LAC8A                   ; AC83: 24 05         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LAC8A;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$03                    ; AC85: 86 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x03; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CLRB                          ; AC87: 5F            \n");
                                      #endif
    B = 0; // SEARCH_ME
    V = 0; 
    Z = 0; 
    N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LAC91                   ; AC88: 20 07         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LAC91;
    
    // ---------------------------------------------------------------------------
  case 0xAC8A:
LAC8A:
                                                     #ifdef DEBUG
                                      mon("LAC8A    CMPA  #$06                    ; AC8A: 81 06         \n");
                                      #endif
    PC = 0xac8a; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x06; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   LAC91                   ; AC8C: 25 03         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LAC91;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$06                    ; AC8E: 86 06         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x06; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CLRB                          ; AC90: 5F            \n");
                                      #endif
    B = 0; // SEARCH_ME
 // V = 0; 
 // Z = 0; 
 // N = 0; 
 // C = 0; 
    clockticks = clockticks + 2; 
  case 0xAC91:
LAC91:
                                                     #ifdef DEBUG
                                      mon("LAC91    ORA   #$70                    ; AC91: 8A 70         \n");
                                      #endif
    PC = 0xac91; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    res = A | (UINT8)0x70; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; AC93: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $05,X                   ; AC95: E6 05         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0005)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; AC97: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; AC98: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; AC99: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; AC9A: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ORB   #$0F                    ; AC9B: CA 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = B | (UINT8)0x0f; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$65                    ; AC9D: 86 65         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x65; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; AC9F: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$A017                  ; ACA1: CC A0 17      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xa0; 
    B = 0x17; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; ACA4: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
  case 0xACA6:
LACA6:
                                                     #ifdef DEBUG
                                      mon("LACA6    LDD   #$7200                  ; ACA6: CC 72 00      \n");
                                      #endif
    PC = 0xaca6; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x72; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; ACA9: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$8040                  ; ACAB: CC 80 40      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; ACAE: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
    // End of function sub_AC52
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; ACB0: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Shield lost by fireball animation
  case 0xACB1:
LACB1:
                                                     #ifdef DEBUG
                                      mon("LACB1    LDX   <$A8                    ; ACB1: 9E A8         \n");
                                      #endif // Fireball data pointer
    PC = 0xacb1; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xa8)<<8; 
    ea = ea | rd_mem(DP|0xa9); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   ,X                      ; ACB3: EE 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   ,U                      ; ACB5: EC C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(U); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(U+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; ACB7: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   $02,U                   ; ACB9: EC 42         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0x0002); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; ACBB: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $05,X                   ; ACBD: A6 05         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0005)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$10                    ; ACBF: C6 10         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x10; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         MUL                           ; ACC1: 3D            \n");
                                      #endif
    res = (UINT16)(A * B); 
 // Z = res; 
 // C = res & 0x80; 
    A = res >> 8; 
    B = (UINT8)res; 
    clockticks = clockticks + 11; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$70                    ; ACC2: 86 70         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x70; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; ACC4: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $05,X                   ; ACC6: E6 05         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0005)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; ACC8: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; ACC9: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; ACCA: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; ACCB: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$67                    ; ACCC: 86 67         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x67; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; ACCE: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$A017                  ; ACD0: CC A0 17      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xa0; 
    B = 0x17; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; ACD3: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$7200                  ; ACD5: CC 72 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x72; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; ACD8: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$8040                  ; ACDA: CC 80 40      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; ACDD: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
    // End of function sub_ACB1
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; ACDF: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Shield lost by fireball hit
  case 0xACE0:
LACE0:
                                                     #ifdef DEBUG
                                      mon("LACE0    LDU   ,X                      ; ACE0: EE 84         \n");
                                      #endif
    PC = 0xace0; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   -4,Y                    ; ACE2: EC 3C         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(Y + 0xfffc); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,U                      ; ACE4: ED C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   -2,Y                    ; ACE6: EC 3E         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(Y + 0xfffe); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $02,U                   ; ACE8: ED 42         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0x0002); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$10                    ; ACEA: 86 10         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x10; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $03,X                   ; ACEC: A7 03         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0003); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$0F                    ; ACEE: 86 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x0f; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $05,X                   ; ACF0: A7 05         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0005); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; ACF2: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $04,X                   ; ACF4: A7 04         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0004); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   L9874                   ; ACF6: BD 98 74      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf9); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xac); 
    clockticks = clockticks + 1; 
    goto L9874;
  case 0xACF9:
LACF9:
                                                     #ifdef DEBUG
                                      mon("LACF9    LDA   <$63                    ; ACF9: 96 63         \n");
                                      #endif
    PC = 0xacf9; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x63); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LAD00                   ; ACFB: 26 03         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LAD00;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4703                   ; ACFD: B6 47 03      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xAD00:
LAD00:
                                                     #ifdef DEBUG
                                      mon("LAD00    LDB   #$20                    ; AD00: C6 20         \n");
                                      #endif
    PC = 0xad00; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x20; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         TSTA                          ; AD02: 4D            \n");
                                      #endif
    val = (UINT8)A; 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LAD06                   ; AD03: 2A 01         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LAD06;
    }
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; AD05: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
  case 0xAD06:
LAD06:
                                                     #ifdef DEBUG
                                      mon("LAD06    STB   <$63                    ; AD06: D7 63         \n");
                                      #endif
    PC = 0xad06; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x63; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   Sound_33                ; AD08: BD BD F3      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x0b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xad); 
    clockticks = clockticks + 1; 
    goto LBDF3;
  case 0xAD0B:
LAD0B:
                                                     #ifdef DEBUG
                                      mon("LAD0B    LDA   $4B37                   ; AD0B: B6 4B 37      \n");
                                      #endif
    PC = 0xad0b; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b37); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   locret_AD1F             ; AD0E: 26 0F         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LAD1F;
    }
                                                     #ifdef DEBUG
                                      mon("         INC   $4B37                   ; AD10: 7C 4B 37      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b37); 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    wr_mem(0x4b37, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$60                    ; AD13: 96 60         \n");
                                      #endif // Shield count
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x60); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$03                    ; AD15: 81 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x03; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BLS   locret_AD1F             ; AD17: 23 06         \n");
                                      #endif
    // temp hack to force a flush
    if ((!Z) || C) {
    clockticks = clockticks + 3; 
    goto LAD1F;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   Sound_9                 ; AD19: BD BD 21      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x1c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xad); 
    clockticks = clockticks + 1; 
    goto LBD21;
  case 0xAD1C:
LAD1C:
                                                     #ifdef DEBUG
                                      mon("LAD1C    JSR   Sound_31                ; AD1C: BD BD E9      \n");
                                      #endif
    PC = 0xad1c; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x1f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xad); 
    clockticks = clockticks + 1; 
    goto LBDE9;
    // End of function sub_ACE0
  case 0xAD1F:
LAD1F:
locret_AD1F:
                                                     #ifdef DEBUG
                                      mon("locret_AD1F RTS                           ; AD1F: 39            \n");
                                      #endif
    PC = 0xad1f; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Fireball destroyed
  case 0xAD20:
LAD20:
                                                     #ifdef DEBUG
                                      mon("LAD20    LDU   <$CA                    ; AD20: DE CA         \n");
                                      #endif
    PC = 0xad20; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xca)<<8; 
    ea = ea | rd_mem(DP|0xcb); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $03,U                   ; AD22: A6 43         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(U + 0x0003)); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   locret_AD3D             ; AD24: 27 17         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LAD3D;
    }
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$04                    ; AD26: 84 04         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x04; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORA   #$20                    ; AD28: 8A 20         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A | (UINT8)0x20; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $03,U                   ; AD2A: A7 43         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(U + 0x0003); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$0F                    ; AD2C: 86 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x0f; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $05,U                   ; AD2E: A7 45         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(U + 0x0005); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; AD30: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $04,U                   ; AD32: A7 44         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = (UINT16)(U + 0x0004); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   Sound_37                ; AD34: BD BE 07      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x37); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xad); 
    clockticks = clockticks + 1; 
    goto LBE07;
  case 0xAD37:
LAD37:
                                                     #ifdef DEBUG
                                      mon("LAD37    JSR   L9801                   ; AD37: BD 98 01      \n");
                                      #endif // Fireball score
    PC = 0xad37; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x3a); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xad); 
    clockticks = clockticks + 1; 
    goto L9801;
  case 0xAD3A:
LAD3A:
                                                     #ifdef DEBUG
                                      mon("LAD3A    JSR   LBDF8                   ; AD3A: BD BD F8      \n");
                                      #endif
    PC = 0xad3a; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x3d); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xad); 
    clockticks = clockticks + 1; 
    goto LBDF8;
    // End of function sub_AD20
  case 0xAD3D:
LAD3D:
locret_AD3D:
                                                     #ifdef DEBUG
                                      mon("locret_AD3D RTS                           ; AD3D: 39            \n");
                                      #endif
    PC = 0xad3d; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xAD3E:
LAD3E:
                                                     #ifdef DEBUG
                                      mon("LAD3E    LDA   #$01                    ; AD3E: 86 01         \n");
                                      #endif
    PC = 0xad3e; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x01; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$45                    ; AD40: 97 45         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x45; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $5098                   ; AD42: FC 50 98      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x5098); // Care needed with I/O space and word fetches
    B = rd_mem(0x5099); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$0100                  ; AD45: C3 01 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0100; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$46                    ; AD48: DD 46         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x46; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $509A                   ; AD4A: FC 50 9A      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x509a); // Care needed with I/O space and word fetches
    B = rd_mem(0x509b); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$48                    ; AD4D: DD 48         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x48; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $509C                   ; AD4F: FC 50 9C      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x509c); // Care needed with I/O space and word fetches
    B = rd_mem(0x509d); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$4A                    ; AD52: DD 4A         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x4a; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$494B                  ; AD54: 8E 49 4B      \n");
                                      #endif // 6x Fireball data structure 2 ($6 bytes per fireball)
    clockticks = clockticks + 3; 
    X = 0x494b; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xAD57:
LAD57:
                                                     #ifdef DEBUG
                                      mon("LAD57    STX   <$CA                    ; AD57: 9F CA         \n");
                                      #endif
    PC = 0xad57; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = X; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = DP|0xca; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LAD20                   ; AD59: BD AD 20      \n");
                                      #endif // Fireball destroyed
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x5c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xad); 
    clockticks = clockticks + 1; 
    goto LAD20;
  case 0xAD5C:
LAD5C:
                                                     #ifdef DEBUG
                                      mon("LAD5C    LDX   <$CA                    ; AD5C: 9E CA         \n");
                                      #endif
    PC = 0xad5c; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xca)<<8; 
    ea = ea | rd_mem(DP|0xcb); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LEAX  $06,X                   ; AD5E: 30 06         \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + 0x0006); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$496F                  ; AD60: 8C 49 6F      \n");
                                      #endif // 6x Fireball data structure 2 ($6 bytes per fireball)
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x496f; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LAD57                   ; AD63: 25 F2         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LAD57;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   Sound_23                ; AD65: BD BD A3      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x68); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xad); 
    clockticks = clockticks + 1; 
    goto LBDA3;
  case 0xAD68:
LAD68:
                                                     #ifdef DEBUG
                                      mon("LAD68    JSR   LBDD5                   ; AD68: BD BD D5      \n");
                                      #endif
    PC = 0xad68; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x6b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xad); 
    clockticks = clockticks + 1; 
    goto LBDD5;
    // End of function sub_AD3E
  case 0xAD6B:
LAD6B:
                                                     #ifdef DEBUG
                                      mon("LAD6B    RTS                           ; AD6B: 39            \n");
                                      #endif
    PC = 0xad6b; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xAD6C:
LAD6C:
                                                     #ifdef DEBUG
                                      mon("LAD6C    LDA   <$45                    ; AD6C: 96 45         \n");
                                      #endif
    PC = 0xad6c; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x45); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   locret_ADAE             ; AD6E: 27 3E         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LADAE;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   <$46                    ; AD70: DC 46         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x46); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x47); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$0300                  ; AD72: C3 03 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0300; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $5086                   ; AD75: F3 50 86      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5086)<<8; 
    ea = ea | rd_mem(0x5087); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  <$96                    ; AD78: 10 93 96      \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x96)<<8; 
    ea = ea | rd_mem(DP|0x97); 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = ea; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
    clockticks = clockticks + 1; 
                                                     #ifdef DEBUG
                                      mon("         BMI   LAD7F                   ; AD7B: 2B 02         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LAD7F;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   <$96                    ; AD7D: DC 96         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x96); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x97); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0xAD7F:
LAD7F:
                                                     #ifdef DEBUG
                                      mon("LAD7F    STD   <$46                    ; AD7F: DD 46         \n");
                                      #endif
    PC = 0xad7f; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x46; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$96                    ; AD81: DC 96         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x96); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x97); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  <$46                    ; AD83: 93 46         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x46)<<8; 
    ea = ea | rd_mem(DP|0x47); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$1000                  ; AD85: 83 10 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x1000; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  <$4A                    ; AD88: 10 93 4A      \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x4a)<<8; 
    ea = ea | rd_mem(DP|0x4b); 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = ea; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
    clockticks = clockticks + 1; 
                                                     #ifdef DEBUG
                                      mon("         BGE   LAD8F                   ; AD8B: 2C 02         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) >= 0) {
    clockticks = clockticks + 3; 
    goto LAD8F;
    }
                                                     #ifdef DEBUG
                                      mon("         STD   <$4A                    ; AD8D: DD 4A         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x4a; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
  case 0xAD8F:
LAD8F:
                                                     #ifdef DEBUG
                                      mon("LAD8F    LDD   <$96                    ; AD8F: DC 96         \n");
                                      #endif
    PC = 0xad8f; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x96); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x97); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  <$46                    ; AD91: 93 46         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x46)<<8; 
    ea = ea | rd_mem(DP|0x47); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_4             ; AD93: BD CD A0      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x96); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xad); 
    clockticks = clockticks + 1; 
    goto LCDA0;
  case 0xAD96:
LAD96:
                                                     #ifdef DEBUG
                                      mon("LAD96    TST   <$48                    ; AD96: 0D 48         \n");
                                      #endif
    PC = 0xad96; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x48); 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BMI   LADA3                   ; AD98: 2B 09         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LADA3;
    }
                                                     #ifdef DEBUG
                                      mon("         CMPD  <$48                    ; AD9A: 10 93 48      \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x48)<<8; 
    ea = ea | rd_mem(DP|0x49); 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = ea; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
    clockticks = clockticks + 1; 
                                                     #ifdef DEBUG
                                      mon("         BGE   LADA1                   ; AD9D: 2C 02         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) >= 0) {
    clockticks = clockticks + 3; 
    goto LADA1;
    }
                                                     #ifdef DEBUG
                                      mon("         STD   <$48                    ; AD9F: DD 48         \n");
                                      #endif
    clockticks = clockticks + 4; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = DP|0x48; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
  case 0xADA1:
LADA1:
                                                     #ifdef DEBUG
                                      mon("LADA1    BRA   locret_ADAE             ; ADA1: 20 0B         \n");
                                      #endif
    PC = 0xada1; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto LADAE;
    
    // ---------------------------------------------------------------------------
  case 0xADA3:
LADA3:
                                                     #ifdef DEBUG
                                      mon("LADA3    COMA                          ; ADA3: 43            \n");
                                      #endif
    PC = 0xada3; 
    INSTRUCTION_START
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; ADA4: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SBCA  #$FF                    ; ADA5: 82 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xff; 
    res = val - (UINT8)arg - (C != 0 ? 1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  <$48                    ; ADA7: 10 93 48      \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x48)<<8; 
    ea = ea | rd_mem(DP|0x49); 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = ea; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
    clockticks = clockticks + 1; 
                                                     #ifdef DEBUG
                                      mon("         BLE   locret_ADAE             ; ADAA: 2F 02         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto LADAE;
    }
                                                     #ifdef DEBUG
                                      mon("         STD   <$48                    ; ADAC: DD 48         \n");
                                      #endif
    clockticks = clockticks + 4; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = DP|0x48; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    // End of function sub_AD6C
  case 0xADAE:
LADAE:
locret_ADAE:
                                                     #ifdef DEBUG
                                      mon("locret_ADAE RTS                           ; ADAE: 39            \n");
                                      #endif
    PC = 0xadae; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xADAF:
LADAF:
                                                     #ifdef DEBUG
                                      mon("LADAF    LDA   <$45                    ; ADAF: 96 45         \n");
                                      #endif
    PC = 0xadaf; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x45); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   locret_ADD3             ; ADB1: 27 20         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LADD3;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   <$46                    ; ADB3: DC 46         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x46); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x47); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5078                   ; ADB5: FD 50 78      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5078, A); // Care needed with I/O space and word fetches
    wr_mem(0x5079, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$48                    ; ADB8: DC 48         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x48); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x49); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
    // End of function sub_ADAF
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$80                    ; ADBA: C3 00 80      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0080; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
    // =============== S U B R O U T I N E =======================================
  case 0xADBD:
LADBD:
                                                     #ifdef DEBUG
                                      mon("LADBD    STD   $507A                   ; ADBD: FD 50 7A      \n");
                                      #endif
    PC = 0xadbd; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x507a, A); // Care needed with I/O space and word fetches
    wr_mem(0x507b, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$4A                    ; ADC0: DC 4A         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x4a); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x4b); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $507C                   ; ADC2: FD 50 7C      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x507c, A); // Care needed with I/O space and word fetches
    wr_mem(0x507d, B); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LADD4                   ; ADC5: BD AD D4      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xc8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xad); 
    clockticks = clockticks + 1; 
    goto LADD4;
  case 0xADC8:
LADC8:
                                                     #ifdef DEBUG
                                      mon("LADC8    LDD   <$48                    ; ADC8: DC 48         \n");
                                      #endif
    PC = 0xadc8; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x48); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x49); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$80                    ; ADCA: 83 00 80      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0080; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $507A                   ; ADCD: FD 50 7A      \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x507a, A); // Care needed with I/O space and word fetches
    wr_mem(0x507b, B); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LADD4                   ; ADD0: BD AD D4      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xd3); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xad); 
    clockticks = clockticks + 1; 
    goto LADD4;
    // End of function sub_ADBD
  case 0xADD3:
LADD3:
locret_ADD3:
                                                     #ifdef DEBUG
                                      mon("locret_ADD3 RTS                           ; ADD3: 39            \n");
                                      #endif
    PC = 0xadd3; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xADD4:
LADD4:
                                                     #ifdef DEBUG
                                      mon("LADD4    LDD   #$0F                    ; ADD4: CC 00 0F      \n");
                                      #endif // Point BIC to $5078 MReg3C
    PC = 0xadd4; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x0f; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4701                   ; ADD7: FD 47 01      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4701, A); // Care needed with I/O space and word fetches
    wr_mem(0x4702, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$67                    ; ADDA: 86 67         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x67; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCDBA                   ; ADDC: BD CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xdf); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xad); 
    clockticks = clockticks + 1; 
    goto LCDBA;
  case 0xADDF:
LADDF:
                                                     #ifdef DEBUG
                                      mon("LADDF    LDD   $5000                   ; ADDF: FC 50 00      \n");
                                      #endif // Math result X
    PC = 0xaddf; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x5000); // Care needed with I/O space and word fetches
    B = rd_mem(0x5001); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #LE000                  ; ADE2: 83 E0 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0xe000; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BGT   LADEB                   ; ADE5: 2E 04         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto LADEB;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; ADE7: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$45                    ; ADE9: 97 45         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x45; 
    wr_mem(ea, val); 
  case 0xADEB:
LADEB:
                                                     #ifdef DEBUG
                                      mon("LADEB    LDD   $5000                   ; ADEB: FC 50 00      \n");
                                      #endif // Math result X
    PC = 0xadeb; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x5000); // Care needed with I/O space and word fetches
    B = rd_mem(0x5001); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$01                    ; ADEE: 10 83 00 01   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x0001; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BLT   locret_AE5F             ; ADF2: 2D 6B         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 3; 
    goto LAE5F;
    }
                                                     #ifdef DEBUG
                                      mon("         STD   $4704                   ; ADF4: FD 47 04      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4704, A); // Care needed with I/O space and word fetches
    wr_mem(0x4705, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $5018                   ; ADF7: FD 50 18      \n");
                                      #endif // XT
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5018, A); // Care needed with I/O space and word fetches
    wr_mem(0x5019, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $5002                   ; ADFA: FC 50 02      \n");
                                      #endif // Math result Y
    clockticks = clockticks + 5; 
    A = rd_mem(0x5002); // Care needed with I/O space and word fetches
    B = rd_mem(0x5003); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LAE03                   ; ADFD: 2A 04         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LAE03;
    }
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; ADFF: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; AE00: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SBCA  #$FF                    ; AE01: 82 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xff; 
    res = val - (UINT8)arg - (C != 0 ? 1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)res; 
  case 0xAE03:
LAE03:
                                                     #ifdef DEBUG
                                      mon("LAE03    SUBD  $5000                   ; AE03: B3 50 00      \n");
                                      #endif // Math result X
    PC = 0xae03; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5000)<<8; 
    ea = ea | rd_mem(0x5001); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BGE   locret_AE5F             ; AE06: 2C 57         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) >= 0) {
    clockticks = clockticks + 3; 
    goto LAE5F;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $5004                   ; AE08: FC 50 04      \n");
                                      #endif // Math result Z
    clockticks = clockticks + 5; 
    A = rd_mem(0x5004); // Care needed with I/O space and word fetches
    B = rd_mem(0x5005); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LAE11                   ; AE0B: 2A 04         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LAE11;
    }
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; AE0D: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; AE0E: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SBCA  #$FF                    ; AE0F: 82 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xff; 
    res = val - (UINT8)arg - (C != 0 ? 1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)res; 
  case 0xAE11:
LAE11:
                                                     #ifdef DEBUG
                                      mon("LAE11    SUBD  $5000                   ; AE11: B3 50 00      \n");
                                      #endif // Math result X
    PC = 0xae11; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5000)<<8; 
    ea = ea | rd_mem(0x5001); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BGE   locret_AE5F             ; AE14: 2C 49         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) >= 0) {
    clockticks = clockticks + 3; 
    goto LAE5F;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $4700                   ; AE16: FC 47 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x4700); // Care needed with I/O space and word fetches
    B = rd_mem(0x4701); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5000                   ; AE19: FD 50 00      \n");
                                      #endif // Math result X
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5000, A); // Care needed with I/O space and word fetches
    wr_mem(0x5001, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$86                    ; AE1C: 86 86         \n");
                                      #endif // Reg02 = Reg02 x Reg00
    clockticks = clockticks + 2; 
    val = (UINT8)0x86; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCDBA                   ; AE1E: BD CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x21); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xae); 
    clockticks = clockticks + 1; 
    goto LCDBA;
  case 0xAE21:
LAE21:
                                                     #ifdef DEBUG
                                      mon("LAE21    LDD   $5004                   ; AE21: FC 50 04      \n");
                                      #endif // Math result Z
    PC = 0xae21; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x5004); // Care needed with I/O space and word fetches
    B = rd_mem(0x5005); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$FF98                  ; AE24: C3 FF 98      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0xff98; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$1F                    ; AE27: 84 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x1f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; AE29: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   $5002                   ; AE2B: FC 50 02      \n");
                                      #endif // Math result Y
    clockticks = clockticks + 5; 
    A = rd_mem(0x5002); // Care needed with I/O space and word fetches
    B = rd_mem(0x5003); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$1F                    ; AE2E: 84 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x1f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; AE30: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$63FF                  ; AE32: CC 63 FF      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x63; 
    B = 0xff; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; AE35: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$06                    ; AE37: 86 06         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x06; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$01                    ; AE39: 97 01         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x01; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $5018                   ; AE3B: FC 50 18      \n");
                                      #endif // XT
    clockticks = clockticks + 5; 
    A = rd_mem(0x5018); // Care needed with I/O space and word fetches
    B = rd_mem(0x5019); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0xAE3E:
LAE3E:
                                                     #ifdef DEBUG
                                      mon("LAE3E    DEC   <$01                    ; AE3E: 0A 01         \n");
                                      #endif
    PC = 0xae3e; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x01); 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    wr_mem(DP|0x01, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LAE48                   ; AE40: 27 06         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LAE48;
    }
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; AE42: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLA                          ; AE43: 49            \n");
                                      #endif
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LAE3E                   ; AE44: 2A F8         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LAE3E;
    }
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$7F                    ; AE46: 84 7F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x7f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
  case 0xAE48:
LAE48:
                                                     #ifdef DEBUG
                                      mon("LAE48    LDB   <$01                    ; AE48: D6 01         \n");
                                      #endif
    PC = 0xae48; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x01); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORB   #$70                    ; AE4A: CA 70         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = B | (UINT8)0x70; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STB   ,Y+                     ; AE4C: E7 A0         \n");
                                      #endif
    clockticks = clockticks + 6; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, val); 
    Y = Y + 1; 
                                                     #ifdef DEBUG
                                      mon("         STA   ,Y+                     ; AE4E: A7 A0         \n");
                                      #endif
    clockticks = clockticks + 6; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, val); 
    Y = Y + 1; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$A016                  ; AE50: CC A0 16      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xa0; 
    B = 0x16; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; AE53: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$7200                  ; AE55: CC 72 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x72; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; AE58: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$8040                  ; AE5A: CC 80 40      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; AE5D: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
    // End of function sub_ADD4
  case 0xAE5F:
LAE5F:
locret_AE5F:
                                                     #ifdef DEBUG
                                      mon("locret_AE5F RTS                           ; AE5F: 39            \n");
                                      #endif
    PC = 0xae5f; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xAE60:
LAE60:
                                                     #ifdef DEBUG
                                      mon("LAE60    LDA   <$BD                    ; AE60: 96 BD         \n");
                                      #endif
    PC = 0xae60; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xbd); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BLE   LAE6E                   ; AE62: 2F 0A         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto LAE6E;
    }
                                                     #ifdef DEBUG
                                      mon("         DEC   <$BD                    ; AE64: 0A BD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xbd); 
    res = (UINT8)(val - 1); 
 // N = res; 
 // Z = res; 
 // V = val & ~res; 
    wr_mem(DP|0xbd, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; AE66: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$B7                    ; AE68: 97 B7         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xb7; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   <$BC                    ; AE6A: 97 BC         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0xbc; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         BRA   LAE72                   ; AE6C: 20 04         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LAE72;
    
    // ---------------------------------------------------------------------------
  case 0xAE6E:
LAE6E:
                                                     #ifdef DEBUG
                                      mon("LAE6E    LDA   #$00                    ; AE6E: 86 00         \n");
                                      #endif
    PC = 0xae6e; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$BD                    ; AE70: 97 BD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xbd; 
    wr_mem(ea, val); 
  case 0xAE72:
LAE72:
                                                     #ifdef DEBUG
                                      mon("LAE72    LDA   #$00                    ; AE72: 86 00         \n");
                                      #endif
    PC = 0xae72; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$BC                    ; AE74: 97 BC         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xbc; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         ORCC  #$10                    ; AE76: 1A 10         \n");
                                      #endif
    I = 1; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$31                    ; AE78: 96 31         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x31); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LAE87                   ; AE7A: 27 0B         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LAE87;
    }
                                                     #ifdef DEBUG
                                      mon("         INC   $4B1B                   ; AE7C: 7C 4B 1B      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b1b); 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    wr_mem(0x4b1b, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         CLR   <$BD                    ; AE7F: 0F BD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    wr_mem(DP|0xbd, 0); 
 // V = 0; 
 // Z = 0; 
 // N = 0; 
 // C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$08                    ; AE81: C6 08         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x08; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STB   <$B7                    ; AE83: D7 B7         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xb7; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         CLR   <$31                    ; AE85: 0F 31         \n");
                                      #endif
    clockticks = clockticks + 4; 
    wr_mem(DP|0x31, 0); 
 // V = 0; 
 // Z = 0; 
 // N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
  case 0xAE87:
LAE87:
                                                     #ifdef DEBUG
                                      mon("LAE87    LDA   <$B7                    ; AE87: 96 B7         \n");
                                      #endif
    PC = 0xae87; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xb7); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BLE   LAE9F                   ; AE89: 2F 14         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto LAE9F;
    }
                                                     #ifdef DEBUG
                                      mon("         DEC   <$B7                    ; AE8B: 0A B7         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xb7); 
    res = (UINT8)(val - 1); 
 // N = res; 
 // Z = res; 
 // V = val & ~res; 
    wr_mem(DP|0xb7, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$BC                    ; AE8D: 97 BC         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xbc; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$74                    ; AE8F: DC 74         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x74); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x75); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$B8                    ; AE91: DD B8         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0xb8; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$6B                    ; AE93: DC 6B         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x6b); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x6c); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$BA                    ; AE95: DD BA         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0xba; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$2D                    ; AE97: DC 2D         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x2d); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x2e); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$B3                    ; AE99: DD B3         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0xb3; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$2F                    ; AE9B: DC 2F         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x2f); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x30); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$B5                    ; AE9D: DD B5         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0xb5; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
  case 0xAE9F:
LAE9F:
                                                     #ifdef DEBUG
                                      mon("LAE9F    ANDCC #$EF                    ; AE9F: 1C EF         \n");
                                      #endif
    PC = 0xae9f; 
    INSTRUCTION_START
    I = 0; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$B7                    ; AEA1: 96 B7         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xb7); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$07                    ; AEA3: 81 07         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x07; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   LAEB2                   ; AEA5: 26 0B         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LAEB2;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B36                   ; AEA7: B6 4B 36      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b36); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LAEAF                   ; AEAA: 26 03         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LAEAF;
    }
                                                     #ifdef DEBUG
                                      mon("         DEC   $4B36                   ; AEAC: 7A 4B 36      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b36); 
    res = (UINT8)(val - 1); 
 // N = res; 
 // Z = res; 
 // V = val & ~res; 
    wr_mem(0x4b36, res); 
    clockticks = clockticks + 2; 
  case 0xAEAF:
LAEAF:
                                                     #ifdef DEBUG
                                      mon("LAEAF    JSR   LBE16                   ; AEAF: BD BE 16      \n");
                                      #endif
    PC = 0xaeaf; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xb2); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xae); 
    clockticks = clockticks + 1; 
    goto LBE16;
  case 0xAEB2:
LAEB2:
                                                     #ifdef DEBUG
                                      mon("LAEB2    LDA   #$FF                    ; AEB2: 86 FF         \n");
                                      #endif
    PC = 0xaeb2; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0xff; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$C4                    ; AEB4: 97 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xc4; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   <$C8                    ; AEB6: 97 C8         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xc8; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   <$CC                    ; AEB8: 97 CC         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xcc; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   <$D0                    ; AEBA: 97 D0         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0xd0; 
    wr_mem(ea, val); 
    // End of function sub_AE60
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; AEBC: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xAEBD:
LAEBD:
                                                     #ifdef DEBUG
                                      mon("LAEBD    LDA   <$BC                    ; AEBD: 96 BC         \n");
                                      #endif
    PC = 0xaebd; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xbc); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORA   <$BD                    ; AEBF: 9A BD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    res = A | (UINT8)rd_mem(DP|0xbd); 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LAEC4                   ; AEC1: 26 01         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LAEC4;
    }
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; AEC3: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
  case 0xAEC4:
LAEC4:
                                                     #ifdef DEBUG
                                      mon("LAEC4    LDA   $4B1B                   ; AEC4: B6 4B 1B      \n");
                                      #endif
    PC = 0xaec4; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b1b); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$01                    ; AEC7: 84 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x01; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LAF25                   ; AEC9: 27 5A         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LAF25;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$FF98                  ; AECB: CC FF 98      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xff; 
    B = 0x98; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $4B1E                   ; AECE: F3 4B 1E      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4b1e)<<8; 
    ea = ea | rd_mem(0x4b1f); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$1F                    ; AED1: 84 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x1f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; AED3: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$B5                    ; AED5: DC B5         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0xb5); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0xb6); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$00                    ; AED7: 83 00 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0000; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $4B1E                   ; AEDA: B3 4B 1E      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4b1e)<<8; 
    ea = ea | rd_mem(0x4b1f); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$03                    ; AEDD: DD 03         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x03; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$FE7A                  ; AEDF: CC FE 7A      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xfe; 
    B = 0x7a; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $4B1C                   ; AEE2: F3 4B 1C      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4b1c)<<8; 
    ea = ea | rd_mem(0x4b1d); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$1F                    ; AEE5: 84 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x1f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; AEE7: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$B3                    ; AEE9: DC B3         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0xb3); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0xb4); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$FE7A                  ; AEEB: 83 FE 7A      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0xfe7a; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $4B1C                   ; AEEE: B3 4B 1C      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4b1c)<<8; 
    ea = ea | rd_mem(0x4b1d); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$01                    ; AEF1: DD 01         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x01; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$00                    ; AEF3: C6 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LAF87                   ; AEF5: BD AF 87      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xae); 
    clockticks = clockticks + 1; 
    goto LAF87;
  case 0xAEF8:
LAEF8:
                                                     #ifdef DEBUG
                                      mon("LAEF8    LDD   #$FDFB                  ; AEF8: CC FD FB      \n");
                                      #endif
    PC = 0xaef8; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0xfd; 
    B = 0xfb; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $4B1E                   ; AEFB: F3 4B 1E      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4b1e)<<8; 
    ea = ea | rd_mem(0x4b1f); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$1F                    ; AEFE: 84 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x1f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; AF00: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$B5                    ; AF02: DC B5         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0xb5); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0xb6); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$FE63                  ; AF04: 83 FE 63      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0xfe63; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $4B1E                   ; AF07: B3 4B 1E      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4b1e)<<8; 
    ea = ea | rd_mem(0x4b1f); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$03                    ; AF0A: DD 03         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x03; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #LFE75                  ; AF0C: CC FE 75      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xfe; 
    B = 0x75; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $4B1C                   ; AF0F: F3 4B 1C      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4b1c)<<8; 
    ea = ea | rd_mem(0x4b1d); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$1F                    ; AF12: 84 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x1f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; AF14: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$B3                    ; AF16: DC B3         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0xb3); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0xb4); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #LFE75                  ; AF18: 83 FE 75      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0xfe75; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $4B1C                   ; AF1B: B3 4B 1C      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4b1c)<<8; 
    ea = ea | rd_mem(0x4b1d); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$01                    ; AF1E: DD 01         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x01; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$08                    ; AF20: C6 08         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x08; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LAF87                   ; AF22: BD AF 87      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x25); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xaf); 
    clockticks = clockticks + 1; 
    goto LAF87;
  case 0xAF25:
LAF25:
                                                     #ifdef DEBUG
                                      mon("LAF25    LDA   $4B1B                   ; AF25: B6 4B 1B      \n");
                                      #endif
    PC = 0xaf25; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b1b); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$01                    ; AF28: 84 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x01; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   locret_AF86             ; AF2A: 26 5A         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LAF86;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$FDFB                  ; AF2C: CC FD FB      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xfd; 
    B = 0xfb; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $4B1E                   ; AF2F: F3 4B 1E      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4b1e)<<8; 
    ea = ea | rd_mem(0x4b1f); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$1F                    ; AF32: 84 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x1f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; AF34: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$B5                    ; AF36: DC B5         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0xb5); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0xb6); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$FE63                  ; AF38: 83 FE 63      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0xfe63; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $4B1E                   ; AF3B: B3 4B 1E      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4b1e)<<8; 
    ea = ea | rd_mem(0x4b1f); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$03                    ; AF3E: DD 03         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x03; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$018B                  ; AF40: CC 01 8B      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x01; 
    B = 0x8b; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $4B1C                   ; AF43: F3 4B 1C      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4b1c)<<8; 
    ea = ea | rd_mem(0x4b1d); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$1F                    ; AF46: 84 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x1f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; AF48: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$B3                    ; AF4A: DC B3         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0xb3); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0xb4); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$018B                  ; AF4C: 83 01 8B      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x018b; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $4B1C                   ; AF4F: B3 4B 1C      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4b1c)<<8; 
    ea = ea | rd_mem(0x4b1d); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$01                    ; AF52: DD 01         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x01; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$00                    ; AF54: C6 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LAF87                   ; AF56: BD AF 87      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x59); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xaf); 
    clockticks = clockticks + 1; 
    goto LAF87;
  case 0xAF59:
LAF59:
                                                     #ifdef DEBUG
                                      mon("LAF59    LDD   #$FF98                  ; AF59: CC FF 98      \n");
                                      #endif
    PC = 0xaf59; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0xff; 
    B = 0x98; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $4B1E                   ; AF5C: F3 4B 1E      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4b1e)<<8; 
    ea = ea | rd_mem(0x4b1f); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$1F                    ; AF5F: 84 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x1f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; AF61: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$B5                    ; AF63: DC B5         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0xb5); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0xb6); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$00                    ; AF65: 83 00 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0000; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $4B1E                   ; AF68: B3 4B 1E      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4b1e)<<8; 
    ea = ea | rd_mem(0x4b1f); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$03                    ; AF6B: DD 03         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x03; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0186                  ; AF6D: CC 01 86      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x01; 
    B = 0x86; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $4B1C                   ; AF70: F3 4B 1C      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4b1c)<<8; 
    ea = ea | rd_mem(0x4b1d); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$1F                    ; AF73: 84 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x1f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; AF75: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$B3                    ; AF77: DC B3         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0xb3); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0xb4); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$0186                  ; AF79: 83 01 86      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0186; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $4B1C                   ; AF7C: B3 4B 1C      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4b1c)<<8; 
    ea = ea | rd_mem(0x4b1d); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$01                    ; AF7F: DD 01         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x01; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$08                    ; AF81: C6 08         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x08; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LAF87                   ; AF83: BD AF 87      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x86); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xaf); 
    clockticks = clockticks + 1; 
    goto LAF87;
    // End of function sub_AEBD
  case 0xAF86:
LAF86:
locret_AF86:
                                                     #ifdef DEBUG
                                      mon("locret_AF86 RTS                           ; AF86: 39            \n");
                                      #endif
    PC = 0xaf86; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xAF87:
LAF87:
                                                     #ifdef DEBUG
                                      mon("LAF87    LDU   #tbl0xB04F              ; AF87: CE B0 4F      \n");
                                      #endif
    PC = 0xaf87; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0xb04f; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LEAU  B,U                     ; AF8A: 33 C5         \n");
                                      #endif
    clockticks = clockticks + 5; 
    U = (U + (SINT8)B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$BD                    ; AF8C: 96 BD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xbd); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BLE   LAF9A                   ; AF8E: 2F 0A         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto LAF9A;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   #$3F                    ; AF90: C6 3F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x3f; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         MUL                           ; AF92: 3D            \n");
                                      #endif
    res = (UINT16)(A * B); 
 // Z = res; 
    C = res & 0x80; 
    A = res >> 8; 
    B = (UINT8)res; 
    clockticks = clockticks + 11; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$63                    ; AF93: 86 63         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x63; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; AF95: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         JMP   LAFEF                   ; AF97: 7E AF EF      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LAFEF;
    
    // ---------------------------------------------------------------------------
  case 0xAF9A:
LAF9A:
                                                     #ifdef DEBUG
                                      mon("LAF9A    LDX   #$4C00                  ; AF9A: 8E 4C 00      \n");
                                      #endif
    PC = 0xaf9a; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x4c00; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xAF9D:
LAF9D:
                                                     #ifdef DEBUG
                                      mon("LAF9D    LDD   ,U++                    ; AF9D: EC C1         \n");
                                      #endif
    PC = 0xaf9d; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
    A = rd_mem(U); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(U+1)); 
    U = U + 2; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; AF9F: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$03                    ; AFA1: DC 03         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x03); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x04); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BMI   LAFA8                   ; AFA3: 2B 03         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LAFA8;
    }
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$01                    ; AFA5: C3 00 01      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0001; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
  case 0xAFA8:
LAFA8:
                                                     #ifdef DEBUG
                                      mon("LAFA8    ASRA                          ; AFA8: 47            \n");
                                      #endif
    PC = 0xafa8; 
    INSTRUCTION_START
    val = (UINT8)A; 
    C = val & 1; 
    val = (UINT8)((SINT8)val >> 1); 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         RORB                          ; AFA9: 56            \n");
                                      #endif
    res = ((UINT8)B) | ((C != 0) ? 0x100 : 0); 
 // C = res & 1; 
    res = (UINT8)(res >> 1); 
 // Z = res; 
 // N = res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y                      ; AFAA: ED A4         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; AFAC: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; AFAD: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SBCA  #$FF                    ; AFAE: 82 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xff; 
    res = val - (UINT8)arg - (C != 0 ? 1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  <$03                    ; AFB0: D3 03         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x03)<<8; 
    ea = ea | rd_mem(DP|0x04); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$03                    ; AFB2: DD 03         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x03; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   ,Y                      ; AFB4: EC A4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(Y); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(Y+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$1F                    ; AFB6: 84 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x1f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; AFB8: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$01                    ; AFBA: DC 01         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x01); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x02); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BMI   LAFC1                   ; AFBC: 2B 03         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LAFC1;
    }
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$01                    ; AFBE: C3 00 01      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0001; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
  case 0xAFC1:
LAFC1:
                                                     #ifdef DEBUG
                                      mon("LAFC1    ASRA                          ; AFC1: 47            \n");
                                      #endif
    PC = 0xafc1; 
    INSTRUCTION_START
    val = (UINT8)A; 
    C = val & 1; 
    val = (UINT8)((SINT8)val >> 1); 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         RORB                          ; AFC2: 56            \n");
                                      #endif
    res = ((UINT8)B) | ((C != 0) ? 0x100 : 0); 
 // C = res & 1; 
    res = (UINT8)(res >> 1); 
 // Z = res; 
 // N = res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y                      ; AFC3: ED A4         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; AFC5: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; AFC6: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SBCA  #$FF                    ; AFC7: 82 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xff; 
    res = val - (UINT8)arg - (C != 0 ? 1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  <$01                    ; AFC9: D3 01         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x01)<<8; 
    ea = ea | rd_mem(DP|0x02); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$01                    ; AFCB: DD 01         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x01; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   ,Y                      ; AFCD: EC A4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(Y); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(Y+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORA   #$E0                    ; AFCF: 8A E0         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A | (UINT8)0xe0; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; AFD1: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$01                    ; AFD3: DC 01         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x01); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x02); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$08                    ; AFD5: C3 00 08      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0008; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ res) & (val ^ res)) >> 8; 
    N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BLT   LAF9D                   ; AFD8: 2D C3         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 3; 
    goto LAF9D;
    }
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$10                    ; AFDA: 83 00 10      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0010; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BGT   LAF9D                   ; AFDD: 2E BE         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto LAF9D;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   <$03                    ; AFDF: DC 03         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x03); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x04); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$08                    ; AFE1: C3 00 08      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0008; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ res) & (val ^ res)) >> 8; 
    N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BLT   LAF9D                   ; AFE4: 2D B7         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 3; 
    goto LAF9D;
    }
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$10                    ; AFE6: 83 00 10      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0010; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BGT   LAF9D                   ; AFE9: 2E B2         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto LAF9D;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   ,U++                    ; AFEB: EC C1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    A = rd_mem(U); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(U+1)); 
    U = U + 2; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; AFED: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
  case 0xAFEF:
LAFEF:
                                                     #ifdef DEBUG
                                      mon("LAFEF    LDD   <$03                    ; AFEF: DC 03         \n");
                                      #endif
    PC = 0xafef; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x03); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x04); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$1F                    ; AFF1: 84 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x1f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; AFF3: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$01                    ; AFF5: DC 01         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x01); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x02); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORA   #$E0                    ; AFF7: 8A E0         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A | (UINT8)0xe0; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; AFF9: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$BD                    ; AFFB: 96 BD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xbd); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BLE   LB006                   ; AFFD: 2F 07         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto LB006;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$A011                  ; AFFF: CC A0 11      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xa0; 
    B = 0x11; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; B002: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LB044                   ; B004: 20 3E         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LB044;
    
    // ---------------------------------------------------------------------------
  case 0xB006:
LB006:
                                                     #ifdef DEBUG
                                      mon("LB006    BGE   LB044                   ; B006: 2C 3C         \n");
                                      #endif
    PC = 0xb006; 
    INSTRUCTION_START
    // temp hack to force a flush
    if ((SINT8)(N^V) >= 0) {
    clockticks = clockticks + 3; 
    goto LB044;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   $4B22                   ; B008: F6 4B 22      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b22); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$71                    ; B00B: 86 71         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x71; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; B00D: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   $4B20                   ; B00F: FC 4B 20      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x4b20); // Care needed with I/O space and word fetches
    B = rd_mem(0x4b21); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; B012: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B23                   ; B014: B6 4B 23      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b23); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$01                    ; B017: 84 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x01; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LB020                   ; B019: 27 05         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LB020;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$A01C                  ; B01B: CC A0 1C      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xa0; 
    B = 0x1c; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; B01E: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
  case 0xB020:
LB020:
                                                     #ifdef DEBUG
                                      mon("LB020    LDA   $4B23                   ; B020: B6 4B 23      \n");
                                      #endif
    PC = 0xb020; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b23); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$02                    ; B023: 84 02         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x02; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LB02C                   ; B025: 27 05         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LB02C;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$A023                  ; B027: CC A0 23      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xa0; 
    B = 0x23; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; B02A: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
  case 0xB02C:
LB02C:
                                                     #ifdef DEBUG
                                      mon("LB02C    LDA   $4B23                   ; B02C: B6 4B 23      \n");
                                      #endif
    PC = 0xb02c; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b23); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$04                    ; B02F: 84 04         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x04; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LB038                   ; B031: 27 05         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LB038;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$A02A                  ; B033: CC A0 2A      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xa0; 
    B = 0x2a; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; B036: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
  case 0xB038:
LB038:
                                                     #ifdef DEBUG
                                      mon("LB038    LDA   $4B23                   ; B038: B6 4B 23      \n");
                                      #endif
    PC = 0xb038; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b23); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$08                    ; B03B: 84 08         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x08; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LB044                   ; B03D: 27 05         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LB044;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$A031                  ; B03F: CC A0 31      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xa0; 
    B = 0x31; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; B042: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
  case 0xB044:
LB044:
                                                     #ifdef DEBUG
                                      mon("LB044    LDD   #$7200                  ; B044: CC 72 00      \n");
                                      #endif
    PC = 0xb044; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x72; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; B047: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$8040                  ; B049: CC 80 40      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; B04C: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
    // End of function sub_AF87
    // ---------------------------------------------------------------------------
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; B04E: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xB071:
LB071:
                                                     #ifdef DEBUG
                                      mon("LB071    LDA   <$BC                    ; B071: 96 BC         \n");
                                      #endif
    PC = 0xb071; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xbc); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   locret_B094             ; B073: 27 1F         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LB094;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   LB095                   ; B075: BD B0 95      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x78); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb0); 
    clockticks = clockticks + 1; 
    goto LB095;
  case 0xB078:
LB078:
                                                     #ifdef DEBUG
                                      mon("LB078    LDD   #$0200                  ; B078: CC 02 00      \n");
                                      #endif
    PC = 0xb078; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x02; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4706                   ; B07B: FD 47 06      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4706, A); // Care needed with I/O space and word fetches
    wr_mem(0x4707, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$CC                    ; B07E: DC CC         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0xcc); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0xcd); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BMI   LB089                   ; B080: 2B 07         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LB089;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$04                    ; B082: 86 04         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x04; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$BD                    ; B084: 97 BD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xbd; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LAD20                   ; B086: BD AD 20      \n");
                                      #endif // Fireball destroyed
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x89); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb0); 
    clockticks = clockticks + 1; 
    goto LAD20;
  case 0xB089:
LB089:
                                                     #ifdef DEBUG
                                      mon("LB089    LDA   <$44                    ; B089: 96 44         \n");
                                      #endif
    PC = 0xb089; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x44); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BLE   locret_B094             ; B08B: 2F 07         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto LB094;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$FF                    ; B08D: 86 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xff; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$44                    ; B08F: 97 44         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0x44; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LAD3E                   ; B091: BD AD 3E      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x94); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb0); 
    clockticks = clockticks + 1; 
    goto LAD3E;
    // End of function sub_B071
  case 0xB094:
LB094:
locret_B094:
                                                     #ifdef DEBUG
                                      mon("locret_B094 RTS                           ; B094: 39            \n");
                                      #endif
    PC = 0xb094; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xB095:
LB095:
                                                     #ifdef DEBUG
                                      mon("LB095    LDD   #$7000                  ; B095: CC 70 00      \n");
                                      #endif
    PC = 0xb095; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x70; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $5040                   ; B098: F3 50 40      \n");
                                      #endif // XT2
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5040)<<8; 
    ea = ea | rd_mem(0x5041); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$01                    ; B09B: DD 01         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x01; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; B09D: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  <$B8                    ; B0A0: 93 B8         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xb8)<<8; 
    ea = ea | rd_mem(DP|0xb9); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_3             ; B0A2: BD CD A2      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xa5); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb0); 
    clockticks = clockticks + 1; 
    goto LCDA2;
  case 0xB0A5:
LB0A5:
                                                     #ifdef DEBUG
                                      mon("LB0A5    ADDD  <$B8                    ; B0A5: D3 B8         \n");
                                      #endif
    PC = 0xb0a5; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xb8)<<8; 
    ea = ea | rd_mem(DP|0xb9); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $5042                   ; B0A7: F3 50 42      \n");
                                      #endif // YT2
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5042)<<8; 
    ea = ea | rd_mem(0x5043); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$03                    ; B0AA: DD 03         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x03; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; B0AC: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  <$BA                    ; B0AF: 93 BA         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xba)<<8; 
    ea = ea | rd_mem(DP|0xbb); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_3             ; B0B1: BD CD A2      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xb4); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb0); 
    clockticks = clockticks + 1; 
    goto LCDA2;
  case 0xB0B4:
LB0B4:
                                                     #ifdef DEBUG
                                      mon("LB0B4    ADDD  <$BA                    ; B0B4: D3 BA         \n");
                                      #endif
    PC = 0xb0b4; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xba)<<8; 
    ea = ea | rd_mem(DP|0xbb); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $5044                   ; B0B6: F3 50 44      \n");
                                      #endif // ZT2
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5044)<<8; 
    ea = ea | rd_mem(0x5045); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$05                    ; B0B9: DD 05         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x05; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$F000                  ; B0BB: CC F0 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xf0; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  <$05                    ; B0BE: 93 05         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x05)<<8; 
    ea = ea | rd_mem(DP|0x06); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         LBLT  LB158                   ; B0C0: 10 2D 00 94   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 1; 
    goto LB158;
    }
                                                     #ifdef DEBUG
                                      mon("         STD   $4706                   ; B0C4: FD 47 06      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4706, A); // Care needed with I/O space and word fetches
    wr_mem(0x4707, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $5044                   ; B0C7: FC 50 44      \n");
                                      #endif // ZT2
    clockticks = clockticks + 5; 
    A = rd_mem(0x5044); // Care needed with I/O space and word fetches
    B = rd_mem(0x5045); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  <$05                    ; B0CA: 93 05         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x05)<<8; 
    ea = ea | rd_mem(DP|0x06); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4704                   ; B0CC: FD 47 04      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4704, A); // Care needed with I/O space and word fetches
    wr_mem(0x4705, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$03                    ; B0CF: DC 03         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x03); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x04); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5042                   ; B0D1: B3 50 42      \n");
                                      #endif // YT2
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5042)<<8; 
    ea = ea | rd_mem(0x5043); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5002                   ; B0D4: FD 50 02      \n");
                                      #endif // Math result Y
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5002, A); // Care needed with I/O space and word fetches
    wr_mem(0x5003, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$01                    ; B0D7: DC 01         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x01); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x02); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5040                   ; B0D9: B3 50 40      \n");
                                      #endif // XT2
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5040)<<8; 
    ea = ea | rd_mem(0x5041); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5004                   ; B0DC: FD 50 04      \n");
                                      #endif // Math result Z
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5004, A); // Care needed with I/O space and word fetches
    wr_mem(0x5005, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $4700                   ; B0DF: FC 47 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x4700); // Care needed with I/O space and word fetches
    B = rd_mem(0x4701); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5000                   ; B0E2: FD 50 00      \n");
                                      #endif // Math result X
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5000, A); // Care needed with I/O space and word fetches
    wr_mem(0x5001, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$86                    ; B0E5: 86 86         \n");
                                      #endif // Reg02 = Reg02 x Reg00
    clockticks = clockticks + 2; 
    val = (UINT8)0x86; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCDBA                   ; B0E7: BD CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xea); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb0); 
    clockticks = clockticks + 1; 
    goto LCDBA;
  case 0xB0EA:
LB0EA:
                                                     #ifdef DEBUG
                                      mon("LB0EA    LDD   <$03                    ; B0EA: DC 03         \n");
                                      #endif
    PC = 0xb0ea; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x03); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x04); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5002                   ; B0EC: B3 50 02      \n");
                                      #endif // Math result Y
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5002)<<8; 
    ea = ea | rd_mem(0x5003); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BMI   LB0F9                   ; B0EF: 2B 08         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LB0F9;
    }
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$0400                  ; B0F1: 10 83 04 00   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x0400; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BGT   LB158                   ; B0F5: 2E 61         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto LB158;
    }
                                                     #ifdef DEBUG
                                      mon("         BRA   LB0FF                   ; B0F7: 20 06         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LB0FF;
    
    // ---------------------------------------------------------------------------
  case 0xB0F9:
LB0F9:
                                                     #ifdef DEBUG
                                      mon("LB0F9    CMPD  #$FC00                  ; B0F9: 10 83 FC 00   \n");
                                      #endif
    PC = 0xb0f9; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0xfc00; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BLT   LB158                   ; B0FD: 2D 59         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 3; 
    goto LB158;
    }
  case 0xB0FF:
LB0FF:
                                                     #ifdef DEBUG
                                      mon("LB0FF    STD   <$03                    ; B0FF: DD 03         \n");
                                      #endif
    PC = 0xb0ff; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x03; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$01                    ; B101: DC 01         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x01); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x02); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5004                   ; B103: B3 50 04      \n");
                                      #endif // Math result Z
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5004)<<8; 
    ea = ea | rd_mem(0x5005); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$01                    ; B106: DD 01         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x01; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   <$C0                    ; B108: DD C0         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0xc0; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$F000                  ; B10A: CC F0 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xf0; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$05                    ; B10D: DD 05         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x05; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$FF                    ; B10F: 86 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xff; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$BD                    ; B111: 97 BD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xbd; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$03                    ; B113: 86 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x03; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B23                   ; B115: B7 4B 23      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b23, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$01                    ; B118: 96 01         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x01); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBA  $5040                   ; B11A: B0 50 40      \n");
                                      #endif // XT2
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    arg = rd_mem(0x5040); 
    res = val - (UINT8)arg; 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)(res); 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$03                    ; B11D: C6 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x03; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         MUL                           ; B11F: 3D            \n");
                                      #endif
    res = (UINT16)(A * B); 
 // Z = res; 
 // C = res & 0x80; 
    A = res >> 8; 
    B = (UINT8)res; 
    clockticks = clockticks + 11; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$E0                    ; B120: 10 83 00 E0   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x00e0; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LB128                   ; B124: 25 02         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LB128;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   #$E0                    ; B126: C6 E0         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xe0; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xB128:
LB128:
                                                     #ifdef DEBUG
                                      mon("LB128    STB   $4B22                   ; B128: F7 4B 22      \n");
                                      #endif
    PC = 0xb128; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b22, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$6280                  ; B12B: CC 62 80      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x62; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B20                   ; B12E: FD 4B 20      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4b20, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b21, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$95                    ; B131: 96 95         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x95); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   locret_B157             ; B133: 27 22         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LB157;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   <$44                    ; B135: 96 44         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x44); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   locret_B157             ; B137: 26 1E         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LB157;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   <$03                    ; B139: DC 03         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x03); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x04); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$0200                  ; B13B: C3 02 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0200; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ res) & (val ^ res)) >> 8; 
    N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BLT   locret_B157             ; B13E: 2D 17         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 3; 
    goto LB157;
    }
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$0400                  ; B140: 83 04 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0400; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BGT   locret_B157             ; B143: 2E 12         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto LB157;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   <$01                    ; B145: DC 01         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x01); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x02); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  <$96                    ; B147: 93 96         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x96)<<8; 
    ea = ea | rd_mem(DP|0x97); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$0200                  ; B149: C3 02 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0200; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ res) & (val ^ res)) >> 8; 
    N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BLT   locret_B157             ; B14C: 2D 09         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 3; 
    goto LB157;
    }
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$0400                  ; B14E: 83 04 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0400; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BGT   locret_B157             ; B151: 2E 04         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto LB157;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$01                    ; B153: 86 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x01; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$44                    ; B155: 97 44         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0x44; 
    wr_mem(ea, val); 
  case 0xB157:
LB157:
locret_B157:
                                                     #ifdef DEBUG
                                      mon("locret_B157 RTS                           ; B157: 39            \n");
                                      #endif
    PC = 0xb157; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
  case 0xB158:
LB158:
                                                     #ifdef DEBUG
                                      mon("LB158    LDD   <$03                    ; B158: DC 03         \n");
                                      #endif
    PC = 0xb158; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x03); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x04); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LBPL  LB1E3                   ; B15A: 10 2A 00 85   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 1; 
    goto LB1E3;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$FC00                  ; B15E: CC FC 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xfc; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  <$03                    ; B161: 93 03         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x03)<<8; 
    ea = ea | rd_mem(DP|0x04); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         LBLT  locret_B260             ; B163: 10 2D 00 F9   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 1; 
    goto LB260;
    }
                                                     #ifdef DEBUG
                                      mon("         STD   $4706                   ; B167: FD 47 06      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4706, A); // Care needed with I/O space and word fetches
    wr_mem(0x4707, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $5042                   ; B16A: FC 50 42      \n");
                                      #endif // YT2
    clockticks = clockticks + 5; 
    A = rd_mem(0x5042); // Care needed with I/O space and word fetches
    B = rd_mem(0x5043); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  <$03                    ; B16D: 93 03         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x03)<<8; 
    ea = ea | rd_mem(DP|0x04); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4704                   ; B16F: FD 47 04      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4704, A); // Care needed with I/O space and word fetches
    wr_mem(0x4705, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$05                    ; B172: DC 05         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x05); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x06); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5044                   ; B174: B3 50 44      \n");
                                      #endif // ZT2
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5044)<<8; 
    ea = ea | rd_mem(0x5045); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5004                   ; B177: FD 50 04      \n");
                                      #endif // Math result Z
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5004, A); // Care needed with I/O space and word fetches
    wr_mem(0x5005, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$01                    ; B17A: DC 01         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x01); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x02); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5040                   ; B17C: B3 50 40      \n");
                                      #endif // XT2
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5040)<<8; 
    ea = ea | rd_mem(0x5041); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5002                   ; B17F: FD 50 02      \n");
                                      #endif // Math result Y
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5002, A); // Care needed with I/O space and word fetches
    wr_mem(0x5003, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $4700                   ; B182: FC 47 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x4700); // Care needed with I/O space and word fetches
    B = rd_mem(0x4701); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5000                   ; B185: FD 50 00      \n");
                                      #endif // Math result X
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5000, A); // Care needed with I/O space and word fetches
    wr_mem(0x5001, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$86                    ; B188: 86 86         \n");
                                      #endif // Reg02 = Reg02 x Reg00
    clockticks = clockticks + 2; 
    val = (UINT8)0x86; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCDBA                   ; B18A: BD CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x8d); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb1); 
    clockticks = clockticks + 1; 
    goto LCDBA;
  case 0xB18D:
LB18D:
                                                     #ifdef DEBUG
                                      mon("LB18D    LDD   <$05                    ; B18D: DC 05         \n");
                                      #endif
    PC = 0xb18d; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x05); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x06); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5004                   ; B18F: B3 50 04      \n");
                                      #endif // Math result Z
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5004)<<8; 
    ea = ea | rd_mem(0x5005); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BMI   LB19E                   ; B192: 2B 0A         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LB19E;
    }
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$00                    ; B194: 10 83 00 00   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x0000; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         LBGT  locret_B260             ; B198: 10 2E 00 C4   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 1; 
    goto LB260;
    }
                                                     #ifdef DEBUG
                                      mon("         BRA   LB1A6                   ; B19C: 20 08         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LB1A6;
    
    // ---------------------------------------------------------------------------
  case 0xB19E:
LB19E:
                                                     #ifdef DEBUG
                                      mon("LB19E    CMPD  #$F000                  ; B19E: 10 83 F0 00   \n");
                                      #endif
    PC = 0xb19e; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0xf000; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         LBLT  locret_B260             ; B1A2: 10 2D 00 BA   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 1; 
    goto LB260;
    }
  case 0xB1A6:
LB1A6:
                                                     #ifdef DEBUG
                                      mon("LB1A6    STD   <$05                    ; B1A6: DD 05         \n");
                                      #endif
    PC = 0xb1a6; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x05; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$1000                  ; B1A8: C3 10 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x1000; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$BE                    ; B1AB: DD BE         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0xbe; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$01                    ; B1AD: DC 01         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x01); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x02); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5002                   ; B1AF: B3 50 02      \n");
                                      #endif // Math result Y
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5002)<<8; 
    ea = ea | rd_mem(0x5003); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$01                    ; B1B2: DD 01         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x01; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   <$C0                    ; B1B4: DD C0         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0xc0; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$FC00                  ; B1B6: CC FC 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xfc; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$03                    ; B1B9: DD 03         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x03; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$FF                    ; B1BB: 86 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xff; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$BD                    ; B1BD: 97 BD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xbd; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$09                    ; B1BF: 86 09         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x09; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B23                   ; B1C1: B7 4B 23      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b23, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$01                    ; B1C4: 96 01         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x01); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBA  $5040                   ; B1C6: B0 50 40      \n");
                                      #endif // XT2
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    arg = rd_mem(0x5040); 
    res = val - (UINT8)arg; 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)(res); 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$03                    ; B1C9: C6 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x03; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         MUL                           ; B1CB: 3D            \n");
                                      #endif
    res = (UINT16)(A * B); 
 // Z = res; 
 // C = res & 0x80; 
    A = res >> 8; 
    B = (UINT8)res; 
    clockticks = clockticks + 11; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$E0                    ; B1CC: 10 83 00 E0   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x00e0; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LB1D4                   ; B1D0: 25 02         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LB1D4;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   #$E0                    ; B1D2: C6 E0         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xe0; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xB1D4:
LB1D4:
                                                     #ifdef DEBUG
                                      mon("LB1D4    STB   $4B22                   ; B1D4: F7 4B 22      \n");
                                      #endif
    PC = 0xb1d4; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b22, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$6280                  ; B1D7: CC 62 80      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x62; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B20                   ; B1DA: FD 4B 20      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4b20, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b21, B); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4989                  ; B1DD: 8E 49 89      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x4989; 
    Z = X; 
    N = (X) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JMP   LB261                   ; B1E0: 7E B2 61      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LB261;
    
    // ---------------------------------------------------------------------------
  case 0xB1E3:
LB1E3:
                                                     #ifdef DEBUG
                                      mon("LB1E3    SUBD  #$0400                  ; B1E3: 83 04 00      \n");
                                      #endif
    PC = 0xb1e3; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = 0x0400; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BLT   locret_B260             ; B1E6: 2D 78         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 3; 
    goto LB260;
    }
                                                     #ifdef DEBUG
                                      mon("         STD   $4706                   ; B1E8: FD 47 06      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4706, A); // Care needed with I/O space and word fetches
    wr_mem(0x4707, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$03                    ; B1EB: DC 03         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x03); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x04); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5042                   ; B1ED: B3 50 42      \n");
                                      #endif // YT2
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5042)<<8; 
    ea = ea | rd_mem(0x5043); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4704                   ; B1F0: FD 47 04      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4704, A); // Care needed with I/O space and word fetches
    wr_mem(0x4705, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$05                    ; B1F3: DC 05         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x05); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x06); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5044                   ; B1F5: B3 50 44      \n");
                                      #endif // ZT2
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5044)<<8; 
    ea = ea | rd_mem(0x5045); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5004                   ; B1F8: FD 50 04      \n");
                                      #endif // Math result Z
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5004, A); // Care needed with I/O space and word fetches
    wr_mem(0x5005, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$01                    ; B1FB: DC 01         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x01); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x02); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5040                   ; B1FD: B3 50 40      \n");
                                      #endif // XT2
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5040)<<8; 
    ea = ea | rd_mem(0x5041); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5002                   ; B200: FD 50 02      \n");
                                      #endif // Math result Y
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5002, A); // Care needed with I/O space and word fetches
    wr_mem(0x5003, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $4700                   ; B203: FC 47 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x4700); // Care needed with I/O space and word fetches
    B = rd_mem(0x4701); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5000                   ; B206: FD 50 00      \n");
                                      #endif // Math result X
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5000, A); // Care needed with I/O space and word fetches
    wr_mem(0x5001, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$86                    ; B209: 86 86         \n");
                                      #endif // Reg02 = Reg02 x Reg00
    clockticks = clockticks + 2; 
    val = (UINT8)0x86; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCDBA                   ; B20B: BD CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x0e); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb2); 
    clockticks = clockticks + 1; 
    goto LCDBA;
  case 0xB20E:
LB20E:
                                                     #ifdef DEBUG
                                      mon("LB20E    LDD   <$05                    ; B20E: DC 05         \n");
                                      #endif
    PC = 0xb20e; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x05); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x06); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5004                   ; B210: B3 50 04      \n");
                                      #endif // Math result Z
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5004)<<8; 
    ea = ea | rd_mem(0x5005); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BMI   LB21D                   ; B213: 2B 08         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LB21D;
    }
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$00                    ; B215: 10 83 00 00   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x0000; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BGT   locret_B260             ; B219: 2E 45         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto LB260;
    }
                                                     #ifdef DEBUG
                                      mon("         BRA   LB223                   ; B21B: 20 06         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LB223;
    
    // ---------------------------------------------------------------------------
  case 0xB21D:
LB21D:
                                                     #ifdef DEBUG
                                      mon("LB21D    CMPD  #$F000                  ; B21D: 10 83 F0 00   \n");
                                      #endif
    PC = 0xb21d; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0xf000; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BLT   locret_B260             ; B221: 2D 3D         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 3; 
    goto LB260;
    }
  case 0xB223:
LB223:
                                                     #ifdef DEBUG
                                      mon("LB223    STD   <$05                    ; B223: DD 05         \n");
                                      #endif
    PC = 0xb223; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x05; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$1000                  ; B225: C3 10 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x1000; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$BE                    ; B228: DD BE         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0xbe; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$01                    ; B22A: DC 01         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x01); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x02); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5002                   ; B22C: B3 50 02      \n");
                                      #endif // Math result Y
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5002)<<8; 
    ea = ea | rd_mem(0x5003); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$01                    ; B22F: DD 01         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x01; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   <$C0                    ; B231: DD C0         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0xc0; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0400                  ; B233: CC 04 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x04; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$03                    ; B236: DD 03         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x03; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$FF                    ; B238: 86 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xff; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$BD                    ; B23A: 97 BD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xbd; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$06                    ; B23C: 86 06         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x06; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B23                   ; B23E: B7 4B 23      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b23, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$01                    ; B241: 96 01         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x01); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBA  $5040                   ; B243: B0 50 40      \n");
                                      #endif // XT2
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    arg = rd_mem(0x5040); 
    res = val - (UINT8)arg; 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)(res); 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$03                    ; B246: C6 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x03; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         MUL                           ; B248: 3D            \n");
                                      #endif
    res = (UINT16)(A * B); 
 // Z = res; 
 // C = res & 0x80; 
    A = res >> 8; 
    B = (UINT8)res; 
    clockticks = clockticks + 11; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$E0                    ; B249: 10 83 00 E0   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x00e0; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LB251                   ; B24D: 25 02         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LB251;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   #$E0                    ; B24F: C6 E0         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xe0; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xB251:
LB251:
                                                     #ifdef DEBUG
                                      mon("LB251    STB   $4B22                   ; B251: F7 4B 22      \n");
                                      #endif
    PC = 0xb251; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b22, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$6280                  ; B254: CC 62 80      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x62; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B20                   ; B257: FD 4B 20      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4b20, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b21, B); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4999                  ; B25A: 8E 49 99      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x4999; 
    Z = X; 
    N = (X) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JMP   LB261                   ; B25D: 7E B2 61      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LB261;
    
    // ---------------------------------------------------------------------------
  case 0xB260:
LB260:
locret_B260:
                                                     #ifdef DEBUG
                                      mon("locret_B260 RTS                           ; B260: 39            \n");
                                      #endif
    PC = 0xb260; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
  case 0xB261:
LB261:
                                                     #ifdef DEBUG
                                      mon("LB261    LDA   <$BC                    ; B261: 96 BC         \n");
                                      #endif
    PC = 0xb261; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xbc); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LB266                   ; B263: 26 01         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LB266;
    }
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; B265: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
  case 0xB266:
LB266:
                                                     #ifdef DEBUG
                                      mon("LB266    LDB   <$C0                    ; B266: D6 C0         \n");
                                      #endif
    PC = 0xb266; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xc0); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LSRB                          ; B268: 54            \n");
                                      #endif
    val = (UINT8)B; 
 // C = val & 1; 
    val = val >> 1; 
    B = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRB                          ; B269: 54            \n");
                                      #endif
    val = (UINT8)B; 
 // C = val & 1; 
    val = val >> 1; 
    B = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRB                          ; B26A: 54            \n");
                                      #endif
    val = (UINT8)B; 
 // C = val & 1; 
    val = val >> 1; 
    B = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$0F                    ; B26B: C4 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x0f; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; B26D: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$C0                    ; B26E: DC C0         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0xc0); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0xc1); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$07                    ; B270: 84 07         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x07; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$01C0                  ; B272: 83 01 C0      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x01c0; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BLT   locret_B29B             ; B275: 2D 24         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 3; 
    goto LB29B;
    }
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$0480                  ; B277: 83 04 80      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0480; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BGT   locret_B29B             ; B27A: 2E 1F         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto LB29B;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$03                    ; B27C: 86 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x03; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$01                    ; B27E: 97 01         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x01; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$BE                    ; B280: DC BE         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0xbe); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0xbf); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$40                    ; B282: 83 00 40      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0040; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
  case 0xB285:
LB285:
                                                     #ifdef DEBUG
                                      mon("LB285    SUBD  #$0380                  ; B285: 83 03 80      \n");
                                      #endif
    PC = 0xb285; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = 0x0380; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BGT   LB292                   ; B288: 2E 08         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto LB292;
    }
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$FC80                  ; B28A: 83 FC 80      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0xfc80; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BLT   locret_B29B             ; B28D: 2D 0C         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 3; 
    goto LB29B;
    }
                                                     #ifdef DEBUG
                                      mon("         JMP   LB29C                   ; B28F: 7E B2 9C      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LB29C;
    
    // ---------------------------------------------------------------------------
  case 0xB292:
LB292:
                                                     #ifdef DEBUG
                                      mon("LB292    SUBD  #$80                    ; B292: 83 00 80      \n");
                                      #endif
    PC = 0xb292; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = 0x0080; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         ASL   <$01                    ; B295: 08 01         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x01); 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    wr_mem(DP|0x01, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASL   <$01                    ; B297: 08 01         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x01); 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
    Z = res; 
    N = res; 
    V = val ^ res; 
    wr_mem(DP|0x01, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LB285                   ; B299: 26 EA         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LB285;
    }
  case 0xB29B:
LB29B:
locret_B29B:
                                                     #ifdef DEBUG
                                      mon("locret_B29B RTS                           ; B29B: 39            \n");
                                      #endif
    PC = 0xb29b; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
  case 0xB29C:
LB29C:
                                                     #ifdef DEBUG
                                      mon("LB29C    LDA   <$01                    ; B29C: 96 01         \n");
                                      #endif
    PC = 0xb29c; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x01); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  ,X                      ; B29E: A4 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)A; 
    res = val & rd_mem(X); 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   locret_B2D1             ; B2A0: 27 2F         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LB2D1;
    }
                                                     #ifdef DEBUG
                                      mon("         STA   <$02                    ; B2A2: 97 02         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x02; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$01                    ; B2A4: 96 01         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x01); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLA                          ; B2A6: 48            \n");
                                      #endif
    val = (UINT8)A; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  <$01                    ; B2A7: 94 01         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)A; 
    res = val & rd_mem(DP|0x01); 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  <$02                    ; B2A9: 91 02         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)A; 
    arg = rd_mem(DP|0x02); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BEQ   locret_B2D1             ; B2AB: 27 24         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LB2D1;
    }
                                                     #ifdef DEBUG
                                      mon("         BLS   LB2C1                   ; B2AD: 23 12         \n");
                                      #endif
    // temp hack to force a flush
    if ((!Z) || C) {
    clockticks = clockticks + 3; 
    goto LB2C1;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$04                    ; B2AF: 86 04         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x04; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$BD                    ; B2B1: 97 BD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xbd; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   ,X                      ; B2B3: A6 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(X); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         EORA  <$02                    ; B2B5: 98 02         \n");
                                      #endif
    clockticks = clockticks + 4; 
    res = A ^ rd_mem(DP|0x02); 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   ,X                      ; B2B7: A7 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = X; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   L97F2                   ; B2B9: BD 97 F2      \n");
                                      #endif // Trench green squares score
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xbc); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb2); 
    clockticks = clockticks + 1; 
    goto L97F2;
  case 0xB2BC:
LB2BC:
                                                     #ifdef DEBUG
                                      mon("LB2BC    JSR   Sound_35                ; B2BC: BD BD FD      \n");
                                      #endif
    PC = 0xb2bc; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xbf); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb2); 
    clockticks = clockticks + 1; 
    goto LBDFD;
  case 0xB2BF:
LB2BF:
                                                     #ifdef DEBUG
                                      mon("LB2BF    BRA   locret_B2D1             ; B2BF: 20 10         \n");
                                      #endif
    PC = 0xb2bf; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto LB2D1;
    
    // ---------------------------------------------------------------------------
  case 0xB2C1:
LB2C1:
                                                     #ifdef DEBUG
                                      mon("LB2C1    LDA   #$04                    ; B2C1: 86 04         \n");
                                      #endif
    PC = 0xb2c1; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x04; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$BD                    ; B2C3: 97 BD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xbd; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   ,X                      ; B2C5: A6 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(X); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         EORA  <$02                    ; B2C7: 98 02         \n");
                                      #endif
    clockticks = clockticks + 4; 
    res = A ^ rd_mem(DP|0x02); 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   ,X                      ; B2C9: A7 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = X; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   L97FC                   ; B2CB: BD 97 FC      \n");
                                      #endif // Trench turrets score
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xce); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb2); 
    clockticks = clockticks + 1; 
    goto L97FC;
  case 0xB2CE:
LB2CE:
                                                     #ifdef DEBUG
                                      mon("LB2CE    JSR   Sound_35                ; B2CE: BD BD FD      \n");
                                      #endif
    PC = 0xb2ce; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xd1); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb2); 
    clockticks = clockticks + 1; 
    goto LBDFD;
    // End of function sub_B095
  case 0xB2D1:
LB2D1:
locret_B2D1:
                                                     #ifdef DEBUG
                                      mon("locret_B2D1 RTS                           ; B2D1: 39            \n");
                                      #endif
    PC = 0xb2d1; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // FUNCTION CHUNK AT ROM:A54B SIZE 00000045 BYTES
  case 0xB2D2:
LB2D2:
                                                     #ifdef DEBUG
                                      mon("LB2D2    LDA   <$BC                    ; B2D2: 96 BC         \n");
                                      #endif
    PC = 0xb2d2; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xbc); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   locret_B2E3             ; B2D4: 27 0D         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LB2E3;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   <$CC                    ; B2D6: DC CC         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0xcc); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0xcd); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BMI   LB2E1                   ; B2D8: 2B 07         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LB2E1;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$04                    ; B2DA: 86 04         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x04; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$BD                    ; B2DC: 97 BD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0xbd; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LAD20                   ; B2DE: BD AD 20      \n");
                                      #endif // Fireball destroyed
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xe1); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb2); 
    clockticks = clockticks + 1; 
    goto LAD20;
  case 0xB2E1:
LB2E1:
                                                     #ifdef DEBUG
                                      mon("LB2E1    BRA   LB2E4                   ; B2E1: 20 01         \n");
                                      #endif
    PC = 0xb2e1; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto LB2E4;
    
    // ---------------------------------------------------------------------------
  case 0xB2E3:
LB2E3:
locret_B2E3:
                                                     #ifdef DEBUG
                                      mon("locret_B2E3 RTS                           ; B2E3: 39            \n");
                                      #endif
    PC = 0xb2e3; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
  case 0xB2E4:
LB2E4:
                                                     #ifdef DEBUG
                                      mon("LB2E4    LDD   <$C4                    ; B2E4: DC C4         \n");
                                      #endif
    PC = 0xb2e4; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0xc4); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0xc5); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BMI   LB2F8                   ; B2E6: 2B 10         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LB2F8;
    }
                                                     #ifdef DEBUG
                                      mon("         CMPD  <$C8                    ; B2E8: 10 93 C8      \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xc8)<<8; 
    ea = ea | rd_mem(DP|0xc9); 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = ea; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
    clockticks = clockticks + 1; 
                                                     #ifdef DEBUG
                                      mon("         BHI   LB2F8                   ; B2EB: 22 0B         \n");
                                      #endif
    // temp hack to force a flush
    if (Z && (!C)) {
    clockticks = clockticks + 3; 
    goto LB2F8;
    }
                                                     #ifdef DEBUG
                                      mon("         SUBD  <$D0                    ; B2ED: 93 D0         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xd0)<<8; 
    ea = ea | rd_mem(DP|0xd1); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BHI   LB307                   ; B2EF: 22 16         \n");
                                      #endif
    // temp hack to force a flush
    if (Z && (!C)) {
    clockticks = clockticks + 3; 
    goto LB307;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$04                    ; B2F1: 86 04         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x04; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$BD                    ; B2F3: 97 BD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0xbd; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         JMP   L8ACF                   ; B2F5: 7E 8A CF      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto L8ACF;
    
    // ---------------------------------------------------------------------------
  case 0xB2F8:
LB2F8:
                                                     #ifdef DEBUG
                                      mon("LB2F8    LDD   <$C8                    ; B2F8: DC C8         \n");
                                      #endif
    PC = 0xb2f8; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0xc8); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0xc9); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BMI   LB307                   ; B2FA: 2B 0B         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LB307;
    }
                                                     #ifdef DEBUG
                                      mon("         SUBD  <$D0                    ; B2FC: 93 D0         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xd0)<<8; 
    ea = ea | rd_mem(DP|0xd1); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BHI   LB307                   ; B2FE: 22 07         \n");
                                      #endif
    // temp hack to force a flush
    if (Z && (!C)) {
    clockticks = clockticks + 3; 
    goto LB307;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$04                    ; B300: 86 04         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x04; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$BD                    ; B302: 97 BD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0xbd; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         JMP   LA54B                   ; B304: 7E A5 4B      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LA54B;
    
    // ---------------------------------------------------------------------------
  case 0xB307:
LB307:
                                                     #ifdef DEBUG
                                      mon("LB307    LDD   <$D0                    ; B307: DC D0         \n");
                                      #endif
    PC = 0xb307; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0xd0); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0xd1); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BMI   locret_B32A             ; B309: 2B 1F         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LB32A;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$FF                    ; B30B: 86 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xff; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$BD                    ; B30D: 97 BD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xbd; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$0F                    ; B30F: 86 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x0f; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B23                   ; B311: B7 4B 23      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b23, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$D0                    ; B314: 96 D0         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xd0); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$03                    ; B316: C6 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x03; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         MUL                           ; B318: 3D            \n");
                                      #endif
    res = (UINT16)(A * B); 
 // Z = res; 
 // C = res & 0x80; 
    A = res >> 8; 
    B = (UINT8)res; 
    clockticks = clockticks + 11; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$E0                    ; B319: 10 83 00 E0   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x00e0; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LB321                   ; B31D: 25 02         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LB321;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   #$E0                    ; B31F: C6 E0         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xe0; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xB321:
LB321:
                                                     #ifdef DEBUG
                                      mon("LB321    STB   $4B22                   ; B321: F7 4B 22      \n");
                                      #endif
    PC = 0xb321; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b22, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$6680                  ; B324: CC 66 80      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x66; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B20                   ; B327: FD 4B 20      \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x4b20, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b21, B); 
    // End of function sub_B2D2
  case 0xB32A:
LB32A:
locret_B32A:
                                                     #ifdef DEBUG
                                      mon("locret_B32A RTS                           ; B32A: 39            \n");
                                      #endif
    PC = 0xb32a; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // FUNCTION CHUNK AT ROM:8ACF SIZE 0000009E BYTES
  case 0xB32B:
LB32B:
                                                     #ifdef DEBUG
                                      mon("LB32B    LDA   <$BC                    ; B32B: 96 BC         \n");
                                      #endif
    PC = 0xb32b; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xbc); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   locret_B33D             ; B32D: 27 0E         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LB33D;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   <$CC                    ; B32F: DC CC         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0xcc); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0xcd); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BMI   LB339                   ; B331: 2B 06         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LB339;
    }
                                                     #ifdef DEBUG
                                      mon("         SUBD  <$C4                    ; B333: 93 C4         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xc4)<<8; 
    ea = ea | rd_mem(DP|0xc5); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LB33E                   ; B335: 25 07         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LB33E;
    }
                                                     #ifdef DEBUG
                                      mon("         BRA   LB345                   ; B337: 20 0C         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LB345;
    
    // ---------------------------------------------------------------------------
  case 0xB339:
LB339:
                                                     #ifdef DEBUG
                                      mon("LB339    LDA   <$C4                    ; B339: 96 C4         \n");
                                      #endif
    PC = 0xb339; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xc4); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BGE   LB345                   ; B33B: 2C 08         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) >= 0) {
    clockticks = clockticks + 3; 
    goto LB345;
    }
  case 0xB33D:
LB33D:
locret_B33D:
                                                     #ifdef DEBUG
                                      mon("locret_B33D RTS                           ; B33D: 39            \n");
                                      #endif
    PC = 0xb33d; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
  case 0xB33E:
LB33E:
                                                     #ifdef DEBUG
                                      mon("LB33E    LDA   #$04                    ; B33E: 86 04         \n");
                                      #endif
    PC = 0xb33e; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x04; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$BD                    ; B340: 97 BD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0xbd; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         JMP   LAD20                   ; B342: 7E AD 20      \n");
                                      #endif // Fireball destroyed
    clockticks = clockticks + 4; 
    goto LAD20;
    
    // ---------------------------------------------------------------------------
  case 0xB345:
LB345:
                                                     #ifdef DEBUG
                                      mon("LB345    LDA   #$04                    ; B345: 86 04         \n");
                                      #endif
    PC = 0xb345; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x04; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$BD                    ; B347: 97 BD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0xbd; 
    wr_mem(ea, val); 
    // End of function sub_B32B
    // ---------------------------------------------------------------------------
                                                     #ifdef DEBUG
                                      mon("         JMP   L8ACF                   ; B349: 7E 8A CF      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto L8ACF;
    
                   // FCB   $28                     ; B3CB:  '(' 28 41          BVC   $B40E ; 
                   // FCB   $41                     ; B3CC:  'A' 41             Invalid ; 
                   // FCB   $4C                     ; B3CD:  'L' 4C             INCA  ; 
                   // FCB   $4C                     ; B3CE:  'L' 4C             INCA  ; 
                   // FCB   $59                     ; B3CF:  'Y' 59             ROLB  ; 
                   // FCB   $20                     ; B3D0:  ' ' 20 57          BRA   $B429 ; 
                   // FCB   $57                     ; B3D1:  'W' 57             ASRB  ; 
                   // FCB   $41                     ; B3D2:  'A' 41             Invalid ; 
                   // FCB   $53                     ; B3D3:  'S' 53             COMB  ; 
                   // FCB   $20                     ; B3D4:  ' ' 20 54          BRA   $B42A ; 
                   // FCB   $54                     ; B3D5:  'T' 54             LSRB  ; 
                   // FCB   $48                     ; B3D6:  'H' 48             ASLA  ; 
                   // FCB   $45                     ; B3D7:  'E' 45             Invalid ; 
                   // FCB   $20                     ; B3D8:  ' ' 20 57          BRA   $B431 ; 
                   // FCB   $57                     ; B3D9:  'W' 57             ASRB  ; 
                   // FCB   $48                     ; B3DA:  'H' 48             ASLA  ; 
                   // FCB   $49                     ; B3DB:  'I' 49             ROLA  ; 
                   // FCB   $50                     ; B3DC:  'P' 50             NEGB  ; 
                   // FCB   $43                     ; B3DD:  'C' 43             COMA  ; 
                   // FCB   $52                     ; B3DE:  'R' 52             Invalid ; 
                   // FCB   $41                     ; B3DF:  'A' 41             Invalid ; 
                   // FCB   $43                     ; B3E0:  'C' 43             COMA  ; 
                   // FCB   $4B                     ; B3E1:  'K' 4B             Invalid ; 
                   // FCB   $45                     ; B3E2:  'E' 45             Invalid ; 
                   // FCB   $52                     ; B3E3:  'R' 52             Invalid ; 
    // =============== S U B R O U T I N E =======================================
  case 0xB3E4:
LB3E4:
                                                     #ifdef DEBUG
                                      mon("LB3E4    LDA   $49C0                   ; B3E4: B6 49 C0      \n");
                                      #endif
    PC = 0xb3e4; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x49c0); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
    // End of function sub_B3E4
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$03                    ; B3E7: 81 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x03; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
    // =============== S U B R O U T I N E =======================================
  case 0xB3E9:
LB3E9:
                                                     #ifdef DEBUG
                                      mon("LB3E9    BCS   LB3F0                   ; B3E9: 25 05         \n");
                                      #endif
    PC = 0xb3e9; 
    INSTRUCTION_START
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LB3F0;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; B3EB: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $49C0                   ; B3ED: B7 49 C0      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x49c0, val); 
  case 0xB3F0:
LB3F0:
                                                     #ifdef DEBUG
                                      mon("LB3F0    LDA   #$01                    ; B3F0: 86 01         \n");
                                      #endif
    PC = 0xb3f0; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x01; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$9C                    ; B3F2: 97 9C         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x9c; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$0B                    ; B3F4: 86 0B         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x0b; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$DC                    ; B3F6: 97 DC         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xdc; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   <$9D                    ; B3F8: 97 9D         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x9d; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCD38                   ; B3FA: BD CD 38      \n");
                                      #endif // Trench left side turret calcs
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xfd); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb3); 
    clockticks = clockticks + 1; 
    goto LCD38;
  case 0xB3FD:
LB3FD:
                                                     #ifdef DEBUG
                                      mon("LB3FD    JSR   LB43F                   ; B3FD: BD B4 3F      \n");
                                      #endif
    PC = 0xb3fd; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x00); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb4); 
    clockticks = clockticks + 1; 
    goto LB43F;
  case 0xB400:
LB400:
                                                     #ifdef DEBUG
                                      mon("LB400    LDA   <$9D                    ; B400: 96 9D         \n");
                                      #endif
    PC = 0xb400; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x9d); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$DC                    ; B402: 97 DC         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xdc; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCD44                   ; B404: BD CD 44      \n");
                                      #endif // Trench right side turret calcs
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x07); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb4); 
    clockticks = clockticks + 1; 
    goto LCD44;
  case 0xB407:
LB407:
                                                     #ifdef DEBUG
                                      mon("LB407    JSR   LB579                   ; B407: BD B5 79      \n");
                                      #endif
    PC = 0xb407; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x0a); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb4); 
    clockticks = clockticks + 1; 
    goto LB579;
  case 0xB40A:
LB40A:
                                                     #ifdef DEBUG
                                      mon("LB40A    LDA   #$02                    ; B40A: 86 02         \n");
                                      #endif
    PC = 0xb40a; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x02; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$9C                    ; B40C: 97 9C         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x9c; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$0E                    ; B40E: 86 0E         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x0e; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$DC                    ; B410: 97 DC         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xdc; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   <$9D                    ; B412: 97 9D         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x9d; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCD38                   ; B414: BD CD 38      \n");
                                      #endif // Trench left side turret calcs
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x17); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb4); 
    clockticks = clockticks + 1; 
    goto LCD38;
  case 0xB417:
LB417:
                                                     #ifdef DEBUG
                                      mon("LB417    JSR   LB43F                   ; B417: BD B4 3F      \n");
                                      #endif
    PC = 0xb417; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x1a); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb4); 
    clockticks = clockticks + 1; 
    goto LB43F;
  case 0xB41A:
LB41A:
                                                     #ifdef DEBUG
                                      mon("LB41A    LDA   <$9D                    ; B41A: 96 9D         \n");
                                      #endif
    PC = 0xb41a; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x9d); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$DC                    ; B41C: 97 DC         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xdc; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCD44                   ; B41E: BD CD 44      \n");
                                      #endif // Trench right side turret calcs
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x21); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb4); 
    clockticks = clockticks + 1; 
    goto LCD44;
  case 0xB421:
LB421:
                                                     #ifdef DEBUG
                                      mon("LB421    JSR   LB579                   ; B421: BD B5 79      \n");
                                      #endif
    PC = 0xb421; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x24); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb4); 
    clockticks = clockticks + 1; 
    goto LB579;
  case 0xB424:
LB424:
                                                     #ifdef DEBUG
                                      mon("LB424    LDA   #$03                    ; B424: 86 03         \n");
                                      #endif
    PC = 0xb424; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x03; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$9C                    ; B426: 97 9C         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x9c; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$0C                    ; B428: 86 0C         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x0c; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$DC                    ; B42A: 97 DC         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xdc; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   <$9D                    ; B42C: 97 9D         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x9d; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCD38                   ; B42E: BD CD 38      \n");
                                      #endif // Trench left side turret calcs
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x31); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb4); 
    clockticks = clockticks + 1; 
    goto LCD38;
  case 0xB431:
LB431:
                                                     #ifdef DEBUG
                                      mon("LB431    JSR   LB43F                   ; B431: BD B4 3F      \n");
                                      #endif
    PC = 0xb431; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x34); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb4); 
    clockticks = clockticks + 1; 
    goto LB43F;
  case 0xB434:
LB434:
                                                     #ifdef DEBUG
                                      mon("LB434    LDA   <$9D                    ; B434: 96 9D         \n");
                                      #endif
    PC = 0xb434; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x9d); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$DC                    ; B436: 97 DC         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0xdc; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCD44                   ; B438: BD CD 44      \n");
                                      #endif // Trench right side turret calcs
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x3b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb4); 
    clockticks = clockticks + 1; 
    goto LCD44;
  case 0xB43B:
LB43B:
                                                     #ifdef DEBUG
                                      mon("LB43B    JSR   LB579                   ; B43B: BD B5 79      \n");
                                      #endif
    PC = 0xb43b; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x3e); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb4); 
    clockticks = clockticks + 1; 
    goto LB579;
    // End of function sub_B3E9
  case 0xB43E:
LB43E:
                                                     #ifdef DEBUG
                                      mon("LB43E    RTS                           ; B43E: 39            \n");
                                      #endif
    PC = 0xb43e; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xB43F:
LB43F:
                                                     #ifdef DEBUG
                                      mon("LB43F    LDA   #$00                    ; B43F: 86 00         \n");
                                      #endif // Trench
    PC = 0xb43f; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $49BD                   ; B441: B7 49 BD      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x49bd, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $49C0                   ; B444: B6 49 C0      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x49c0); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $49BE                   ; B447: B7 49 BE      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x49be, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$88                    ; B44A: 86 88         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x88; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $49C1                   ; B44C: B7 49 C1      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x49c1, val); 
                                                     #ifdef DEBUG
                                      mon("         LDB   $5040                   ; B44F: F6 50 40      \n");
                                      #endif // XT2
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x5040); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LSRB                          ; B452: 54            \n");
                                      #endif
    val = (UINT8)B; 
 // C = val & 1; 
    val = val >> 1; 
    B = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRB                          ; B453: 54            \n");
                                      #endif
    val = (UINT8)B; 
 // C = val & 1; 
    val = val >> 1; 
    B = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRB                          ; B454: 54            \n");
                                      #endif
    val = (UINT8)B; 
 // C = val & 1; 
    val = val >> 1; 
    B = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$0F                    ; B455: C4 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x0f; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4989                  ; B457: 8E 49 89      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x4989; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; B45A: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         STX   <$64                    ; B45B: 9F 64         \n");
                                      #endif // Pointer to Tie fighter data
    clockticks = clockticks + 4; 
    val = X; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = DP|0x64; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $5040                   ; B45D: B6 50 40      \n");
                                      #endif // XT2
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x5040); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$F8                    ; B460: 84 F8         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0xf8; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDA  #$04                    ; B462: 8B 04         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x04; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$00                    ; B464: C6 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5078                   ; B466: FD 50 78      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5078, A); // Care needed with I/O space and word fetches
    wr_mem(0x5079, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$FC00                  ; B469: CC FC 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xfc; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $507A                   ; B46C: FD 50 7A      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x507a, A); // Care needed with I/O space and word fetches
    wr_mem(0x507b, B); 
  case 0xB46F:
LB46F:
                                                     #ifdef DEBUG
                                      mon("LB46F    LDD   #$F200                  ; B46F: CC F2 00      \n");
                                      #endif
    PC = 0xb46f; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0xf2; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $507C                   ; B472: FD 50 7C      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x507c, A); // Care needed with I/O space and word fetches
    wr_mem(0x507d, B); 
                                                     #ifdef DEBUG
                                      mon("         LDX   <$64                    ; B475: 9E 64         \n");
                                      #endif // Pointer to Tie fighter data
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x64)<<8; 
    ea = ea | rd_mem(DP|0x65); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$4999                  ; B477: 8C 49 99      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x4999; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LB47F                   ; B47A: 25 03         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LB47F;
    }
                                                     #ifdef DEBUG
                                      mon("         LEAX  -$10,X                  ; B47C: 30 88 F0      \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + (SINT8)0xf0); 
 // Z = X; 
  case 0xB47F:
LB47F:
                                                     #ifdef DEBUG
                                      mon("LB47F    LDA   ,X+                     ; B47F: A6 80         \n");
                                      #endif
    PC = 0xb47f; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    val = (UINT8)rd_mem(X); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
    X = X + 1; 
                                                     #ifdef DEBUG
                                      mon("         STX   <$64                    ; B481: 9F 64         \n");
                                      #endif // Pointer to Tie fighter data
    clockticks = clockticks + 4; 
    val = X; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = DP|0x64; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
  case 0xB483:
LB483:
                                                     #ifdef DEBUG
                                      mon("LB483    STA   <$9E                    ; B483: 97 9E         \n");
                                      #endif
    PC = 0xb483; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x9e; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$03                    ; B485: 84 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x03; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  <$9C                    ; B487: 91 9C         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)A; 
    arg = rd_mem(DP|0x9c); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         LBNE  LB516                   ; B489: 10 26 00 89   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if (Z) {
    clockticks = clockticks + 1; 
    goto LB516;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   <$9D                    ; B48D: 96 9D         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x9d); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$DC                    ; B48F: 97 DC         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xdc; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0F                    ; B491: CC 00 0F      \n");
                                      #endif // Point BIC to $5078 MReg3C
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x0f; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4701                   ; B494: FD 47 01      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4701, A); // Care needed with I/O space and word fetches
    wr_mem(0x4702, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$67                    ; B497: 86 67         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x67; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCDBA                   ; B499: BD CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x9c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb4); 
    clockticks = clockticks + 1; 
    goto LCDBA;
  case 0xB49C:
LB49C:
                                                     #ifdef DEBUG
                                      mon("LB49C    LDA   <$9C                    ; B49C: 96 9C         \n");
                                      #endif
    PC = 0xb49c; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x9c); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$02                    ; B49E: 81 02         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x02; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   LB4B5                   ; B4A0: 26 13         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LB4B5;
    }
                                                     #ifdef DEBUG
                                      mon("         INC   $49BD                   ; B4A2: 7C 49 BD      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x49bd); 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    wr_mem(0x49bd, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $49BE                   ; B4A5: F6 49 BE      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x49be); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; B4A8: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #word_B6B3              ; B4A9: 8E B6 B3      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0xb6b3; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   B,X                     ; B4AC: EC 85         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + (SINT8)B); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; B4AE: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $49C1                   ; B4B0: B6 49 C1      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x49c1); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   -1,Y                    ; B4B3: A7 3F         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(Y + 0xffff); 
    wr_mem(ea, val); 
  case 0xB4B5:
LB4B5:
                                                     #ifdef DEBUG
                                      mon("LB4B5    LDD   $5078                   ; B4B5: FC 50 78      \n");
                                      #endif
    PC = 0xb4b5; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x5078); // Care needed with I/O space and word fetches
    B = rd_mem(0x5079); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5040                   ; B4B8: B3 50 40      \n");
                                      #endif // XT2
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5040)<<8; 
    ea = ea | rd_mem(0x5041); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$1000                  ; B4BB: 10 83 10 00   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x1000; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BGT   LB510                   ; B4BF: 2E 4F         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto LB510;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   <$9D                    ; B4C1: 96 9D         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x9d); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$0E                    ; B4C3: 81 0E         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x0e; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   LB50B                   ; B4C5: 26 44         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LB50B;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $5000                   ; B4C7: FC 50 00      \n");
                                      #endif // Math result X
    clockticks = clockticks + 5; 
    A = rd_mem(0x5000); // Care needed with I/O space and word fetches
    B = rd_mem(0x5001); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$00                    ; B4CA: 83 00 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0000; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BLT   LB516                   ; B4CD: 2D 47         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 3; 
    goto LB516;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $5042                   ; B4CF: FC 50 42      \n");
                                      #endif // YT2
    clockticks = clockticks + 5; 
    A = rd_mem(0x5042); // Care needed with I/O space and word fetches
    B = rd_mem(0x5043); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BGT   LB50B                   ; B4D2: 2E 37         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto LB50B;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $507C                   ; B4D4: FC 50 7C      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x507c); // Care needed with I/O space and word fetches
    B = rd_mem(0x507d); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$0200                  ; B4D7: C3 02 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0200; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5044                   ; B4DA: B3 50 44      \n");
                                      #endif // ZT2
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5044)<<8; 
    ea = ea | rd_mem(0x5045); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BLT   LB50B                   ; B4DD: 2D 2C         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 3; 
    goto LB50B;
    }
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$0400                  ; B4DF: 83 04 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0400; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BGT   LB50B                   ; B4E2: 2E 27         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto LB50B;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $5078                   ; B4E4: FC 50 78      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x5078); // Care needed with I/O space and word fetches
    B = rd_mem(0x5079); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5040                   ; B4E7: B3 50 40      \n");
                                      #endif // XT2
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5040)<<8; 
    ea = ea | rd_mem(0x5041); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$0400                  ; B4EA: 83 04 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0400; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BHI   LB50B                   ; B4ED: 22 1C         \n");
                                      #endif
    // temp hack to force a flush
    if (Z && (!C)) {
    clockticks = clockticks + 3; 
    goto LB50B;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$0F                    ; B4EF: 86 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x0f; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$DC                    ; B4F1: 97 DC         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xdc; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$60                    ; B4F3: 96 60         \n");
                                      #endif // Shield count
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x60); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BLT   LB4FD                   ; B4F5: 2D 06         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 3; 
    goto LB4FD;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   L9874                   ; B4F7: BD 98 74      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xfa); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb4); 
    clockticks = clockticks + 1; 
    goto L9874;
  case 0xB4FA:
LB4FA:
                                                     #ifdef DEBUG
                                      mon("LB4FA    JSR   Sound_26                ; B4FA: BD BD B2      \n");
                                      #endif // Explosion
    PC = 0xb4fa; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xfd); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb4); 
    clockticks = clockticks + 1; 
    goto LBDB2;
  case 0xB4FD:
LB4FD:
                                                     #ifdef DEBUG
                                      mon("LB4FD    LDA   <$63                    ; B4FD: 96 63         \n");
                                      #endif
    PC = 0xb4fd; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x63); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LB50B                   ; B4FF: 26 0A         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LB50B;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$4E                    ; B501: 86 4E         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x4e; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $4703                   ; B503: F6 47 03      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LB509                   ; B506: 2A 01         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LB509;
    }
                                                     #ifdef DEBUG
                                      mon("         NEGA                          ; B508: 40            \n");
                                      #endif
    val = (UINT8)A; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
  case 0xB509:
LB509:
                                                     #ifdef DEBUG
                                      mon("LB509    STA   <$63                    ; B509: 97 63         \n");
                                      #endif
    PC = 0xb509; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0x63; 
    wr_mem(ea, val); 
  case 0xB50B:
LB50B:
                                                     #ifdef DEBUG
                                      mon("LB50B    JSR   LCD5C                   ; B50B: BD CD 5C      \n");
                                      #endif // Trench calcs
    PC = 0xb50b; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x0e); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb5); 
    clockticks = clockticks + 1; 
    goto LCD5C;
  case 0xB50E:
LB50E:
                                                     #ifdef DEBUG
                                      mon("LB50E    BRA   LB513                   ; B50E: 20 03         \n");
                                      #endif
    PC = 0xb50e; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto LB513;
    
    // ---------------------------------------------------------------------------
  case 0xB510:
LB510:
                                                     #ifdef DEBUG
                                      mon("LB510    JSR   LCD50                   ; B510: BD CD 50      \n");
                                      #endif
    PC = 0xb510; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x13); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb5); 
    clockticks = clockticks + 1; 
    goto LCD50;
  case 0xB513:
LB513:
                                                     #ifdef DEBUG
                                      mon("LB513    JSR   LCD74                   ; B513: BD CD 74      \n");
                                      #endif // Function select for an object
    PC = 0xb513; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x16); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb5); 
    clockticks = clockticks + 1; 
    goto LCD74;
  case 0xB516:
LB516:
                                                     #ifdef DEBUG
                                      mon("LB516    LDD   $507C                   ; B516: FC 50 7C      \n");
                                      #endif
    PC = 0xb516; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x507c); // Care needed with I/O space and word fetches
    B = rd_mem(0x507d); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$0400                  ; B519: C3 04 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0400; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $507C                   ; B51C: FD 50 7C      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x507c, A); // Care needed with I/O space and word fetches
    wr_mem(0x507d, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$9E                    ; B51F: 96 9E         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x9e); 
    A = val; 
 // N = val; 
 // Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; B521: 44            \n");
                                      #endif
    val = (UINT8)A; 
 // C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; B522: 44            \n");
                                      #endif
    val = (UINT8)A; 
    C = val & 1; 
    val = val >> 1; 
    A = val; 
    N = 0; 
    Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LBNE  LB483                   ; B523: 10 26 FF 5C   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if (Z) {
    clockticks = clockticks + 1; 
    goto LB483;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   <$9C                    ; B527: 96 9C         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x9c); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$02                    ; B529: 81 02         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x02; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   LB565                   ; B52B: 26 38         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LB565;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   <$64                    ; B52D: 9E 64         \n");
                                      #endif // Pointer to Tie fighter data
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x64)<<8; 
    ea = ea | rd_mem(DP|0x65); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $000F,X                 ; B52F: A6 89 00 0F   \n");
                                      #endif
    clockticks = clockticks + 8; 
    val = (UINT8)rd_mem((UINT16)(X + 0x000f)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xB533:
LB533:
                                                     #ifdef DEBUG
                                      mon("LB533    ASLA                          ; B533: 48            \n");
                                      #endif
    PC = 0xb533; 
    INSTRUCTION_START
    val = (UINT8)A; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
    Z = res; 
    N = res; 
    V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BCC   LB53D                   ; B534: 24 07         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LB53D;
    }
                                                     #ifdef DEBUG
                                      mon("         BMI   LB53D                   ; B536: 2B 05         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LB53D;
    }
                                                     #ifdef DEBUG
                                      mon("         INC   $49BD                   ; B538: 7C 49 BD      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x49bd); 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    wr_mem(0x49bd, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LB540                   ; B53B: 20 03         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LB540;
    
    // ---------------------------------------------------------------------------
  case 0xB53D:
LB53D:
                                                     #ifdef DEBUG
                                      mon("LB53D    ASLA                          ; B53D: 48            \n");
                                      #endif
    PC = 0xb53d; 
    INSTRUCTION_START
    val = (UINT8)A; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
    Z = res; 
    N = res; 
    V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LB533                   ; B53E: 26 F3         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LB533;
    }
  case 0xB540:
LB540:
                                                     #ifdef DEBUG
                                      mon("LB540    LDA   $49BD                   ; B540: B6 49 BD      \n");
                                      #endif
    PC = 0xb540; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x49bd); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LB565                   ; B543: 27 20         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LB565;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $49BE                   ; B545: B6 49 BE      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x49be); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         INCA                          ; B548: 4C            \n");
                                      #endif
    val = (UINT8)A; 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$03                    ; B549: 81 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x03; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   LB54F                   ; B54B: 25 02         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LB54F;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; B54D: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xB54F:
LB54F:
                                                     #ifdef DEBUG
                                      mon("LB54F    STA   $49BE                   ; B54F: B7 49 BE      \n");
                                      #endif
    PC = 0xb54f; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x49be, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $49C1                   ; B552: B6 49 C1      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x49c1); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBA  #$08                    ; B555: 80 08         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x08; 
    res = val - (UINT8)arg; 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)(res); 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$40                    ; B557: 81 40         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x40; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCC   LB55D                   ; B559: 24 02         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LB55D;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$40                    ; B55B: 86 40         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x40; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xB55D:
LB55D:
                                                     #ifdef DEBUG
                                      mon("LB55D    STA   $49C1                   ; B55D: B7 49 C1      \n");
                                      #endif
    PC = 0xb55d; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x49c1, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; B560: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $49BD                   ; B562: B7 49 BD      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x49bd, val); 
  case 0xB565:
LB565:
                                                     #ifdef DEBUG
                                      mon("LB565    LDD   $5078                   ; B565: FC 50 78      \n");
                                      #endif
    PC = 0xb565; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x5078); // Care needed with I/O space and word fetches
    B = rd_mem(0x5079); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$0800                  ; B568: C3 08 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0800; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5078                   ; B56B: FD 50 78      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5078, A); // Care needed with I/O space and word fetches
    wr_mem(0x5079, B); 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5040                   ; B56E: B3 50 40      \n");
                                      #endif // XT2
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5040)<<8; 
    ea = ea | rd_mem(0x5041); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$7000                  ; B571: 83 70 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x7000; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         LBCS  LB46F                   ; B574: 10 25 FE F7   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if (C) {
    clockticks = clockticks + 1; 
    goto LB46F;
    }
    // End of function sub_B43F
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; B578: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xB579:
LB579:
                                                     #ifdef DEBUG
                                      mon("LB579    LDA   #$00                    ; B579: 86 00         \n");
                                      #endif
    PC = 0xb579; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $49BD                   ; B57B: B7 49 BD      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x49bd, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $49C0                   ; B57E: B6 49 C0      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x49c0); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $49BE                   ; B581: B7 49 BE      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x49be, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$88                    ; B584: 86 88         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x88; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $49C1                   ; B586: B7 49 C1      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x49c1, val); 
                                                     #ifdef DEBUG
                                      mon("         LDB   $5040                   ; B589: F6 50 40      \n");
                                      #endif // XT2
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x5040); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LSRB                          ; B58C: 54            \n");
                                      #endif
    val = (UINT8)B; 
 // C = val & 1; 
    val = val >> 1; 
    B = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRB                          ; B58D: 54            \n");
                                      #endif
    val = (UINT8)B; 
 // C = val & 1; 
    val = val >> 1; 
    B = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRB                          ; B58E: 54            \n");
                                      #endif
    val = (UINT8)B; 
 // C = val & 1; 
    val = val >> 1; 
    B = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$0F                    ; B58F: C4 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x0f; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4999                  ; B591: 8E 49 99      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x4999; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; B594: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         STX   <$64                    ; B595: 9F 64         \n");
                                      #endif // Pointer to Tie fighter data
    clockticks = clockticks + 4; 
    val = X; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = DP|0x64; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $5040                   ; B597: B6 50 40      \n");
                                      #endif // XT2
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x5040); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$F8                    ; B59A: 84 F8         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0xf8; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDA  #$04                    ; B59C: 8B 04         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x04; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$00                    ; B59E: C6 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5078                   ; B5A0: FD 50 78      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5078, A); // Care needed with I/O space and word fetches
    wr_mem(0x5079, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0400                  ; B5A3: CC 04 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x04; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $507A                   ; B5A6: FD 50 7A      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x507a, A); // Care needed with I/O space and word fetches
    wr_mem(0x507b, B); 
  case 0xB5A9:
LB5A9:
                                                     #ifdef DEBUG
                                      mon("LB5A9    LDD   #$F200                  ; B5A9: CC F2 00      \n");
                                      #endif
    PC = 0xb5a9; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0xf2; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $507C                   ; B5AC: FD 50 7C      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x507c, A); // Care needed with I/O space and word fetches
    wr_mem(0x507d, B); 
                                                     #ifdef DEBUG
                                      mon("         LDX   <$64                    ; B5AF: 9E 64         \n");
                                      #endif // Pointer to Tie fighter data
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x64)<<8; 
    ea = ea | rd_mem(DP|0x65); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$49A9                  ; B5B1: 8C 49 A9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x49a9; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LB5B9                   ; B5B4: 25 03         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LB5B9;
    }
                                                     #ifdef DEBUG
                                      mon("         LEAX  -$10,X                  ; B5B6: 30 88 F0      \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + (SINT8)0xf0); 
 // Z = X; 
  case 0xB5B9:
LB5B9:
                                                     #ifdef DEBUG
                                      mon("LB5B9    LDA   ,X+                     ; B5B9: A6 80         \n");
                                      #endif
    PC = 0xb5b9; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    val = (UINT8)rd_mem(X); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
    X = X + 1; 
                                                     #ifdef DEBUG
                                      mon("         STX   <$64                    ; B5BB: 9F 64         \n");
                                      #endif // Pointer to Tie fighter data
    clockticks = clockticks + 4; 
    val = X; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = DP|0x64; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
  case 0xB5BD:
LB5BD:
                                                     #ifdef DEBUG
                                      mon("LB5BD    STA   <$9E                    ; B5BD: 97 9E         \n");
                                      #endif
    PC = 0xb5bd; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x9e; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$03                    ; B5BF: 84 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x03; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  <$9C                    ; B5C1: 91 9C         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)A; 
    arg = rd_mem(DP|0x9c); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         LBNE  LB650                   ; B5C3: 10 26 00 89   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if (Z) {
    clockticks = clockticks + 1; 
    goto LB650;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   <$9D                    ; B5C7: 96 9D         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x9d); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$DC                    ; B5C9: 97 DC         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xdc; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0F                    ; B5CB: CC 00 0F      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x0f; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4701                   ; B5CE: FD 47 01      \n");
                                      #endif // Point BIC to $5078 MReg3C
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4701, A); // Care needed with I/O space and word fetches
    wr_mem(0x4702, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$67                    ; B5D1: 86 67         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x67; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCDBA                   ; B5D3: BD CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xd6); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb5); 
    clockticks = clockticks + 1; 
    goto LCDBA;
  case 0xB5D6:
LB5D6:
                                                     #ifdef DEBUG
                                      mon("LB5D6    LDA   <$9C                    ; B5D6: 96 9C         \n");
                                      #endif
    PC = 0xb5d6; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x9c); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$02                    ; B5D8: 81 02         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x02; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   LB5EF                   ; B5DA: 26 13         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LB5EF;
    }
                                                     #ifdef DEBUG
                                      mon("         INC   $49BD                   ; B5DC: 7C 49 BD      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x49bd); 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    wr_mem(0x49bd, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $49BE                   ; B5DF: F6 49 BE      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x49be); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; B5E2: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #word_B6B3              ; B5E3: 8E B6 B3      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0xb6b3; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   B,X                     ; B5E6: EC 85         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + (SINT8)B); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; B5E8: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $49C1                   ; B5EA: B6 49 C1      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x49c1); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   -1,Y                    ; B5ED: A7 3F         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(Y + 0xffff); 
    wr_mem(ea, val); 
  case 0xB5EF:
LB5EF:
                                                     #ifdef DEBUG
                                      mon("LB5EF    LDD   $5078                   ; B5EF: FC 50 78      \n");
                                      #endif
    PC = 0xb5ef; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x5078); // Care needed with I/O space and word fetches
    B = rd_mem(0x5079); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5040                   ; B5F2: B3 50 40      \n");
                                      #endif // XT2
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5040)<<8; 
    ea = ea | rd_mem(0x5041); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$1000                  ; B5F5: 10 83 10 00   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x1000; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BGT   LB64A                   ; B5F9: 2E 4F         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto LB64A;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   <$9D                    ; B5FB: 96 9D         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x9d); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$0E                    ; B5FD: 81 0E         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x0e; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   LB645                   ; B5FF: 26 44         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LB645;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $5000                   ; B601: FC 50 00      \n");
                                      #endif // Math result X
    clockticks = clockticks + 5; 
    A = rd_mem(0x5000); // Care needed with I/O space and word fetches
    B = rd_mem(0x5001); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$00                    ; B604: 83 00 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0000; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BLT   LB650                   ; B607: 2D 47         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 3; 
    goto LB650;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $5042                   ; B609: FC 50 42      \n");
                                      #endif // YT2
    clockticks = clockticks + 5; 
    A = rd_mem(0x5042); // Care needed with I/O space and word fetches
    B = rd_mem(0x5043); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BLT   LB645                   ; B60C: 2D 37         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 3; 
    goto LB645;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $507C                   ; B60E: FC 50 7C      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x507c); // Care needed with I/O space and word fetches
    B = rd_mem(0x507d); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$0200                  ; B611: C3 02 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0200; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5044                   ; B614: B3 50 44      \n");
                                      #endif // ZT2
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5044)<<8; 
    ea = ea | rd_mem(0x5045); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BLT   LB645                   ; B617: 2D 2C         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 3; 
    goto LB645;
    }
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$0400                  ; B619: 83 04 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0400; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BGT   LB645                   ; B61C: 2E 27         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto LB645;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $5078                   ; B61E: FC 50 78      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x5078); // Care needed with I/O space and word fetches
    B = rd_mem(0x5079); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5040                   ; B621: B3 50 40      \n");
                                      #endif // XT2
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5040)<<8; 
    ea = ea | rd_mem(0x5041); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$0400                  ; B624: 83 04 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0400; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BHI   LB645                   ; B627: 22 1C         \n");
                                      #endif
    // temp hack to force a flush
    if (Z && (!C)) {
    clockticks = clockticks + 3; 
    goto LB645;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$0F                    ; B629: 86 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x0f; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$DC                    ; B62B: 97 DC         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xdc; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$60                    ; B62D: 96 60         \n");
                                      #endif // Shield count
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x60); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BLT   LB637                   ; B62F: 2D 06         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 3; 
    goto LB637;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   L9874                   ; B631: BD 98 74      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x34); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb6); 
    clockticks = clockticks + 1; 
    goto L9874;
  case 0xB634:
LB634:
                                                     #ifdef DEBUG
                                      mon("LB634    JSR   Sound_26                ; B634: BD BD B2      \n");
                                      #endif // Explosion
    PC = 0xb634; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x37); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb6); 
    clockticks = clockticks + 1; 
    goto LBDB2;
  case 0xB637:
LB637:
                                                     #ifdef DEBUG
                                      mon("LB637    LDA   <$63                    ; B637: 96 63         \n");
                                      #endif
    PC = 0xb637; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x63); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LB645                   ; B639: 26 0A         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LB645;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$4E                    ; B63B: 86 4E         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x4e; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $4703                   ; B63D: F6 47 03      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LB643                   ; B640: 2A 01         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LB643;
    }
                                                     #ifdef DEBUG
                                      mon("         NEGA                          ; B642: 40            \n");
                                      #endif
    val = (UINT8)A; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
  case 0xB643:
LB643:
                                                     #ifdef DEBUG
                                      mon("LB643    STA   <$63                    ; B643: 97 63         \n");
                                      #endif
    PC = 0xb643; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0x63; 
    wr_mem(ea, val); 
  case 0xB645:
LB645:
                                                     #ifdef DEBUG
                                      mon("LB645    JSR   LCD5C                   ; B645: BD CD 5C      \n");
                                      #endif // Trench calcs
    PC = 0xb645; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x48); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb6); 
    clockticks = clockticks + 1; 
    goto LCD5C;
  case 0xB648:
LB648:
                                                     #ifdef DEBUG
                                      mon("LB648    BRA   LB64D                   ; B648: 20 03         \n");
                                      #endif
    PC = 0xb648; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto LB64D;
    
    // ---------------------------------------------------------------------------
  case 0xB64A:
LB64A:
                                                     #ifdef DEBUG
                                      mon("LB64A    JSR   LCD50                   ; B64A: BD CD 50      \n");
                                      #endif
    PC = 0xb64a; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x4d); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb6); 
    clockticks = clockticks + 1; 
    goto LCD50;
  case 0xB64D:
LB64D:
                                                     #ifdef DEBUG
                                      mon("LB64D    JSR   LCD74                   ; B64D: BD CD 74      \n");
                                      #endif // Function select for an object
    PC = 0xb64d; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x50); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb6); 
    clockticks = clockticks + 1; 
    goto LCD74;
  case 0xB650:
LB650:
                                                     #ifdef DEBUG
                                      mon("LB650    LDD   $507C                   ; B650: FC 50 7C      \n");
                                      #endif
    PC = 0xb650; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x507c); // Care needed with I/O space and word fetches
    B = rd_mem(0x507d); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$0400                  ; B653: C3 04 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0400; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $507C                   ; B656: FD 50 7C      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x507c, A); // Care needed with I/O space and word fetches
    wr_mem(0x507d, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$9E                    ; B659: 96 9E         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x9e); 
    A = val; 
 // N = val; 
 // Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; B65B: 44            \n");
                                      #endif
    val = (UINT8)A; 
 // C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; B65C: 44            \n");
                                      #endif
    val = (UINT8)A; 
    C = val & 1; 
    val = val >> 1; 
    A = val; 
    N = 0; 
    Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LBNE  LB5BD                   ; B65D: 10 26 FF 5C   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if (Z) {
    clockticks = clockticks + 1; 
    goto LB5BD;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   <$9C                    ; B661: 96 9C         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x9c); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$02                    ; B663: 81 02         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x02; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   LB69F                   ; B665: 26 38         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LB69F;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   <$64                    ; B667: 9E 64         \n");
                                      #endif // Pointer to Tie fighter data
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x64)<<8; 
    ea = ea | rd_mem(DP|0x65); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   -$0011,X                ; B669: A6 89 FF EF   \n");
                                      #endif
    clockticks = clockticks + 8; 
    val = (UINT8)rd_mem((UINT16)(X + 0xffef)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xB66D:
LB66D:
                                                     #ifdef DEBUG
                                      mon("LB66D    ASLA                          ; B66D: 48            \n");
                                      #endif
    PC = 0xb66d; 
    INSTRUCTION_START
    val = (UINT8)A; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
    Z = res; 
    N = res; 
    V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BCC   LB677                   ; B66E: 24 07         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LB677;
    }
                                                     #ifdef DEBUG
                                      mon("         BMI   LB677                   ; B670: 2B 05         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LB677;
    }
                                                     #ifdef DEBUG
                                      mon("         INC   $49BD                   ; B672: 7C 49 BD      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x49bd); 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    wr_mem(0x49bd, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LB67A                   ; B675: 20 03         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LB67A;
    
    // ---------------------------------------------------------------------------
  case 0xB677:
LB677:
                                                     #ifdef DEBUG
                                      mon("LB677    ASLA                          ; B677: 48            \n");
                                      #endif
    PC = 0xb677; 
    INSTRUCTION_START
    val = (UINT8)A; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
    Z = res; 
    N = res; 
    V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LB66D                   ; B678: 26 F3         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LB66D;
    }
  case 0xB67A:
LB67A:
                                                     #ifdef DEBUG
                                      mon("LB67A    LDA   $49BD                   ; B67A: B6 49 BD      \n");
                                      #endif
    PC = 0xb67a; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x49bd); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LB69F                   ; B67D: 27 20         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LB69F;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $49BE                   ; B67F: B6 49 BE      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x49be); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         INCA                          ; B682: 4C            \n");
                                      #endif
    val = (UINT8)A; 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$03                    ; B683: 81 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x03; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   LB689                   ; B685: 25 02         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LB689;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; B687: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xB689:
LB689:
                                                     #ifdef DEBUG
                                      mon("LB689    STA   $49BE                   ; B689: B7 49 BE      \n");
                                      #endif
    PC = 0xb689; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x49be, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $49C1                   ; B68C: B6 49 C1      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x49c1); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBA  #$08                    ; B68F: 80 08         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x08; 
    res = val - (UINT8)arg; 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)(res); 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$40                    ; B691: 81 40         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x40; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCC   LB697                   ; B693: 24 02         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LB697;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$40                    ; B695: 86 40         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x40; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xB697:
LB697:
                                                     #ifdef DEBUG
                                      mon("LB697    STA   $49C1                   ; B697: B7 49 C1      \n");
                                      #endif
    PC = 0xb697; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x49c1, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; B69A: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $49BD                   ; B69C: B7 49 BD      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x49bd, val); 
  case 0xB69F:
LB69F:
                                                     #ifdef DEBUG
                                      mon("LB69F    LDD   $5078                   ; B69F: FC 50 78      \n");
                                      #endif
    PC = 0xb69f; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x5078); // Care needed with I/O space and word fetches
    B = rd_mem(0x5079); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$0800                  ; B6A2: C3 08 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0800; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5078                   ; B6A5: FD 50 78      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5078, A); // Care needed with I/O space and word fetches
    wr_mem(0x5079, B); 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5040                   ; B6A8: B3 50 40      \n");
                                      #endif // XT2
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5040)<<8; 
    ea = ea | rd_mem(0x5041); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$7000                  ; B6AB: 83 70 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x7000; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         LBCS  LB5A9                   ; B6AE: 10 25 FE F7   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if (C) {
    clockticks = clockticks + 1; 
    goto LB5A9;
    }
    // End of function sub_B579
    // ---------------------------------------------------------------------------
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; B6B2: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Insert vector instructions at joystick position for laser explosion 2
  case 0xB6B9:
LB6B9:
                                                     #ifdef DEBUG
                                      mon("LB6B9    JSR   LB6C7                   ; B6B9: BD B6 C7      \n");
                                      #endif
    PC = 0xb6b9; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xbc); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb6); 
    clockticks = clockticks + 1; 
    goto LB6C7;
  case 0xB6BC:
LB6BC:
                                                     #ifdef DEBUG
                                      mon("LB6BC    JSR   LB6D7                   ; B6BC: BD B6 D7      \n");
                                      #endif // Insert vector instructions at joystick position for laser explosion
    PC = 0xb6bc; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xbf); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb6); 
    clockticks = clockticks + 1; 
    goto LB6D7;
    // End of function sub_B6B9
  case 0xB6BF:
LB6BF:
                                                     #ifdef DEBUG
                                      mon("LB6BF    RTS                           ; B6BF: 39            \n");
                                      #endif
    PC = 0xb6bf; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Insert vector instructions at joystick position for laser explosion 3
  case 0xB6C0:
LB6C0:
                                                     #ifdef DEBUG
                                      mon("LB6C0    JSR   LB6CC                   ; B6C0: BD B6 CC      \n");
                                      #endif
    PC = 0xb6c0; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xc3); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb6); 
    clockticks = clockticks + 1; 
    goto LB6CC;
  case 0xB6C3:
LB6C3:
                                                     #ifdef DEBUG
                                      mon("LB6C3    JSR   LB6D7                   ; B6C3: BD B6 D7      \n");
                                      #endif // Insert vector instructions at joystick position for laser explosion
    PC = 0xb6c3; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xc6); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb6); 
    clockticks = clockticks + 1; 
    goto LB6D7;
    // End of function sub_B6C0
  case 0xB6C6:
LB6C6:
                                                     #ifdef DEBUG
                                      mon("LB6C6    RTS                           ; B6C6: 39            \n");
                                      #endif
    PC = 0xb6c6; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xB6C7:
LB6C7:
                                                     #ifdef DEBUG
                                      mon("LB6C7    LDD   #$6380                  ; B6C7: CC 63 80      \n");
                                      #endif
    PC = 0xb6c7; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x63; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
    // End of function sub_B6C7
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; B6CA: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
    // =============== S U B R O U T I N E =======================================
  case 0xB6CC:
LB6CC:
                                                     #ifdef DEBUG
                                      mon("LB6CC    LDD   #$A012                  ; B6CC: CC A0 12      \n");
                                      #endif
    PC = 0xb6cc; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0xa0; 
    B = 0x12; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; B6CF: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   $32FE                   ; B6D1: FC 32 FE      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x32fe); // Care needed with I/O space and word fetches
    B = rd_mem(0x32ff); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; B6D4: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
    // End of function sub_B6CC
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; B6D6: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Insert vector instructions at joystick position for laser explosion
  case 0xB6D7:
LB6D7:
                                                     #ifdef DEBUG
                                      mon("LB6D7    LDA   <$7D                    ; B6D7: 96 7D         \n");
                                      #endif // Joystick X
    PC = 0xb6d7; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x7d); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LB6DC                   ; B6D9: 2A 01         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LB6DC;
    }
                                                     #ifdef DEBUG
                                      mon("         NEGA                          ; B6DB: 40            \n");
                                      #endif
    val = (UINT8)A; 
    res = -val; 
 // V = val & (UINT8)res; 
 // C = res & 0x100; 
    val = (UINT8)res; 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
  case 0xB6DC:
LB6DC:
                                                     #ifdef DEBUG
                                      mon("LB6DC    LDB   #$6E                    ; B6DC: C6 6E         \n");
                                      #endif
    PC = 0xb6dc; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x6e; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         MUL                           ; B6DE: 3D            \n");
                                      #endif
    res = (UINT16)(A * B); 
 // Z = res; 
    C = res & 0x80; 
    A = res >> 8; 
    B = (UINT8)res; 
    clockticks = clockticks + 11; 
                                                     #ifdef DEBUG
                                      mon("         LDB   <$7D                    ; B6DF: D6 7D         \n");
                                      #endif // Joystick X
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x7d); 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LB6E4                   ; B6E1: 2A 01         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LB6E4;
    }
                                                     #ifdef DEBUG
                                      mon("         NEGA                          ; B6E3: 40            \n");
                                      #endif
    val = (UINT8)A; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
  case 0xB6E4:
LB6E4:
                                                     #ifdef DEBUG
                                      mon("LB6E4    TFR   A,B                     ; B6E4: 1F 89         \n");
                                      #endif
    PC = 0xb6e4; 
    INSTRUCTION_START
    B = (UINT8)A; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         SEX                           ; B6E6: 1D            \n");
                                      #endif
 // Z = B; 
 // N = B; 
    A = ((SINT8)B < 0 ? 0xff : 0); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B1C                   ; B6E7: FD 4B 1C      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4b1c, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b1d, B); 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$1F                    ; B6EA: 84 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x1f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $02,Y                   ; B6EC: ED 22         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(Y + 0x0002); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $08,Y                   ; B6EE: ED 28         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(Y + 0x0008); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $0E,Y                   ; B6F0: ED 2E         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(Y + 0x000e); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $14,Y                   ; B6F2: ED A8 14      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(Y + (SINT8)0x14); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $1A,Y                   ; B6F5: ED A8 1A      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(Y + (SINT8)0x1a); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$7F                    ; B6F8: 96 7F         \n");
                                      #endif // Joystick Y
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x7f); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LB6FD                   ; B6FA: 2A 01         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LB6FD;
    }
  case 0xB6FC:
LB6FC:
                                                     #ifdef DEBUG
                                      mon("LB6FC    NEGA                          ; B6FC: 40            \n");
                                      #endif
    PC = 0xb6fc; 
    INSTRUCTION_START
    val = (UINT8)A; 
    res = -val; 
 // V = val & (UINT8)res; 
 // C = res & 0x100; 
    val = (UINT8)res; 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
  case 0xB6FD:
LB6FD:
                                                     #ifdef DEBUG
                                      mon("LB6FD    LDB   #$50                    ; B6FD: C6 50         \n");
                                      #endif
    PC = 0xb6fd; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x50; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         MUL                           ; B6FF: 3D            \n");
                                      #endif
    res = (UINT16)(A * B); 
 // Z = res; 
    C = res & 0x80; 
    A = res >> 8; 
    B = (UINT8)res; 
    clockticks = clockticks + 11; 
                                                     #ifdef DEBUG
                                      mon("         LDB   <$7F                    ; B700: D6 7F         \n");
                                      #endif // Joystick Y
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x7f); 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LB705                   ; B702: 2A 01         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LB705;
    }
                                                     #ifdef DEBUG
                                      mon("         NEGA                          ; B704: 40            \n");
                                      #endif
    val = (UINT8)A; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
  case 0xB705:
LB705:
                                                     #ifdef DEBUG
                                      mon("LB705    TFR   A,B                     ; B705: 1F 89         \n");
                                      #endif
    PC = 0xb705; 
    INSTRUCTION_START
    B = (UINT8)A; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         SEX                           ; B707: 1D            \n");
                                      #endif
 // Z = B; 
 // N = B; 
    A = ((SINT8)B < 0 ? 0xff : 0); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B1E                   ; B708: FD 4B 1E      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4b1e, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b1f, B); 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$1F                    ; B70B: 84 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x1f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y                      ; B70D: ED A4         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $06,Y                   ; B70F: ED 26         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(Y + 0x0006); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $0C,Y                   ; B711: ED 2C         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(Y + 0x000c); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $12,Y                   ; B713: ED A8 12      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(Y + (SINT8)0x12); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $18,Y                   ; B716: ED A8 18      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(Y + (SINT8)0x18); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #LBAAC                  ; B719: CC BA AC      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xba; 
    B = 0xac; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $04,Y                   ; B71C: ED 24         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(Y + 0x0004); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$BA0D                  ; B71E: CC BA 0D      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xba; 
    B = 0x0d; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $0A,Y                   ; B721: ED 2A         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(Y + 0x000a); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$BB33                  ; B723: CC BB 33      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xbb; 
    B = 0x33; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $10,Y                   ; B726: ED A8 10      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(Y + (SINT8)0x10); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$BAE6                  ; B729: CC BA E6      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xba; 
    B = 0xe6; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $16,Y                   ; B72C: ED A8 16      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(Y + (SINT8)0x16); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$BA5A                  ; B72F: CC BA 5A      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xba; 
    B = 0x5a; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $1C,Y                   ; B732: ED A8 1C      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
    N = A; 
    V = 0; 
    ea = (UINT16)(Y + (SINT8)0x1c); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LEAY  $1E,Y                   ; B735: 31 A8 1E      \n");
                                      #endif
    clockticks = clockticks + 5; 
    Y = (Y + (SINT8)0x1e); 
    Z = Y; 
    // End of function sub_B6D7
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; B738: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xB739:
LB739:
                                                     #ifdef DEBUG
                                      mon("LB739    LDA   #$00                    ; B739: 86 00         \n");
                                      #endif
    PC = 0xb739; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $03,X                   ; B73B: A7 03         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = (UINT16)(X + 0x0003); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   L8E1C                   ; B73D: BD 8E 1C      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x40); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb7); 
    clockticks = clockticks + 1; 
    goto L8E1C;
  case 0xB740:
LB740:
                                                     #ifdef DEBUG
                                      mon("LB740    PSHS  U,X                     ; B740: 34 50         \n");
                                      #endif
    PC = 0xb740; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 2; 
    --S;
    wr_mem(S, U); 
    --S;
    wr_mem(S, U >> 8); 
    clockticks = clockticks + 1; 
    clockticks = clockticks + 2; 
    --S;
    wr_mem(S, X); 
    --S;
    wr_mem(S, X >> 8); 
    clockticks = clockticks + 1; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LB76C                   ; B742: BD B7 6C      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x45); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb7); 
    clockticks = clockticks + 1; 
    goto LB76C;
  case 0xB745:
LB745:
                                                     #ifdef DEBUG
                                      mon("LB745    PULS  X,U                     ; B745: 35 50         \n");
                                      #endif
    PC = 0xb745; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 2; 
    clockticks = clockticks + 1; 
    X = rd_mem(S)<<8; 
    S++;
    X = X | rd_mem(S); 
    S++;
    clockticks = clockticks + 2; 
    clockticks = clockticks + 1; 
    U = rd_mem(S)<<8; 
    S++;
    U = U | rd_mem(S); 
    S++;
    // End of function sub_B739
    // ---------------------------------------------------------------------------
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; B747: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xB76C:
LB76C:
                                                     #ifdef DEBUG
                                      mon("LB76C    LDU   ,X                      ; B76C: EE 84         \n");
                                      #endif
    PC = 0xb76c; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LB948                   ; B76E: BD B9 48      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x71); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb7); 
    clockticks = clockticks + 1; 
    goto LB948;
  case 0xB771:
LB771:
                                                     #ifdef DEBUG
                                      mon("LB771    LDA   #$06                    ; B771: 86 06         \n");
                                      #endif
    PC = 0xb771; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x06; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $0C,X                   ; B773: A7 0C         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x000c); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$18                    ; B775: 86 18         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x18; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $0D,X                   ; B777: A7 0D         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x000d); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; B779: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  -14,U                   ; B77C: A3 52         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0xfff2))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0xfff2))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_6             ; B77E: BD CD 9C      \n");
                                      #endif // Shift D register right
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x81); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb7); 
    clockticks = clockticks + 1; 
    goto LCD9C;
  case 0xB781:
LB781:
                                                     #ifdef DEBUG
                                      mon("LB781    STD   $06,X                   ; B781: ED 06         \n");
                                      #endif
    PC = 0xb781; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x0006); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $08,U                   ; B783: E3 48         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0008))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0008))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,X                      ; B785: ED 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; B787: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  -6,U                    ; B78A: A3 5A         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0xfffa))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0xfffa))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_6             ; B78C: BD CD 9C      \n");
                                      #endif // Shift D register right
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x8f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb7); 
    clockticks = clockticks + 1; 
    goto LCD9C;
  case 0xB78F:
LB78F:
                                                     #ifdef DEBUG
                                      mon("LB78F    STD   $08,X                   ; B78F: ED 08         \n");
                                      #endif
    PC = 0xb78f; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x0008); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $0A,U                   ; B791: E3 4A         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x000a))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x000a))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $02,X                   ; B793: ED 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x0002); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; B795: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $02,U                   ; B798: A3 42         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0002))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0002))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_6             ; B79A: BD CD 9C      \n");
                                      #endif // Shift D register right
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x9d); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb7); 
    clockticks = clockticks + 1; 
    goto LCD9C;
  case 0xB79D:
LB79D:
                                                     #ifdef DEBUG
                                      mon("LB79D    STD   $0A,X                   ; B79D: ED 0A         \n");
                                      #endif
    PC = 0xb79d; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x000a); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $0C,U                   ; B79F: E3 4C         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x000c))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x000c))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $04,X                   ; B7A1: ED 04         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x0004); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LB83F                   ; B7A3: BD B8 3F      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xa6); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb7); 
    clockticks = clockticks + 1; 
    goto LB83F;
  case 0xB7A6:
LB7A6:
                                                     #ifdef DEBUG
                                      mon("LB7A6    JSR   LB948                   ; B7A6: BD B9 48      \n");
                                      #endif
    PC = 0xb7a6; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xa9); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb7); 
    clockticks = clockticks + 1; 
    goto LB948;
  case 0xB7A9:
LB7A9:
                                                     #ifdef DEBUG
                                      mon("LB7A9    LDA   #$07                    ; B7A9: 86 07         \n");
                                      #endif
    PC = 0xb7a9; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x07; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $0C,X                   ; B7AB: A7 0C         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x000c); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$18                    ; B7AD: 86 18         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x18; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $0D,X                   ; B7AF: A7 0D         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x000d); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   -14,U                   ; B7B1: EC 52         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0xfff2); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_6             ; B7B3: BD CD 9C      \n");
                                      #endif // Shift D register right
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xb6); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb7); 
    clockticks = clockticks + 1; 
    goto LCD9C;
  case 0xB7B6:
LB7B6:
                                                     #ifdef DEBUG
                                      mon("LB7B6    STD   $06,X                   ; B7B6: ED 06         \n");
                                      #endif
    PC = 0xb7b6; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x0006); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $08,U                   ; B7B8: E3 48         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0008))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0008))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,X                      ; B7BA: ED 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   -6,U                    ; B7BC: EC 5A         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0xfffa); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_6             ; B7BE: BD CD 9C      \n");
                                      #endif // Shift D register right
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xc1); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb7); 
    clockticks = clockticks + 1; 
    goto LCD9C;
  case 0xB7C1:
LB7C1:
                                                     #ifdef DEBUG
                                      mon("LB7C1    STD   $08,X                   ; B7C1: ED 08         \n");
                                      #endif
    PC = 0xb7c1; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x0008); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $0A,U                   ; B7C3: E3 4A         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x000a))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x000a))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $02,X                   ; B7C5: ED 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x0002); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $02,U                   ; B7C7: EC 42         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0x0002); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_6             ; B7C9: BD CD 9C      \n");
                                      #endif // Shift D register right
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xcc); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb7); 
    clockticks = clockticks + 1; 
    goto LCD9C;
  case 0xB7CC:
LB7CC:
                                                     #ifdef DEBUG
                                      mon("LB7CC    STD   $0A,X                   ; B7CC: ED 0A         \n");
                                      #endif
    PC = 0xb7cc; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x000a); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $0C,U                   ; B7CE: E3 4C         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x000c))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x000c))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $04,X                   ; B7D0: ED 04         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x0004); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LB83F                   ; B7D2: BD B8 3F      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xd5); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb7); 
    clockticks = clockticks + 1; 
    goto LB83F;
  case 0xB7D5:
LB7D5:
                                                     #ifdef DEBUG
                                      mon("LB7D5    JSR   LB948                   ; B7D5: BD B9 48      \n");
                                      #endif
    PC = 0xb7d5; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xd8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb7); 
    clockticks = clockticks + 1; 
    goto LB948;
  case 0xB7D8:
LB7D8:
                                                     #ifdef DEBUG
                                      mon("LB7D8    LDA   #$08                    ; B7D8: 86 08         \n");
                                      #endif
    PC = 0xb7d8; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x08; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $0C,X                   ; B7DA: A7 0C         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x000c); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$10                    ; B7DC: 86 10         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x10; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $0D,X                   ; B7DE: A7 0D         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x000d); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $08,U                   ; B7E0: EC 48         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0x0008); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,X                      ; B7E2: ED 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $06,X                   ; B7E4: ED 06         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x0006); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $0A,U                   ; B7E6: EC 4A         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0x000a); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $02,X                   ; B7E8: ED 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x0002); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $08,X                   ; B7EA: ED 08         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x0008); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $0C,U                   ; B7EC: EC 4C         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0x000c); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $04,X                   ; B7EE: ED 04         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x0004); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $0A,X                   ; B7F0: ED 0A         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x000a); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $06,X                   ; B7F2: A6 06         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0006)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$80                    ; B7F4: C6 80         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x80; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xB7F6:
LB7F6:
                                                     #ifdef DEBUG
                                      mon("LB7F6    ASLB                          ; B7F6: 58            \n");
                                      #endif
    PC = 0xb7f6; 
    INSTRUCTION_START
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLA                          ; B7F7: 49            \n");
                                      #endif
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BVC   LB7FE                   ; B7F8: 28 04         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)V >= 0) {
    clockticks = clockticks + 3; 
    goto LB7FE;
    }
                                                     #ifdef DEBUG
                                      mon("         RORA                          ; B7FA: 46            \n");
                                      #endif
    res = ((UINT8)A) | ((C != 0) ? 0x100 : 0); 
    C = res & 1; 
    res = (UINT8)(res >> 1); 
 // Z = res; 
 // N = res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         RORB                          ; B7FB: 56            \n");
                                      #endif
    res = ((UINT8)B) | ((C != 0) ? 0x100 : 0); 
    C = res & 1; 
    res = (UINT8)(res >> 1); 
    Z = res; 
    N = res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LB81C                   ; B7FC: 20 1E         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LB81C;
    
    // ---------------------------------------------------------------------------
  case 0xB7FE:
LB7FE:
                                                     #ifdef DEBUG
                                      mon("LB7FE    ASL   $09,X                   ; B7FE: 68 09         \n");
                                      #endif
    PC = 0xb7fe; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0009)); 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    wr_mem((UINT16)(X + 0x0009), res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROL   $08,X                   ; B800: 69 08         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0008)); 
    res = (val << 1) + (C != 0 ?1:0); 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)res ^ val; 
    wr_mem((UINT16)(X + 0x0008), (UINT8)res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BVC   LB80C                   ; B802: 28 08         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)V >= 0) {
    clockticks = clockticks + 3; 
    goto LB80C;
    }
                                                     #ifdef DEBUG
                                      mon("         ROR   $08,X                   ; B804: 66 08         \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = ((UINT8)rd_mem((UINT16)(X + 0x0008))) | ((C != 0) ? 0x100 : 0); 
    C = res & 1; 
    res = (UINT8)(res >> 1); 
 // Z = res; 
 // N = res; 
    wr_mem((UINT16)(X + 0x0008), res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROR   $09,X                   ; B806: 66 09         \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = ((UINT8)rd_mem((UINT16)(X + 0x0009))) | ((C != 0) ? 0x100 : 0); 
 // C = res & 1; 
    res = (UINT8)(res >> 1); 
 // Z = res; 
 // N = res; 
    wr_mem((UINT16)(X + 0x0009), res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASRA                          ; B808: 47            \n");
                                      #endif
    val = (UINT8)A; 
    C = val & 1; 
    val = (UINT8)((SINT8)val >> 1); 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         RORB                          ; B809: 56            \n");
                                      #endif
    res = ((UINT8)B) | ((C != 0) ? 0x100 : 0); 
    C = res & 1; 
    res = (UINT8)(res >> 1); 
    Z = res; 
    N = res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LB81C                   ; B80A: 20 10         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LB81C;
    
    // ---------------------------------------------------------------------------
  case 0xB80C:
LB80C:
                                                     #ifdef DEBUG
                                      mon("LB80C    ASL   $0B,X                   ; B80C: 68 0B         \n");
                                      #endif
    PC = 0xb80c; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x000b)); 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    wr_mem((UINT16)(X + 0x000b), res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROL   $0A,X                   ; B80E: 69 0A         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x000a)); 
    res = (val << 1) + (C != 0 ?1:0); 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)res ^ val; 
    wr_mem((UINT16)(X + 0x000a), (UINT8)res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BVC   LB7F6                   ; B810: 28 E4         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)V >= 0) {
    clockticks = clockticks + 3; 
    goto LB7F6;
    }
                                                     #ifdef DEBUG
                                      mon("         ROR   $0A,X                   ; B812: 66 0A         \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = ((UINT8)rd_mem((UINT16)(X + 0x000a))) | ((C != 0) ? 0x100 : 0); 
    C = res & 1; 
    res = (UINT8)(res >> 1); 
 // Z = res; 
 // N = res; 
    wr_mem((UINT16)(X + 0x000a), res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROR   $0B,X                   ; B814: 66 0B         \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = ((UINT8)rd_mem((UINT16)(X + 0x000b))) | ((C != 0) ? 0x100 : 0); 
 // C = res & 1; 
    res = (UINT8)(res >> 1); 
 // Z = res; 
 // N = res; 
    wr_mem((UINT16)(X + 0x000b), res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASR   $08,X                   ; B816: 67 08         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0008)); 
 // C = val & 1; 
    val = (UINT8)((SINT8)val >> 1); 
    wr_mem((UINT16)(X + 0x0008), val); 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASR   $09,X                   ; B818: 67 09         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0009)); 
 // C = val & 1; 
    val = (UINT8)((SINT8)val >> 1); 
    wr_mem((UINT16)(X + 0x0009), val); 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASRA                          ; B81A: 47            \n");
                                      #endif
    val = (UINT8)A; 
    C = val & 1; 
    val = (UINT8)((SINT8)val >> 1); 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         RORB                          ; B81B: 56            \n");
                                      #endif
    res = ((UINT8)B) | ((C != 0) ? 0x100 : 0); 
 // C = res & 1; 
    res = (UINT8)(res >> 1); 
 // Z = res; 
 // N = res; 
    B = res; 
    clockticks = clockticks + 2; 
  case 0xB81C:
LB81C:
                                                     #ifdef DEBUG
                                      mon("LB81C    SUBD  ,X                      ; B81C: A3 84         \n");
                                      #endif
    PC = 0xb81c; 
    INSTRUCTION_START
    clockticks = clockticks + 1; 
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_4             ; B81E: BD CD A0      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x21); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb8); 
    clockticks = clockticks + 1; 
    goto LCDA0;
  case 0xB821:
LB821:
                                                     #ifdef DEBUG
                                      mon("LB821    LDB   $4703                   ; B821: F6 47 03      \n");
                                      #endif
    PC = 0xb821; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $06,X                   ; B824: ED 06         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x0006); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $08,X                   ; B826: EC 08         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + 0x0008); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $02,X                   ; B828: A3 02         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(X + 0x0002))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(X + 0x0002))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_4             ; B82A: BD CD A0      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x2d); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb8); 
    clockticks = clockticks + 1; 
    goto LCDA0;
  case 0xB82D:
LB82D:
                                                     #ifdef DEBUG
                                      mon("LB82D    LDB   $4703                   ; B82D: F6 47 03      \n");
                                      #endif
    PC = 0xb82d; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $08,X                   ; B830: ED 08         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x0008); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $0A,X                   ; B832: EC 0A         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + 0x000a); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $04,X                   ; B834: A3 04         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(X + 0x0004))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(X + 0x0004))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
  case 0xB836:
LB836:
                                                     #ifdef DEBUG
                                      mon("LB836    JSR   Shift_D_R_4             ; B836: BD CD A0      \n");
                                      #endif
    PC = 0xb836; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x39); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb8); 
    clockticks = clockticks + 1; 
    goto LCDA0;
  case 0xB839:
LB839:
                                                     #ifdef DEBUG
                                      mon("LB839    LDB   $4703                   ; B839: F6 47 03      \n");
                                      #endif
    PC = 0xb839; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $0A,X                   ; B83C: ED 0A         \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = (UINT16)(X + 0x000a); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    // End of function sub_B76C
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; B83E: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xB83F:
LB83F:
                                                     #ifdef DEBUG
                                      mon("LB83F    LDD   -10,U                   ; B83F: EC 56         \n");
                                      #endif
    PC = 0xb83f; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0xfff6); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $06,X                   ; B841: E3 06         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(X + 0x0006))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(X + 0x0006))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $06,X                   ; B843: ED 06         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x0006); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   -2,U                    ; B845: EC 5E         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0xfffe); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $08,X                   ; B847: E3 08         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(X + 0x0008))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(X + 0x0008))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $08,X                   ; B849: ED 08         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x0008); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
  case 0xB84B:
LB84B:
                                                     #ifdef DEBUG
                                      mon("LB84B    LDD   $06,U                   ; B84B: EC 46         \n");
                                      #endif
    PC = 0xb84b; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0x0006); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $0A,X                   ; B84D: E3 0A         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(X + 0x000a))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(X + 0x000a))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $0A,X                   ; B84F: ED 0A         \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = (UINT16)(X + 0x000a); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    // End of function sub_B83F
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; B851: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xB852:
LB852:
                                                     #ifdef DEBUG
                                      mon("LB852    LDD   #$01                    ; B852: CC 00 01      \n");
                                      #endif
    PC = 0xb852; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x01; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$01                    ; B855: DD 01         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x01; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0203                  ; B857: CC 02 03      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x02; 
    B = 0x03; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$03                    ; B85A: DD 03         \n");
                                      #endif
    clockticks = clockticks + 4; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = DP|0x03; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    // End of function sub_B852
                                                     #ifdef DEBUG
                                      mon("         BRA   LB868                   ; B85C: 20 0A         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LB868;
    
    // =============== S U B R O U T I N E =======================================
  case 0xB85E:
LB85E:
                                                     #ifdef DEBUG
                                      mon("LB85E    LDD   #$0304                  ; B85E: CC 03 04      \n");
                                      #endif
    PC = 0xb85e; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x03; 
    B = 0x04; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$01                    ; B861: DD 01         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x01; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0502                  ; B863: CC 05 02      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x05; 
    B = 0x02; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$03                    ; B866: DD 03         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x03; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
  case 0xB868:
LB868:
                                                     #ifdef DEBUG
                                      mon("LB868    JSR   LB948                   ; B868: BD B9 48      \n");
                                      #endif
    PC = 0xb868; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x6b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb8); 
    clockticks = clockticks + 1; 
    goto LB948;
  case 0xB86B:
LB86B:
                                                     #ifdef DEBUG
                                      mon("LB86B    LDA   <$01                    ; B86B: 96 01         \n");
                                      #endif
    PC = 0xb86b; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x01); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $0C,X                   ; B86D: A7 0C         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x000c); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$20                    ; B86F: 86 20         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x20; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $0D,X                   ; B871: A7 0D         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x000d); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $5018                   ; B873: FC 50 18      \n");
                                      #endif // XT
    clockticks = clockticks + 5; 
    A = rd_mem(0x5018); // Care needed with I/O space and word fetches
    B = rd_mem(0x5019); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0xB876:
LB876:
                                                     #ifdef DEBUG
                                      mon("LB876    STD   ,X                      ; B876: ED 84         \n");
                                      #endif
    PC = 0xb876; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $501A                   ; B878: FC 50 1A      \n");
                                      #endif // YT
    clockticks = clockticks + 5; 
    A = rd_mem(0x501a); // Care needed with I/O space and word fetches
    B = rd_mem(0x501b); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDA  #$FE                    ; B87B: 8B FE         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xfe; 
    res = val + (UINT8)arg; 
 // C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
  case 0xB87D:
LB87D:
                                                     #ifdef DEBUG
                                      mon("LB87D    STD   $02,X                   ; B87D: ED 02         \n");
                                      #endif
    PC = 0xb87d; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x0002); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $501C                   ; B87F: FC 50 1C      \n");
                                      #endif // ZT
    clockticks = clockticks + 5; 
    A = rd_mem(0x501c); // Care needed with I/O space and word fetches
    B = rd_mem(0x501d); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $04,X                   ; B882: ED 04         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x0004); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $5098                   ; B884: FC 50 98      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x5098); // Care needed with I/O space and word fetches
    B = rd_mem(0x5099); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDA  #$7F                    ; B887: 8B 7F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x7f; 
    res = val + (UINT8)arg; 
 // C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5018                   ; B889: B3 50 18      \n");
                                      #endif // XT
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5018)<<8; 
    ea = ea | rd_mem(0x5019); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_5             ; B88C: BD CD 9E      \n");
                                      #endif // Shift D register right
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x8f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb8); 
    clockticks = clockticks + 1; 
    goto LCD9E;
  case 0xB88F:
LB88F:
                                                     #ifdef DEBUG
                                      mon("LB88F    LDB   $4703                   ; B88F: F6 47 03      \n");
                                      #endif
    PC = 0xb88f; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $06,X                   ; B892: ED 06         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x0006); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $509A                   ; B894: FC 50 9A      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x509a); // Care needed with I/O space and word fetches
    B = rd_mem(0x509b); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDA  #$C1                    ; B897: 8B C1         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xc1; 
    res = val + (UINT8)arg; 
 // C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $501A                   ; B899: B3 50 1A      \n");
                                      #endif // YT
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x501a)<<8; 
    ea = ea | rd_mem(0x501b); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_5             ; B89C: BD CD 9E      \n");
                                      #endif // Shift D register right
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x9f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb8); 
    clockticks = clockticks + 1; 
    goto LCD9E;
  case 0xB89F:
LB89F:
                                                     #ifdef DEBUG
                                      mon("LB89F    LDB   $4703                   ; B89F: F6 47 03      \n");
                                      #endif
    PC = 0xb89f; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $08,X                   ; B8A2: ED 08         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x0008); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$04                    ; B8A4: 96 04         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x04); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $4703                   ; B8A6: F6 47 03      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_L_2             ; B8A9: BD CD B5      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xac); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb8); 
    clockticks = clockticks + 1; 
    goto LCDB5;
  case 0xB8AC:
LB8AC:
                                                     #ifdef DEBUG
                                      mon("LB8AC    STD   $0A,X                   ; B8AC: ED 0A         \n");
                                      #endif
    PC = 0xb8ac; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x000a); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LB948                   ; B8AE: BD B9 48      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xb1); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb8); 
    clockticks = clockticks + 1; 
    goto LB948;
  case 0xB8B1:
LB8B1:
                                                     #ifdef DEBUG
                                      mon("LB8B1    LDA   <$02                    ; B8B1: 96 02         \n");
                                      #endif
    PC = 0xb8b1; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x02); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $0C,X                   ; B8B3: A7 0C         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x000c); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$20                    ; B8B5: 86 20         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x20; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $0D,X                   ; B8B7: A7 0D         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x000d); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $5018                   ; B8B9: FC 50 18      \n");
                                      #endif // XT
    clockticks = clockticks + 5; 
    A = rd_mem(0x5018); // Care needed with I/O space and word fetches
    B = rd_mem(0x5019); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDA  #$02                    ; B8BC: 8B 02         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x02; 
    res = val + (UINT8)arg; 
 // C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,X                      ; B8BE: ED 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $501A                   ; B8C0: FC 50 1A      \n");
                                      #endif // YT
    clockticks = clockticks + 5; 
    A = rd_mem(0x501a); // Care needed with I/O space and word fetches
    B = rd_mem(0x501b); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $02,X                   ; B8C3: ED 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x0002); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $501C                   ; B8C5: FC 50 1C      \n");
                                      #endif // ZT
    clockticks = clockticks + 5; 
    A = rd_mem(0x501c); // Care needed with I/O space and word fetches
    B = rd_mem(0x501d); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $04,X                   ; B8C8: ED 04         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x0004); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $5098                   ; B8CA: FC 50 98      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x5098); // Care needed with I/O space and word fetches
    B = rd_mem(0x5099); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDA  #$7F                    ; B8CD: 8B 7F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x7f; 
    res = val + (UINT8)arg; 
 // C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5018                   ; B8CF: B3 50 18      \n");
                                      #endif // XT
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5018)<<8; 
    ea = ea | rd_mem(0x5019); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_5             ; B8D2: BD CD 9E      \n");
                                      #endif // Shift D register right
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xd5); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb8); 
    clockticks = clockticks + 1; 
    goto LCD9E;
  case 0xB8D5:
LB8D5:
                                                     #ifdef DEBUG
                                      mon("LB8D5    LDB   $4703                   ; B8D5: F6 47 03      \n");
                                      #endif
    PC = 0xb8d5; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $06,X                   ; B8D8: ED 06         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x0006); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $509A                   ; B8DA: FC 50 9A      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x509a); // Care needed with I/O space and word fetches
    B = rd_mem(0x509b); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $501A                   ; B8DD: B3 50 1A      \n");
                                      #endif // YT
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x501a)<<8; 
    ea = ea | rd_mem(0x501b); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_5             ; B8E0: BD CD 9E      \n");
                                      #endif // Shift D register right
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xe3); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb8); 
    clockticks = clockticks + 1; 
    goto LCD9E;
  case 0xB8E3:
LB8E3:
                                                     #ifdef DEBUG
                                      mon("LB8E3    LDB   $4703                   ; B8E3: F6 47 03      \n");
                                      #endif
    PC = 0xb8e3; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $08,X                   ; B8E6: ED 08         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x0008); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$04                    ; B8E8: 96 04         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x04); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $4703                   ; B8EA: F6 47 03      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_L_2             ; B8ED: BD CD B5      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf0); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb8); 
    clockticks = clockticks + 1; 
    goto LCDB5;
  case 0xB8F0:
LB8F0:
                                                     #ifdef DEBUG
                                      mon("LB8F0    STD   $0A,X                   ; B8F0: ED 0A         \n");
                                      #endif
    PC = 0xb8f0; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x000a); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LB948                   ; B8F2: BD B9 48      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf5); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb8); 
    clockticks = clockticks + 1; 
    goto LB948;
  case 0xB8F5:
LB8F5:
                                                     #ifdef DEBUG
                                      mon("LB8F5    LDA   <$03                    ; B8F5: 96 03         \n");
                                      #endif
    PC = 0xb8f5; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x03); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $0C,X                   ; B8F7: A7 0C         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x000c); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$20                    ; B8F9: 86 20         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x20; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $0D,X                   ; B8FB: A7 0D         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x000d); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $5018                   ; B8FD: FC 50 18      \n");
                                      #endif // XT
    clockticks = clockticks + 5; 
    A = rd_mem(0x5018); // Care needed with I/O space and word fetches
    B = rd_mem(0x5019); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,X                      ; B900: ED 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $501A                   ; B902: FC 50 1A      \n");
                                      #endif // YT
    clockticks = clockticks + 5; 
    A = rd_mem(0x501a); // Care needed with I/O space and word fetches
    B = rd_mem(0x501b); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDA  #$02                    ; B905: 8B 02         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x02; 
    res = val + (UINT8)arg; 
 // C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $02,X                   ; B907: ED 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x0002); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $501C                   ; B909: FC 50 1C      \n");
                                      #endif // ZT
    clockticks = clockticks + 5; 
    A = rd_mem(0x501c); // Care needed with I/O space and word fetches
    B = rd_mem(0x501d); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $04,X                   ; B90C: ED 04         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x0004); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $5098                   ; B90E: FC 50 98      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x5098); // Care needed with I/O space and word fetches
    B = rd_mem(0x5099); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDA  #$7F                    ; B911: 8B 7F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x7f; 
    res = val + (UINT8)arg; 
 // C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5018                   ; B913: B3 50 18      \n");
                                      #endif // XT
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5018)<<8; 
    ea = ea | rd_mem(0x5019); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_5             ; B916: BD CD 9E      \n");
                                      #endif // Shift D register right
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x19); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb9); 
    clockticks = clockticks + 1; 
    goto LCD9E;
  case 0xB919:
LB919:
                                                     #ifdef DEBUG
                                      mon("LB919    LDB   $4703                   ; B919: F6 47 03      \n");
                                      #endif
    PC = 0xb919; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $06,X                   ; B91C: ED 06         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x0006); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $509A                   ; B91E: FC 50 9A      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x509a); // Care needed with I/O space and word fetches
    B = rd_mem(0x509b); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDA  #$3F                    ; B921: 8B 3F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x3f; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $501A                   ; B923: B3 50 1A      \n");
                                      #endif // YT
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x501a)<<8; 
    ea = ea | rd_mem(0x501b); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_5             ; B926: BD CD 9E      \n");
                                      #endif // Shift D register right
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x29); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb9); 
    clockticks = clockticks + 1; 
    goto LCD9E;
  case 0xB929:
LB929:
                                                     #ifdef DEBUG
                                      mon("LB929    LDB   $4703                   ; B929: F6 47 03      \n");
                                      #endif
    PC = 0xb929; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $08,X                   ; B92C: ED 08         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x0008); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$04                    ; B92E: 96 04         \n");
                                      #endif // Game over/insert coins timer
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x04); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $4703                   ; B930: F6 47 03      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_L_2             ; B933: BD CD B5      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x36); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb9); 
    clockticks = clockticks + 1; 
    goto LCDB5;
  case 0xB936:
LB936:
                                                     #ifdef DEBUG
                                      mon("LB936    STD   $0A,X                   ; B936: ED 0A         \n");
                                      #endif
    PC = 0xb936; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = (UINT16)(X + 0x000a); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    // End of function sub_B85E
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; B938: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xB939:
LB939:
                                                     #ifdef DEBUG
                                      mon("LB939    LDX   #$49E2                  ; B939: 8E 49 E2      \n");
                                      #endif // 3D Object state data 2. 8 slots of 14 bytes
    PC = 0xb939; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x49e2; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xB93C:
LB93C:
                                                     #ifdef DEBUG
                                      mon("LB93C    LDA   #$00                    ; B93C: 86 00         \n");
                                      #endif
    PC = 0xb93c; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $0D,X                   ; B93E: A7 0D         \n");
                                      #endif // Free up object state slot
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x000d); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LEAX  $0E,X                   ; B940: 30 0E         \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + 0x000e); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$4A52                  ; B942: 8C 4A 52      \n");
                                      #endif // 3D Object state data 2. 8 slots of 14 bytes
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x4a52; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LB93C                   ; B945: 25 F5         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LB93C;
    }
    // End of function sub_B939
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; B947: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xB948:
LB948:
                                                     #ifdef DEBUG
                                      mon("LB948    LDB   <$A2                    ; B948: D6 A2         \n");
                                      #endif // 3D Object slot select
    PC = 0xb948; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xa2); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         INCB                          ; B94A: 5C            \n");
                                      #endif
    val = (UINT8)B; 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$08                    ; B94B: C1 08         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x08; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   LB951                   ; B94D: 25 02         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LB951;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   #$00                    ; B94F: C6 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xB951:
LB951:
                                                     #ifdef DEBUG
                                      mon("LB951    STB   <$A2                    ; B951: D7 A2         \n");
                                      #endif // 3D Object slot select
    PC = 0xb951; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xa2; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$0E                    ; B953: 86 0E         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x0e; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         MUL                           ; B955: 3D            \n");
                                      #endif
    res = (UINT16)(A * B); 
 // Z = res; 
    C = res & 0x80; 
    A = res >> 8; 
    B = (UINT8)res; 
    clockticks = clockticks + 11; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$49E2                  ; B956: 8E 49 E2      \n");
                                      #endif // 3D Object state data 2. 8 slots of 14 bytes
    clockticks = clockticks + 3; 
    X = 0x49e2; 
 // Z = X; 
    N = (X) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LEAX  D,X                     ; B959: 30 8B         \n");
                                      #endif
    clockticks = clockticks + 8; 
    X = (X + (((UINT8)A<<8)|(UINT8)B)); 
    Z = X; 
    // End of function sub_B948
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; B95B: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
    // START OF FUNCTION CHUNK FOR sub_B98B
  case 0xB95C:
LB95C:
                                                     #ifdef DEBUG
                                      mon("LB95C    LDD   #$14BD                  ; B95C: CC 14 BD      \n");
                                      #endif
    PC = 0xb95c; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x14; 
    B = 0xbd; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5022                   ; B95F: FD 50 22      \n");
                                      #endif // Sine for rotation
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5022, A); // Care needed with I/O space and word fetches
    wr_mem(0x5023, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$3C8C                  ; B962: CC 3C 8C      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x3c; 
    B = 0x8c; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5024                   ; B965: FD 50 24      \n");
                                      #endif // Cosine for rotation
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5024, A); // Care needed with I/O space and word fetches
    wr_mem(0x5025, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$18                    ; B968: CC 00 18      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x18; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4701                   ; B96B: FD 47 01      \n");
                                      #endif // Point BIC to $50C0
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4701, A); // Care needed with I/O space and word fetches
    wr_mem(0x4702, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; B96E: 86 00         \n");
                                      #endif // Roll
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCDBA                   ; B970: BD CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb9); 
    clockticks = clockticks + 1; 
    goto LCDBA;
  case 0xB973:
LB973:
                                                     #ifdef DEBUG
                                      mon("LB973    LDD   #$0590                  ; B973: CC 05 90      \n");
                                      #endif
    PC = 0xb973; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x05; 
    B = 0x90; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5022                   ; B976: FD 50 22      \n");
                                      #endif // Sine for rotation
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5022, A); // Care needed with I/O space and word fetches
    wr_mem(0x5023, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$3FC2                  ; B979: CC 3F C2      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x3f; 
    B = 0xc2; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5024                   ; B97C: FD 50 24      \n");
                                      #endif // Cosine for rotation
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5024, A); // Care needed with I/O space and word fetches
    wr_mem(0x5025, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$18                    ; B97F: CC 00 18      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x18; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4701                   ; B982: FD 47 01      \n");
                                      #endif // Point BIC to $50C0
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4701, A); // Care needed with I/O space and word fetches
    wr_mem(0x4702, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$0E                    ; B985: 86 0E         \n");
                                      #endif // Pitch
    clockticks = clockticks + 2; 
    val = (UINT8)0x0e; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCDBA                   ; B987: BD CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x8a); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb9); 
    clockticks = clockticks + 1; 
    goto LCDBA;
    // END OF FUNCTION CHUNK FOR sub_B98B
  case 0xB98A:
LB98A:
                                                     #ifdef DEBUG
                                      mon("LB98A    RTS                           ; B98A: 39            \n");
                                      #endif
    PC = 0xb98a; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Check if tie/bunker/tower been hit
    // FUNCTION CHUNK AT ROM:B95C SIZE 0000002F BYTES
  case 0xB98B:
LB98B:
                                                     #ifdef DEBUG
                                      mon("LB98B    LDX   #$49E2                  ; B98B: 8E 49 E2      \n");
                                      #endif // 3D Object state data 2. 8 slots of 14 bytes
    PC = 0xb98b; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x49e2; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xB98E:
LB98E:
                                                     #ifdef DEBUG
                                      mon("LB98E    LDA   $0D,X                   ; B98E: A6 0D         \n");
                                      #endif
    PC = 0xb98e; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x000d)); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LB9A1                   ; B990: 27 0F         \n");
                                      #endif // If object state slot active then
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LB9A1;
    }
                                                     #ifdef DEBUG
                                      mon("         DEC   $0D,X                   ; B992: 6A 0D         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x000d)); 
    res = (UINT8)(val - 1); 
 // N = res; 
 // Z = res; 
 // V = val & ~res; 
    wr_mem((UINT16)(X + 0x000d), res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $0C,X                   ; B994: E6 0C         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x000c)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$09                    ; B996: C1 09         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x09; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   LB99B                   ; B998: 25 01         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LB99B;
    }
                                                     #ifdef DEBUG
                                      mon("         SWI                           ; B99A: 3F            \n");
                                      #endif
    clockticks = clockticks + 19; 
    --S;
    wr_mem(S, 0x9b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb9); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, U); 
    --S;
    wr_mem(S, U >> 8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, Y); 
    --S;
    wr_mem(S, Y >> 8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, X); 
    --S;
    wr_mem(S, X >> 8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, (DP >> 8)); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, B); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, A); 
    clockticks = clockticks + 1; 
    simplify_flags();
    CC = (((((((((((((E<<1) | F)<<1) | H)<<1) |I)<<1) | N)<<1) | Z)<<1) | V)<<1) | C; // Placeholder for now
    restore_flags();
    --S;
    wr_mem(S, CC); 
    clockticks = clockticks + 1; 
    PC = (rd_mem(0xfffa)<<8)|rd_mem(0xfffb); 
    JUMP;
  case 0xB99B:
LB99B:
                                                     #ifdef DEBUG
                                      mon("LB99B    LDU   #jt1                    ; B99B: CE B7 48      \n");
                                      #endif
    PC = 0xb99b; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0xb748; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; B99E: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
    Z = res; 
    N = res; 
    V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         JSR   [B,U]                   ; B99F: AD D5         \n");
                                      #endif
    clockticks = clockticks + 3; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 2; 
    ea = rd_mem((UINT16)(U + (SINT8)B))<<8; 
    ea = ea | rd_mem((UINT16)(U + (SINT8)B + 1)); 
    --S;
    wr_mem(S, 0xa1); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb9); 
    clockticks = clockticks + 1; 
    PC = ea; 
    JUMP;
  case 0xB9A1:
LB9A1:
                                                     #ifdef DEBUG
                                      mon("LB9A1    LEAX  $0E,X                   ; B9A1: 30 0E         \n");
                                      #endif
    PC = 0xb9a1; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    X = (X + 0x000e); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$4A52                  ; B9A3: 8C 4A 52      \n");
                                      #endif // 3D Object state data 2. 8 slots of 14 bytes
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x4a52; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LB98E                   ; B9A6: 25 E6         \n");
                                      #endif // Loop until all 3D Object states processed
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LB98E;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   #$49E2                  ; B9A8: 8E 49 E2      \n");
                                      #endif // 3D Object state data 2. 8 slots of 14 bytes
    clockticks = clockticks + 3; 
    X = 0x49e2; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xB9AB:
LB9AB:
                                                     #ifdef DEBUG
                                      mon("LB9AB    LDA   $0D,X                   ; B9AB: A6 0D         \n");
                                      #endif
    PC = 0xb9ab; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x000d)); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LB9B2                   ; B9AD: 27 03         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LB9B2;
    }
                                                     #ifdef DEBUG
                                      mon("         JMP   LB95C                   ; B9AF: 7E B9 5C      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LB95C;
    
    // ---------------------------------------------------------------------------
  case 0xB9B2:
LB9B2:
                                                     #ifdef DEBUG
                                      mon("LB9B2    LEAX  $0E,X                   ; B9B2: 30 0E         \n");
                                      #endif
    PC = 0xb9b2; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    X = (X + 0x000e); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$4A52                  ; B9B4: 8C 4A 52      \n");
                                      #endif // 3D Object state data 2. 8 slots of 14 bytes
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x4a52; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LB9AB                   ; B9B7: 25 F2         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LB9AB;
    }
                                                     #ifdef DEBUG
                                      mon("         LDU   #$50D0                  ; B9B9: CE 50 D0      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x50d0; 
    Z = U; 
    N = (U) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCDC3                   ; B9BC: BD CD C3      \n");
                                      #endif // Initialise math registers matrix
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xbf); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb9); 
    clockticks = clockticks + 1; 
    goto LCDC3;
    // End of function sub_B98B
  case 0xB9BF:
LB9BF:
                                                     #ifdef DEBUG
                                      mon("LB9BF    RTS                           ; B9BF: 39            \n");
                                      #endif
    PC = 0xb9bf; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xB9C0:
LB9C0:
                                                     #ifdef DEBUG
                                      mon("LB9C0    LDD   $06,X                   ; B9C0: EC 06         \n");
                                      #endif
    PC = 0xb9c0; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + 0x0006); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  ,X                      ; B9C2: E3 84         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,X                      ; B9C4: ED 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; B9C6: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $06,X                   ; B9C9: A3 06         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(X + 0x0006))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(X + 0x0006))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_5             ; B9CB: BD CD 9E      \n");
                                      #endif // Shift D register right
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xce); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb9); 
    clockticks = clockticks + 1; 
    goto LCD9E;
  case 0xB9CE:
LB9CE:
                                                     #ifdef DEBUG
                                      mon("LB9CE    ADDD  $06,X                   ; B9CE: E3 06         \n");
                                      #endif
    PC = 0xb9ce; 
    INSTRUCTION_START
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(X + 0x0006))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(X + 0x0006))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $06,X                   ; B9D0: ED 06         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x0006); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $08,X                   ; B9D2: EC 08         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + 0x0008); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $02,X                   ; B9D4: E3 02         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(X + 0x0002))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(X + 0x0002))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $02,X                   ; B9D6: ED 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x0002); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; B9D8: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $08,X                   ; B9DB: A3 08         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(X + 0x0008))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(X + 0x0008))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Shift_D_R_5             ; B9DD: BD CD 9E      \n");
                                      #endif // Shift D register right
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xe0); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xb9); 
    clockticks = clockticks + 1; 
    goto LCD9E;
  case 0xB9E0:
LB9E0:
                                                     #ifdef DEBUG
                                      mon("LB9E0    ADDD  $08,X                   ; B9E0: E3 08         \n");
                                      #endif
    PC = 0xb9e0; 
    INSTRUCTION_START
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(X + 0x0008))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(X + 0x0008))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $08,X                   ; B9E2: ED 08         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x0008); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $04,X                   ; B9E4: EC 04         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + 0x0004); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $0A,X                   ; B9E6: E3 0A         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(X + 0x000a))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(X + 0x000a))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ res) & (val ^ res)) >> 8; 
    N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BVS   LB9F1                   ; B9E8: 29 07         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)V <  0) {
    clockticks = clockticks + 3; 
    goto LB9F1;
    }
                                                     #ifdef DEBUG
                                      mon("         BGE   LB9EF                   ; B9EA: 2C 03         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) >= 0) {
    clockticks = clockticks + 3; 
    goto LB9EF;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; B9EC: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0xB9EF:
LB9EF:
                                                     #ifdef DEBUG
                                      mon("LB9EF    STD   $04,X                   ; B9EF: ED 04         \n");
                                      #endif
    PC = 0xb9ef; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x0004); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
  case 0xB9F1:
LB9F1:
                                                     #ifdef DEBUG
                                      mon("LB9F1    LDD   $0A,X                   ; B9F1: EC 0A         \n");
                                      #endif
    PC = 0xb9f1; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + 0x000a); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$C8                    ; B9F3: 83 00 C8      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x00c8; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $0A,X                   ; B9F6: ED 0A         \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = (UINT16)(X + 0x000a); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    // End of function sub_B9C0
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; B9F8: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xB9F9:
LB9F9:
                                                     #ifdef DEBUG
                                      mon("LB9F9    LDD   $06,X                   ; B9F9: EC 06         \n");
                                      #endif
    PC = 0xb9f9; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + 0x0006); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  ,X                      ; B9FB: E3 84         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ res) & (val ^ res)) >> 8; 
    N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BVS   LBA01                   ; B9FD: 29 02         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)V <  0) {
    clockticks = clockticks + 3; 
    goto LBA01;
    }
                                                     #ifdef DEBUG
                                      mon("         STD   ,X                      ; B9FF: ED 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
  case 0xBA01:
LBA01:
                                                     #ifdef DEBUG
                                      mon("LBA01    LDD   $08,X                   ; BA01: EC 08         \n");
                                      #endif
    PC = 0xba01; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + 0x0008); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $02,X                   ; BA03: E3 02         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(X + 0x0002))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(X + 0x0002))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ res) & (val ^ res)) >> 8; 
    N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BVS   LBA09                   ; BA05: 29 02         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)V <  0) {
    clockticks = clockticks + 3; 
    goto LBA09;
    }
                                                     #ifdef DEBUG
                                      mon("         STD   $02,X                   ; BA07: ED 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x0002); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
  case 0xBA09:
LBA09:
                                                     #ifdef DEBUG
                                      mon("LBA09    LDD   $0A,X                   ; BA09: EC 0A         \n");
                                      #endif
    PC = 0xba09; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + 0x000a); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $04,X                   ; BA0B: E3 04         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(X + 0x0004))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(X + 0x0004))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ res) & (val ^ res)) >> 8; 
    N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BVS   locret_BA11             ; BA0D: 29 02         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)V <  0) {
    clockticks = clockticks + 3; 
    goto LBA11;
    }
                                                     #ifdef DEBUG
                                      mon("         STD   $04,X                   ; BA0F: ED 04         \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = (UINT16)(X + 0x0004); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    // End of function sub_B9F9
  case 0xBA11:
LBA11:
locret_BA11:
                                                     #ifdef DEBUG
                                      mon("locret_BA11 RTS                           ; BA11: 39            \n");
                                      #endif
    PC = 0xba11; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Process tie/tower/bunker explosions
  case 0xBA12:
LBA12:
                                                     #ifdef DEBUG
                                      mon("LBA12    LDA   #$18                    ; BA12: 86 18         \n");
                                      #endif // BIC points to $50C0
    PC = 0xba12; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x18; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCE18                   ; BA14: BD CE 18      \n");
                                      #endif // Run math program $80 Copy [BIC] to Matrix 3
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x17); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xba); 
    clockticks = clockticks + 1; 
    goto LCE18;
  case 0xBA17:
LBA17:
                                                     #ifdef DEBUG
                                      mon("LBA17    LDA   #$40                    ; BA17: 86 40         \n");
                                      #endif // @      ; Matrix 1 = Matrix 2 x Matrix 3
    PC = 0xba17; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x40; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCDBA                   ; BA19: BD CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x1c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xba); 
    clockticks = clockticks + 1; 
    goto LCDBA;
  case 0xBA1C:
LBA1C:
                                                     #ifdef DEBUG
                                      mon("LBA1C    LDX   #$49E2                  ; BA1C: 8E 49 E2      \n");
                                      #endif // 3D Object state data 2. 8 slots of 14 bytes
    PC = 0xba1c; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x49e2; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xBA1F:
LBA1F:
                                                     #ifdef DEBUG
                                      mon("LBA1F    STX   <$64                    ; BA1F: 9F 64         \n");
                                      #endif // Pointer to Tie fighter data
    PC = 0xba1f; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = X; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = DP|0x64; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $0D,X                   ; BA21: A6 0D         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x000d)); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LBA28                   ; BA23: 27 03         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LBA28;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   LBA32                   ; BA25: BD BA 32      \n");
                                      #endif // Tie/bunker/tower hit explosion
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x28); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xba); 
    clockticks = clockticks + 1; 
    goto LBA32;
  case 0xBA28:
LBA28:
                                                     #ifdef DEBUG
                                      mon("LBA28    LDX   <$64                    ; BA28: 9E 64         \n");
                                      #endif // Pointer to Tie fighter data
    PC = 0xba28; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x64)<<8; 
    ea = ea | rd_mem(DP|0x65); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LEAX  $0E,X                   ; BA2A: 30 0E         \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + 0x000e); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$4A52                  ; BA2C: 8C 4A 52      \n");
                                      #endif // 3D Object state data 2. 8 slots of 14 bytes
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x4a52; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LBA1F                   ; BA2F: 25 EE         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LBA1F;
    }
    // End of function sub_BA12
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; BA31: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBA32:
LBA32:
                                                     #ifdef DEBUG
                                      mon("LBA32    LDD   ,X                      ; BA32: EC 84         \n");
                                      #endif
    PC = 0xba32; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(X); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(X+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5078                   ; BA34: FD 50 78      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5078, A); // Care needed with I/O space and word fetches
    wr_mem(0x5079, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $02,X                   ; BA37: EC 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + 0x0002); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $507A                   ; BA39: FD 50 7A      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x507a, A); // Care needed with I/O space and word fetches
    wr_mem(0x507b, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $04,X                   ; BA3C: EC 04         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + 0x0004); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $507C                   ; BA3E: FD 50 7C      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x507c, A); // Care needed with I/O space and word fetches
    wr_mem(0x507d, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0F                    ; BA41: CC 00 0F      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x0f; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4701                   ; BA44: FD 47 01      \n");
                                      #endif // Point BIC to $5078 MReg3C
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4701, A); // Care needed with I/O space and word fetches
    wr_mem(0x4702, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$67                    ; BA47: 86 67         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x67; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCDBA                   ; BA49: BD CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x4c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xba); 
    clockticks = clockticks + 1; 
    goto LCDBA;
  case 0xBA4C:
LBA4C:
                                                     #ifdef DEBUG
                                      mon("LBA4C    LDD   $5000                   ; BA4C: FC 50 00      \n");
                                      #endif // Math result X
    PC = 0xba4c; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x5000); // Care needed with I/O space and word fetches
    B = rd_mem(0x5001); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BMI   LBA9D                   ; BA4F: 2B 4C         \n");
                                      #endif // If object behind observer then remove
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LBA9D;
    }
                                                     #ifdef DEBUG
                                      mon("         STD   $5018                   ; BA51: FD 50 18      \n");
                                      #endif // XT
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5018, A); // Care needed with I/O space and word fetches
    wr_mem(0x5019, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $4704                   ; BA54: FD 47 04      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4704, A); // Care needed with I/O space and word fetches
    wr_mem(0x4705, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $5002                   ; BA57: FC 50 02      \n");
                                      #endif // Math result Y
    clockticks = clockticks + 5; 
    A = rd_mem(0x5002); // Care needed with I/O space and word fetches
    B = rd_mem(0x5003); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $501A                   ; BA5A: FD 50 1A      \n");
                                      #endif // YT
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x501a, A); // Care needed with I/O space and word fetches
    wr_mem(0x501b, B); 
                                                     #ifdef DEBUG
                                      mon("         BPL   LBA63                   ; BA5D: 2A 04         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LBA63;
    }
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; BA5F: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; BA60: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SBCA  #$FF                    ; BA61: 82 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xff; 
    res = val - (UINT8)arg - (C != 0 ? 1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)res; 
  case 0xBA63:
LBA63:
                                                     #ifdef DEBUG
                                      mon("LBA63    SUBD  $5018                   ; BA63: B3 50 18      \n");
                                      #endif // XT
    PC = 0xba63; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5018)<<8; 
    ea = ea | rd_mem(0x5019); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BGE   LBA9D                   ; BA66: 2C 35         \n");
                                      #endif // Remove object if outside visible limit
    // temp hack to force a flush
    if ((SINT8)(N^V) >= 0) {
    clockticks = clockticks + 3; 
    goto LBA9D;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $5004                   ; BA68: FC 50 04      \n");
                                      #endif // Math result Z
    clockticks = clockticks + 5; 
    A = rd_mem(0x5004); // Care needed with I/O space and word fetches
    B = rd_mem(0x5005); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $501C                   ; BA6B: FD 50 1C      \n");
                                      #endif // ZT
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x501c, A); // Care needed with I/O space and word fetches
    wr_mem(0x501d, B); 
                                                     #ifdef DEBUG
                                      mon("         BPL   LBA74                   ; BA6E: 2A 04         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LBA74;
    }
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; BA70: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; BA71: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SBCA  #$FF                    ; BA72: 82 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xff; 
    res = val - (UINT8)arg - (C != 0 ? 1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)res; 
  case 0xBA74:
LBA74:
                                                     #ifdef DEBUG
                                      mon("LBA74    LSRA                          ; BA74: 44            \n");
                                      #endif
    PC = 0xba74; 
    INSTRUCTION_START
    val = (UINT8)A; 
    C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         RORB                          ; BA75: 56            \n");
                                      #endif
    res = ((UINT8)B) | ((C != 0) ? 0x100 : 0); 
 // C = res & 1; 
    res = (UINT8)(res >> 1); 
 // Z = res; 
 // N = res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5018                   ; BA76: B3 50 18      \n");
                                      #endif // XT
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5018)<<8; 
    ea = ea | rd_mem(0x5019); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BGE   LBA9D                   ; BA79: 2C 22         \n");
                                      #endif // Remove object if outside visible limit
    // temp hack to force a flush
    if ((SINT8)(N^V) >= 0) {
    clockticks = clockticks + 3; 
    goto LBA9D;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   $0C,X                   ; BA7B: E6 0C         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x000c)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$09                    ; BA7D: C1 09         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x09; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   LBA82                   ; BA7F: 25 01         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LBA82;
    }
                                                     #ifdef DEBUG
                                      mon("         SWI                           ; BA81: 3F            \n");
                                      #endif
    clockticks = clockticks + 19; 
    --S;
    wr_mem(S, 0x82); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xba); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, U); 
    --S;
    wr_mem(S, U >> 8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, Y); 
    --S;
    wr_mem(S, Y >> 8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, X); 
    --S;
    wr_mem(S, X >> 8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, (DP >> 8)); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, B); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, A); 
    clockticks = clockticks + 1; 
    simplify_flags();
    CC = (((((((((((((E<<1) | F)<<1) | H)<<1) |I)<<1) | N)<<1) | Z)<<1) | V)<<1) | C; // Placeholder for now
    restore_flags();
    --S;
    wr_mem(S, CC); 
    clockticks = clockticks + 1; 
    PC = (rd_mem(0xfffa)<<8)|rd_mem(0xfffb); 
    JUMP;
  case 0xBA82:
LBA82:
                                                     #ifdef DEBUG
                                      mon("LBA82    LDU   #off_B75A               ; BA82: CE B7 5A      \n");
                                      #endif // Tie/bunker/tower fragments table
    PC = 0xba82; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0xb75a; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; BA85: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
    Z = res; 
    N = res; 
    V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         JSR   [B,U]                   ; BA86: AD D5         \n");
                                      #endif // Work out which colour for tie/bunker/ tower fragments
    clockticks = clockticks + 3; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 2; 
    ea = rd_mem((UINT16)(U + (SINT8)B))<<8; 
    ea = ea | rd_mem((UINT16)(U + (SINT8)B + 1)); 
    --S;
    wr_mem(S, 0x88); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xba); 
    clockticks = clockticks + 1; 
    PC = ea; 
    JUMP;
  case 0xBA88:
LBA88:
                                                     #ifdef DEBUG
                                      mon("LBA88    JSR   LCCD8                   ; BA88: BD CC D8      \n");
                                      #endif // Copy object 3D data to math ram
    PC = 0xba88; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x8b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xba); 
    clockticks = clockticks + 1; 
    goto LCCD8;
  case 0xBA8B:
LBA8B:
                                                     #ifdef DEBUG
                                      mon("LBA8B    JSR   LCD20                   ; BA8B: BD CD 20      \n");
                                      #endif // Do 3D object transform using Matrix 1
    PC = 0xba8b; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x8e); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xba); 
    clockticks = clockticks + 1; 
    goto LCD20;
  case 0xBA8E:
LBA8E:
                                                     #ifdef DEBUG
                                      mon("LBA8E    JSR   LCD2C                   ; BA8E: BD CD 2C      \n");
                                      #endif // Format vectors for ties, and tower/bunker explosions
    PC = 0xba8e; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x91); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xba); 
    clockticks = clockticks + 1; 
    goto LCD2C;
  case 0xBA91:
LBA91:
                                                     #ifdef DEBUG
                                      mon("LBA91    LDD   #$7200                  ; BA91: CC 72 00      \n");
                                      #endif
    PC = 0xba91; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x72; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; BA94: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$8040                  ; BA96: CC 80 40      \n");
                                      #endif // Insert vector CNTR instruction
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; BA99: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         BRA   locret_BA9F             ; BA9B: 20 02         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LBA9F;
    
    // ---------------------------------------------------------------------------
  case 0xBA9D:
LBA9D:
                                                     #ifdef DEBUG
                                      mon("LBA9D    CLR   $0D,X                   ; BA9D: 6F 0D         \n");
                                      #endif // Remove/clear object state flag
    PC = 0xba9d; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    wr_mem((UINT16)(X + 0x000d), 0); 
    V = 0; 
    Z = 0; 
    N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
    // End of function sub_BA32
  case 0xBA9F:
LBA9F:
locret_BA9F:
                                                     #ifdef DEBUG
                                      mon("locret_BA9F RTS                           ; BA9F: 39            \n");
                                      #endif
    PC = 0xba9f; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBAA0:
LBAA0:
                                                     #ifdef DEBUG
                                      mon("LBAA0    LDA   #$14                    ; BAA0: 86 14         \n");
                                      #endif
    PC = 0xbaa0; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x14; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LBABE                   ; BAA2: 20 1A         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LBABE;
    
    // ---------------------------------------------------------------------------
  case 0xBAA4:
LBAA4:
                                                     #ifdef DEBUG
                                      mon("LBAA4    LDA   #$15                    ; BAA4: 86 15         \n");
                                      #endif
    PC = 0xbaa4; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x15; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LBABE                   ; BAA6: 20 16         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LBABE;
    
    // ---------------------------------------------------------------------------
  case 0xBAA8:
LBAA8:
                                                     #ifdef DEBUG
                                      mon("LBAA8    LDA   #$16                    ; BAA8: 86 16         \n");
                                      #endif
    PC = 0xbaa8; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x16; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LBABE                   ; BAAA: 20 12         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LBABE;
    
    // ---------------------------------------------------------------------------
  case 0xBAAC:
LBAAC:
                                                     #ifdef DEBUG
                                      mon("LBAAC    LDA   #$11                    ; BAAC: 86 11         \n");
                                      #endif
    PC = 0xbaac; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x11; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LBAB8                   ; BAAE: 20 08         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LBAB8;
    
    // ---------------------------------------------------------------------------
  case 0xBAB0:
LBAB0:
                                                     #ifdef DEBUG
                                      mon("LBAB0    LDA   #$12                    ; BAB0: 86 12         \n");
                                      #endif
    PC = 0xbab0; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x12; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LBAB8                   ; BAB2: 20 04         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LBAB8;
    
    // ---------------------------------------------------------------------------
  case 0xBAB4:
LBAB4:
                                                     #ifdef DEBUG
                                      mon("LBAB4    LDA   #$13                    ; BAB4: 86 13         \n");
                                      #endif
    PC = 0xbab4; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x13; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LBAB8                   ; BAB6: 20 00         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LBAB8;
    
  case 0xBAB8:
LBAB8:
                                                     #ifdef DEBUG
                                      mon("LBAB8    STA   <$DC                    ; BAB8: 97 DC         \n");
                                      #endif
    PC = 0xbab8; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xdc; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$67                    ; BABA: 86 67         \n");
                                      #endif // g      ; Tower fragments colour
    clockticks = clockticks + 2; 
    val = (UINT8)0x67; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LBAC2                   ; BABC: 20 04         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LBAC2;
    
    // ---------------------------------------------------------------------------
  case 0xBABE:
LBABE:
                                                     #ifdef DEBUG
                                      mon("LBABE    STA   <$DC                    ; BABE: 97 DC         \n");
                                      #endif
    PC = 0xbabe; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xdc; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$64                    ; BAC0: 86 64         \n");
                                      #endif // d      ; Bunker fragments colour
    clockticks = clockticks + 2; 
    val = (UINT8)0x64; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xBAC2:
LBAC2:
                                                     #ifdef DEBUG
                                      mon("LBAC2    LDB   $0D,X                   ; BAC2: E6 0D         \n");
                                      #endif
    PC = 0xbac2; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x000d)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$07                    ; BAC4: C1 07         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x07; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BHI   LBACE                   ; BAC6: 22 06         \n");
                                      #endif
    // temp hack to force a flush
    if (Z && (!C)) {
    clockticks = clockticks + 3; 
    goto LBACE;
    }
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; BAC8: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; BAC9: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; BACA: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; BACB: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
    Z = res; 
    N = res; 
    V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LBAD0                   ; BACC: 20 02         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LBAD0;
    
    // ---------------------------------------------------------------------------
  case 0xBACE:
LBACE:
                                                     #ifdef DEBUG
                                      mon("LBACE    LDB   #$80                    ; BACE: C6 80         \n");
                                      #endif
    PC = 0xbace; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x80; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xBAD0:
LBAD0:
                                                     #ifdef DEBUG
                                      mon("LBAD0    STD   ,Y++                    ; BAD0: ED A1         \n");
                                      #endif
    PC = 0xbad0; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   ,X                      ; BAD2: EC 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(X); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(X+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5078                   ; BAD4: FD 50 78      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5078, A); // Care needed with I/O space and word fetches
    wr_mem(0x5079, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $02,X                   ; BAD7: EC 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + 0x0002); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $507A                   ; BAD9: FD 50 7A      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x507a, A); // Care needed with I/O space and word fetches
    wr_mem(0x507b, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; BADC: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $507C                   ; BADF: FD 50 7C      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x507c, A); // Care needed with I/O space and word fetches
    wr_mem(0x507d, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0F                    ; BAE2: CC 00 0F      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x0f; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4701                   ; BAE5: FD 47 01      \n");
                                      #endif // Point BIC to $5078 MReg3C
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4701, A); // Care needed with I/O space and word fetches
    wr_mem(0x4702, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $501C                   ; BAE8: FC 50 1C      \n");
                                      #endif // ZT
    clockticks = clockticks + 5; 
    A = rd_mem(0x501c); // Care needed with I/O space and word fetches
    B = rd_mem(0x501d); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         PSHS  U,X,B,A                 ; BAEB: 34 56         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 2; 
    --S;
    wr_mem(S, U); 
    --S;
    wr_mem(S, U >> 8); 
    clockticks = clockticks + 1; 
    clockticks = clockticks + 2; 
    --S;
    wr_mem(S, X); 
    --S;
    wr_mem(S, X >> 8); 
    clockticks = clockticks + 1; 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, B); 
    clockticks = clockticks + 1; 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, A); 
    clockticks = clockticks + 1; 
                                                     #ifdef DEBUG
                                      mon("         LDU   $501A                   ; BAED: FE 50 1A      \n");
                                      #endif // YT
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x501a)<<8; 
    ea = ea | rd_mem(0x501b); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDX   $5018                   ; BAF0: BE 50 18      \n");
                                      #endif // XT
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5018)<<8; 
    ea = ea | rd_mem(0x5019); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$67                    ; BAF3: 86 67         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x67; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCDBA                   ; BAF5: BD CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xba); 
    clockticks = clockticks + 1; 
    goto LCDBA;
  case 0xBAF8:
LBAF8:
                                                     #ifdef DEBUG
                                      mon("LBAF8    STX   $5018                   ; BAF8: BF 50 18      \n");
                                      #endif // XT
    PC = 0xbaf8; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = X; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    wr_mem(0x5018, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem(0x5019, (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         STU   $501A                   ; BAFB: FF 50 1A      \n");
                                      #endif // YT
    clockticks = clockticks + 5; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    wr_mem(0x501a, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem(0x501b, (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         PULS  A,B,X,U                 ; BAFE: 35 56         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    clockticks = clockticks + 1; 
    A = rd_mem(S); 
    S++;
    clockticks = clockticks + 1; 
    clockticks = clockticks + 1; 
    B = rd_mem(S); 
    S++;
    clockticks = clockticks + 2; 
    clockticks = clockticks + 1; 
    X = rd_mem(S)<<8; 
    S++;
    X = X | rd_mem(S); 
    S++;
    clockticks = clockticks + 2; 
    clockticks = clockticks + 1; 
    U = rd_mem(S)<<8; 
    S++;
    U = U | rd_mem(S); 
    S++;
                                                     #ifdef DEBUG
                                      mon("         STD   $501C                   ; BB00: FD 50 1C      \n");
                                      #endif // ZT
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x501c, A); // Care needed with I/O space and word fetches
    wr_mem(0x501d, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $5000                   ; BB03: FC 50 00      \n");
                                      #endif // Math result X
    clockticks = clockticks + 5; 
    A = rd_mem(0x5000); // Care needed with I/O space and word fetches
    B = rd_mem(0x5001); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4704                   ; BB06: FD 47 04      \n");
                                      #endif // Do division
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4704, A); // Care needed with I/O space and word fetches
    wr_mem(0x4705, B); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCCF0                   ; BB09: BD CC F0      \n");
                                      #endif // Get divider result and multiply by Math result Z, insert VCTR instruction
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x0c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbb); 
    clockticks = clockticks + 1; 
    goto LCCF0;
  case 0xBB0C:
LBB0C:
                                                     #ifdef DEBUG
                                      mon("LBB0C    LDA   #$72                    ; BB0C: 86 72         \n");
                                      #endif // r      ; Vector SCAL instruction
    PC = 0xbb0c; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x72; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $5018                   ; BB0E: F6 50 18      \n");
                                      #endif // XT
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x5018); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; BB11: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; BB12: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; BB13: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
    // End of function sub_BAA0
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; BB15: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBB16:
LBB16:
                                                     #ifdef DEBUG
                                      mon("LBB16    LDB   #$03                    ; BB16: C6 03         \n");
                                      #endif
    PC = 0xbb16; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x03; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function sub_BB16
                                                     #ifdef DEBUG
                                      mon("         BRA   LBB22                   ; BB18: 20 08         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LBB22;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBB1A:
LBB1A:
                                                     #ifdef DEBUG
                                      mon("LBB1A    LDB   #$01                    ; BB1A: C6 01         \n");
                                      #endif
    PC = 0xbb1a; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x01; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function sub_BB1A
                                                     #ifdef DEBUG
                                      mon("         BRA   LBB22                   ; BB1C: 20 04         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LBB22;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBB1E:
LBB1E:
                                                     #ifdef DEBUG
                                      mon("LBB1E    LDB   #$02                    ; BB1E: C6 02         \n");
                                      #endif
    PC = 0xbb1e; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x02; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LBB22                   ; BB20: 20 00         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LBB22;
    
  case 0xBB22:
LBB22:
                                                     #ifdef DEBUG
                                      mon("LBB22    STB   <$DC                    ; BB22: D7 DC         \n");
                                      #endif
    PC = 0xbb22; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xdc; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDB   $0D,X                   ; BB24: E6 0D         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x000d)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$1F                    ; BB26: C1 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x1f; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BLS   LBB2F                   ; BB28: 23 05         \n");
                                      #endif // Tie fighter hit colour cycle table
    // temp hack to force a flush
    if ((!Z) || C) {
    clockticks = clockticks + 3; 
    goto LBB2F;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$A018                  ; BB2A: CC A0 18      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xa0; 
    B = 0x18; 
    Z = A|B; 
    N = A; 
    V = 0; 
    // End of function sub_BB1E
                                                     #ifdef DEBUG
                                      mon("         BRA   LBB35                   ; BB2D: 20 06         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LBB35;
    
    // =============== S U B R O U T I N E =======================================
    // Tie fighter hit colour cycle table
  case 0xBB2F:
LBB2F:
                                                     #ifdef DEBUG
                                      mon("LBB2F    LDU   #word_BB3B              ; BB2F: CE BB 3B      \n");
                                      #endif
    PC = 0xbb2f; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0xbb3b; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; BB32: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   B,U                     ; BB33: EC C5         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + (SINT8)B); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0xBB35:
LBB35:
                                                     #ifdef DEBUG
                                      mon("LBB35    STD   ,Y++                    ; BB35: ED A1         \n");
                                      #endif
    PC = 0xbb35; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCCF0                   ; BB37: BD CC F0      \n");
                                      #endif // Get divider result and multiply by Math result Z, insert VCTR instruction
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x3a); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbb); 
    clockticks = clockticks + 1; 
    goto LCCF0;
    // End of function sub_BB2F
    // ---------------------------------------------------------------------------
  case 0xBB3A:
LBB3A:
                                                     #ifdef DEBUG
                                      mon("LBB3A    RTS                           ; BB3A: 39            \n");
                                      #endif
    PC = 0xbb3a; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBB7B:
LBB7B:
                                                     #ifdef DEBUG
                                      mon("LBB7B    LDA   #$01                    ; BB7B: 86 01         \n");
                                      #endif
    PC = 0xbb7b; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x01; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$A1                    ; BB7D: 97 A1         \n");
                                      #endif // Death Star explosion state
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xa1; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$01                    ; BB7F: CC 00 01      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x01; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$9F                    ; BB82: DD 9F         \n");
                                      #endif
    clockticks = clockticks + 4; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = DP|0x9f; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    // End of function sub_BB7B
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; BB84: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Death Star explosion animation
  case 0xBB85:
LBB85:
                                                     #ifdef DEBUG
                                      mon("LBB85    LDA   <$A1                    ; BB85: 96 A1         \n");
                                      #endif // Death Star explosion state
    PC = 0xbb85; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xa1); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLA                          ; BB87: 48            \n");
                                      #endif
    val = (UINT8)A; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #off_BB8E               ; BB88: 8E BB 8E      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0xbb8e; 
    Z = X; 
    N = (X) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   [A,X]                   ; BB8B: AD 96         \n");
                                      #endif
    clockticks = clockticks + 3; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 2; 
    ea = rd_mem((UINT16)(X + (SINT8)A))<<8; 
    ea = ea | rd_mem((UINT16)(X + (SINT8)A + 1)); 
    --S;
    wr_mem(S, 0x8d); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbb); 
    clockticks = clockticks + 1; 
    PC = ea; 
    JUMP;
    // End of function sub_BB85
    // ---------------------------------------------------------------------------
  case 0xBB8D:
LBB8D:
locret_BB8D:
                                                     #ifdef DEBUG
                                      mon("locret_BB8D RTS                           ; BB8D: 39            \n");
                                      #endif
    PC = 0xbb8d; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBB98:
LBB98:
                                                     #ifdef DEBUG
                                      mon("LBB98    LDD   #$6480                  ; BB98: CC 64 80      \n");
                                      #endif
    PC = 0xbb98; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x64; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #$76F0                  ; BB9B: CE 76 F0      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x76f0; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDX   <$9F                    ; BB9E: 9E 9F         \n");
                                      #endif
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x9f)<<8; 
    ea = ea | rd_mem(DP|0xa0); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LBCAE                   ; BBA0: BD BC AE      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xa3); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbb); 
    clockticks = clockticks + 1; 
    goto LBCAE;
  case 0xBBA3:
LBBA3:
                                                     #ifdef DEBUG
                                      mon("LBBA3    LDD   <$9F                    ; BBA3: DC 9F         \n");
                                      #endif
    PC = 0xbba3; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x9f); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0xa0); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$02                    ; BBA5: C3 00 02      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0002; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$9F                    ; BBA8: DD 9F         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x9f; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$3F                    ; BBAA: 10 83 00 3F   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x003f; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCC   locret_BBBA             ; BBAE: 24 0A         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LBBBA;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$01                    ; BBB0: CC 00 01      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x01; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$9F                    ; BBB3: DD 9F         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x9f; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         INC   <$A1                    ; BBB5: 0C A1         \n");
                                      #endif // Death Star explosion state
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xa1); 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    wr_mem(DP|0xa1, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Sound_27                ; BBB7: BD BD B7      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xba); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbb); 
    clockticks = clockticks + 1; 
    goto LBDB7;
    // End of function sub_BB98
  case 0xBBBA:
LBBBA:
locret_BBBA:
                                                     #ifdef DEBUG
                                      mon("locret_BBBA RTS                           ; BBBA: 39            \n");
                                      #endif
    PC = 0xbbba; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBBBB:
LBBBB:
                                                     #ifdef DEBUG
                                      mon("LBBBB    LDX   <$9F                    ; BBBB: 9E 9F         \n");
                                      #endif
    PC = 0xbbbb; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x9f)<<8; 
    ea = ea | rd_mem(DP|0xa0); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$61FF                  ; BBBD: CC 61 FF      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x61; 
    B = 0xff; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #$76F0                  ; BBC0: CE 76 F0      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x76f0; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LBCAE                   ; BBC3: BD BC AE      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xc6); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbb); 
    clockticks = clockticks + 1; 
    goto LBCAE;
  case 0xBBC6:
LBBC6:
                                                     #ifdef DEBUG
                                      mon("LBBC6    LDD   <$9F                    ; BBC6: DC 9F         \n");
                                      #endif
    PC = 0xbbc6; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x9f); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0xa0); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$02                    ; BBC8: C3 00 02      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0002; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$9F                    ; BBCB: DD 9F         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x9f; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$3F                    ; BBCD: 10 83 00 3F   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x003f; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCC   LBC0B                   ; BBD1: 24 38         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LBC0B;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   #$3F                    ; BBD3: C6 3F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x3f; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBB  <$A0                    ; BBD5: D0 A0         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)B; 
    arg = rd_mem(DP|0xa0); 
    res = val - (UINT8)arg; 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    B = (UINT8)(res); 
                                                     #ifdef DEBUG
                                      mon("         CLRA                          ; BBD7: 4F            \n");
                                      #endif
    A = 0; // SEARCH_ME
 // V = 0; 
 // Z = 0; 
 // N = 0; 
 // C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         TFR   D,X                     ; BBD8: 1F 01         \n");
                                      #endif
    X = ((A << 8) | B); 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$64FF                  ; BBDA: CC 64 FF      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x64; 
    B = 0xff; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LBCAE                   ; BBDD: BD BC AE      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xe0); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbb); 
    clockticks = clockticks + 1; 
    goto LBCAE;
  case 0xBBE0:
LBBE0:
                                                     #ifdef DEBUG
                                      mon("LBBE0    LDD   <$9F                    ; BBE0: DC 9F         \n");
                                      #endif
    PC = 0xbbe0; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x9f); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0xa0); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; BBE2: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLA                          ; BBE3: 49            \n");
                                      #endif
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; BBE4: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLA                          ; BBE5: 49            \n");
                                      #endif
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; BBE6: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLA                          ; BBE7: 49            \n");
                                      #endif
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; BBE8: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         COMB                          ; BBE9: 53            \n");
                                      #endif
    val = (UINT8)B ^ 0xff; 
    B = val; 
    Z = val; 
    N = val; 
    V = 0; 
    C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BMI   LBBEF                   ; BBEA: 2B 03         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LBBEF;
    }
                                                     #ifdef DEBUG
                                      mon("         DECA                          ; BBEC: 4A            \n");
                                      #endif
    val = (UINT8)A; 
    res = (UINT8)(val - 1); 
 // N = res; 
 // Z = res; 
 // V = val & ~res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ORB   #$80                    ; BBED: CA 80         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = B | (UINT8)0x80; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
  case 0xBBEF:
LBBEF:
                                                     #ifdef DEBUG
                                      mon("LBBEF    ADDD  #$7670                  ; BBEF: C3 76 70      \n");
                                      #endif
    PC = 0xbbef; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = 0x7670; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         TSTB                          ; BBF2: 5D            \n");
                                      #endif
    val = (UINT8)B; 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BMI   LBBF8                   ; BBF3: 2B 03         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LBBF8;
    }
                                                     #ifdef DEBUG
                                      mon("         DECA                          ; BBF5: 4A            \n");
                                      #endif
    val = (UINT8)A; 
    res = (UINT8)(val - 1); 
 // N = res; 
 // Z = res; 
 // V = val & ~res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$7F                    ; BBF6: C4 7F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x7f; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
  case 0xBBF8:
LBBF8:
                                                     #ifdef DEBUG
                                      mon("LBBF8    TFR   D,U                     ; BBF8: 1F 03         \n");
                                      #endif
    PC = 0xbbf8; 
    INSTRUCTION_START
    U = ((A << 8) | B); 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$9F                    ; BBFA: DC 9F         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x9f); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0xa0); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LSRB                          ; BBFC: 54            \n");
                                      #endif
    val = (UINT8)B; 
 // C = val & 1; 
    val = val >> 1; 
    B = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRB                          ; BBFD: 54            \n");
                                      #endif
    val = (UINT8)B; 
 // C = val & 1; 
    val = val >> 1; 
    B = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$07                    ; BBFE: C4 07         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x07; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         EORB  #$07                    ; BC00: C8 07         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = B ^ (SINT8)0x07; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         INCB                          ; BC02: 5C            \n");
                                      #endif
    val = (UINT8)B; 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         TFR   D,X                     ; BC03: 1F 01         \n");
                                      #endif
    X = ((A << 8) | B); 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$64FF                  ; BC05: CC 64 FF      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x64; 
    B = 0xff; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LBCC8                   ; BC08: BD BC C8      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x0b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbc); 
    clockticks = clockticks + 1; 
    goto LBCC8;
  case 0xBC0B:
LBC0B:
                                                     #ifdef DEBUG
                                      mon("LBC0B    LDD   <$9F                    ; BC0B: DC 9F         \n");
                                      #endif
    PC = 0xbc0b; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x9f); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0xa0); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$3F                    ; BC0D: 10 83 00 3F   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x003f; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   locret_BC1D             ; BC11: 25 0A         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LBC1D;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$01                    ; BC13: CC 00 01      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x01; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$9F                    ; BC16: DD 9F         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x9f; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         INC   <$A1                    ; BC18: 0C A1         \n");
                                      #endif // Death Star explosion state
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xa1); 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    wr_mem(DP|0xa1, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Sound_27                ; BC1A: BD BD B7      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x1d); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbc); 
    clockticks = clockticks + 1; 
    goto LBDB7;
    // End of function sub_BBBB
  case 0xBC1D:
LBC1D:
locret_BC1D:
                                                     #ifdef DEBUG
                                      mon("locret_BC1D RTS                           ; BC1D: 39            \n");
                                      #endif
    PC = 0xbc1d; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBC1E:
LBC1E:
                                                     #ifdef DEBUG
                                      mon("LBC1E    LDX   <$9F                    ; BC1E: 9E 9F         \n");
                                      #endif
    PC = 0xbc1e; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x9f)<<8; 
    ea = ea | rd_mem(DP|0xa0); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$67FF                  ; BC20: CC 67 FF      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x67; 
    B = 0xff; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #$7670                  ; BC23: CE 76 70      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x7670; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LBCAE                   ; BC26: BD BC AE      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x29); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbc); 
    clockticks = clockticks + 1; 
    goto LBCAE;
  case 0xBC29:
LBC29:
                                                     #ifdef DEBUG
                                      mon("LBC29    LDD   <$9F                    ; BC29: DC 9F         \n");
                                      #endif
    PC = 0xbc29; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x9f); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0xa0); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$03                    ; BC2B: C3 00 03      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0003; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$9F                    ; BC2E: DD 9F         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x9f; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$3F                    ; BC30: 10 83 00 3F   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x003f; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCC   LBC43                   ; BC34: 24 0D         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LBC43;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   #$3F                    ; BC36: C6 3F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x3f; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBB  <$A0                    ; BC38: D0 A0         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)B; 
    arg = rd_mem(DP|0xa0); 
    res = val - (UINT8)arg; 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    B = (UINT8)(res); 
                                                     #ifdef DEBUG
                                      mon("         CLRA                          ; BC3A: 4F            \n");
                                      #endif
    A = 0; // SEARCH_ME
 // V = 0; 
 // Z = 0; 
 // N = 0; 
 // C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         TFR   D,X                     ; BC3B: 1F 01         \n");
                                      #endif
    X = ((A << 8) | B); 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$61FF                  ; BC3D: CC 61 FF      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x61; 
    B = 0xff; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LBCAE                   ; BC40: BD BC AE      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x43); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbc); 
    clockticks = clockticks + 1; 
    goto LBCAE;
  case 0xBC43:
LBC43:
                                                     #ifdef DEBUG
                                      mon("LBC43    LDD   <$9F                    ; BC43: DC 9F         \n");
                                      #endif
    PC = 0xbc43; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x9f); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0xa0); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$3F                    ; BC45: 10 83 00 3F   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x003f; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCC   LBC72                   ; BC49: 24 27         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LBC72;
    }
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; BC4B: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLA                          ; BC4C: 49            \n");
                                      #endif
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; BC4D: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLA                          ; BC4E: 49            \n");
                                      #endif
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; BC4F: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLA                          ; BC50: 49            \n");
                                      #endif
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; BC51: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         COMB                          ; BC52: 53            \n");
                                      #endif
    val = (UINT8)B ^ 0xff; 
    B = val; 
    Z = val; 
    N = val; 
    V = 0; 
    C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BMI   LBC58                   ; BC53: 2B 03         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LBC58;
    }
                                                     #ifdef DEBUG
                                      mon("         DECA                          ; BC55: 4A            \n");
                                      #endif
    val = (UINT8)A; 
    res = (UINT8)(val - 1); 
 // N = res; 
 // Z = res; 
 // V = val & ~res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ORB   #$80                    ; BC56: CA 80         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = B | (UINT8)0x80; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
  case 0xBC58:
LBC58:
                                                     #ifdef DEBUG
                                      mon("LBC58    ADDD  #$7670                  ; BC58: C3 76 70      \n");
                                      #endif
    PC = 0xbc58; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = 0x7670; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         TSTB                          ; BC5B: 5D            \n");
                                      #endif
    val = (UINT8)B; 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BMI   LBC61                   ; BC5C: 2B 03         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LBC61;
    }
                                                     #ifdef DEBUG
                                      mon("         DECA                          ; BC5E: 4A            \n");
                                      #endif
    val = (UINT8)A; 
    res = (UINT8)(val - 1); 
 // N = res; 
 // Z = res; 
 // V = val & ~res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$7F                    ; BC5F: C4 7F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x7f; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
  case 0xBC61:
LBC61:
                                                     #ifdef DEBUG
                                      mon("LBC61    TFR   D,U                     ; BC61: 1F 03         \n");
                                      #endif
    PC = 0xbc61; 
    INSTRUCTION_START
    U = ((A << 8) | B); 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$9F                    ; BC63: DC 9F         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x9f); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0xa0); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$0F                    ; BC65: C4 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x0f; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         EORB  #$0F                    ; BC67: C8 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = B ^ (SINT8)0x0f; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         INCB                          ; BC69: 5C            \n");
                                      #endif
    val = (UINT8)B; 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         TFR   D,X                     ; BC6A: 1F 01         \n");
                                      #endif
    X = ((A << 8) | B); 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$61FF                  ; BC6C: CC 61 FF      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x61; 
    B = 0xff; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LBCC8                   ; BC6F: BD BC C8      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x72); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbc); 
    clockticks = clockticks + 1; 
    goto LBCC8;
  case 0xBC72:
LBC72:
                                                     #ifdef DEBUG
                                      mon("LBC72    LDD   <$9F                    ; BC72: DC 9F         \n");
                                      #endif
    PC = 0xbc72; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x9f); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0xa0); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$50                    ; BC74: 10 83 00 50   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x0050; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   locret_BC84             ; BC78: 25 0A         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LBC84;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$80                    ; BC7A: CC 00 80      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$9F                    ; BC7D: DD 9F         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x9f; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         INC   <$A1                    ; BC7F: 0C A1         \n");
                                      #endif // Death Star explosion state
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xa1); 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    wr_mem(DP|0xa1, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Sound_27                ; BC81: BD BD B7      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x84); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbc); 
    clockticks = clockticks + 1; 
    goto LBDB7;
    // End of function sub_BC1E
  case 0xBC84:
LBC84:
locret_BC84:
                                                     #ifdef DEBUG
                                      mon("locret_BC84 RTS                           ; BC84: 39            \n");
                                      #endif
    PC = 0xbc84; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBC85:
LBC85:
                                                     #ifdef DEBUG
                                      mon("LBC85    LDD   <$9F                    ; BC85: DC 9F         \n");
                                      #endif
    PC = 0xbc85; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x9f); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0xa0); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$04                    ; BC87: 83 00 04      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0004; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$9F                    ; BC8A: DD 9F         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x9f; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$08                    ; BC8C: 10 83 00 08   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x0008; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LBCA9                   ; BC90: 25 17         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LBCA9;
    }
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$7500                  ; BC92: C3 75 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x7500; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         TFR   D,U                     ; BC95: 1F 03         \n");
                                      #endif
    U = ((A << 8) | B); 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$9F                    ; BC97: DC 9F         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x9f); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0xa0); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; BC99: 44            \n");
                                      #endif
    val = (UINT8)A; 
    C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         RORB                          ; BC9A: 56            \n");
                                      #endif
    res = ((UINT8)B) | ((C != 0) ? 0x100 : 0); 
    C = res & 1; 
    res = (UINT8)(res >> 1); 
 // Z = res; 
 // N = res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$3F                    ; BC9B: C4 3F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x3f; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         EORB  #$3F                    ; BC9D: C8 3F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = B ^ (SINT8)0x3f; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         TFR   D,X                     ; BC9F: 1F 01         \n");
                                      #endif
    X = ((A << 8) | B); 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$67FF                  ; BCA1: CC 67 FF      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x67; 
    B = 0xff; 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LBCC8                   ; BCA4: BD BC C8      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xa7); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbc); 
    clockticks = clockticks + 1; 
    goto LBCC8;
  case 0xBCA7:
LBCA7:
                                                     #ifdef DEBUG
                                      mon("LBCA7    BRA   locret_BCAD             ; BCA7: 20 04         \n");
                                      #endif
    PC = 0xbca7; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto LBCAD;
    
    // ---------------------------------------------------------------------------
  case 0xBCA9:
LBCA9:
                                                     #ifdef DEBUG
                                      mon("LBCA9    LDA   #$00                    ; BCA9: 86 00         \n");
                                      #endif
    PC = 0xbca9; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$A1                    ; BCAB: 97 A1         \n");
                                      #endif // Death Star explosion state
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0xa1; 
    wr_mem(ea, val); 
    // End of function sub_BC85
  case 0xBCAD:
LBCAD:
locret_BCAD:
                                                     #ifdef DEBUG
                                      mon("locret_BCAD RTS                           ; BCAD: 39            \n");
                                      #endif
    PC = 0xbcad; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBCAE:
LBCAE:
                                                     #ifdef DEBUG
                                      mon("LBCAE    STD   ,Y++                    ; BCAE: ED A1         \n");
                                      #endif
    PC = 0xbcae; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
  case 0xBCB0:
LBCB0:
                                                     #ifdef DEBUG
                                      mon("LBCB0    LDD   #$1F98                  ; BCB0: CC 1F 98      \n");
                                      #endif
    PC = 0xbcb0; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x1f; 
    B = 0x98; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; BCB3: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; BCB5: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; BCB8: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         STU   ,Y++                    ; BCBA: EF A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$BD69                  ; BCBC: CC BD 69      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xbd; 
    B = 0x69; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; BCBF: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
    N = A; 
    V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LEAU  -2,U                    ; BCC1: 33 5E         \n");
                                      #endif
    clockticks = clockticks + 5; 
    U = (U + 0xfffe); 
                                                     #ifdef DEBUG
                                      mon("         LEAX  -1,X                    ; BCC3: 30 1F         \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + 0xffff); 
    Z = X; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LBCB0                   ; BCC5: 26 E9         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LBCB0;
    }
    // End of function sub_BCAE
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; BCC7: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBCC8:
LBCC8:
                                                     #ifdef DEBUG
                                      mon("LBCC8    STD   ,Y++                    ; BCC8: ED A1         \n");
                                      #endif
    PC = 0xbcc8; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
  case 0xBCCA:
LBCCA:
                                                     #ifdef DEBUG
                                      mon("LBCCA    LDD   #$1F98                  ; BCCA: CC 1F 98      \n");
                                      #endif
    PC = 0xbcca; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x1f; 
    B = 0x98; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; BCCD: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; BCCF: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; BCD2: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         STU   ,Y++                    ; BCD4: EF A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$BD69                  ; BCD6: CC BD 69      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xbd; 
    B = 0x69; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; BCD9: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         TFR   U,D                     ; BCDB: 1F 30         \n");
                                      #endif
    val = U; 
    A = (UINT8)(val >> 8); 
    B = (UINT8)val; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$04                    ; BCDD: 83 00 04      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0004; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$7F                    ; BCE0: C4 7F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x7f; 
    B = res; 
 // Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         TFR   D,U                     ; BCE2: 1F 03         \n");
                                      #endif
    U = ((A << 8) | B); 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         LEAX  -1,X                    ; BCE4: 30 1F         \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + 0xffff); 
    Z = X; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LBCCA                   ; BCE6: 26 E2         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LBCCA;
    }
    // End of function sub_BCC8
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; BCE8: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
    // START OF FUNCTION CHUNK FOR Sound_3
  case 0xBCE9:
LBCE9:
Write_Sound:
                                                     #ifdef DEBUG
                                      mon("Write_Sound LDB   #$0E                    ; BCE9: C6 0E         \n");
                                      #endif
    PC = 0xbce9; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x0e; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xBCEB:
LBCEB:
                                                     #ifdef DEBUG
                                      mon("LBCEB    TST   $4401                   ; BCEB: 7D 44 01      \n");
                                      #endif
    PC = 0xbceb; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4401); 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LBCF5                   ; BCEE: 2A 05         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LBCF5;
    }
                                                     #ifdef DEBUG
                                      mon("         DECB                          ; BCF0: 5A            \n");
                                      #endif
    val = (UINT8)B; 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LBCEB                   ; BCF1: 26 F8         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LBCEB;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; BCF3: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xBCF5:
LBCF5:
                                                     #ifdef DEBUG
                                      mon("LBCF5    STA   $4400                   ; BCF5: B7 44 00      \n");
                                      #endif
    PC = 0xbcf5; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x4400, val); 
    // END OF FUNCTION CHUNK FOR Sound_3
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; BCF8: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBCF9:
LBCF9:
Sound_1:
                                                     #ifdef DEBUG
                                      mon("Sound_1  LDA   #$01                    ; BCF9: 86 01         \n");
                                      #endif
    PC = 0xbcf9; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x01; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_1
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BCFB: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBCFE:
LBCFE:
Sound_2:
                                                     #ifdef DEBUG
                                      mon("Sound_2  LDA   #$02                    ; BCFE: 86 02         \n");
                                      #endif
    PC = 0xbcfe; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x02; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_2
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BD00: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
    // Attributes: noreturn
    // FUNCTION CHUNK AT ROM:BCE9 SIZE 00000010 BYTES
  case 0xBD03:
LBD03:
                                                     #ifdef DEBUG
                                      mon("LBD03    LDA   #$03                    ; BD03: 86 03         \n");
                                      #endif
    PC = 0xbd03; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x03; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_3
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BD05: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBD08:
LBD08:
Sound_4:
                                                     #ifdef DEBUG
                                      mon("Sound_4  LDA   #$04                    ; BD08: 86 04         \n");
                                      #endif
    PC = 0xbd08; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x04; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_4
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BD0A: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBD0D:
LBD0D:
Sound_5:
                                                     #ifdef DEBUG
                                      mon("Sound_5  LDA   #$05                    ; BD0D: 86 05         \n");
                                      #endif
    PC = 0xbd0d; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x05; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_5
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BD0F: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBD12:
LBD12:
Sound_6:
                                                     #ifdef DEBUG
                                      mon("Sound_6  LDA   #$06                    ; BD12: 86 06         \n");
                                      #endif
    PC = 0xbd12; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x06; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_6
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BD14: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBD17:
LBD17:
Sound_7:
                                                     #ifdef DEBUG
                                      mon("Sound_7  LDA   #$07                    ; BD17: 86 07         \n");
                                      #endif
    PC = 0xbd17; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x07; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_7
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BD19: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBD1C:
LBD1C:
Sound_8:
                                                     #ifdef DEBUG
                                      mon("Sound_8  LDA   #$08                    ; BD1C: 86 08         \n");
                                      #endif
    PC = 0xbd1c; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x08; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_8
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BD1E: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBD21:
LBD21:
Sound_9:
                                                     #ifdef DEBUG
                                      mon("Sound_9  LDA   #$09                    ; BD21: 86 09         \n");
                                      #endif
    PC = 0xbd21; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x09; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_9
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BD23: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBD26:
LBD26:
Sound_A:
                                                     #ifdef DEBUG
                                      mon("Sound_A  LDA   #$0A                    ; BD26: 86 0A         \n");
                                      #endif
    PC = 0xbd26; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x0a; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_A
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BD28: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBD2B:
LBD2B:
Sound_B:
                                                     #ifdef DEBUG
                                      mon("Sound_B  LDA   #$0B                    ; BD2B: 86 0B         \n");
                                      #endif
    PC = 0xbd2b; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x0b; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_B
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BD2D: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBD30:
LBD30:
Sound_C:
                                                     #ifdef DEBUG
                                      mon("Sound_C  LDA   #$0C                    ; BD30: 86 0C         \n");
                                      #endif
    PC = 0xbd30; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x0c; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_C
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BD32: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBD35:
LBD35:
Sound_D:
                                                     #ifdef DEBUG
                                      mon("Sound_D  LDA   #$0D                    ; BD35: 86 0D         \n");
                                      #endif
    PC = 0xbd35; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x0d; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_D
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BD37: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBD3A:
LBD3A:
Sound_E:
                                                     #ifdef DEBUG
                                      mon("Sound_E  LDA   #$0E                    ; BD3A: 86 0E         \n");
                                      #endif
    PC = 0xbd3a; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x0e; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_E
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BD3C: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBD3F:
LBD3F:
Sound_F:
                                                     #ifdef DEBUG
                                      mon("Sound_F  LDA   #$0F                    ; BD3F: 86 0F         \n");
                                      #endif
    PC = 0xbd3f; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x0f; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_F
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BD41: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBD44:
LBD44:
Sound_10:
                                                     #ifdef DEBUG
                                      mon("Sound_10 LDA   #$10                    ; BD44: 86 10         \n");
                                      #endif
    PC = 0xbd44; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x10; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_10
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BD46: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
    // Remember
  case 0xBD49:
LBD49:
Sound_11:
                                                     #ifdef DEBUG
                                      mon("Sound_11 LDA   #$11                    ; BD49: 86 11         \n");
                                      #endif
    PC = 0xbd49; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x11; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_11
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BD4B: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBD4E:
LBD4E:
Sound_12:
                                                     #ifdef DEBUG
                                      mon("Sound_12 LDA   #$12                    ; BD4E: 86 12         \n");
                                      #endif
    PC = 0xbd4e; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x12; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_12
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BD50: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
    // Look at the size of that thing
  case 0xBD53:
LBD53:
Sound_13:
                                                     #ifdef DEBUG
                                      mon("Sound_13 LDA   #$13                    ; BD53: 86 13         \n");
                                      #endif
    PC = 0xbd53; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x13; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_13
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BD55: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
    // Stay in attack formation
  case 0xBD58:
LBD58:
Sound_14:
                                                     #ifdef DEBUG
                                      mon("Sound_14 LDA   #$14                    ; BD58: 86 14         \n");
                                      #endif
    PC = 0xbd58; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x14; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_14
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BD5A: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBD5D:
LBD5D:
Sound_15:
                                                     #ifdef DEBUG
                                      mon("Sound_15 LDA   #$15                    ; BD5D: 86 15         \n");
                                      #endif
    PC = 0xbd5d; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x15; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_15
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BD5F: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
    // Force is strong in this one
  case 0xBD62:
LBD62:
Sound_16:
                                                     #ifdef DEBUG
                                      mon("Sound_16 LDA   #$16                    ; BD62: 86 16         \n");
                                      #endif
    PC = 0xbd62; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x16; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_16
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BD64: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
    // Red 5 Im going in
  case 0xBD67:
LBD67:
Sound_17:
                                                     #ifdef DEBUG
                                      mon("Sound_17 LDA   #$17                    ; BD67: 86 17         \n");
                                      #endif
    PC = 0xbd67; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x17; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_17
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BD69: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
    // Luke trust me
  case 0xBD6C:
LBD6C:
Sound_18:
                                                     #ifdef DEBUG
                                      mon("Sound_18 LDA   #$18                    ; BD6C: 86 18         \n");
                                      #endif
    PC = 0xbd6c; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x18; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_18
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BD6E: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBD71:
LBD71:
Sound_19:
                                                     #ifdef DEBUG
                                      mon("Sound_19 LDA   #$19                    ; BD71: 86 19         \n");
                                      #endif
    PC = 0xbd71; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x19; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_19
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BD73: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
    // Yahoo youre all clear kid
  case 0xBD76:
LBD76:
Sound_1A:
                                                     #ifdef DEBUG
                                      mon("Sound_1A LDA   #$1A                    ; BD76: 86 1A         \n");
                                      #endif
    PC = 0xbd76; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x1a; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_1A
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BD78: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
    // High score
  case 0xBD7B:
LBD7B:
Sound_1B:
                                                     #ifdef DEBUG
                                      mon("Sound_1B LDA   #$1B                    ; BD7B: 86 1B         \n");
                                      #endif
    PC = 0xbd7b; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x1b; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_1B
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BD7D: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBD80:
LBD80:
Sound_1C:
                                                     #ifdef DEBUG
                                      mon("Sound_1C LDA   #$1C                    ; BD80: 86 1C         \n");
                                      #endif
    PC = 0xbd80; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x1c; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_1C
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BD82: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
    // Imperial March
  case 0xBD85:
LBD85:
Sound_1D:
                                                     #ifdef DEBUG
                                      mon("Sound_1D LDA   #$1D                    ; BD85: 86 1D         \n");
                                      #endif
    PC = 0xbd85; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x1d; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_1D
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BD87: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
    // Enter Death Star
  case 0xBD8A:
LBD8A:
Sound_1E:
                                                     #ifdef DEBUG
                                      mon("Sound_1E LDA   #$1E                    ; BD8A: 86 1E         \n");
                                      #endif
    PC = 0xbd8a; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x1e; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_1E
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BD8C: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
    // Death Star destroyed
  case 0xBD8F:
LBD8F:
Sound_1F:
                                                     #ifdef DEBUG
                                      mon("Sound_1F LDA   #$1F                    ; BD8F: 86 1F         \n");
                                      #endif
    PC = 0xbd8f; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x1f; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_1F
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BD91: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
    // Towers 1 music
  case 0xBD94:
LBD94:
Sound_20:
                                                     #ifdef DEBUG
                                      mon("Sound_20 LDA   #$20                    ; BD94: 86 20         \n");
                                      #endif
    PC = 0xbd94; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x20; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_20
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BD96: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
    // Towers 2 music
  case 0xBD99:
LBD99:
Sound_21:
                                                     #ifdef DEBUG
                                      mon("Sound_21 LDA   #$21                    ; BD99: 86 21         \n");
                                      #endif
    PC = 0xbd99; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x21; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_21
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BD9B: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
    // Trench music
  case 0xBD9E:
LBD9E:
Sound_22:
                                                     #ifdef DEBUG
                                      mon("Sound_22 LDA   #$22                    ; BD9E: 86 22         \n");
                                      #endif
    PC = 0xbd9e; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x22; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_22
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BDA0: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBDA3:
LBDA3:
Sound_23:
                                                     #ifdef DEBUG
                                      mon("Sound_23 LDA   #$23                    ; BDA3: 86 23         \n");
                                      #endif
    PC = 0xbda3; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x23; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_23
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BDA5: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
    // Space wave 1 music
  case 0xBDA8:
LBDA8:
Sound_24:
                                                     #ifdef DEBUG
                                      mon("Sound_24 LDA   #$24                    ; BDA8: 86 24         \n");
                                      #endif
    PC = 0xbda8; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x24; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_24
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BDAA: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
    // Space Wave 2 music
  case 0xBDAD:
LBDAD:
Sound_25:
                                                     #ifdef DEBUG
                                      mon("Sound_25 LDA   #$25                    ; BDAD: 86 25         \n");
                                      #endif
    PC = 0xbdad; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x25; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_25
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BDAF: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
    // Explosion
  case 0xBDB2:
LBDB2:
Sound_26:
                                                     #ifdef DEBUG
                                      mon("Sound_26 LDA   #$26                    ; BDB2: 86 26         \n");
                                      #endif
    PC = 0xbdb2; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x26; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_26
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BDB4: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBDB7:
LBDB7:
Sound_27:
                                                     #ifdef DEBUG
                                      mon("Sound_27 LDA   #$27                    ; BDB7: 86 27         \n");
                                      #endif
    PC = 0xbdb7; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x27; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_27
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BDB9: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBDBC:
LBDBC:
Sound_28:
                                                     #ifdef DEBUG
                                      mon("Sound_28 LDA   #$28                    ; BDBC: 86 28         \n");
                                      #endif
    PC = 0xbdbc; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x28; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_28
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BDBE: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBDC1:
LBDC1:
Sound_29:
                                                     #ifdef DEBUG
                                      mon("Sound_29 LDA   #$29                    ; BDC1: 86 29         \n");
                                      #endif
    PC = 0xbdc1; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x29; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_29
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BDC3: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBDC6:
LBDC6:
Sound_2A:
                                                     #ifdef DEBUG
                                      mon("Sound_2A LDA   #$2A                    ; BDC6: 86 2A         \n");
                                      #endif
    PC = 0xbdc6; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x2a; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_2A
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BDC8: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBDCB:
LBDCB:
Sound_2B:
                                                     #ifdef DEBUG
                                      mon("Sound_2B LDA   #$2B                    ; BDCB: 86 2B         \n");
                                      #endif
    PC = 0xbdcb; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x2b; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_2B
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BDCD: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBDD0:
LBDD0:
Sound_2C:
                                                     #ifdef DEBUG
                                      mon("Sound_2C LDA   #$2C                    ; BDD0: 86 2C         \n");
                                      #endif
    PC = 0xbdd0; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x2c; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_2C
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BDD2: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBDD5:
LBDD5:
                                                     #ifdef DEBUG
                                      mon("LBDD5    LDA   #$2D                    ; BDD5: 86 2D         \n");
                                      #endif
    PC = 0xbdd5; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x2d; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_2D
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BDD7: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBDDA:
LBDDA:
Sound_2E:
                                                     #ifdef DEBUG
                                      mon("Sound_2E LDA   #$2E                    ; BDDA: 86 2E         \n");
                                      #endif
    PC = 0xbdda; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x2e; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_2E
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BDDC: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBDDF:
LBDDF:
Sound_2F:
                                                     #ifdef DEBUG
                                      mon("Sound_2F LDA   #$2F                    ; BDDF: 86 2F         \n");
                                      #endif
    PC = 0xbddf; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x2f; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_2F
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BDE1: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBDE4:
LBDE4:
Sound_30:
                                                     #ifdef DEBUG
                                      mon("Sound_30 LDA   #$30                    ; BDE4: 86 30         \n");
                                      #endif
    PC = 0xbde4; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x30; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_30
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BDE6: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBDE9:
LBDE9:
Sound_31:
                                                     #ifdef DEBUG
                                      mon("Sound_31 LDA   #$31                    ; BDE9: 86 31         \n");
                                      #endif
    PC = 0xbde9; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x31; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_31
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BDEB: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
    // R2 beeps entering Death Star
  case 0xBDEE:
LBDEE:
Sound_32:
                                                     #ifdef DEBUG
                                      mon("Sound_32 LDA   #$32                    ; BDEE: 86 32         \n");
                                      #endif
    PC = 0xbdee; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x32; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_32
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BDF0: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBDF3:
LBDF3:
Sound_33:
                                                     #ifdef DEBUG
                                      mon("Sound_33 LDA   #$33                    ; BDF3: 86 33         \n");
                                      #endif
    PC = 0xbdf3; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x33; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_33
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BDF5: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBDF8:
LBDF8:
                                                     #ifdef DEBUG
                                      mon("LBDF8    LDA   #$34                    ; BDF8: 86 34         \n");
                                      #endif
    PC = 0xbdf8; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x34; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_34
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BDFA: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBDFD:
LBDFD:
Sound_35:
                                                     #ifdef DEBUG
                                      mon("Sound_35 LDA   #$35                    ; BDFD: 86 35         \n");
                                      #endif
    PC = 0xbdfd; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x35; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_35
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BDFF: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBE02:
LBE02:
Sound_36:
                                                     #ifdef DEBUG
                                      mon("Sound_36 LDA   #$36                    ; BE02: 86 36         \n");
                                      #endif
    PC = 0xbe02; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x36; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_36
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BE04: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBE07:
LBE07:
Sound_37:
                                                     #ifdef DEBUG
                                      mon("Sound_37 LDA   #$37                    ; BE07: 86 37         \n");
                                      #endif
    PC = 0xbe07; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x37; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_37
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BE09: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBE0C:
LBE0C:
Sound_38:
                                                     #ifdef DEBUG
                                      mon("Sound_38 LDA   #$38                    ; BE0C: 86 38         \n");
                                      #endif
    PC = 0xbe0c; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x38; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_38
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BE0E: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBE11:
LBE11:
Sound_39:
                                                     #ifdef DEBUG
                                      mon("Sound_39 LDA   #$39                    ; BE11: 86 39         \n");
                                      #endif
    PC = 0xbe11; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x39; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_39
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BE13: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBE16:
LBE16:
                                                     #ifdef DEBUG
                                      mon("LBE16    LDA   #$3A                    ; BE16: 86 3A         \n");
                                      #endif
    PC = 0xbe16; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x3a; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_3A
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BE18: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
  case 0xBE1B:
LBE1B:
Sound_3B:
                                                     #ifdef DEBUG
                                      mon("Sound_3B LDA   #$3B                    ; BE1B: 86 3B         \n");
                                      #endif
    PC = 0xbe1b; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x3b; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function Sound_3B
                                                     #ifdef DEBUG
                                      mon("         JMP   Write_Sound             ; BE1D: 7E BC E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LBCE9;
    
    // =============== S U B R O U T I N E =======================================
    // Display accounting screen
  case 0xBE20:
LBE20:
                                                     #ifdef DEBUG
                                      mon("LBE20    LDA   #$59                    ; BE20: 86 59         \n");
                                      #endif
    PC = 0xbe20; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x59; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xBE22:
LBE22:
                                                     #ifdef DEBUG
                                      mon("LBE22    JSR   LD8DF                   ; BE22: BD D8 DF      \n");
                                      #endif // Called from select screen, attract screen 1 + 3 when writing text
    PC = 0xbe22; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x25); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbe); 
    clockticks = clockticks + 1; 
    goto LD8DF;
  case 0xBE25:
LBE25:
                                                     #ifdef DEBUG
                                      mon("LBE25    INCA                          ; BE25: 4C            \n");
                                      #endif
    PC = 0xbe25; 
    INSTRUCTION_START
    val = (UINT8)A; 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$65                    ; BE26: 81 65         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x65; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   LBE22                   ; BE28: 25 F8         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LBE22;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$D3                    ; BE2A: 86 D3         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xd3; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LD8DF                   ; BE2C: BD D8 DF      \n");
                                      #endif // Called from select screen, attract screen 1 + 3 when writing text
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x2f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbe); 
    clockticks = clockticks + 1; 
    goto LD8DF;
  case 0xBE2F:
LBE2F:
                                                     #ifdef DEBUG
                                      mon("LBE2F    LDD   #$6480                  ; BE2F: CC 64 80      \n");
                                      #endif
    PC = 0xbe2f; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x64; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; BE32: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$453C                  ; BE34: 8E 45 3C      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x453c; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #word_C7BB              ; BE37: CE C7 BB      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0xc7bb; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0xBE3A:
LBE3A:
                                                     #ifdef DEBUG
                                      mon("LBE3A    LDD   ,U++                    ; BE3A: EC C1         \n");
                                      #endif
    PC = 0xbe3a; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
    A = rd_mem(U); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(U+1)); 
    U = U + 2; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; BE3C: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$30                    ; BE3E: CC 00 30      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x30; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; BE41: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         STU   $4AFA                   ; BE43: FF 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    wr_mem(0x4afa, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem(0x4afb, (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$05                    ; BE46: C6 05         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x05; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STB   <$AD                    ; BE48: D7 AD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xad; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$05                    ; BE4A: C6 05         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x05; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xBE4C:
LBE4C:
                                                     #ifdef DEBUG
                                      mon("LBE4C    LDA   ,X+                     ; BE4C: A6 80         \n");
                                      #endif
    PC = 0xbe4c; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    val = (UINT8)rd_mem(X); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
    X = X + 1; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LE7AD                   ; BE4E: BD E7 AD      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x51); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbe); 
    clockticks = clockticks + 1; 
    goto LE7AD;
  case 0xBE51:
LBE51:
                                                     #ifdef DEBUG
                                      mon("LBE51    DECB                          ; BE51: 5A            \n");
                                      #endif
    PC = 0xbe51; 
    INSTRUCTION_START
    val = (UINT8)B; 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LBE4C                   ; BE52: 2A F8         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LBE4C;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$8040                  ; BE54: CC 80 40      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; BE57: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDU   $4AFA                   ; BE59: FE 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4afa)<<8; 
    ea = ea | rd_mem(0x4afb); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$4554                  ; BE5C: 8C 45 54      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x4554; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LBE3A                   ; BE5F: 25 D9         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LBE3A;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   word_C7C1               ; BE61: FC C7 C1      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0xc7c1); // Care needed with I/O space and word fetches
    B = rd_mem(0xc7c2); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; BE64: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$013C                  ; BE66: CC 01 3C      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x01; 
    B = 0x3c; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; BE69: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$01                    ; BE6B: 86 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x01; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$AD                    ; BE6D: 97 AD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xad; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4588                   ; BE6F: B6 45 88      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4588); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LE7AD                   ; BE72: BD E7 AD      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x75); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbe); 
    clockticks = clockticks + 1; 
    goto LE7AD;
  case 0xBE75:
LBE75:
                                                     #ifdef DEBUG
                                      mon("LBE75    LDA   $4589                   ; BE75: B6 45 89      \n");
                                      #endif
    PC = 0xbe75; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4589); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LE7AD                   ; BE78: BD E7 AD      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x7b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbe); 
    clockticks = clockticks + 1; 
    goto LE7AD;
  case 0xBE7B:
LBE7B:
                                                     #ifdef DEBUG
                                      mon("LBE7B    LDD   #$8040                  ; BE7B: CC 80 40      \n");
                                      #endif
    PC = 0xbe7b; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; BE7E: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4548                  ; BE80: 8E 45 48      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x4548; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC6D4                   ; BE83: BD C6 D4      \n");
                                      #endif // Read NOVRAM
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x86); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbe); 
    clockticks = clockticks + 1; 
    goto LC6D4;
  case 0xBE86:
LBE86:
                                                     #ifdef DEBUG
                                      mon("LBE86    LDU   #$4AFE                  ; BE86: CE 4A FE      \n");
                                      #endif
    PC = 0xbe86; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0x4afe; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4542                  ; BE89: 8E 45 42      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x4542; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC6D7                   ; BE8C: BD C6 D7      \n");
                                      #endif // Read NOVRAM
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x8f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbe); 
    clockticks = clockticks + 1; 
    goto LC6D7;
  case 0xBE8F:
LBE8F:
                                                     #ifdef DEBUG
                                      mon("LBE8F    LDA   $4AFC                   ; BE8F: B6 4A FC      \n");
                                      #endif
    PC = 0xbe8f; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4afc); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDA  $4B00                   ; BE92: BB 4B 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    arg = rd_mem(0x4b00); 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         DAA                           ; BE95: 19            \n");
                                      #endif
    res = A; 
    msn = res & 0xf0; 
    lsn = res & 0x0f; 
    res = res + (((lsn > 0x09) || (H & 0x10)) ? 0x06 : 0); 
    res = res + ((((UINT8)msn > 0x80U) && ((UINT8)lsn > 0x09U)) || (((UINT8)msn > 0x90U) || (C != 0)) ? 0x60 : 0); 
    C = C | (res & 0x100); 
    res = (UINT8)res; 
    A = res; 
 // N = res; 
 // Z = res; 
 // V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4AFC                   ; BE96: B7 4A FC      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4afc, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4AFB                   ; BE99: B6 4A FB      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4afb); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADCA  $4AFF                   ; BE9C: B9 4A FF      \n");
                                      #endif
    clockticks = clockticks + 5; 
    arg = A; 
    val = rd_mem(0x4aff); 
    res = arg + val + (C != 0 ? 1:0); 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = arg ^ val ^ (UINT8)res ^ C; 
 // V = arg ^ val ^ (UINT8)res ^ C; 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         DAA                           ; BE9F: 19            \n");
                                      #endif
    res = A; 
    msn = res & 0xf0; 
    lsn = res & 0x0f; 
    res = res + (((lsn > 0x09) || (H & 0x10)) ? 0x06 : 0); 
    res = res + ((((UINT8)msn > 0x80U) && ((UINT8)lsn > 0x09U)) || (((UINT8)msn > 0x90U) || (C != 0)) ? 0x60 : 0); 
    C = C | (res & 0x100); 
    res = (UINT8)res; 
    A = res; 
 // N = res; 
 // Z = res; 
 // V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4AFB                   ; BEA0: B7 4A FB      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4afb, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4AFA                   ; BEA3: B6 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4afa); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADCA  $4AFE                   ; BEA6: B9 4A FE      \n");
                                      #endif
    clockticks = clockticks + 5; 
    arg = A; 
    val = rd_mem(0x4afe); 
    res = arg + val + (C != 0 ? 1:0); 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = arg ^ val ^ (UINT8)res ^ C; 
 // V = arg ^ val ^ (UINT8)res ^ C; 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         DAA                           ; BEA9: 19            \n");
                                      #endif
    res = A; 
    msn = res & 0xf0; 
    lsn = res & 0x0f; 
    res = res + (((lsn > 0x09) || (H & 0x10)) ? 0x06 : 0); 
    res = res + ((((UINT8)msn > 0x80U) && ((UINT8)lsn > 0x09U)) || (((UINT8)msn > 0x90U) || (C != 0)) ? 0x60 : 0); 
 // C = C | (res & 0x100); 
    res = (UINT8)res; 
    A = res; 
 // N = res; 
 // Z = res; 
 // V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4AFA                   ; BEAA: B7 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4afa, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   word_C7C3               ; BEAD: FC C7 C3      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0xc7c3); // Care needed with I/O space and word fetches
    B = rd_mem(0xc7c4); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; BEB0: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$30                    ; BEB2: CC 00 30      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x30; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; BEB5: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$05                    ; BEB7: C6 05         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x05; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STB   <$AD                    ; BEB9: D7 AD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xad; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4AFA                   ; BEBB: B6 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4afa); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Display_Vect_BCD        ; BEBE: BD E7 90      \n");
                                      #endif // Display BCD numbers
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xc1); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbe); 
    clockticks = clockticks + 1; 
    goto LE790;
  case 0xBEC1:
LBEC1:
                                                     #ifdef DEBUG
                                      mon("LBEC1    LDA   $4AFB                   ; BEC1: B6 4A FB      \n");
                                      #endif
    PC = 0xbec1; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4afb); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Display_Vect_BCD        ; BEC4: BD E7 90      \n");
                                      #endif // Display BCD numbers
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xc7); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbe); 
    clockticks = clockticks + 1; 
    goto LE790;
  case 0xBEC7:
LBEC7:
                                                     #ifdef DEBUG
                                      mon("LBEC7    LDA   $4AFC                   ; BEC7: B6 4A FC      \n");
                                      #endif
    PC = 0xbec7; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4afc); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Display_Vect_BCD        ; BECA: BD E7 90      \n");
                                      #endif // Display BCD numbers
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xcd); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbe); 
    clockticks = clockticks + 1; 
    goto LE790;
  case 0xBECD:
LBECD:
                                                     #ifdef DEBUG
                                      mon("LBECD    LDD   #$8040                  ; BECD: CC 80 40      \n");
                                      #endif
    PC = 0xbecd; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; BED0: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4554                  ; BED2: 8E 45 54      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x4554; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC6D4                   ; BED5: BD C6 D4      \n");
                                      #endif // Read NOVRAM
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xd8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbe); 
    clockticks = clockticks + 1; 
    goto LC6D4;
  case 0xBED8:
LBED8:
                                                     #ifdef DEBUG
                                      mon("LBED8    JSR   LC087                   ; BED8: BD C0 87      \n");
                                      #endif
    PC = 0xbed8; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xdb); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbe); 
    clockticks = clockticks + 1; 
    goto LC087;
  case 0xBEDB:
LBEDB:
                                                     #ifdef DEBUG
                                      mon("LBEDB    LDD   word_C7C9               ; BEDB: FC C7 C9      \n");
                                      #endif
    PC = 0xbedb; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0xc7c9); // Care needed with I/O space and word fetches
    B = rd_mem(0xc7ca); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; BEDE: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$30                    ; BEE0: CC 00 30      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x30; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; BEE3: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$07                    ; BEE5: C6 07         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x07; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STB   <$AD                    ; BEE7: D7 AD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xad; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4AFA                   ; BEE9: B6 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4afa); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Display_Vect_BCD        ; BEEC: BD E7 90      \n");
                                      #endif // Display BCD numbers
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xef); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbe); 
    clockticks = clockticks + 1; 
    goto LE790;
  case 0xBEEF:
LBEEF:
                                                     #ifdef DEBUG
                                      mon("LBEEF    LDA   $4AFB                   ; BEEF: B6 4A FB      \n");
                                      #endif
    PC = 0xbeef; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4afb); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Display_Vect_BCD        ; BEF2: BD E7 90      \n");
                                      #endif // Display BCD numbers
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf5); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbe); 
    clockticks = clockticks + 1; 
    goto LE790;
  case 0xBEF5:
LBEF5:
                                                     #ifdef DEBUG
                                      mon("LBEF5    LDA   $4AFC                   ; BEF5: B6 4A FC      \n");
                                      #endif
    PC = 0xbef5; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4afc); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Display_Vect_BCD        ; BEF8: BD E7 90      \n");
                                      #endif // Display BCD numbers
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xfb); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbe); 
    clockticks = clockticks + 1; 
    goto LE790;
  case 0xBEFB:
LBEFB:
                                                     #ifdef DEBUG
                                      mon("LBEFB    LDA   $4AFD                   ; BEFB: B6 4A FD      \n");
                                      #endif
    PC = 0xbefb; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4afd); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Display_Vect_BCD        ; BEFE: BD E7 90      \n");
                                      #endif // Display BCD numbers
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x01); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbf); 
    clockticks = clockticks + 1; 
    goto LE790;
  case 0xBF01:
LBF01:
                                                     #ifdef DEBUG
                                      mon("LBF01    LDD   #$8040                  ; BF01: CC 80 40      \n");
                                      #endif
    PC = 0xbf01; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; BF04: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$455C                  ; BF06: 8E 45 5C      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x455c; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC6D4                   ; BF09: BD C6 D4      \n");
                                      #endif // Read NOVRAM
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x0c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbf); 
    clockticks = clockticks + 1; 
    goto LC6D4;
  case 0xBF0C:
LBF0C:
                                                     #ifdef DEBUG
                                      mon("LBF0C    JSR   LC087                   ; BF0C: BD C0 87      \n");
                                      #endif
    PC = 0xbf0c; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x0f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbf); 
    clockticks = clockticks + 1; 
    goto LC087;
  case 0xBF0F:
LBF0F:
                                                     #ifdef DEBUG
                                      mon("LBF0F    LDD   word_C7CB               ; BF0F: FC C7 CB      \n");
                                      #endif
    PC = 0xbf0f; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0xc7cb); // Care needed with I/O space and word fetches
    B = rd_mem(0xc7cc); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; BF12: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$30                    ; BF14: CC 00 30      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x30; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; BF17: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$07                    ; BF19: C6 07         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x07; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STB   <$AD                    ; BF1B: D7 AD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xad; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4AFA                   ; BF1D: B6 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4afa); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Display_Vect_BCD        ; BF20: BD E7 90      \n");
                                      #endif // Display BCD numbers
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x23); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbf); 
    clockticks = clockticks + 1; 
    goto LE790;
  case 0xBF23:
LBF23:
                                                     #ifdef DEBUG
                                      mon("LBF23    LDA   $4AFB                   ; BF23: B6 4A FB      \n");
                                      #endif
    PC = 0xbf23; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4afb); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Display_Vect_BCD        ; BF26: BD E7 90      \n");
                                      #endif // Display BCD numbers
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x29); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbf); 
    clockticks = clockticks + 1; 
    goto LE790;
  case 0xBF29:
LBF29:
                                                     #ifdef DEBUG
                                      mon("LBF29    LDA   $4AFC                   ; BF29: B6 4A FC      \n");
                                      #endif
    PC = 0xbf29; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4afc); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Display_Vect_BCD        ; BF2C: BD E7 90      \n");
                                      #endif // Display BCD numbers
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x2f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbf); 
    clockticks = clockticks + 1; 
    goto LE790;
  case 0xBF2F:
LBF2F:
                                                     #ifdef DEBUG
                                      mon("LBF2F    LDA   $4AFD                   ; BF2F: B6 4A FD      \n");
                                      #endif
    PC = 0xbf2f; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4afd); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Display_Vect_BCD        ; BF32: BD E7 90      \n");
                                      #endif // Display BCD numbers
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x35); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbf); 
    clockticks = clockticks + 1; 
    goto LE790;
  case 0xBF35:
LBF35:
                                                     #ifdef DEBUG
                                      mon("LBF35    LDD   #$8040                  ; BF35: CC 80 40      \n");
                                      #endif
    PC = 0xbf35; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; BF38: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$454C                  ; BF3A: 8E 45 4C      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x454c; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC6D4                   ; BF3D: BD C6 D4      \n");
                                      #endif // Read NOVRAM
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x40); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbf); 
    clockticks = clockticks + 1; 
    goto LC6D4;
  case 0xBF40:
LBF40:
                                                     #ifdef DEBUG
                                      mon("LBF40    CLR   $4AFA                   ; BF40: 7F 4A FA      \n");
                                      #endif
    PC = 0xbf40; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    wr_mem(0x4afa, 0); 
 // V = 0; 
 // Z = 0; 
 // N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4AFB                   ; BF43: B6 4A FB      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4afb); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORA   $4AFC                   ; BF46: BA 4A FC      \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = A | (UINT8)rd_mem(0x4afc); 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORA   $4AFD                   ; BF49: BA 4A FD      \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = A | (UINT8)rd_mem(0x4afd); 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LBF7C                   ; BF4C: 27 2E         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LBF7C;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4554                  ; BF4E: 8E 45 54      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x4554; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #$4AFE                  ; BF51: CE 4A FE      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x4afe; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC6D7                   ; BF54: BD C6 D7      \n");
                                      #endif // Read NOVRAM
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x57); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbf); 
    clockticks = clockticks + 1; 
    goto LC6D7;
  case 0xBF57:
LBF57:
                                                     #ifdef DEBUG
                                      mon("LBF57    JSR   LC02F                   ; BF57: BD C0 2F      \n");
                                      #endif
    PC = 0xbf57; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x5a); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbf); 
    clockticks = clockticks + 1; 
    goto LC02F;
  case 0xBF5A:
LBF5A:
                                                     #ifdef DEBUG
                                      mon("LBF5A    LDA   $4AFA                   ; BF5A: B6 4A FA      \n");
                                      #endif
    PC = 0xbf5a; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4afa); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$0F                    ; BF5D: 84 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x0f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$0F                    ; BF5F: 81 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x0f; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4AFA                   ; BF61: B6 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4afa); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LBF69                   ; BF64: 25 03         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LBF69;
    }
                                                     #ifdef DEBUG
                                      mon("         INC   $4AFA                   ; BF66: 7C 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4afa); 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    wr_mem(0x4afa, res); 
    clockticks = clockticks + 2; 
  case 0xBF69:
LBF69:
                                                     #ifdef DEBUG
                                      mon("LBF69    LSRA                          ; BF69: 44            \n");
                                      #endif
    PC = 0xbf69; 
    INSTRUCTION_START
    val = (UINT8)A; 
 // C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; BF6A: 44            \n");
                                      #endif
    val = (UINT8)A; 
 // C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; BF6B: 44            \n");
                                      #endif
    val = (UINT8)A; 
 // C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; BF6C: 44            \n");
                                      #endif
    val = (UINT8)A; 
 // C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ADDA  $4AFA                   ; BF6D: BB 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    arg = rd_mem(0x4afa); 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4AFA                   ; BF70: B7 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4afa, val); 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$0F                    ; BF73: 84 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x0f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$0F                    ; BF75: 81 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x0f; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   LBF7C                   ; BF77: 25 03         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LBF7C;
    }
                                                     #ifdef DEBUG
                                      mon("         INC   $4AFA                   ; BF79: 7C 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4afa); 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    wr_mem(0x4afa, res); 
    clockticks = clockticks + 2; 
  case 0xBF7C:
LBF7C:
                                                     #ifdef DEBUG
                                      mon("LBF7C    LDD   word_C7C5               ; BF7C: FC C7 C5      \n");
                                      #endif
    PC = 0xbf7c; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0xc7c5); // Care needed with I/O space and word fetches
    B = rd_mem(0xc7c6); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; BF7F: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$30                    ; BF81: CC 00 30      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x30; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; BF84: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4AFA                   ; BF86: B6 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4afa); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC70E                   ; BF89: BD C7 0E      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x8c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbf); 
    clockticks = clockticks + 1; 
    goto LC70E;
  case 0xBF8C:
LBF8C:
                                                     #ifdef DEBUG
                                      mon("LBF8C    LDD   #$8040                  ; BF8C: CC 80 40      \n");
                                      #endif
    PC = 0xbf8c; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; BF8F: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$455C                  ; BF91: 8E 45 5C      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x455c; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC6D4                   ; BF94: BD C6 D4      \n");
                                      #endif // Read NOVRAM
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x97); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbf); 
    clockticks = clockticks + 1; 
    goto LC6D4;
  case 0xBF97:
LBF97:
                                                     #ifdef DEBUG
                                      mon("LBF97    LDA   $4AFA                   ; BF97: B6 4A FA      \n");
                                      #endif
    PC = 0xbf97; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4afa); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORA   $4AFB                   ; BF9A: BA 4A FB      \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = A | (UINT8)rd_mem(0x4afb); 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORA   $4AFC                   ; BF9D: BA 4A FC      \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = A | (UINT8)rd_mem(0x4afc); 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORA   $4AFD                   ; BFA0: BA 4A FD      \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = A | (UINT8)rd_mem(0x4afd); 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LBFB4                   ; BFA3: 27 0F         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LBFB4;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4556                  ; BFA5: 8E 45 56      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x4556; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #$4AFE                  ; BFA8: CE 4A FE      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x4afe; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC6D7                   ; BFAB: BD C6 D7      \n");
                                      #endif // Read NOVRAM
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xae); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbf); 
    clockticks = clockticks + 1; 
    goto LC6D7;
  case 0xBFAE:
LBFAE:
                                                     #ifdef DEBUG
                                      mon("LBFAE    CLR   $4B01                   ; BFAE: 7F 4B 01      \n");
                                      #endif
    PC = 0xbfae; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    wr_mem(0x4b01, 0); 
 // V = 0; 
 // Z = 0; 
 // N = 0; 
 // C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC02F                   ; BFB1: BD C0 2F      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xb4); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbf); 
    clockticks = clockticks + 1; 
    goto LC02F;
  case 0xBFB4:
LBFB4:
                                                     #ifdef DEBUG
                                      mon("LBFB4    LDD   word_C7C7               ; BFB4: FC C7 C7      \n");
                                      #endif
    PC = 0xbfb4; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0xc7c7); // Care needed with I/O space and word fetches
    B = rd_mem(0xc7c8); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; BFB7: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$30                    ; BFB9: CC 00 30      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x30; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; BFBC: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         CLRA                          ; BFBE: 4F            \n");
                                      #endif
    A = 0; // SEARCH_ME
 // V = 0; 
 // Z = 0; 
 // N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $4AFA                   ; BFBF: F6 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4afa); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$10                    ; BFC2: 8E 00 10      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x0010; 
    Z = X; 
    N = (X) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $7720                   ; BFC5: BD 77 20      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xc8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbf); 
    clockticks = clockticks + 1; 
    PC = 0x7720; 
    JUMP;
  case 0xBFC8:
LBFC8:
                                                     #ifdef DEBUG
                                      mon("LBFC8    LDB   #$01                    ; BFC8: C6 01         \n");
                                      #endif
    PC = 0xbfc8; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x01; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STB   <$AD                    ; BFCA: D7 AD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xad; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4AD6                   ; BFCC: B6 4A D6      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4ad6); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Display_Vect_BCD        ; BFCF: BD E7 90      \n");
                                      #endif // Display BCD numbers
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xd2); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xbf); 
    clockticks = clockticks + 1; 
    goto LE790;
  case 0xBFD2:
LBFD2:
                                                     #ifdef DEBUG
                                      mon("LBFD2    LDD   #$8040                  ; BFD2: CC 80 40      \n");
                                      #endif
    PC = 0xbfd2; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; BFD5: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$11                    ; BFD7: C6 11         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x11; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STB   $4AFA                   ; BFD9: F7 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4afa, val); 
                                                     #ifdef DEBUG
                                      mon("         LDU   #word_C7CD              ; BFDC: CE C7 CD      \n");
                                      #endif // Table for game time history text positions
    clockticks = clockticks + 3; 
    U = 0xc7cd; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STU   $4AFC                   ; BFDF: FF 4A FC      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    wr_mem(0x4afc, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem(0x4afd, (UINT8)val); 
  case 0xBFE2:
LBFE2:
                                                     #ifdef DEBUG
                                      mon("LBFE2    LDU   $4AFC                   ; BFE2: FE 4A FC      \n");
                                      #endif
    PC = 0xbfe2; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4afc)<<8; 
    ea = ea | rd_mem(0x4afd); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   ,U++                    ; BFE5: EC C1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    A = rd_mem(U); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(U+1)); 
    U = U + 2; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; BFE7: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         CMPU  #$C7E1                  ; BFE9: 11 83 C7 E1   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
    arg = 0xc7e1; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LBFF4                   ; BFED: 25 05         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LBFF4;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$1ED4                  ; BFEF: CC 1E D4      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x1e; 
    B = 0xd4; 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LBFF7                   ; BFF2: 20 03         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LBFF7;
    
    // ---------------------------------------------------------------------------
  case 0xBFF4:
LBFF4:
                                                     #ifdef DEBUG
                                      mon("LBFF4    LDD   #$64                    ; BFF4: CC 00 64      \n");
                                      #endif
    PC = 0xbff4; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x64; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0xBFF7:
LBFF7:
                                                     #ifdef DEBUG
                                      mon("LBFF7    STD   ,Y++                    ; BFF7: ED A1         \n");
                                      #endif
    PC = 0xbff7; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         STU   $4AFC                   ; BFF9: FF 4A FC      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    wr_mem(0x4afc, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem(0x4afd, (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #unk_C7A3               ; BFFC: 8E C7 A3      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0xc7a3; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $4AFA                   ; BFFF: F6 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4afa); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   B,X                     ; C002: A6 85         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + (SINT8)B)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC70E                   ; C004: BD C7 0E      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x07); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc0); 
    clockticks = clockticks + 1; 
    goto LC70E;
  case 0xC007:
LC007:
                                                     #ifdef DEBUG
                                      mon("LC007    LDD   $3002                   ; C007: FC 30 02      \n");
                                      #endif
    PC = 0xc007; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x3002); // Care needed with I/O space and word fetches
    B = rd_mem(0x3003); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; C00A: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; C00C: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$00                    ; C00E: C6 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STB   <$AD                    ; C010: D7 AD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xad; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4564                  ; C012: 8E 45 64      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x4564; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $4AFA                   ; C015: F6 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4afa); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; C018: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   B,X                     ; C019: A6 85         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + (SINT8)B)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LE7AD                   ; C01B: BD E7 AD      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x1e); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc0); 
    clockticks = clockticks + 1; 
    goto LE7AD;
  case 0xC01E:
LC01E:
                                                     #ifdef DEBUG
                                      mon("LC01E    INCB                          ; C01E: 5C            \n");
                                      #endif
    PC = 0xc01e; 
    INSTRUCTION_START
    val = (UINT8)B; 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   B,X                     ; C01F: A6 85         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + (SINT8)B)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LE7AD                   ; C021: BD E7 AD      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x24); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc0); 
    clockticks = clockticks + 1; 
    goto LE7AD;
  case 0xC024:
LC024:
                                                     #ifdef DEBUG
                                      mon("LC024    LDD   #$8040                  ; C024: CC 80 40      \n");
                                      #endif
    PC = 0xc024; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; C027: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         DEC   $4AFA                   ; C029: 7A 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4afa); 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    wr_mem(0x4afa, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LBFE2                   ; C02C: 2A B4         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LBFE2;
    }
    // End of function sub_BE20
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; C02E: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xC02F:
LC02F:
                                                     #ifdef DEBUG
                                      mon("LC02F    LDX   #$4AFE                  ; C02F: 8E 4A FE      \n");
                                      #endif
    PC = 0xc02f; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x4afe; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$01                    ; C032: 86 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x01; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B02                   ; C034: B7 4B 02      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b02, val); 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$03                    ; C037: C6 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x03; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xC039:
LC039:
                                                     #ifdef DEBUG
                                      mon("LC039    LDA   #$99                    ; C039: 86 99         \n");
                                      #endif
    PC = 0xc039; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x99; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBA  ,-X                     ; C03B: A0 82         \n");
                                      #endif
    clockticks = clockticks + 6; 
    X = X - 1; 
    val = (UINT8)A; 
    arg = rd_mem(X); 
    res = val - (UINT8)arg; 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)(res); 
                                                     #ifdef DEBUG
                                      mon("         ADDA  $4B02                   ; C03D: BB 4B 02      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    arg = rd_mem(0x4b02); 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         DAA                           ; C040: 19            \n");
                                      #endif
    res = A; 
    msn = res & 0xf0; 
    lsn = res & 0x0f; 
    res = res + (((lsn > 0x09) || (H & 0x10)) ? 0x06 : 0); 
    res = res + ((((UINT8)msn > 0x80U) && ((UINT8)lsn > 0x09U)) || (((UINT8)msn > 0x90U) || (C != 0)) ? 0x60 : 0); 
    C = C | (res & 0x100); 
    res = (UINT8)res; 
    A = res; 
 // N = res; 
 // Z = res; 
 // V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   ,X                      ; C041: A7 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = X; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         BCS   LC04A                   ; C043: 25 05         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LC04A;
    }
                                                     #ifdef DEBUG
                                      mon("         CLR   $4B02                   ; C045: 7F 4B 02      \n");
                                      #endif
    clockticks = clockticks + 5; 
    wr_mem(0x4b02, 0); 
    V = 0; 
    Z = 0; 
    N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LC04F                   ; C048: 20 05         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LC04F;
    
    // ---------------------------------------------------------------------------
  case 0xC04A:
LC04A:
                                                     #ifdef DEBUG
                                      mon("LC04A    LDA   #$01                    ; C04A: 86 01         \n");
                                      #endif
    PC = 0xc04a; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x01; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B02                   ; C04C: B7 4B 02      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b02, val); 
  case 0xC04F:
LC04F:
                                                     #ifdef DEBUG
                                      mon("LC04F    DECB                          ; C04F: 5A            \n");
                                      #endif
    PC = 0xc04f; 
    INSTRUCTION_START
    val = (UINT8)B; 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LC039                   ; C050: 2A E7         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LC039;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   #$FF                    ; C052: C6 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xff; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xC054:
LC054:
                                                     #ifdef DEBUG
                                      mon("LC054    INCB                          ; C054: 5C            \n");
                                      #endif
    PC = 0xc054; 
    INSTRUCTION_START
    val = (UINT8)B; 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$EF                    ; C055: C1 EF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0xef; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LC083                   ; C057: 27 2A         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LC083;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B01                   ; C059: B6 4B 01      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b01); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDA  $4AFD                   ; C05C: BB 4A FD      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    arg = rd_mem(0x4afd); 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         DAA                           ; C05F: 19            \n");
                                      #endif
    res = A; 
    msn = res & 0xf0; 
    lsn = res & 0x0f; 
    res = res + (((lsn > 0x09) || (H & 0x10)) ? 0x06 : 0); 
    res = res + ((((UINT8)msn > 0x80U) && ((UINT8)lsn > 0x09U)) || (((UINT8)msn > 0x90U) || (C != 0)) ? 0x60 : 0); 
    C = C | (res & 0x100); 
    res = (UINT8)res; 
    A = res; 
 // N = res; 
 // Z = res; 
 // V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B01                   ; C060: B7 4B 01      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b01, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B00                   ; C063: B6 4B 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b00); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADCA  $4AFC                   ; C066: B9 4A FC      \n");
                                      #endif
    clockticks = clockticks + 5; 
    arg = A; 
    val = rd_mem(0x4afc); 
    res = arg + val + (C != 0 ? 1:0); 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = arg ^ val ^ (UINT8)res ^ C; 
 // V = arg ^ val ^ (UINT8)res ^ C; 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         DAA                           ; C069: 19            \n");
                                      #endif
    res = A; 
    msn = res & 0xf0; 
    lsn = res & 0x0f; 
    res = res + (((lsn > 0x09) || (H & 0x10)) ? 0x06 : 0); 
    res = res + ((((UINT8)msn > 0x80U) && ((UINT8)lsn > 0x09U)) || (((UINT8)msn > 0x90U) || (C != 0)) ? 0x60 : 0); 
    C = C | (res & 0x100); 
    res = (UINT8)res; 
    A = res; 
 // N = res; 
 // Z = res; 
 // V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B00                   ; C06A: B7 4B 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b00, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4AFF                   ; C06D: B6 4A FF      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4aff); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADCA  $4AFB                   ; C070: B9 4A FB      \n");
                                      #endif
    clockticks = clockticks + 5; 
    arg = A; 
    val = rd_mem(0x4afb); 
    res = arg + val + (C != 0 ? 1:0); 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = arg ^ val ^ (UINT8)res ^ C; 
 // V = arg ^ val ^ (UINT8)res ^ C; 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         DAA                           ; C073: 19            \n");
                                      #endif
    res = A; 
    msn = res & 0xf0; 
    lsn = res & 0x0f; 
    res = res + (((lsn > 0x09) || (H & 0x10)) ? 0x06 : 0); 
    res = res + ((((UINT8)msn > 0x80U) && ((UINT8)lsn > 0x09U)) || (((UINT8)msn > 0x90U) || (C != 0)) ? 0x60 : 0); 
    C = C | (res & 0x100); 
    res = (UINT8)res; 
    A = res; 
 // N = res; 
 // Z = res; 
 // V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4AFF                   ; C074: B7 4A FF      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4aff, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4AFE                   ; C077: B6 4A FE      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4afe); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADCA  $4AFA                   ; C07A: B9 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    arg = A; 
    val = rd_mem(0x4afa); 
    res = arg + val + (C != 0 ? 1:0); 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = arg ^ val ^ (UINT8)res ^ C; 
 // V = arg ^ val ^ (UINT8)res ^ C; 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         DAA                           ; C07D: 19            \n");
                                      #endif
    res = A; 
    msn = res & 0xf0; 
    lsn = res & 0x0f; 
    res = res + (((lsn > 0x09) || (H & 0x10)) ? 0x06 : 0); 
    res = res + ((((UINT8)msn > 0x80U) && ((UINT8)lsn > 0x09U)) || (((UINT8)msn > 0x90U) || (C != 0)) ? 0x60 : 0); 
    C = C | (res & 0x100); 
    res = (UINT8)res; 
    A = res; 
 // N = res; 
 // Z = res; 
 // V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4AFE                   ; C07E: B7 4A FE      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x4afe, val); 
                                                     #ifdef DEBUG
                                      mon("         BCS   LC054                   ; C081: 25 D1         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LC054;
    }
  case 0xC083:
LC083:
                                                     #ifdef DEBUG
                                      mon("LC083    STB   $4AFA                   ; C083: F7 4A FA      \n");
                                      #endif
    PC = 0xc083; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = B; 
    Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x4afa, val); 
    // End of function sub_C02F
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; C086: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xC087:
LC087:
                                                     #ifdef DEBUG
                                      mon("LC087    BSR   $C089                   ; C087: 8D 00         \n");
                                      #endif
    PC = 0xc087; 
    INSTRUCTION_START
    --S;
    wr_mem(S, 0x89); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc0); 
    clockticks = clockticks + 1; 
    clockticks = clockticks + 7; 
    goto LC089;
  case 0xC089:
LC089:
                                                     #ifdef DEBUG
                                      mon("LC089    ANDCC #$FE                    ; C089: 1C FE         \n");
                                      #endif
    PC = 0xc089; 
    INSTRUCTION_START
    C = 0; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$03                    ; C08B: C6 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x03; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4AFD                  ; C08D: 8E 4A FD      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x4afd; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xC090:
LC090:
                                                     #ifdef DEBUG
                                      mon("LC090    LDA   ,X                      ; C090: A6 84         \n");
                                      #endif
    PC = 0xc090; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(X); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADCA  ,X                      ; C092: A9 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    arg = A; 
    val = rd_mem(X); 
    res = arg + val + (C != 0 ? 1:0); 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = arg ^ val ^ (UINT8)res ^ C; 
 // V = arg ^ val ^ (UINT8)res ^ C; 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         DAA                           ; C094: 19            \n");
                                      #endif
    res = A; 
    msn = res & 0xf0; 
    lsn = res & 0x0f; 
    res = res + (((lsn > 0x09) || (H & 0x10)) ? 0x06 : 0); 
    res = res + ((((UINT8)msn > 0x80U) && ((UINT8)lsn > 0x09U)) || (((UINT8)msn > 0x90U) || (C != 0)) ? 0x60 : 0); 
    C = C | (res & 0x100); 
    res = (UINT8)res; 
    A = res; 
 // N = res; 
 // Z = res; 
 // V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   ,X                      ; C095: A7 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LEAX  -1,X                    ; C097: 30 1F         \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + 0xffff); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         DECB                          ; C099: 5A            \n");
                                      #endif
    val = (UINT8)B; 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LC090                   ; C09A: 2A F4         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LC090;
    }
    // End of function sub_C087
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; C09C: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xC09D:
LC09D:
                                                     #ifdef DEBUG
                                      mon("LC09D    LDA   #$02                    ; C09D: 86 02         \n");
                                      #endif
    PC = 0xc09d; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x02; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC2C3                   ; C09F: BD C2 C3      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xa2); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc0); 
    clockticks = clockticks + 1; 
    goto LC2C3;
  case 0xC0A2:
LC0A2:
                                                     #ifdef DEBUG
                                      mon("LC0A2    BNE   locret_C0FE             ; C0A2: 26 5A         \n");
                                      #endif
    PC = 0xc0a2; 
    INSTRUCTION_START
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LC0FE;
    }
                                                     #ifdef DEBUG
                                      mon("         CLRA                          ; C0A4: 4F            \n");
                                      #endif
    A = 0; // SEARCH_ME
 // V = 0; 
 // Z = 0; 
 // N = 0; 
 // C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $4815                   ; C0A5: F6 48 15      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4815); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; C0A8: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLA                          ; C0A9: 49            \n");
                                      #endif
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $4816                   ; C0AA: F6 48 16      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4816); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; C0AD: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLA                          ; C0AE: 49            \n");
                                      #endif
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $4817                   ; C0AF: F6 48 17      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4817); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; C0B2: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLA                          ; C0B3: 49            \n");
                                      #endif
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         TFR   A,B                     ; C0B4: 1F 89         \n");
                                      #endif
    B = (UINT8)A; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         EORB  $4AF4                   ; C0B6: F8 4A F4      \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = B ^ rd_mem(0x4af4); 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  $4AF4                   ; C0B9: F4 4A F4      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)B; 
    res = val & rd_mem(0x4af4); 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4AF4                   ; C0BC: B7 4A F4      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4af4, val); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4548                  ; C0BF: 8E 45 48      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x4548; 
 // Z = X; 
 // N = (X) >> 8; 
    V = 0; 
  case 0xC0C2:
LC0C2:
                                                     #ifdef DEBUG
                                      mon("LC0C2    LSRB                          ; C0C2: 54            \n");
                                      #endif
    PC = 0xc0c2; 
    INSTRUCTION_START
    val = (UINT8)B; 
    C = val & 1; 
    val = val >> 1; 
    B = val; 
    N = 0; 
    Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BCC   LC0F7                   ; C0C3: 24 32         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LC0F7;
    }
                                                     #ifdef DEBUG
                                      mon("         LDU   #$4B5F                  ; C0C5: CE 4B 5F      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x4b5f; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC6D7                   ; C0C8: BD C6 D7      \n");
                                      #endif // Read NOVRAM
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xcb); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc0); 
    clockticks = clockticks + 1; 
    goto LC6D7;
  case 0xC0CB:
LC0CB:
                                                     #ifdef DEBUG
                                      mon("LC0CB    LDA   $4B61                   ; C0CB: B6 4B 61      \n");
                                      #endif
    PC = 0xc0cb; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b61); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDA  #$01                    ; C0CE: 8B 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x01; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         DAA                           ; C0D0: 19            \n");
                                      #endif
    res = A; 
    msn = res & 0xf0; 
    lsn = res & 0x0f; 
    res = res + (((lsn > 0x09) || (H & 0x10)) ? 0x06 : 0); 
    res = res + ((((UINT8)msn > 0x80U) && ((UINT8)lsn > 0x09U)) || (((UINT8)msn > 0x90U) || (C != 0)) ? 0x60 : 0); 
    C = C | (res & 0x100); 
    res = (UINT8)res; 
    A = res; 
 // N = res; 
 // Z = res; 
 // V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B61                   ; C0D1: B7 4B 61      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b61, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B60                   ; C0D4: B6 4B 60      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b60); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADCA  #$00                    ; C0D7: 89 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    arg = A; 
    val = (SINT8)0x00; 
    res = arg + val + (C != 0 ? 1:0); 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = arg ^ val ^ (UINT8)res ^ C; 
 // V = arg ^ val ^ (UINT8)res ^ C; 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         DAA                           ; C0D9: 19            \n");
                                      #endif
    res = A; 
    msn = res & 0xf0; 
    lsn = res & 0x0f; 
    res = res + (((lsn > 0x09) || (H & 0x10)) ? 0x06 : 0); 
    res = res + ((((UINT8)msn > 0x80U) && ((UINT8)lsn > 0x09U)) || (((UINT8)msn > 0x90U) || (C != 0)) ? 0x60 : 0); 
    C = C | (res & 0x100); 
    res = (UINT8)res; 
    A = res; 
 // N = res; 
 // Z = res; 
 // V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B60                   ; C0DA: B7 4B 60      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b60, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B5F                   ; C0DD: B6 4B 5F      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b5f); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADCA  #$00                    ; C0E0: 89 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    arg = A; 
    val = (SINT8)0x00; 
    res = arg + val + (C != 0 ? 1:0); 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = arg ^ val ^ (UINT8)res ^ C; 
 // V = arg ^ val ^ (UINT8)res ^ C; 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         DAA                           ; C0E2: 19            \n");
                                      #endif
    res = A; 
    msn = res & 0xf0; 
    lsn = res & 0x0f; 
    res = res + (((lsn > 0x09) || (H & 0x10)) ? 0x06 : 0); 
    res = res + ((((UINT8)msn > 0x80U) && ((UINT8)lsn > 0x09U)) || (((UINT8)msn > 0x90U) || (C != 0)) ? 0x60 : 0); 
 // C = C | (res & 0x100); 
    res = (UINT8)res; 
    A = res; 
 // N = res; 
 // Z = res; 
 // V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B5F                   ; C0E3: B7 4B 5F      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b5f, val); 
                                                     #ifdef DEBUG
                                      mon("         LDU   #$4B5F                  ; C0E6: CE 4B 5F      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x4b5f; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC6F7                   ; C0E9: BD C6 F7      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xec); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc0); 
    clockticks = clockticks + 1; 
    goto LC6F7;
  case 0xC0EC:
LC0EC:
                                                     #ifdef DEBUG
                                      mon("LC0EC    LDA   #$02                    ; C0EC: 86 02         \n");
                                      #endif
    PC = 0xc0ec; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x02; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STB   $4B62                   ; C0EE: F7 4B 62      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b62, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC2B3                   ; C0F1: BD C2 B3      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf4); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc0); 
    clockticks = clockticks + 1; 
    goto LC2B3;
  case 0xC0F4:
LC0F4:
                                                     #ifdef DEBUG
                                      mon("LC0F4    LDB   $4B62                   ; C0F4: F6 4B 62      \n");
                                      #endif
    PC = 0xc0f4; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b62); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xC0F7:
LC0F7:
                                                     #ifdef DEBUG
                                      mon("LC0F7    LEAX  -6,X                    ; C0F7: 30 1A         \n");
                                      #endif
    PC = 0xc0f7; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    X = (X + 0xfffa); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$453C                  ; C0F9: 8C 45 3C      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x453c; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCC   LC0C2                   ; C0FC: 24 C4         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LC0C2;
    }
    // End of function sub_C09D
  case 0xC0FE:
LC0FE:
locret_C0FE:
                                                     #ifdef DEBUG
                                      mon("locret_C0FE RTS                           ; C0FE: 39            \n");
                                      #endif
    PC = 0xc0fe; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // NVRAM something
  case 0xC0FF:
LC0FF:
                                                     #ifdef DEBUG
                                      mon("LC0FF    LDA   #$02                    ; C0FF: 86 02         \n");
                                      #endif
    PC = 0xc0ff; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x02; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC413                   ; C101: BD C4 13      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x04); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc1); 
    clockticks = clockticks + 1; 
    goto LC413;
  case 0xC104:
LC104:
                                                     #ifdef DEBUG
                                      mon("LC104    LDX   #$4554                  ; C104: 8E 45 54      \n");
                                      #endif
    PC = 0xc104; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x4554; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC6D4                   ; C107: BD C6 D4      \n");
                                      #endif // Read NOVRAM
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x0a); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc1); 
    clockticks = clockticks + 1; 
    goto LC6D4;
  case 0xC10A:
LC10A:
                                                     #ifdef DEBUG
                                      mon("LC10A    LDA   $4AFD                   ; C10A: B6 4A FD      \n");
                                      #endif
    PC = 0xc10a; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4afd); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDA  $481A                   ; C10D: BB 48 1A      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    arg = rd_mem(0x481a); 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         DAA                           ; C110: 19            \n");
                                      #endif
    res = A; 
    msn = res & 0xf0; 
    lsn = res & 0x0f; 
    res = res + (((lsn > 0x09) || (H & 0x10)) ? 0x06 : 0); 
    res = res + ((((UINT8)msn > 0x80U) && ((UINT8)lsn > 0x09U)) || (((UINT8)msn > 0x90U) || (C != 0)) ? 0x60 : 0); 
    C = C | (res & 0x100); 
    res = (UINT8)res; 
    A = res; 
 // N = res; 
 // Z = res; 
 // V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4AFD                   ; C111: B7 4A FD      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4afd, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4AFC                   ; C114: B6 4A FC      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4afc); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADCA  $4819                   ; C117: B9 48 19      \n");
                                      #endif
    clockticks = clockticks + 5; 
    arg = A; 
    val = rd_mem(0x4819); 
    res = arg + val + (C != 0 ? 1:0); 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = arg ^ val ^ (UINT8)res ^ C; 
 // V = arg ^ val ^ (UINT8)res ^ C; 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         DAA                           ; C11A: 19            \n");
                                      #endif
    res = A; 
    msn = res & 0xf0; 
    lsn = res & 0x0f; 
    res = res + (((lsn > 0x09) || (H & 0x10)) ? 0x06 : 0); 
    res = res + ((((UINT8)msn > 0x80U) && ((UINT8)lsn > 0x09U)) || (((UINT8)msn > 0x90U) || (C != 0)) ? 0x60 : 0); 
    C = C | (res & 0x100); 
    res = (UINT8)res; 
    A = res; 
 // N = res; 
 // Z = res; 
 // V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4AFC                   ; C11B: B7 4A FC      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4afc, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4AFB                   ; C11E: B6 4A FB      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4afb); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADCA  #$00                    ; C121: 89 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    arg = A; 
    val = (SINT8)0x00; 
    res = arg + val + (C != 0 ? 1:0); 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = arg ^ val ^ (UINT8)res ^ C; 
 // V = arg ^ val ^ (UINT8)res ^ C; 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         DAA                           ; C123: 19            \n");
                                      #endif
    res = A; 
    msn = res & 0xf0; 
    lsn = res & 0x0f; 
    res = res + (((lsn > 0x09) || (H & 0x10)) ? 0x06 : 0); 
    res = res + ((((UINT8)msn > 0x80U) && ((UINT8)lsn > 0x09U)) || (((UINT8)msn > 0x90U) || (C != 0)) ? 0x60 : 0); 
    C = C | (res & 0x100); 
    res = (UINT8)res; 
    A = res; 
 // N = res; 
 // Z = res; 
 // V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4AFB                   ; C124: B7 4A FB      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4afb, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4AFA                   ; C127: B6 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4afa); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADCA  #$00                    ; C12A: 89 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    arg = A; 
    val = (SINT8)0x00; 
    res = arg + val + (C != 0 ? 1:0); 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = arg ^ val ^ (UINT8)res ^ C; 
 // V = arg ^ val ^ (UINT8)res ^ C; 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         DAA                           ; C12C: 19            \n");
                                      #endif
    res = A; 
    msn = res & 0xf0; 
    lsn = res & 0x0f; 
    res = res + (((lsn > 0x09) || (H & 0x10)) ? 0x06 : 0); 
    res = res + ((((UINT8)msn > 0x80U) && ((UINT8)lsn > 0x09U)) || (((UINT8)msn > 0x90U) || (C != 0)) ? 0x60 : 0); 
    C = C | (res & 0x100); 
    res = (UINT8)res; 
    A = res; 
    N = res; 
    Z = res; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LC132                   ; C12D: 25 03         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LC132;
    }
                                                     #ifdef DEBUG
                                      mon("         STA   $4AFA                   ; C12F: B7 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4afa, val); 
  case 0xC132:
LC132:
                                                     #ifdef DEBUG
                                      mon("LC132    LDA   #$03                    ; C132: 86 03         \n");
                                      #endif
    PC = 0xc132; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x03; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STB   $4B02                   ; C134: F7 4B 02      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b02, val); 
                                                     #ifdef DEBUG
                                      mon("         LDU   #$4AFA                  ; C137: CE 4A FA      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x4afa; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC6F9                   ; C13A: BD C6 F9      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x3d); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc1); 
    clockticks = clockticks + 1; 
    goto LC6F9;
  case 0xC13D:
LC13D:
                                                     #ifdef DEBUG
                                      mon("LC13D    LDX   #$454E                  ; C13D: 8E 45 4E      \n");
                                      #endif
    PC = 0xc13d; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x454e; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC6D4                   ; C140: BD C6 D4      \n");
                                      #endif // Read NOVRAM
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x43); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc1); 
    clockticks = clockticks + 1; 
    goto LC6D4;
  case 0xC143:
LC143:
                                                     #ifdef DEBUG
                                      mon("LC143    LDA   $4AFC                   ; C143: B6 4A FC      \n");
                                      #endif
    PC = 0xc143; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4afc); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDA  #$01                    ; C146: 8B 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x01; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         DAA                           ; C148: 19            \n");
                                      #endif
    res = A; 
    msn = res & 0xf0; 
    lsn = res & 0x0f; 
    res = res + (((lsn > 0x09) || (H & 0x10)) ? 0x06 : 0); 
    res = res + ((((UINT8)msn > 0x80U) && ((UINT8)lsn > 0x09U)) || (((UINT8)msn > 0x90U) || (C != 0)) ? 0x60 : 0); 
    C = C | (res & 0x100); 
    res = (UINT8)res; 
    A = res; 
 // N = res; 
 // Z = res; 
 // V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4AFC                   ; C149: B7 4A FC      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4afc, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4AFB                   ; C14C: B6 4A FB      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4afb); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADCA  #$00                    ; C14F: 89 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    arg = A; 
    val = (SINT8)0x00; 
    res = arg + val + (C != 0 ? 1:0); 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = arg ^ val ^ (UINT8)res ^ C; 
 // V = arg ^ val ^ (UINT8)res ^ C; 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         DAA                           ; C151: 19            \n");
                                      #endif
    res = A; 
    msn = res & 0xf0; 
    lsn = res & 0x0f; 
    res = res + (((lsn > 0x09) || (H & 0x10)) ? 0x06 : 0); 
    res = res + ((((UINT8)msn > 0x80U) && ((UINT8)lsn > 0x09U)) || (((UINT8)msn > 0x90U) || (C != 0)) ? 0x60 : 0); 
    C = C | (res & 0x100); 
    res = (UINT8)res; 
    A = res; 
 // N = res; 
 // Z = res; 
 // V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4AFB                   ; C152: B7 4A FB      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4afb, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4AFA                   ; C155: B6 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4afa); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADCA  #$00                    ; C158: 89 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    arg = A; 
    val = (SINT8)0x00; 
    res = arg + val + (C != 0 ? 1:0); 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = arg ^ val ^ (UINT8)res ^ C; 
 // V = arg ^ val ^ (UINT8)res ^ C; 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         DAA                           ; C15A: 19            \n");
                                      #endif
    res = A; 
    msn = res & 0xf0; 
    lsn = res & 0x0f; 
    res = res + (((lsn > 0x09) || (H & 0x10)) ? 0x06 : 0); 
    res = res + ((((UINT8)msn > 0x80U) && ((UINT8)lsn > 0x09U)) || (((UINT8)msn > 0x90U) || (C != 0)) ? 0x60 : 0); 
 // C = C | (res & 0x100); 
    res = (UINT8)res; 
    A = res; 
 // N = res; 
 // Z = res; 
 // V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4AFA                   ; C15B: B7 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4afa, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC6F4                   ; C15E: BD C6 F4      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x61); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc1); 
    clockticks = clockticks + 1; 
    goto LC6F4;
  case 0xC161:
LC161:
                                                     #ifdef DEBUG
                                      mon("LC161    LDX   #$4588                  ; C161: 8E 45 88      \n");
                                      #endif
    PC = 0xc161; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x4588; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC6D4                   ; C164: BD C6 D4      \n");
                                      #endif // Read NOVRAM
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x67); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc1); 
    clockticks = clockticks + 1; 
    goto LC6D4;
  case 0xC167:
LC167:
                                                     #ifdef DEBUG
                                      mon("LC167    LDA   $4B16                   ; C167: B6 4B 16      \n");
                                      #endif
    PC = 0xc167; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b16); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  $4AFA                   ; C16A: B1 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    arg = rd_mem(0x4afa); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BLS   LC17B                   ; C16D: 23 0C         \n");
                                      #endif
    // temp hack to force a flush
    if ((!Z) || C) {
    clockticks = clockticks + 3; 
    goto LC17B;
    }
                                                     #ifdef DEBUG
                                      mon("         STA   $4AFA                   ; C16F: B7 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4afa, val); 
                                                     #ifdef DEBUG
                                      mon("         CLR   $4AFB                   ; C172: 7F 4A FB      \n");
                                      #endif
    clockticks = clockticks + 5; 
    wr_mem(0x4afb, 0); 
 // V = 0; 
 // Z = 0; 
 // N = 0; 
 // C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         CLR   $4AFC                   ; C175: 7F 4A FC      \n");
                                      #endif
    clockticks = clockticks + 5; 
    wr_mem(0x4afc, 0); 
 // V = 0; 
 // Z = 0; 
 // N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC6F4                   ; C178: BD C6 F4      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x7b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc1); 
    clockticks = clockticks + 1; 
    goto LC6F4;
  case 0xC17B:
LC17B:
                                                     #ifdef DEBUG
                                      mon("LC17B    LDX   #$4586                  ; C17B: 8E 45 86      \n");
                                      #endif
    PC = 0xc17b; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x4586; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4819                   ; C17E: B6 48 19      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4819); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LC19E                   ; C181: 26 1B         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LC19E;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $481A                   ; C183: B6 48 1A      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x481a); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4564                  ; C186: 8E 45 64      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x4564; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$9A                    ; C189: C6 9A         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x9a; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBB  word_C7A4               ; C18B: F0 C7 A4      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)B; 
    arg = rd_mem(0xc7a4); 
    res = val - (UINT8)arg; 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    B = (UINT8)(res); 
                                                     #ifdef DEBUG
                                      mon("         STB   $4AFA                   ; C18E: F7 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4afa, val); 
  case 0xC191:
LC191:
                                                     #ifdef DEBUG
                                      mon("LC191    ADDA  $4AFA                   ; C191: BB 4A FA      \n");
                                      #endif
    PC = 0xc191; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    arg = rd_mem(0x4afa); 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         DAA                           ; C194: 19            \n");
                                      #endif
    res = A; 
    msn = res & 0xf0; 
    lsn = res & 0x0f; 
    res = res + (((lsn > 0x09) || (H & 0x10)) ? 0x06 : 0); 
    res = res + ((((UINT8)msn > 0x80U) && ((UINT8)lsn > 0x09U)) || (((UINT8)msn > 0x90U) || (C != 0)) ? 0x60 : 0); 
    C = C | (res & 0x100); 
    res = (UINT8)res; 
    A = res; 
    N = res; 
    Z = res; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BCC   LC19E                   ; C195: 24 07         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LC19E;
    }
                                                     #ifdef DEBUG
                                      mon("         LEAX  $02,X                   ; C197: 30 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + 0x0002); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$4586                  ; C199: 8C 45 86      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x4586; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LC191                   ; C19C: 25 F3         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LC191;
    }
  case 0xC19E:
LC19E:
                                                     #ifdef DEBUG
                                      mon("LC19E    LDA   $01,X                   ; C19E: A6 01         \n");
                                      #endif
    PC = 0xc19e; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0001)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$0F                    ; C1A0: 84 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x0f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDA  #$01                    ; C1A2: 8B 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x01; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         DAA                           ; C1A4: 19            \n");
                                      #endif
    res = A; 
    msn = res & 0xf0; 
    lsn = res & 0x0f; 
    res = res + (((lsn > 0x09) || (H & 0x10)) ? 0x06 : 0); 
    res = res + ((((UINT8)msn > 0x80U) && ((UINT8)lsn > 0x09U)) || (((UINT8)msn > 0x90U) || (C != 0)) ? 0x60 : 0); 
    C = C | (res & 0x100); 
    res = (UINT8)res; 
    A = res; 
 // N = res; 
 // Z = res; 
 // V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $01,X                   ; C1A5: A7 01         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0001); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$F0                    ; C1A7: 84 F0         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0xf0; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LC1E9                   ; C1A9: 27 3E         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LC1E9;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   ,X                      ; C1AB: A6 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(X); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$0F                    ; C1AD: 84 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x0f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDA  #$01                    ; C1AF: 8B 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x01; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         DAA                           ; C1B1: 19            \n");
                                      #endif
    res = A; 
    msn = res & 0xf0; 
    lsn = res & 0x0f; 
    res = res + (((lsn > 0x09) || (H & 0x10)) ? 0x06 : 0); 
    res = res + ((((UINT8)msn > 0x80U) && ((UINT8)lsn > 0x09U)) || (((UINT8)msn > 0x90U) || (C != 0)) ? 0x60 : 0); 
    C = C | (res & 0x100); 
    res = (UINT8)res; 
    A = res; 
 // N = res; 
 // Z = res; 
 // V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   ,X                      ; C1B2: A7 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$F0                    ; C1B4: 84 F0         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0xf0; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LC1E9                   ; C1B6: 27 31         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LC1E9;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4564                  ; C1B8: 8E 45 64      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x4564; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xC1BB:
LC1BB:
                                                     #ifdef DEBUG
                                      mon("LC1BB    LDA   ,X                      ; C1BB: A6 84         \n");
                                      #endif
    PC = 0xc1bb; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(X); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLA                          ; C1BD: 48            \n");
                                      #endif
    val = (UINT8)A; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLA                          ; C1BE: 48            \n");
                                      #endif
    val = (UINT8)A; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLA                          ; C1BF: 48            \n");
                                      #endif
    val = (UINT8)A; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLA                          ; C1C0: 48            \n");
                                      #endif
    val = (UINT8)A; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4AFA                   ; C1C1: B7 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4afa, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $01,X                   ; C1C4: A6 01         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0001)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$0F                    ; C1C6: 84 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x0f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDA  $4AFA                   ; C1C8: BB 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    arg = rd_mem(0x4afa); 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BITA  #$10                    ; C1CB: 85 10         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A & (SINT8)0x10; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LC1D1                   ; C1CD: 27 02         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LC1D1;
    }
                                                     #ifdef DEBUG
                                      mon("         SUBA  #$06                    ; C1CF: 80 06         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x06; 
    res = val - (UINT8)arg; 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)(res); 
  case 0xC1D1:
LC1D1:
                                                     #ifdef DEBUG
                                      mon("LC1D1    LSRA                          ; C1D1: 44            \n");
                                      #endif
    PC = 0xc1d1; 
    INSTRUCTION_START
    val = (UINT8)A; 
 // C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $01,X                   ; C1D2: A7 01         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0001); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; C1D4: 44            \n");
                                      #endif
    val = (UINT8)A; 
 // C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; C1D5: 44            \n");
                                      #endif
    val = (UINT8)A; 
 // C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; C1D6: 44            \n");
                                      #endif
    val = (UINT8)A; 
 // C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; C1D7: 44            \n");
                                      #endif
    val = (UINT8)A; 
 // C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   ,X                      ; C1D8: A7 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LEAX  $02,X                   ; C1DA: 30 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + 0x0002); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$4588                  ; C1DC: 8C 45 88      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x4588; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LC1BB                   ; C1DF: 25 DA         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LC1BB;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$05                    ; C1E1: 86 05         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x05; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   ,U                      ; C1E3: A7 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; C1E5: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $01,U                   ; C1E7: A7 41         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(U + 0x0001); 
    wr_mem(ea, val); 
  case 0xC1E9:
LC1E9:
                                                     #ifdef DEBUG
                                      mon("LC1E9    LDA   $4866                   ; C1E9: B6 48 66      \n");
                                      #endif // Joystick pitch data structure
    PC = 0xc1e9; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4866); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4AFA                   ; C1EC: B7 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4afa, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4868                   ; C1EF: B6 48 68      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4868); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4AFB                   ; C1F2: B7 4A FB      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4afb, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $486F                   ; C1F5: B6 48 6F      \n");
                                      #endif // Joystick roll data structure
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x486f); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4AFC                   ; C1F8: B7 4A FC      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4afc, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4871                   ; C1FB: B6 48 71      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4871); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4AFD                   ; C1FE: B7 4A FD      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4afd, val); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4534                  ; C201: 8E 45 34      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x4534; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #$4AFA                  ; C204: CE 4A FA      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x4afa; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$03                    ; C207: 86 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x03; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
    // End of function sub_C0FF
                                                     #ifdef DEBUG
                                      mon("         JSR   LC6F9                   ; C209: BD C6 F9      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x0c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc2); 
    clockticks = clockticks + 1; 
    goto LC6F9;
    // =============== S U B R O U T I N E =======================================
  case 0xC20C:
LC20C:
                                                     #ifdef DEBUG
                                      mon("LC20C    LDX   #$455C                  ; C20C: 8E 45 5C      \n");
                                      #endif
    PC = 0xc20c; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x455c; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC6D4                   ; C20F: BD C6 D4      \n");
                                      #endif // Read NOVRAM
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x12); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc2); 
    clockticks = clockticks + 1; 
    goto LC6D4;
  case 0xC212:
LC212:
                                                     #ifdef DEBUG
                                      mon("LC212    ORCC  #$10                    ; C212: 1A 10         \n");
                                      #endif
    PC = 0xc212; 
    INSTRUCTION_START
    I = 1; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         LDU   $4B06                   ; C214: FE 4B 06      \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4b06)<<8; 
    ea = ea | rd_mem(0x4b07); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   $4B04                   ; C217: FC 4B 04      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x4b04); // Care needed with I/O space and word fetches
    B = rd_mem(0x4b05); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDCC #$EF                    ; C21A: 1C EF         \n");
                                      #endif
    I = 0; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  $4AFA                   ; C21C: 10 B3 4A FA   \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4afa)<<8; 
    ea = ea | rd_mem(0x4afb); 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = ea; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
    clockticks = clockticks + 1; 
                                                     #ifdef DEBUG
                                      mon("         BHI   LC22A                   ; C220: 22 08         \n");
                                      #endif
    // temp hack to force a flush
    if (Z && (!C)) {
    clockticks = clockticks + 3; 
    goto LC22A;
    }
                                                     #ifdef DEBUG
                                      mon("         BCS   LC23D                   ; C222: 25 19         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LC23D;
    }
                                                     #ifdef DEBUG
                                      mon("         CMPU  $4AFC                   ; C224: 11 B3 4A FC   \n");
                                      #endif
    clockticks = clockticks + 7; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4afc)<<8; 
    ea = ea | rd_mem(0x4afd); 
    val = U; 
    arg = ea; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BLS   LC23D                   ; C228: 23 13         \n");
                                      #endif
    // temp hack to force a flush
    if ((!Z) || C) {
    clockticks = clockticks + 3; 
    goto LC23D;
    }
  case 0xC22A:
LC22A:
                                                     #ifdef DEBUG
                                      mon("LC22A    STD   $4AFA                   ; C22A: FD 4A FA      \n");
                                      #endif
    PC = 0xc22a; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4afa, A); // Care needed with I/O space and word fetches
    wr_mem(0x4afb, B); 
                                                     #ifdef DEBUG
                                      mon("         STU   $4AFC                   ; C22D: FF 4A FC      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    wr_mem(0x4afc, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem(0x4afd, (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$455C                  ; C230: 8E 45 5C      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x455c; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #$4AFA                  ; C233: CE 4A FA      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x4afa; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$03                    ; C236: 86 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x03; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC6F9                   ; C238: BD C6 F9      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x3b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc2); 
    clockticks = clockticks + 1; 
    goto LC6F9;
  case 0xC23B:
LC23B:
                                                     #ifdef DEBUG
                                      mon("LC23B    BRA   LC249                   ; C23B: 20 0C         \n");
                                      #endif
    PC = 0xc23b; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto LC249;
    
    // ---------------------------------------------------------------------------
  case 0xC23D:
LC23D:
                                                     #ifdef DEBUG
                                      mon("LC23D    LDD   $4AFA                   ; C23D: FC 4A FA      \n");
                                      #endif
    PC = 0xc23d; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x4afa); // Care needed with I/O space and word fetches
    B = rd_mem(0x4afb); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B04                   ; C240: FD 4B 04      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4b04, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b05, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $4AFC                   ; C243: FC 4A FC      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x4afc); // Care needed with I/O space and word fetches
    B = rd_mem(0x4afd); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B06                   ; C246: FD 4B 06      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4b06, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b07, B); 
  case 0xC249:
LC249:
                                                     #ifdef DEBUG
                                      mon("LC249    LDA   #$02                    ; C249: 86 02         \n");
                                      #endif
    PC = 0xc249; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x02; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function sub_C20C
                                                     #ifdef DEBUG
                                      mon("         JMP   LC2B3                   ; C24B: 7E C2 B3      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LC2B3;
    
    // =============== S U B R O U T I N E =======================================
  case 0xC24E:
LC24E:
                                                     #ifdef DEBUG
                                      mon("LC24E    CMPA  #$03                    ; C24E: 81 03         \n");
                                      #endif
    PC = 0xc24e; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x03; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCC   LC2B3                   ; C250: 24 61         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LC2B3;
    }
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$02                    ; C252: 81 02         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x02; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   LC27F                   ; C254: 25 29         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LC27F;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   #word_C7B7              ; C256: 8E C7 B7      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0xc7b7; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   A,X                     ; C259: E6 86         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + (SINT8)A)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBB  #$02                    ; C25B: C0 02         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x02; 
    res = val - (UINT8)arg; 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    B = (UINT8)(res); 
                                                     #ifdef DEBUG
                                      mon("         STB   $4AFB                   ; C25D: F7 4A FB      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4afb, val); 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$45                    ; C260: C6 45         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x45; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STB   $4AFA                   ; C262: F7 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4afa, val); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #unk_C7B6               ; C265: 8E C7 B6      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0xc7b6; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   A,X                     ; C268: E6 86         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + (SINT8)A)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$C707                  ; C26A: 8E C7 07      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0xc707; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; C26D: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         TFR   X,U                     ; C26E: 1F 13         \n");
                                      #endif
    U = X; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4500                  ; C270: 8E 45 00      \n");
                                      #endif // NOVRAM
    clockticks = clockticks + 3; 
    X = 0x4500; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; C273: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
  case 0xC274:
LC274:
                                                     #ifdef DEBUG
                                      mon("LC274    LDB   ,U+                     ; C274: E6 C0         \n");
                                      #endif
    PC = 0xc274; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    val = (UINT8)rd_mem(U); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
    U = U + 1; 
                                                     #ifdef DEBUG
                                      mon("         STB   ,X+                     ; C276: E7 80         \n");
                                      #endif
    clockticks = clockticks + 6; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, val); 
    X = X + 1; 
                                                     #ifdef DEBUG
                                      mon("         CPX   $4AFA                   ; C278: BC 4A FA      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4afa)<<8; 
    ea = ea | rd_mem(0x4afb); 
    val = X; 
    arg = ea; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LC274                   ; C27B: 25 F7         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LC274;
    }
                                                     #ifdef DEBUG
                                      mon("         BRA   LC2B3                   ; C27D: 20 34         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LC2B3;
    
    // ---------------------------------------------------------------------------
  case 0xC27F:
LC27F:
                                                     #ifdef DEBUG
                                      mon("LC27F    TFR   A,B                     ; C27F: 1F 89         \n");
                                      #endif
    PC = 0xc27f; 
    INSTRUCTION_START
    B = (UINT8)A; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         TSTA                          ; C281: 4D            \n");
                                      #endif
    val = (UINT8)A; 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LC29B                   ; C282: 26 17         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LC29B;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   <$27                    ; C284: 96 27         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x27); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4AFA                   ; C286: B7 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4afa, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$24                    ; C289: 96 24         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x24); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4AFB                   ; C28B: B7 4A FB      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4afb, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; C28E: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4AFC                   ; C290: B7 4A FC      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4afc, val); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4500                  ; C293: 8E 45 00      \n");
                                      #endif // NOVRAM
    clockticks = clockticks + 3; 
    X = 0x4500; 
    Z = X; 
    N = (X) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC6F4                   ; C296: BD C6 F4      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x99); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc2); 
    clockticks = clockticks + 1; 
    goto LC6F4;
  case 0xC299:
LC299:
                                                     #ifdef DEBUG
                                      mon("LC299    BRA   LC2B1                   ; C299: 20 16         \n");
                                      #endif
    PC = 0xc299; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto LC2B1;
    
    // ---------------------------------------------------------------------------
  case 0xC29B:
LC29B:
                                                     #ifdef DEBUG
                                      mon("LC29B    LDX   #$4508                  ; C29B: 8E 45 08      \n");
                                      #endif
    PC = 0xc29b; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x4508; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #word_CC98              ; C29E: CE CC 98      \n");
                                      #endif // High scores init table
    clockticks = clockticks + 3; 
    U = 0xcc98; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$0B                    ; C2A1: 86 0B         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x0b; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC6F9                   ; C2A3: BD C6 F9      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xa6); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc2); 
    clockticks = clockticks + 1; 
    goto LC6F9;
  case 0xC2A6:
LC2A6:
                                                     #ifdef DEBUG
                                      mon("LC2A6    LDX   #$4520                  ; C2A6: 8E 45 20      \n");
                                      #endif
    PC = 0xc2a6; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x4520; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #word_CC7A              ; C2A9: CE CC 7A      \n");
                                      #endif // High score names
    clockticks = clockticks + 3; 
    U = 0xcc7a; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$08                    ; C2AC: 86 08         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x08; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC6F9                   ; C2AE: BD C6 F9      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xb1); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc2); 
    clockticks = clockticks + 1; 
    goto LC6F9;
    // End of function sub_C24E
  case 0xC2B1:
LC2B1:
                                                     #ifdef DEBUG
                                      mon("LC2B1    TFR   B,A                     ; C2B1: 1F 98         \n");
                                      #endif
    PC = 0xc2b1; 
    INSTRUCTION_START
    A = (UINT8)B; 
    clockticks = clockticks + 6; 
    // =============== S U B R O U T I N E =======================================
  case 0xC2B3:
LC2B3:
                                                     #ifdef DEBUG
                                      mon("LC2B3    JSR   LC2C3                   ; C2B3: BD C2 C3      \n");
                                      #endif
    PC = 0xc2b3; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xb6); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc2); 
    clockticks = clockticks + 1; 
    goto LC2C3;
  case 0xC2B6:
LC2B6:
                                                     #ifdef DEBUG
                                      mon("LC2B6    BEQ   locret_C2C2             ; C2B6: 27 0A         \n");
                                      #endif
    PC = 0xc2b6; 
    INSTRUCTION_START
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LC2C2;
    }
                                                     #ifdef DEBUG
                                      mon("         STB   $01,X                   ; C2B8: E7 01         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0001); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LSRB                          ; C2BA: 54            \n");
                                      #endif
    val = (UINT8)B; 
 // C = val & 1; 
    val = val >> 1; 
    B = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRB                          ; C2BB: 54            \n");
                                      #endif
    val = (UINT8)B; 
 // C = val & 1; 
    val = val >> 1; 
    B = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRB                          ; C2BC: 54            \n");
                                      #endif
    val = (UINT8)B; 
 // C = val & 1; 
    val = val >> 1; 
    B = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRB                          ; C2BD: 54            \n");
                                      #endif
    val = (UINT8)B; 
    C = val & 1; 
    val = val >> 1; 
    B = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STB   ,X                      ; C2BE: E7 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$FF                    ; C2C0: C6 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xff; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function sub_C2B3
  case 0xC2C2:
LC2C2:
locret_C2C2:
                                                     #ifdef DEBUG
                                      mon("locret_C2C2 RTS                           ; C2C2: 39            \n");
                                      #endif
    PC = 0xc2c2; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xC2C3:
LC2C3:
                                                     #ifdef DEBUG
                                      mon("LC2C3    LEAS  -3,S                    ; C2C3: 32 7D         \n");
                                      #endif
    PC = 0xc2c3; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    S = (S + 0xfffd); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #word_C7B7              ; C2C5: 8E C7 B7      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0xc7b7; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   A,X                     ; C2C8: E6 86         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + (SINT8)A)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #unk_C7B6               ; C2CA: 8E C7 B6      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0xc7b6; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBB  A,X                     ; C2CD: E0 86         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)B; 
    arg = rd_mem((UINT16)(X + (SINT8)A)); 
    res = val - (UINT8)arg; 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    B = (UINT8)(res); 
                                                     #ifdef DEBUG
                                      mon("         SUBB  #$02                    ; C2CF: C0 02         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x02; 
    res = val - (UINT8)arg; 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    B = (UINT8)(res); 
                                                     #ifdef DEBUG
                                      mon("         STB   ,S                      ; C2D1: E7 E4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = S; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDB   A,X                     ; C2D3: E6 86         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + (SINT8)A)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4500                  ; C2D5: 8E 45 00      \n");
                                      #endif // NOVRAM
    clockticks = clockticks + 3; 
    X = 0x4500; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; C2D8: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$00                    ; C2D9: C6 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STB   $01,S                   ; C2DB: E7 61         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(S + 0x0001); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         ORCC  #$01                    ; C2DD: 1A 01         \n");
                                      #endif
    C = 1; 
    clockticks = clockticks + 3; 
  case 0xC2DF:
LC2DF:
                                                     #ifdef DEBUG
                                      mon("LC2DF    LDB   ,X+                     ; C2DF: E6 80         \n");
                                      #endif
    PC = 0xc2df; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    val = (UINT8)rd_mem(X); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
    X = X + 1; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$0F                    ; C2E1: C4 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x0f; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADCB  $01,S                   ; C2E3: E9 61         \n");
                                      #endif
    clockticks = clockticks + 5; 
    arg = B; 
    val = rd_mem((UINT16)(S + 0x0001)); 
    res = arg + val + (C != 0 ? 1:0); 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = arg ^ val ^ (UINT8)res ^ C; 
 // V = arg ^ val ^ (UINT8)res ^ C; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STB   $01,S                   ; C2E5: E7 61         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(S + 0x0001); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         DEC   ,S                      ; C2E7: 6A E4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(S); 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    wr_mem(S, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LC2DF                   ; C2E9: 26 F4         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LC2DF;
    }
                                                     #ifdef DEBUG
                                      mon("         ADCB  #$00                    ; C2EB: C9 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    arg = B; 
    val = (SINT8)0x00; 
    res = arg + val + (C != 0 ? 1:0); 
 // C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // H = arg ^ val ^ (UINT8)res ^ C; 
 // V = arg ^ val ^ (UINT8)res ^ C; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STB   $01,S                   ; C2ED: E7 61         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(S + 0x0001); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDB   ,X                      ; C2EF: E6 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(X); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; C2F1: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; C2F2: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; C2F3: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; C2F4: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STB   $02,S                   ; C2F5: E7 62         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(S + 0x0002); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDB   $01,X                   ; C2F7: E6 01         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0001)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$0F                    ; C2F9: C4 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x0f; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDB  $02,S                   ; C2FB: EB 62         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)B; 
    arg = rd_mem((UINT16)(S + 0x0002)); 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STB   $02,S                   ; C2FD: E7 62         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(S + 0x0002); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDB   $01,S                   ; C2FF: E6 61         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(S + 0x0001)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  $02,S                   ; C301: E1 62         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)B; 
    arg = rd_mem((UINT16)(S + 0x0002)); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         LEAS  $03,S                   ; C303: 32 63         \n");
                                      #endif
    clockticks = clockticks + 5; 
    S = (S + 0x0003); 
    // End of function sub_C2C3
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; C305: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xC306:
LC306:
                                                     #ifdef DEBUG
                                      mon("LC306    LDX   #$4500                  ; C306: 8E 45 00      \n");
                                      #endif // NOVRAM
    PC = 0xc306; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x4500; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #$4C00                  ; C309: CE 4C 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x4c00; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0xC30C:
LC30C:
                                                     #ifdef DEBUG
                                      mon("LC30C    LDD   ,X++                    ; C30C: EC 81         \n");
                                      #endif
    PC = 0xc30c; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
    A = rd_mem(X); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(X+1)); 
    X = X + 2; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,U++                    ; C30E: ED C1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    U = U + 2; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$4600                  ; C310: 8C 46 00      \n");
                                      #endif // NOVRAM
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x4600; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LC30C                   ; C313: 25 F7         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LC30C;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$FF                    ; C315: 86 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xff; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4687                   ; C317: B7 46 87      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4687, val); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$0100                  ; C31A: 8E 01 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x0100; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xC31D:
LC31D:
                                                     #ifdef DEBUG
                                      mon("LC31D    STA   $4640                   ; C31D: B7 46 40      \n");
                                      #endif
    PC = 0xc31d; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x4640, val); 
                                                     #ifdef DEBUG
                                      mon("         LEAX  -1,X                    ; C320: 30 1F         \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + 0xffff); 
    Z = X; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LC31D                   ; C322: 26 F9         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LC31D;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; C324: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4687                   ; C326: B7 46 87      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4687, val); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$A000                  ; C329: 8E A0 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0xa000; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xC32C:
LC32C:
                                                     #ifdef DEBUG
                                      mon("LC32C    STA   $4640                   ; C32C: B7 46 40      \n");
                                      #endif
    PC = 0xc32c; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x4640, val); 
                                                     #ifdef DEBUG
                                      mon("         LEAX  -1,X                    ; C32F: 30 1F         \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + 0xffff); 
    Z = X; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LC32C                   ; C331: 26 F9         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LC32C;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4500                  ; C333: 8E 45 00      \n");
                                      #endif // NOVRAM
    clockticks = clockticks + 3; 
    X = 0x4500; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDY   #$4C00                  ; C336: 10 8E 4C 00   \n");
                                      #endif
    clockticks = clockticks + 4; 
    Y = 0x4c00; 
 // Z = Y; 
 // N = (Y) >> 8; 
 // V = 0; 
  case 0xC33A:
LC33A:
                                                     #ifdef DEBUG
                                      mon("LC33A    LDU   ,X                      ; C33A: EE 84         \n");
                                      #endif
    PC = 0xc33a; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   ,Y                      ; C33C: EC A4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(Y); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(Y+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STU   ,Y++                    ; C33E: EF A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,X++                    ; C340: ED 81         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    X = X + 2; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$4600                  ; C342: 8C 46 00      \n");
                                      #endif // NOVRAM
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x4600; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LC33A                   ; C345: 25 F3         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LC33A;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$03                    ; C347: 86 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x03; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC2C3                   ; C349: BD C2 C3      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x4c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc3); 
    clockticks = clockticks + 1; 
    goto LC2C3;
  case 0xC34C:
LC34C:
                                                     #ifdef DEBUG
                                      mon("LC34C    BEQ   LC37C                   ; C34C: 27 2E         \n");
                                      #endif
    PC = 0xc34c; 
    INSTRUCTION_START
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LC37C;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; C34E: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC2C3                   ; C350: BD C2 C3      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x53); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc3); 
    clockticks = clockticks + 1; 
    goto LC2C3;
  case 0xC353:
LC353:
                                                     #ifdef DEBUG
                                      mon("LC353    BEQ   LC36C                   ; C353: 27 17         \n");
                                      #endif
    PC = 0xc353; 
    INSTRUCTION_START
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LC36C;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   LC3EE                   ; C355: BD C3 EE      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x58); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc3); 
    clockticks = clockticks + 1; 
    goto LC3EE;
  case 0xC358:
LC358:
                                                     #ifdef DEBUG
                                      mon("LC358    LDA   #$03                    ; C358: 86 03         \n");
                                      #endif
    PC = 0xc358; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x03; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC3EE                   ; C35A: BD C3 EE      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x5d); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc3); 
    clockticks = clockticks + 1; 
    goto LC3EE;
  case 0xC35D:
LC35D:
                                                     #ifdef DEBUG
                                      mon("LC35D    JSR   LC2C3                   ; C35D: BD C2 C3      \n");
                                      #endif
    PC = 0xc35d; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x60); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc3); 
    clockticks = clockticks + 1; 
    goto LC2C3;
  case 0xC360:
LC360:
                                                     #ifdef DEBUG
                                      mon("LC360    BEQ   LC37C                   ; C360: 27 1A         \n");
                                      #endif
    PC = 0xc360; 
    INSTRUCTION_START
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LC37C;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; C362: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC2C3                   ; C364: BD C2 C3      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x67); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc3); 
    clockticks = clockticks + 1; 
    goto LC2C3;
  case 0xC367:
LC367:
                                                     #ifdef DEBUG
                                      mon("LC367    BEQ   LC36C                   ; C367: 27 03         \n");
                                      #endif
    PC = 0xc367; 
    INSTRUCTION_START
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LC36C;
    }
  case 0xC369:
LC369:
                                                     #ifdef DEBUG
                                      mon("LC369    JSR   LC24E                   ; C369: BD C2 4E      \n");
                                      #endif
    PC = 0xc369; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x6c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc3); 
    clockticks = clockticks + 1; 
    goto LC24E;
  case 0xC36C:
LC36C:
                                                     #ifdef DEBUG
                                      mon("LC36C    LDX   #unk_C7B6               ; C36C: 8E C7 B6      \n");
                                      #endif
    PC = 0xc36c; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0xc7b6; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $0003,X                 ; C36F: E6 89 00 03   \n");
                                      #endif
    clockticks = clockticks + 8; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0003)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4500                  ; C373: 8E 45 00      \n");
                                      #endif // NOVRAM
    clockticks = clockticks + 3; 
    X = 0x4500; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; C376: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #$4500                  ; C377: CE 45 00      \n");
                                      #endif // NOVRAM
    clockticks = clockticks + 3; 
    U = 0x4500; 
    Z = U; 
    N = (U) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LC3B7                   ; C37A: 20 3B         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LC3B7;
    
    // ---------------------------------------------------------------------------
  case 0xC37C:
LC37C:
                                                     #ifdef DEBUG
                                      mon("LC37C    LDA   #$00                    ; C37C: 86 00         \n");
                                      #endif
    PC = 0xc37c; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC2C3                   ; C37E: BD C2 C3      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x81); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc3); 
    clockticks = clockticks + 1; 
    goto LC2C3;
  case 0xC381:
LC381:
                                                     #ifdef DEBUG
                                      mon("LC381    BNE   LC3A7                   ; C381: 26 24         \n");
                                      #endif
    PC = 0xc381; 
    INSTRUCTION_START
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LC3A7;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4596                   ; C383: B6 45 96      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4596); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$0F                    ; C386: 84 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x0f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4AFA                   ; C388: B7 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4afa, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4506                   ; C38B: B6 45 06      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4506); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$0F                    ; C38E: 84 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x0f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  $4AFA                   ; C390: B1 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    arg = rd_mem(0x4afa); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   LC3A5                   ; C393: 26 10         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LC3A5;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4597                   ; C395: B6 45 97      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4597); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$0F                    ; C398: 84 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x0f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4AFA                   ; C39A: B7 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4afa, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4507                   ; C39D: B6 45 07      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4507); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$0F                    ; C3A0: 84 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x0f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  $4AFA                   ; C3A2: B1 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    arg = rd_mem(0x4afa); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
  case 0xC3A5:
LC3A5:
                                                     #ifdef DEBUG
                                      mon("LC3A5    BEQ   LC3C6                   ; C3A5: 27 1F         \n");
                                      #endif
    PC = 0xc3a5; 
    INSTRUCTION_START
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LC3C6;
    }
  case 0xC3A7:
LC3A7:
                                                     #ifdef DEBUG
                                      mon("LC3A7    LDX   #unk_C7B6               ; C3A7: 8E C7 B6      \n");
                                      #endif
    PC = 0xc3a7; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0xc7b6; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $0003,X                 ; C3AA: E6 89 00 03   \n");
                                      #endif
    clockticks = clockticks + 8; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0003)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4500                  ; C3AE: 8E 45 00      \n");
                                      #endif // NOVRAM
    clockticks = clockticks + 3; 
    X = 0x4500; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; C3B1: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         TFR   X,U                     ; C3B2: 1F 13         \n");
                                      #endif
    U = X; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4500                  ; C3B4: 8E 45 00      \n");
                                      #endif // NOVRAM
    clockticks = clockticks + 3; 
    X = 0x4500; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xC3B7:
LC3B7:
                                                     #ifdef DEBUG
                                      mon("LC3B7    LDB   word_C7B7               ; C3B7: F6 C7 B7      \n");
                                      #endif
    PC = 0xc3b7; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0xc7b7); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STB   $4B02                   ; C3BA: F7 4B 02      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b02, val); 
  case 0xC3BD:
LC3BD:
                                                     #ifdef DEBUG
                                      mon("LC3BD    LDB   ,U+                     ; C3BD: E6 C0         \n");
                                      #endif
    PC = 0xc3bd; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    val = (UINT8)rd_mem(U); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
    U = U + 1; 
                                                     #ifdef DEBUG
                                      mon("         STB   ,X+                     ; C3BF: E7 80         \n");
                                      #endif
    clockticks = clockticks + 6; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, val); 
    X = X + 1; 
                                                     #ifdef DEBUG
                                      mon("         DEC   $4B02                   ; C3C1: 7A 4B 02      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b02); 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    wr_mem(0x4b02, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LC3BD                   ; C3C4: 26 F7         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LC3BD;
    }
  case 0xC3C6:
LC3C6:
                                                     #ifdef DEBUG
                                      mon("LC3C6    LDA   #$02                    ; C3C6: 86 02         \n");
                                      #endif
    PC = 0xc3c6; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x02; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
  case 0xC3C8:
LC3C8:
                                                     #ifdef DEBUG
                                      mon("LC3C8    JSR   LC2C3                   ; C3C8: BD C2 C3      \n");
                                      #endif
    PC = 0xc3c8; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xcb); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc3); 
    clockticks = clockticks + 1; 
    goto LC2C3;
  case 0xC3CB:
LC3CB:
                                                     #ifdef DEBUG
                                      mon("LC3CB    BEQ   LC3D8                   ; C3CB: 27 0B         \n");
                                      #endif
    PC = 0xc3cb; 
    INSTRUCTION_START
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LC3D8;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   LC3EE                   ; C3CD: BD C3 EE      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xd0); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc3); 
    clockticks = clockticks + 1; 
    goto LC3EE;
  case 0xC3D0:
LC3D0:
                                                     #ifdef DEBUG
                                      mon("LC3D0    JSR   LC2C3                   ; C3D0: BD C2 C3      \n");
                                      #endif
    PC = 0xc3d0; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xd3); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc3); 
    clockticks = clockticks + 1; 
    goto LC2C3;
  case 0xC3D3:
LC3D3:
                                                     #ifdef DEBUG
                                      mon("LC3D3    BEQ   LC3D8                   ; C3D3: 27 03         \n");
                                      #endif
    PC = 0xc3d3; 
    INSTRUCTION_START
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LC3D8;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   LC24E                   ; C3D5: BD C2 4E      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xd8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc3); 
    clockticks = clockticks + 1; 
    goto LC24E;
  case 0xC3D8:
LC3D8:
                                                     #ifdef DEBUG
                                      mon("LC3D8    DECA                          ; C3D8: 4A            \n");
                                      #endif
    PC = 0xc3d8; 
    INSTRUCTION_START
    val = (UINT8)A; 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LC3C8                   ; C3D9: 26 ED         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LC3C8;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   #$455C                  ; C3DB: 8E 45 5C      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x455c; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC6D4                   ; C3DE: BD C6 D4      \n");
                                      #endif // Read NOVRAM
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xe1); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc3); 
    clockticks = clockticks + 1; 
    goto LC6D4;
  case 0xC3E1:
LC3E1:
                                                     #ifdef DEBUG
                                      mon("LC3E1    LDD   $4AFA                   ; C3E1: FC 4A FA      \n");
                                      #endif
    PC = 0xc3e1; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x4afa); // Care needed with I/O space and word fetches
    B = rd_mem(0x4afb); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B04                   ; C3E4: FD 4B 04      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4b04, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b05, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $4AFC                   ; C3E7: FC 4A FC      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x4afc); // Care needed with I/O space and word fetches
    B = rd_mem(0x4afd); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B06                   ; C3EA: FD 4B 06      \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x4b06, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b07, B); 
    // End of function sub_C306
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; C3ED: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xC3EE:
LC3EE:
                                                     #ifdef DEBUG
                                      mon("LC3EE    LDX   #word_C7B7              ; C3EE: 8E C7 B7      \n");
                                      #endif
    PC = 0xc3ee; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0xc7b7; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   A,X                     ; C3F1: E6 86         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + (SINT8)A)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4500                  ; C3F3: 8E 45 00      \n");
                                      #endif // NOVRAM
    clockticks = clockticks + 3; 
    X = 0x4500; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; C3F6: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         STX   $4AFA                   ; C3F7: BF 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = X; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    wr_mem(0x4afa, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem(0x4afb, (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #unk_C7B6               ; C3FA: 8E C7 B6      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0xc7b6; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   A,X                     ; C3FD: E6 86         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + (SINT8)A)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4C00                  ; C3FF: 8E 4C 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x4c00; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; C402: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         TFR   X,U                     ; C403: 1F 13         \n");
                                      #endif
    U = X; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4500                  ; C405: 8E 45 00      \n");
                                      #endif // NOVRAM
    clockticks = clockticks + 3; 
    X = 0x4500; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; C408: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
  case 0xC409:
LC409:
                                                     #ifdef DEBUG
                                      mon("LC409    LDB   ,U+                     ; C409: E6 C0         \n");
                                      #endif
    PC = 0xc409; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    val = (UINT8)rd_mem(U); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
    U = U + 1; 
                                                     #ifdef DEBUG
                                      mon("         STB   ,X+                     ; C40B: E7 80         \n");
                                      #endif
    clockticks = clockticks + 6; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, val); 
    X = X + 1; 
                                                     #ifdef DEBUG
                                      mon("         CPX   $4AFA                   ; C40D: BC 4A FA      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4afa)<<8; 
    ea = ea | rd_mem(0x4afb); 
    val = X; 
    arg = ea; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LC409                   ; C410: 25 F7         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LC409;
    }
    // End of function sub_C3EE
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; C412: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xC413:
LC413:
                                                     #ifdef DEBUG
                                      mon("LC413    JSR   LC2C3                   ; C413: BD C2 C3      \n");
                                      #endif
    PC = 0xc413; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x16); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc4); 
    clockticks = clockticks + 1; 
    goto LC2C3;
  case 0xC416:
LC416:
                                                     #ifdef DEBUG
                                      mon("LC416    BEQ   locret_C44F             ; C416: 27 37         \n");
                                      #endif
    PC = 0xc416; 
    INSTRUCTION_START
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LC44F;
    }
                                                     #ifdef DEBUG
                                      mon("         STA   $4AFA                   ; C418: B7 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4afa, val); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4500                  ; C41B: 8E 45 00      \n");
                                      #endif // NOVRAM
    clockticks = clockticks + 3; 
    X = 0x4500; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #$4C00                  ; C41E: CE 4C 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x4c00; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0xC421:
LC421:
                                                     #ifdef DEBUG
                                      mon("LC421    LDD   ,X++                    ; C421: EC 81         \n");
                                      #endif
    PC = 0xc421; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
    A = rd_mem(X); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(X+1)); 
    X = X + 2; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,U++                    ; C423: ED C1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    U = U + 2; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$4600                  ; C425: 8C 46 00      \n");
                                      #endif // NOVRAM
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x4600; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LC421                   ; C428: 25 F7         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LC421;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   LC6B8                   ; C42A: BD C6 B8      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x2d); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc4); 
    clockticks = clockticks + 1; 
    goto LC6B8;
  case 0xC42D:
LC42D:
                                                     #ifdef DEBUG
                                      mon("LC42D    LDX   #$4500                  ; C42D: 8E 45 00      \n");
                                      #endif // NOVRAM
    PC = 0xc42d; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x4500; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDY   #$4C00                  ; C430: 10 8E 4C 00   \n");
                                      #endif
    clockticks = clockticks + 4; 
    Y = 0x4c00; 
 // Z = Y; 
 // N = (Y) >> 8; 
 // V = 0; 
  case 0xC434:
LC434:
                                                     #ifdef DEBUG
                                      mon("LC434    LDU   ,X                      ; C434: EE 84         \n");
                                      #endif
    PC = 0xc434; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   ,Y                      ; C436: EC A4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(Y); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(Y+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STU   ,Y++                    ; C438: EF A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,X++                    ; C43A: ED 81         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    X = X + 2; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$4600                  ; C43C: 8C 46 00      \n");
                                      #endif // NOVRAM
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x4600; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LC434                   ; C43F: 25 F3         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LC434;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4AFA                   ; C441: B6 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4afa); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC3EE                   ; C444: BD C3 EE      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x47); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc4); 
    clockticks = clockticks + 1; 
    goto LC3EE;
  case 0xC447:
LC447:
                                                     #ifdef DEBUG
                                      mon("LC447    JSR   LC2C3                   ; C447: BD C2 C3      \n");
                                      #endif
    PC = 0xc447; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x4a); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc4); 
    clockticks = clockticks + 1; 
    goto LC2C3;
  case 0xC44A:
LC44A:
                                                     #ifdef DEBUG
                                      mon("LC44A    BEQ   locret_C44F             ; C44A: 27 03         \n");
                                      #endif
    PC = 0xc44a; 
    INSTRUCTION_START
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LC44F;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   LC24E                   ; C44C: BD C2 4E      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x4f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc4); 
    clockticks = clockticks + 1; 
    goto LC24E;
    // End of function sub_C413
  case 0xC44F:
LC44F:
locret_C44F:
                                                     #ifdef DEBUG
                                      mon("locret_C44F RTS                           ; C44F: 39            \n");
                                      #endif
    PC = 0xc44f; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xC450:
LC450:
                                                     #ifdef DEBUG
                                      mon("LC450    LDA   #$65                    ; C450: 86 65         \n");
                                      #endif
    PC = 0xc450; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x65; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xC452:
LC452:
                                                     #ifdef DEBUG
                                      mon("LC452    JSR   LD8DF                   ; C452: BD D8 DF      \n");
                                      #endif // Called from select screen, attract screen 1 + 3 when writing text
    PC = 0xc452; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x55); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc4); 
    clockticks = clockticks + 1; 
    goto LD8DF;
  case 0xC455:
LC455:
                                                     #ifdef DEBUG
                                      mon("LC455    INCA                          ; C455: 4C            \n");
                                      #endif
    PC = 0xc455; 
    INSTRUCTION_START
    val = (UINT8)A; 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$74                    ; C456: 81 74         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x74; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   LC452                   ; C458: 25 F8         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LC452;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$D4                    ; C45A: 86 D4         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xd4; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LD8DF                   ; C45C: BD D8 DF      \n");
                                      #endif // Called from select screen, attract screen 1 + 3 when writing text
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x5f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc4); 
    clockticks = clockticks + 1; 
    goto LD8DF;
  case 0xC45F:
LC45F:
                                                     #ifdef DEBUG
                                      mon("LC45F    LDD   #$6280                  ; C45F: CC 62 80      \n");
                                      #endif
    PC = 0xc45f; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x62; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; C462: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$0B                    ; C464: 86 0B         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x0b; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4AFE                   ; C466: B7 4A FE      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4afe, val); 
  case 0xC469:
LC469:
                                                     #ifdef DEBUG
                                      mon("LC469    LDA   $4AFE                   ; C469: B6 4A FE      \n");
                                      #endif
    PC = 0xc469; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4afe); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC5A4                   ; C46C: BD C5 A4      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x6f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc4); 
    clockticks = clockticks + 1; 
    goto LC5A4;
  case 0xC46F:
LC46F:
                                                     #ifdef DEBUG
                                      mon("LC46F    DEC   $4AFE                   ; C46F: 7A 4A FE      \n");
                                      #endif
    PC = 0xc46f; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4afe); 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    wr_mem(0x4afe, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LC469                   ; C472: 2A F5         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LC469;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   LC690                   ; C474: BD C6 90      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x77); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc4); 
    clockticks = clockticks + 1; 
    goto LC690;
  case 0xC477:
LC477:
                                                     #ifdef DEBUG
                                      mon("LC477    LDA   $4598                   ; C477: B6 45 98      \n");
                                      #endif
    PC = 0xc477; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4598); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$0F                    ; C47A: 84 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x0f; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   locret_C4EA             ; C47C: 27 6C         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LC4EA;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   #$D5                    ; C47E: C6 D5         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xd5; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LE7C7                   ; C480: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x83); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc4); 
    clockticks = clockticks + 1; 
    goto LE7C7;
  case 0xC483:
LC483:
                                                     #ifdef DEBUG
                                      mon("LC483    LDA   <$AC                    ; C483: 96 AC         \n");
                                      #endif
    PC = 0xc483; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xac); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$40                    ; C485: 84 40         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x40; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   locret_C4EA             ; C487: 27 61         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LC4EA;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4598                   ; C489: B6 45 98      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4598); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$08                    ; C48C: 84 08         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x08; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LC498                   ; C48E: 27 08         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LC498;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$01                    ; C490: 86 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x01; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC24E                   ; C492: BD C2 4E      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x95); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc4); 
    clockticks = clockticks + 1; 
    goto LC24E;
  case 0xC495:
LC495:
                                                     #ifdef DEBUG
                                      mon("LC495    JSR   LCC18                   ; C495: BD CC 18      \n");
                                      #endif
    PC = 0xc495; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x98); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc4); 
    clockticks = clockticks + 1; 
    goto LCC18;
  case 0xC498:
LC498:
                                                     #ifdef DEBUG
                                      mon("LC498    LDA   $4598                   ; C498: B6 45 98      \n");
                                      #endif
    PC = 0xc498; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4598); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$04                    ; C49B: 84 04         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x04; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LC4B1                   ; C49D: 27 12         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LC4B1;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   #$454E                  ; C49F: 8E 45 4E      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x454e; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; C4A2: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0xC4A5:
LC4A5:
                                                     #ifdef DEBUG
                                      mon("LC4A5    STD   ,X++                    ; C4A5: ED 81         \n");
                                      #endif
    PC = 0xc4a5; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    X = X + 2; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$458E                  ; C4A7: 8C 45 8E      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x458e; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LC4A5                   ; C4AA: 25 F9         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LC4A5;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$02                    ; C4AC: 86 02         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x02; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC2B3                   ; C4AE: BD C2 B3      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xb1); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc4); 
    clockticks = clockticks + 1; 
    goto LC2B3;
  case 0xC4B1:
LC4B1:
                                                     #ifdef DEBUG
                                      mon("LC4B1    LDA   $4598                   ; C4B1: B6 45 98      \n");
                                      #endif
    PC = 0xc4b1; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4598); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$02                    ; C4B4: 84 02         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x02; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LC4DA                   ; C4B6: 27 22         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LC4DA;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; C4B8: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC24E                   ; C4BA: BD C2 4E      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xbd); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc4); 
    clockticks = clockticks + 1; 
    goto LC24E;
  case 0xC4BD:
LC4BD:
                                                     #ifdef DEBUG
                                      mon("LC4BD    LDX   #unk_C7B6               ; C4BD: 8E C7 B6      \n");
                                      #endif
    PC = 0xc4bd; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0xc7b6; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $0003,X                 ; C4C0: E6 89 00 03   \n");
                                      #endif
    clockticks = clockticks + 8; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0003)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4500                  ; C4C4: 8E 45 00      \n");
                                      #endif // NOVRAM
    clockticks = clockticks + 3; 
    X = 0x4500; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; C4C7: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #$4500                  ; C4C8: CE 45 00      \n");
                                      #endif // NOVRAM
    clockticks = clockticks + 3; 
    U = 0x4500; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   word_C7B7               ; C4CB: F6 C7 B7      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0xc7b7); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STB   $4B02                   ; C4CE: F7 4B 02      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b02, val); 
  case 0xC4D1:
LC4D1:
                                                     #ifdef DEBUG
                                      mon("LC4D1    LDB   ,U+                     ; C4D1: E6 C0         \n");
                                      #endif
    PC = 0xc4d1; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    val = (UINT8)rd_mem(U); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
    U = U + 1; 
                                                     #ifdef DEBUG
                                      mon("         STB   ,X+                     ; C4D3: E7 80         \n");
                                      #endif
    clockticks = clockticks + 6; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, val); 
    X = X + 1; 
                                                     #ifdef DEBUG
                                      mon("         DEC   $4B02                   ; C4D5: 7A 4B 02      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b02); 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    wr_mem(0x4b02, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LC4D1                   ; C4D8: 26 F7         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LC4D1;
    }
  case 0xC4DA:
LC4DA:
                                                     #ifdef DEBUG
                                      mon("LC4DA    LDA   $4598                   ; C4DA: B6 45 98      \n");
                                      #endif
    PC = 0xc4da; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4598); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$01                    ; C4DD: 84 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x01; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LC4E4                   ; C4DF: 27 03         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LC4E4;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   LC5F2                   ; C4E1: BD C5 F2      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xe4); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc4); 
    clockticks = clockticks + 1; 
    goto LC5F2;
  case 0xC4E4:
LC4E4:
                                                     #ifdef DEBUG
                                      mon("LC4E4    LDD   #$00                    ; C4E4: CC 00 00      \n");
                                      #endif
    PC = 0xc4e4; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4598                   ; C4E7: FD 45 98      \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x4598, A); // Care needed with I/O space and word fetches
    wr_mem(0x4599, B); 
    // End of function sub_C450
  case 0xC4EA:
LC4EA:
locret_C4EA:
                                                     #ifdef DEBUG
                                      mon("locret_C4EA RTS                           ; C4EA: 39            \n");
                                      #endif
    PC = 0xc4ea; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xC4EB:
LC4EB:
                                                     #ifdef DEBUG
                                      mon("LC4EB    LDB   <$43                    ; C4EB: D6 43         \n");
                                      #endif // Game over/insert coins timer
    PC = 0xc4eb; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x43); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$0F                    ; C4ED: C4 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x0f; 
    B = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LC519                   ; C4EF: 26 28         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LC519;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   $487F                   ; C4F1: F6 48 7F      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x487f); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$D0                    ; C4F4: C1 D0         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0xd0; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCC   LC519                   ; C4F6: 24 21         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LC519;
    }
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$30                    ; C4F8: C1 30         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x30; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BLS   LC519                   ; C4FA: 23 1D         \n");
                                      #endif
    // temp hack to force a flush
    if ((!Z) || C) {
    clockticks = clockticks + 3; 
    goto LC519;
    }
                                                     #ifdef DEBUG
                                      mon("         TSTB                          ; C4FC: 5D            \n");
                                      #endif
    val = (UINT8)B; 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BMI   LC50C                   ; C4FD: 2B 0D         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LC50C;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   $4AF6                   ; C4FF: F6 4A F6      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4af6); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         DECB                          ; C502: 5A            \n");
                                      #endif
    val = (UINT8)B; 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LC507                   ; C503: 2A 02         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LC507;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   #$0B                    ; C505: C6 0B         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x0b; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xC507:
LC507:
                                                     #ifdef DEBUG
                                      mon("LC507    STB   $4AF6                   ; C507: F7 4A F6      \n");
                                      #endif
    PC = 0xc507; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = B; 
    Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x4af6, val); 
                                                     #ifdef DEBUG
                                      mon("         BRA   LC519                   ; C50A: 20 0D         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LC519;
    
    // ---------------------------------------------------------------------------
  case 0xC50C:
LC50C:
                                                     #ifdef DEBUG
                                      mon("LC50C    LDB   $4AF6                   ; C50C: F6 4A F6      \n");
                                      #endif
    PC = 0xc50c; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4af6); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         INCB                          ; C50F: 5C            \n");
                                      #endif
    val = (UINT8)B; 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$0B                    ; C510: C1 0B         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x0b; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BLS   LC516                   ; C512: 23 02         \n");
                                      #endif
    // temp hack to force a flush
    if ((!Z) || C) {
    clockticks = clockticks + 3; 
    goto LC516;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   #$00                    ; C514: C6 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xC516:
LC516:
                                                     #ifdef DEBUG
                                      mon("LC516    STB   $4AF6                   ; C516: F7 4A F6      \n");
                                      #endif
    PC = 0xc516; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4af6, val); 
  case 0xC519:
LC519:
                                                     #ifdef DEBUG
                                      mon("LC519    LDX   #byte_C797              ; C519: 8E C7 97      \n");
                                      #endif
    PC = 0xc519; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0xc797; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4AF6                   ; C51C: B6 4A F6      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4af6); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   A,X                     ; C51F: E6 86         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + (SINT8)A)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STB   $4AFC                   ; C521: F7 4A FC      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4afc, val); 
                                                     #ifdef DEBUG
                                      mon("         LSRB                          ; C524: 54            \n");
                                      #endif
    val = (UINT8)B; 
 // C = val & 1; 
    val = val >> 1; 
    B = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRB                          ; C525: 54            \n");
                                      #endif
    val = (UINT8)B; 
 // C = val & 1; 
    val = val >> 1; 
    B = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRB                          ; C526: 54            \n");
                                      #endif
    val = (UINT8)B; 
    C = val & 1; 
    val = val >> 1; 
    B = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$03                    ; C527: C4 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x03; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #byte_C737              ; C529: 8E C7 37      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0xc737; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   B,X                     ; C52C: A6 85         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + (SINT8)B)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4AFA                   ; C52E: B7 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4afa, val); 
                                                     #ifdef DEBUG
                                      mon("         LDB   <$AC                    ; C531: D6 AC         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xac); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$80                    ; C533: C4 80         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x80; 
    B = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   locret_C5A3             ; C535: 27 6C         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LC5A3;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   $4AF5                   ; C537: F6 4A F5      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4af5); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         INCB                          ; C53A: 5C            \n");
                                      #endif
    val = (UINT8)B; 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  $4AFA                   ; C53B: F1 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)B; 
    arg = rd_mem(0x4afa); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BLS   LC542                   ; C53E: 23 02         \n");
                                      #endif
    // temp hack to force a flush
    if ((!Z) || C) {
    clockticks = clockticks + 3; 
    goto LC542;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   #$00                    ; C540: C6 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xC542:
LC542:
                                                     #ifdef DEBUG
                                      mon("LC542    STA   $4AF5                   ; C542: B7 4A F5      \n");
                                      #endif
    PC = 0xc542; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4af5, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4AFC                   ; C545: B6 4A FC      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4afc); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ROLA                          ; C548: 49            \n");
                                      #endif
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
    C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLA                          ; C549: 49            \n");
                                      #endif
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
    C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLA                          ; C54A: 49            \n");
                                      #endif
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
    C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLA                          ; C54B: 49            \n");
                                      #endif
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
    C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$07                    ; C54C: 84 07         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x07; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
  case 0xC54E:
LC54E:
                                                     #ifdef DEBUG
                                      mon("LC54E    DECA                          ; C54E: 4A            \n");
                                      #endif
    PC = 0xc54e; 
    INSTRUCTION_START
    val = (UINT8)A; 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BMI   LC557                   ; C54F: 2B 06         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LC557;
    }
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; C551: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASL   $4AFA                   ; C552: 78 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4afa); 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
    Z = res; 
    N = res; 
    V = val ^ res; 
    wr_mem(0x4afa, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LC54E                   ; C555: 20 F7         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LC54E;
    
    // ---------------------------------------------------------------------------
  case 0xC557:
LC557:
                                                     #ifdef DEBUG
                                      mon("LC557    LDA   $4AFC                   ; C557: B6 4A FC      \n");
                                      #endif
    PC = 0xc557; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4afc); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$07                    ; C55A: 84 07         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x07; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLA                          ; C55C: 48            \n");
                                      #endif
    val = (UINT8)A; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4590                  ; C55D: 8E 45 90      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x4590; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LEAX  A,X                     ; C560: 30 86         \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + (SINT8)A); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         LDA   ,X                      ; C562: A6 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(X); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLA                          ; C564: 48            \n");
                                      #endif
    val = (UINT8)A; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLA                          ; C565: 48            \n");
                                      #endif
    val = (UINT8)A; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLA                          ; C566: 48            \n");
                                      #endif
    val = (UINT8)A; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLA                          ; C567: 48            \n");
                                      #endif
    val = (UINT8)A; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4AFB                   ; C568: B7 4A FB      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4afb, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $01,X                   ; C56B: A6 01         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0001)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$0F                    ; C56D: 84 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x0f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDA  $4AFB                   ; C56F: BB 4A FB      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    arg = rd_mem(0x4afb); 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4AFB                   ; C572: B7 4A FB      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4afb, val); 
                                                     #ifdef DEBUG
                                      mon("         EORB  $4AFB                   ; C575: F8 4A FB      \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = B ^ rd_mem(0x4afb); 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  $4AFA                   ; C578: F4 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)B; 
    res = val & rd_mem(0x4afa); 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         EORB  $4AFB                   ; C57B: F8 4A FB      \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = B ^ rd_mem(0x4afb); 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STB   $01,X                   ; C57E: E7 01         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0001); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LSRB                          ; C580: 54            \n");
                                      #endif
    val = (UINT8)B; 
 // C = val & 1; 
    val = val >> 1; 
    B = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRB                          ; C581: 54            \n");
                                      #endif
    val = (UINT8)B; 
 // C = val & 1; 
    val = val >> 1; 
    B = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRB                          ; C582: 54            \n");
                                      #endif
    val = (UINT8)B; 
 // C = val & 1; 
    val = val >> 1; 
    B = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRB                          ; C583: 54            \n");
                                      #endif
    val = (UINT8)B; 
 // C = val & 1; 
    val = val >> 1; 
    B = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STB   ,X                      ; C584: E7 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$03                    ; C586: 86 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x03; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC2B3                   ; C588: BD C2 B3      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x8b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc5); 
    clockticks = clockticks + 1; 
    goto LC2B3;
  case 0xC58B:
LC58B:
                                                     #ifdef DEBUG
                                      mon("LC58B    LDX   #$4500                  ; C58B: 8E 45 00      \n");
                                      #endif // NOVRAM
    PC = 0xc58b; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x4500; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #$4C00                  ; C58E: CE 4C 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x4c00; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0xC591:
LC591:
                                                     #ifdef DEBUG
                                      mon("LC591    LDD   ,X++                    ; C591: EC 81         \n");
                                      #endif
    PC = 0xc591; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
    A = rd_mem(X); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(X+1)); 
    X = X + 2; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,U++                    ; C593: ED C1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    U = U + 2; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$45FF                  ; C595: 8C 45 FF      \n");
                                      #endif // NOVRAM
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x45ff; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LC591                   ; C598: 25 F7         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LC591;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   LC3A7                   ; C59A: BD C3 A7      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x9d); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc5); 
    clockticks = clockticks + 1; 
    goto LC3A7;
  case 0xC59D:
LC59D:
                                                     #ifdef DEBUG
                                      mon("LC59D    LDA   $4AF6                   ; C59D: B6 4A F6      \n");
                                      #endif
    PC = 0xc59d; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4af6); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC5A4                   ; C5A0: BD C5 A4      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xa3); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc5); 
    clockticks = clockticks + 1; 
    goto LC5A4;
    // End of function sub_C4EB
  case 0xC5A3:
LC5A3:
locret_C5A3:
                                                     #ifdef DEBUG
                                      mon("locret_C5A3 RTS                           ; C5A3: 39            \n");
                                      #endif
    PC = 0xc5a3; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xC5A4:
LC5A4:
                                                     #ifdef DEBUG
                                      mon("LC5A4    LDX   #byte_C797              ; C5A4: 8E C7 97      \n");
                                      #endif
    PC = 0xc5a4; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0xc797; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   A,X                     ; C5A7: E6 86         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + (SINT8)A)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STB   $4AFA                   ; C5A9: F7 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4afa, val); 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$07                    ; C5AC: C4 07         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x07; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4590                  ; C5AE: 8E 45 90      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x4590; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; C5B1: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; C5B2: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $4AFA                   ; C5B3: F6 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4afa); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LSRB                          ; C5B6: 54            \n");
                                      #endif
    val = (UINT8)B; 
 // C = val & 1; 
    val = val >> 1; 
    B = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRB                          ; C5B7: 54            \n");
                                      #endif
    val = (UINT8)B; 
 // C = val & 1; 
    val = val >> 1; 
    B = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRB                          ; C5B8: 54            \n");
                                      #endif
    val = (UINT8)B; 
 // C = val & 1; 
    val = val >> 1; 
    B = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STB   $4AFA                   ; C5B9: F7 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4afa, val); 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$03                    ; C5BC: C4 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x03; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #byte_C737              ; C5BE: CE C7 37      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0xc737; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LEAU  B,U                     ; C5C1: 33 C5         \n");
                                      #endif
    clockticks = clockticks + 5; 
    U = (U + (SINT8)B); 
                                                     #ifdef DEBUG
                                      mon("         LDB   $4AFA                   ; C5C3: F6 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4afa); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LSRB                          ; C5C6: 54            \n");
                                      #endif
    val = (UINT8)B; 
 // C = val & 1; 
    val = val >> 1; 
    B = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRB                          ; C5C7: 54            \n");
                                      #endif
    val = (UINT8)B; 
 // C = val & 1; 
    val = val >> 1; 
    B = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STB   $4AFA                   ; C5C8: F7 4A FA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4afa, val); 
                                                     #ifdef DEBUG
                                      mon("         LDB   ,X                      ; C5CB: E6 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(X); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; C5CD: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; C5CE: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; C5CF: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; C5D0: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STB   $4AFB                   ; C5D1: F7 4A FB      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4afb, val); 
                                                     #ifdef DEBUG
                                      mon("         LDB   $01,X                   ; C5D4: E6 01         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0001)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$0F                    ; C5D6: C4 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x0f; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDB  $4AFB                   ; C5D8: FB 4A FB      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)B; 
    arg = rd_mem(0x4afb); 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    B = (UINT8)res; 
  case 0xC5DB:
LC5DB:
                                                     #ifdef DEBUG
                                      mon("LC5DB    DEC   $4AFA                   ; C5DB: 7A 4A FA      \n");
                                      #endif
    PC = 0xc5db; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4afa); 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    wr_mem(0x4afa, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BMI   LC5E3                   ; C5DE: 2B 03         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LC5E3;
    }
                                                     #ifdef DEBUG
                                      mon("         LSRB                          ; C5E0: 54            \n");
                                      #endif
    val = (UINT8)B; 
    C = val & 1; 
    val = val >> 1; 
    B = val; 
    N = 0; 
    Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LC5DB                   ; C5E1: 20 F8         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LC5DB;
    
    // ---------------------------------------------------------------------------
  case 0xC5E3:
LC5E3:
                                                     #ifdef DEBUG
                                      mon("LC5E3    ANDB  ,U                      ; C5E3: E4 C4         \n");
                                      #endif
    PC = 0xc5e3; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)B; 
    res = val & rd_mem(U); 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STB   $4AF5                   ; C5E5: F7 4A F5      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4af5, val); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #byte_C7F1              ; C5E8: 8E C7 F1      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0xc7f1; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LEAX  A,X                     ; C5EB: 30 86         \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + (SINT8)A); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         ADDB  ,X                      ; C5ED: EB 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)B; 
    arg = rd_mem(X); 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
    V = (UINT8)(val ^ arg ^ res ^ C); 
    B = (UINT8)res; 
    // End of function sub_C5A4
                                                     #ifdef DEBUG
                                      mon("         JMP   LE7D3                   ; C5EF: 7E E7 D3      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LE7D3;
    
    // =============== S U B R O U T I N E =======================================
    // FUNCTION CHUNK AT ROM:C65B SIZE 0000001F BYTES
  case 0xC5F2:
LC5F2:
                                                     #ifdef DEBUG
                                      mon("LC5F2    LDX   #$4500                  ; C5F2: 8E 45 00      \n");
                                      #endif // NOVRAM
    PC = 0xc5f2; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x4500; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #$4C00                  ; C5F5: CE 4C 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x4c00; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0xC5F8:
LC5F8:
                                                     #ifdef DEBUG
                                      mon("LC5F8    LDD   ,X++                    ; C5F8: EC 81         \n");
                                      #endif
    PC = 0xc5f8; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
    A = rd_mem(X); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(X+1)); 
    X = X + 2; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,U++                    ; C5FA: ED C1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    U = U + 2; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$4600                  ; C5FC: 8C 46 00      \n");
                                      #endif // NOVRAM
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x4600; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LC5F8                   ; C5FF: 25 F7         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LC5F8;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4500                  ; C601: 8E 45 00      \n");
                                      #endif // NOVRAM
    clockticks = clockticks + 3; 
    X = 0x4500; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xC604:
LC604:
                                                     #ifdef DEBUG
                                      mon("LC604    LDA   ,X                      ; C604: A6 84         \n");
                                      #endif
    PC = 0xc604; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(X); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; C606: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   ,X+                     ; C607: A7 80         \n");
                                      #endif
    clockticks = clockticks + 6; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, val); 
    X = X + 1; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$4600                  ; C609: 8C 46 00      \n");
                                      #endif // NOVRAM
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x4600; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LC604                   ; C60C: 25 F6         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LC604;
    }
                                                     #ifdef DEBUG
                                      mon("         STA   $46A0                   ; C60E: B7 46 A0      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x46a0, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC688                   ; C611: BD C6 88      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x14); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc6); 
    clockticks = clockticks + 1; 
    goto LC688;
  case 0xC614:
LC614:
                                                     #ifdef DEBUG
                                      mon("LC614    JSR   LC67A                   ; C614: BD C6 7A      \n");
                                      #endif
    PC = 0xc614; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x17); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc6); 
    clockticks = clockticks + 1; 
    goto LC67A;
  case 0xC617:
LC617:
                                                     #ifdef DEBUG
                                      mon("LC617    JSR   LC6B8                   ; C617: BD C6 B8      \n");
                                      #endif
    PC = 0xc617; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x1a); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc6); 
    clockticks = clockticks + 1; 
    goto LC6B8;
  case 0xC61A:
LC61A:
                                                     #ifdef DEBUG
                                      mon("LC61A    LDX   #$4500                  ; C61A: 8E 45 00      \n");
                                      #endif // NOVRAM
    PC = 0xc61a; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x4500; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xC61D:
LC61D:
                                                     #ifdef DEBUG
                                      mon("LC61D    LDA   ,X                      ; C61D: A6 84         \n");
                                      #endif
    PC = 0xc61d; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(X); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; C61F: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   ,X+                     ; C620: A7 80         \n");
                                      #endif
    clockticks = clockticks + 6; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, val); 
    X = X + 1; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$4600                  ; C622: 8C 46 00      \n");
                                      #endif // NOVRAM
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x4600; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LC61D                   ; C625: 25 F6         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LC61D;
    }
                                                     #ifdef DEBUG
                                      mon("         STA   $46A0                   ; C627: B7 46 A0      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x46a0, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC688                   ; C62A: BD C6 88      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x2d); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc6); 
    clockticks = clockticks + 1; 
    goto LC688;
  case 0xC62D:
LC62D:
                                                     #ifdef DEBUG
                                      mon("LC62D    JSR   LC641                   ; C62D: BD C6 41      \n");
                                      #endif
    PC = 0xc62d; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x30); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc6); 
    clockticks = clockticks + 1; 
    goto LC641;
  case 0xC630:
LC630:
                                                     #ifdef DEBUG
                                      mon("LC630    BNE   LC65B                   ; C630: 26 29         \n");
                                      #endif
    PC = 0xc630; 
    INSTRUCTION_START
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LC65B;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   LC67A                   ; C632: BD C6 7A      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x35); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc6); 
    clockticks = clockticks + 1; 
    goto LC67A;
  case 0xC635:
LC635:
                                                     #ifdef DEBUG
                                      mon("LC635    JSR   LC6B8                   ; C635: BD C6 B8      \n");
                                      #endif
    PC = 0xc635; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x38); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc6); 
    clockticks = clockticks + 1; 
    goto LC6B8;
  case 0xC638:
LC638:
                                                     #ifdef DEBUG
                                      mon("LC638    JSR   LC641                   ; C638: BD C6 41      \n");
                                      #endif
    PC = 0xc638; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x3b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc6); 
    clockticks = clockticks + 1; 
    goto LC641;
  case 0xC63B:
LC63B:
                                                     #ifdef DEBUG
                                      mon("LC63B    BEQ   locret_C640             ; C63B: 27 03         \n");
                                      #endif
    PC = 0xc63b; 
    INSTRUCTION_START
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LC640;
    }
                                                     #ifdef DEBUG
                                      mon("         JMP   LC65B                   ; C63D: 7E C6 5B      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LC65B;
    
    // ---------------------------------------------------------------------------
    // End of function sub_C5F2
  case 0xC640:
LC640:
locret_C640:
                                                     #ifdef DEBUG
                                      mon("locret_C640 RTS                           ; C640: 39            \n");
                                      #endif
    PC = 0xc640; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xC641:
LC641:
                                                     #ifdef DEBUG
                                      mon("LC641    LDX   #$4500                  ; C641: 8E 45 00      \n");
                                      #endif // NOVRAM
    PC = 0xc641; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x4500; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #$4C00                  ; C644: CE 4C 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x4c00; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0xC647:
LC647:
                                                     #ifdef DEBUG
                                      mon("LC647    LDA   ,X+                     ; C647: A6 80         \n");
                                      #endif
    PC = 0xc647; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    val = (UINT8)rd_mem(X); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
    X = X + 1; 
                                                     #ifdef DEBUG
                                      mon("         EORA  ,U+                     ; C649: A8 C0         \n");
                                      #endif
    clockticks = clockticks + 6; 
    res = A ^ rd_mem(U); 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
    U = U + 1; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$0F                    ; C64B: 84 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x0f; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   locret_C65A             ; C64D: 26 0B         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LC65A;
    }
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$4600                  ; C64F: 8C 46 00      \n");
                                      #endif // NOVRAM
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x4600; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LC647                   ; C652: 25 F3         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LC647;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$01                    ; C654: 86 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x01; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4AF7                   ; C656: B7 4A F7      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4af7, val); 
                                                     #ifdef DEBUG
                                      mon("         CLRA                          ; C659: 4F            \n");
                                      #endif
    A = 0; // SEARCH_ME
    V = 0; 
    Z = 0; 
    N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
    // End of function sub_C641
  case 0xC65A:
LC65A:
locret_C65A:
                                                     #ifdef DEBUG
                                      mon("locret_C65A RTS                           ; C65A: 39            \n");
                                      #endif
    PC = 0xc65a; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
    // START OF FUNCTION CHUNK FOR sub_C5F2
  case 0xC65B:
LC65B:
                                                     #ifdef DEBUG
                                      mon("LC65B    LEAX  -1,X                    ; C65B: 30 1F         \n");
                                      #endif
    PC = 0xc65b; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    X = (X + 0xffff); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         TFR   X,D                     ; C65D: 1F 10         \n");
                                      #endif
    val = X; 
    A = (UINT8)(val >> 8); 
    B = (UINT8)val; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4AF8                   ; C65F: FD 4A F8      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4af8, A); // Care needed with I/O space and word fetches
    wr_mem(0x4af9, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$FF                    ; C662: 86 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xff; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4AF7                   ; C664: B7 4A F7      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4af7, val); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4500                  ; C667: 8E 45 00      \n");
                                      #endif // NOVRAM
    clockticks = clockticks + 3; 
    X = 0x4500; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #$4C00                  ; C66A: CE 4C 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x4c00; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0xC66D:
LC66D:
                                                     #ifdef DEBUG
                                      mon("LC66D    LDD   ,U++                    ; C66D: EC C1         \n");
                                      #endif
    PC = 0xc66d; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
    A = rd_mem(U); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(U+1)); 
    U = U + 2; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,X++                    ; C66F: ED 81         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    X = X + 2; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$4600                  ; C671: 8C 46 00      \n");
                                      #endif // NOVRAM
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x4600; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LC66D                   ; C674: 25 F7         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LC66D;
    }
                                                     #ifdef DEBUG
                                      mon("         TST   $4AF7                   ; C676: 7D 4A F7      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4af7); 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
    // END OF FUNCTION CHUNK FOR sub_C5F2
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; C679: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xC67A:
LC67A:
                                                     #ifdef DEBUG
                                      mon("LC67A    LDX   #$4500                  ; C67A: 8E 45 00      \n");
                                      #endif // NOVRAM
    PC = 0xc67a; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x4500; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; C67D: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0xC680:
LC680:
                                                     #ifdef DEBUG
                                      mon("LC680    STD   ,X++                    ; C680: ED 81         \n");
                                      #endif
    PC = 0xc680; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    X = X + 2; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$4600                  ; C682: 8C 46 00      \n");
                                      #endif // NOVRAM
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x4600; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LC680                   ; C685: 25 F9         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LC680;
    }
    // End of function sub_C67A
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; C687: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xC688:
LC688:
                                                     #ifdef DEBUG
                                      mon("LC688    LDX   #$07D0                  ; C688: 8E 07 D0      \n");
                                      #endif
    PC = 0xc688; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x07d0; 
 // Z = X; 
    N = (X) >> 8; 
    V = 0; 
  case 0xC68B:
LC68B:
                                                     #ifdef DEBUG
                                      mon("LC68B    LEAX  -1,X                    ; C68B: 30 1F         \n");
                                      #endif
    PC = 0xc68b; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    X = (X + 0xffff); 
    Z = X; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LC68B                   ; C68D: 26 FC         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LC68B;
    }
    // End of function sub_C688
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; C68F: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xC690:
LC690:
                                                     #ifdef DEBUG
                                      mon("LC690    LDA   $4AF7                   ; C690: B6 4A F7      \n");
                                      #endif
    PC = 0xc690; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4af7); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   locret_C6B7             ; C693: 27 22         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LC6B7;
    }
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$01                    ; C695: 81 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x01; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   LC69D                   ; C697: 26 04         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LC69D;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   #$9C                    ; C699: C6 9C         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x9c; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LC6B4                   ; C69B: 20 17         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LC6B4;
    
    // ---------------------------------------------------------------------------
  case 0xC69D:
LC69D:
                                                     #ifdef DEBUG
                                      mon("LC69D    LDD   #$1F6A                  ; C69D: CC 1F 6A      \n");
                                      #endif
    PC = 0xc69d; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x1f; 
    B = 0x6a; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; C6A0: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$01A4                  ; C6A2: CC 01 A4      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x01; 
    B = 0xa4; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; C6A5: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4AF9                   ; C6A7: B6 4A F9      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4af9); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Display_Vect_BCD        ; C6AA: BD E7 90      \n");
                                      #endif // Display BCD numbers
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xad); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc6); 
    clockticks = clockticks + 1; 
    goto LE790;
  case 0xC6AD:
LC6AD:
                                                     #ifdef DEBUG
                                      mon("LC6AD    LDD   #$8040                  ; C6AD: CC 80 40      \n");
                                      #endif
    PC = 0xc6ad; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; C6B0: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$9D                    ; C6B2: C6 9D         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x9d; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
  case 0xC6B4:
LC6B4:
                                                     #ifdef DEBUG
                                      mon("LC6B4    JSR   LE7C7                   ; C6B4: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    PC = 0xc6b4; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xb7); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc6); 
    clockticks = clockticks + 1; 
    goto LE7C7;
    // End of function sub_C690
  case 0xC6B7:
LC6B7:
locret_C6B7:
                                                     #ifdef DEBUG
                                      mon("locret_C6B7 RTS                           ; C6B7: 39            \n");
                                      #endif
    PC = 0xc6b7; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xC6B8:
LC6B8:
                                                     #ifdef DEBUG
                                      mon("LC6B8    LDA   #$FF                    ; C6B8: 86 FF         \n");
                                      #endif
    PC = 0xc6b8; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0xff; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4687                   ; C6BA: B7 46 87      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x4687, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   $6005                   ; C6BD: BD 60 05      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xc0); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc6); 
    clockticks = clockticks + 1; 
    PC = 0x6005; 
    JUMP;
  case 0xC6C0:
LC6C0:
                                                     #ifdef DEBUG
                                      mon("LC6C0    LDA   #$00                    ; C6C0: 86 00         \n");
                                      #endif
    PC = 0xc6c0; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4687                   ; C6C2: B7 46 87      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4687, val); 
                                                     #ifdef DEBUG
                                      mon("         LDU   #$00                    ; C6C5: CE 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x0000; 
    Z = U; 
    N = (U) >> 8; 
    V = 0; 
  case 0xC6C8:
LC6C8:
                                                     #ifdef DEBUG
                                      mon("LC6C8    JSR   $6005                   ; C6C8: BD 60 05      \n");
                                      #endif
    PC = 0xc6c8; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xcb); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc6); 
    clockticks = clockticks + 1; 
    PC = 0x6005; 
    JUMP;
  case 0xC6CB:
LC6CB:
                                                     #ifdef DEBUG
                                      mon("LC6CB    LEAU  $01,U                   ; C6CB: 33 41         \n");
                                      #endif
    PC = 0xc6cb; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    U = (U + 0x0001); 
                                                     #ifdef DEBUG
                                      mon("         CMPU  #$20                    ; C6CD: 11 83 00 20   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
    arg = 0x0020; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LC6C8                   ; C6D1: 25 F5         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LC6C8;
    }
    // End of function sub_C6B8
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; C6D3: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Read NOVRAM
    // End of function sub_C6D4
  case 0xC6D4:
LC6D4:
                                                     #ifdef DEBUG
                                      mon("LC6D4    LDU   #$4AFA                  ; C6D4: CE 4A FA      \n");
                                      #endif
    PC = 0xc6d4; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0x4afa; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
    // =============== S U B R O U T I N E =======================================
    // Read NOVRAM
  case 0xC6D7:
LC6D7:
                                                     #ifdef DEBUG
                                      mon("LC6D7    LDA   #$03                    ; C6D7: 86 03         \n");
                                      #endif
    PC = 0xc6d7; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x03; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xC6D9:
LC6D9:
                                                     #ifdef DEBUG
                                      mon("LC6D9    STA   $4B02                   ; C6D9: B7 4B 02      \n");
                                      #endif
    PC = 0xc6d9; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b02, val); 
  case 0xC6DC:
LC6DC:
                                                     #ifdef DEBUG
                                      mon("LC6DC    LDA   ,X+                     ; C6DC: A6 80         \n");
                                      #endif
    PC = 0xc6dc; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    val = (UINT8)rd_mem(X); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
    X = X + 1; 
                                                     #ifdef DEBUG
                                      mon("         ASLA                          ; C6DE: 48            \n");
                                      #endif
    val = (UINT8)A; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLA                          ; C6DF: 48            \n");
                                      #endif
    val = (UINT8)A; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLA                          ; C6E0: 48            \n");
                                      #endif
    val = (UINT8)A; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLA                          ; C6E1: 48            \n");
                                      #endif
    val = (UINT8)A; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   ,U                      ; C6E2: A7 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   ,X+                     ; C6E4: A6 80         \n");
                                      #endif
    clockticks = clockticks + 6; 
    val = (UINT8)rd_mem(X); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
    X = X + 1; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$0F                    ; C6E6: 84 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x0f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDA  ,U                      ; C6E8: AB C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)A; 
    arg = rd_mem(U); 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STA   ,U+                     ; C6EA: A7 C0         \n");
                                      #endif
    clockticks = clockticks + 6; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, val); 
    U = U + 1; 
                                                     #ifdef DEBUG
                                      mon("         DEC   $4B02                   ; C6EC: 7A 4B 02      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b02); 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    wr_mem(0x4b02, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LC6DC                   ; C6EF: 2A EB         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LC6DC;
    }
                                                     #ifdef DEBUG
                                      mon("         LEAX  -8,X                    ; C6F1: 30 18         \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + 0xfff8); 
    Z = X; 
    // End of function sub_C6D7
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; C6F3: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // End of function sub_C6F4
  case 0xC6F4:
LC6F4:
                                                     #ifdef DEBUG
                                      mon("LC6F4    LDU   #$4AFA                  ; C6F4: CE 4A FA      \n");
                                      #endif
    PC = 0xc6f4; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0x4afa; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
    // =============== S U B R O U T I N E =======================================
  case 0xC6F7:
LC6F7:
                                                     #ifdef DEBUG
                                      mon("LC6F7    LDA   #$02                    ; C6F7: 86 02         \n");
                                      #endif
    PC = 0xc6f7; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x02; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xC6F9:
LC6F9:
                                                     #ifdef DEBUG
                                      mon("LC6F9    STA   $4B02                   ; C6F9: B7 4B 02      \n");
                                      #endif
    PC = 0xc6f9; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b02, val); 
  case 0xC6FC:
LC6FC:
                                                     #ifdef DEBUG
                                      mon("LC6FC    LDA   ,U+                     ; C6FC: A6 C0         \n");
                                      #endif
    PC = 0xc6fc; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    val = (UINT8)rd_mem(U); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
    U = U + 1; 
                                                     #ifdef DEBUG
                                      mon("         STA   $01,X                   ; C6FE: A7 01         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0001); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; C700: 44            \n");
                                      #endif
    val = (UINT8)A; 
 // C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; C701: 44            \n");
                                      #endif
    val = (UINT8)A; 
 // C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; C702: 44            \n");
                                      #endif
    val = (UINT8)A; 
 // C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; C703: 44            \n");
                                      #endif
    val = (UINT8)A; 
    C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   ,X++                    ; C704: A7 81         \n");
                                      #endif
    clockticks = clockticks + 7; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, val); 
    X = X + 2; 
  case 0xC706:
LC706:
                                                     #ifdef DEBUG
                                      mon("LC706    DEC   $4B02                   ; C706: 7A 4B 02      \n");
                                      #endif
    PC = 0xc706; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b02); 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    wr_mem(0x4b02, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LC6FC                   ; C709: 2A F1         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LC6FC;
    }
                                                     #ifdef DEBUG
                                      mon("         LEAX  -6,X                    ; C70B: 30 1A         \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + 0xfffa); 
    Z = X; 
    // End of function sub_C6F7
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; C70D: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xC70E:
LC70E:
                                                     #ifdef DEBUG
                                      mon("LC70E    LDB   #$00                    ; C70E: C6 00         \n");
                                      #endif
    PC = 0xc70e; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STB   <$AD                    ; C710: D7 AD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xad; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         TFR   A,B                     ; C712: 1F 89         \n");
                                      #endif
    B = (UINT8)A; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; C714: 44            \n");
                                      #endif
    val = (UINT8)A; 
 // C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; C715: 44            \n");
                                      #endif
    val = (UINT8)A; 
 // C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; C716: 44            \n");
                                      #endif
    val = (UINT8)A; 
 // C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; C717: 44            \n");
                                      #endif
    val = (UINT8)A; 
 // C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$0A                    ; C718: 81 0A         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x0a; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   LC71E                   ; C71A: 25 02         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LC71E;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$09                    ; C71C: 86 09         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x09; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xC71E:
LC71E:
                                                     #ifdef DEBUG
                                      mon("LC71E    JSR   LE7AD                   ; C71E: BD E7 AD      \n");
                                      #endif
    PC = 0xc71e; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x21); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc7); 
    clockticks = clockticks + 1; 
    goto LE7AD;
  case 0xC721:
LC721:
                                                     #ifdef DEBUG
                                      mon("LC721    LDA   #$B8                    ; C721: 86 B8         \n");
                                      #endif
    PC = 0xc721; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0xb8; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   ,Y+                     ; C723: A7 A0         \n");
                                      #endif
    clockticks = clockticks + 6; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, val); 
    Y = Y + 1; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$DF                    ; C725: 86 DF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xdf; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   ,Y+                     ; C727: A7 A0         \n");
                                      #endif
    clockticks = clockticks + 6; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, val); 
    Y = Y + 1; 
                                                     #ifdef DEBUG
                                      mon("         CLRA                          ; C729: 4F            \n");
                                      #endif
    A = 0; // SEARCH_ME
 // V = 0; 
 // Z = 0; 
 // N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$0F                    ; C72A: C4 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x0f; 
    B = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LC734                   ; C72C: 27 06         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LC734;
    }
  case 0xC72E:
LC72E:
                                                     #ifdef DEBUG
                                      mon("LC72E    ADDA  #$04                    ; C72E: 8B 04         \n");
                                      #endif
    PC = 0xc72e; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x04; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         DAA                           ; C730: 19            \n");
                                      #endif
    res = A; 
    msn = res & 0xf0; 
    lsn = res & 0x0f; 
    res = res + (((lsn > 0x09) || (H & 0x10)) ? 0x06 : 0); 
    res = res + ((((UINT8)msn > 0x80U) && ((UINT8)lsn > 0x09U)) || (((UINT8)msn > 0x90U) || (C != 0)) ? 0x60 : 0); 
    C = C | (res & 0x100); 
    res = (UINT8)res; 
    A = res; 
 // N = res; 
 // Z = res; 
 // V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         DECB                          ; C731: 5A            \n");
                                      #endif
    val = (UINT8)B; 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LC72E                   ; C732: 26 FA         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LC72E;
    }
    // End of function sub_C70E
    // ---------------------------------------------------------------------------
  case 0xC734:
LC734:
                                                     #ifdef DEBUG
                                      mon("LC734    JMP   Display_Vect_BCD        ; C734: 7E E7 90      \n");
                                      #endif // Display BCD numbers
    PC = 0xc734; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    goto LE790;
    
                   // FCB   $90                     ; C7B9:  ' ' 90 98          SUBA  <$98 ; 
                   // FCB   $98                     ; C7BA:  ' ' 98 01          EORA  <$01 ; 
    // =============== S U B R O U T I N E =======================================
    // Display high scores
  case 0xC7FD:
LC7FD:
                                                     #ifdef DEBUG
                                      mon("LC7FD    TST   $4AEC                   ; C7FD: 7D 4A EC      \n");
                                      #endif
    PC = 0xc7fd; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4aec); 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BMI   LC811                   ; C800: 2B 0F         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LC811;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$3E                    ; C802: 86 3E         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x3e; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LD8DF                   ; C804: BD D8 DF      \n");
                                      #endif // Called from select screen, attract screen 1 + 3 when writing text
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x07); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc8); 
    clockticks = clockticks + 1; 
    goto LD8DF;
  case 0xC807:
LC807:
                                                     #ifdef DEBUG
                                      mon("LC807    LDD   #$7200                  ; C807: CC 72 00      \n");
                                      #endif
    PC = 0xc807; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x72; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; C80A: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #word_CA64              ; C80C: CC CA 64      \n");
                                      #endif // High scores text position table
    clockticks = clockticks + 3; 
    A = 0xca; 
    B = 0x64; 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LC81E                   ; C80F: 20 0D         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LC81E;
    
    // ---------------------------------------------------------------------------
  case 0xC811:
LC811:
                                                     #ifdef DEBUG
                                      mon("LC811    LDA   #$3F                    ; C811: 86 3F         \n");
                                      #endif
    PC = 0xc811; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x3f; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LD8DF                   ; C813: BD D8 DF      \n");
                                      #endif // Called from select screen, attract screen 1 + 3 when writing text
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x16); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc8); 
    clockticks = clockticks + 1; 
    goto LD8DF;
  case 0xC816:
LC816:
                                                     #ifdef DEBUG
                                      mon("LC816    LDD   #$7140                  ; C816: CC 71 40      \n");
                                      #endif // High scores text size
    PC = 0xc816; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x71; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; C819: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #word_CA78              ; C81B: CC CA 78      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xca; 
    B = 0x78; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0xC81E:
LC81E:
                                                     #ifdef DEBUG
                                      mon("LC81E    STD   $4AF1                   ; C81E: FD 4A F1      \n");
                                      #endif
    PC = 0xc81e; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4af1, A); // Care needed with I/O space and word fetches
    wr_mem(0x4af2, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; C821: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4AEA                   ; C823: B7 4A EA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4aea, val); 
  case 0xC826:
LC826:
                                                     #ifdef DEBUG
                                      mon("LC826    LDU   $4AF1                   ; C826: FE 4A F1      \n");
                                      #endif
    PC = 0xc826; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4af1)<<8; 
    ea = ea | rd_mem(0x4af2); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   ,U                      ; C829: EC C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(U); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(U+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; C82B: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$1F80                  ; C82D: CC 1F 80      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x1f; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; C830: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $4AEA                   ; C832: F6 4A EA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4aea); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; C835: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ADDB  $4AEA                   ; C836: FB 4A EA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)B; 
    arg = rd_mem(0x4aea); 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4AB6                  ; C839: 8E 4A B6      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x4ab6; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; C83C: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         CPX   $4AEC                   ; C83D: BC 4A EC      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4aec)<<8; 
    ea = ea | rd_mem(0x4aed); 
    val = X; 
    arg = ea; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LC847                   ; C840: 26 05         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LC847;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$6780                  ; C842: CC 67 80      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x67; 
    B = 0x80; 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LC84A                   ; C845: 20 03         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LC84A;
    
    // ---------------------------------------------------------------------------
  case 0xC847:
LC847:
                                                     #ifdef DEBUG
                                      mon("LC847    LDD   $4B10                   ; C847: FC 4B 10      \n");
                                      #endif // Attract text colour/intensity for fading
    PC = 0xc847; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x4b10); // Care needed with I/O space and word fetches
    B = rd_mem(0x4b11); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0xC84A:
LC84A:
                                                     #ifdef DEBUG
                                      mon("LC84A    STD   ,Y++                    ; C84A: ED A1         \n");
                                      #endif
    PC = 0xc84a; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$01                    ; C84C: DD 01         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x01; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDU   #$3016                  ; C84E: CE 30 16      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x3016; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         TST   $4AEC                   ; C851: 7D 4A EC      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4aec); 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BMI   LC871                   ; C854: 2B 1B         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LC871;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4AEE                   ; C856: B6 4A EE      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4aee); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$00                    ; C859: 81 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x00; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   LC86D                   ; C85B: 26 10         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LC86D;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4843                   ; C85D: B6 48 43      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4843); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$01                    ; C860: 84 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x01; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LC869                   ; C862: 26 05         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LC869;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $4B10                   ; C864: FC 4B 10      \n");
                                      #endif // Attract text colour/intensity for fading
    clockticks = clockticks + 5; 
    A = rd_mem(0x4b10); // Care needed with I/O space and word fetches
    B = rd_mem(0x4b11); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LC86B                   ; C867: 20 02         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LC86B;
    
    // ---------------------------------------------------------------------------
  case 0xC869:
LC869:
                                                     #ifdef DEBUG
                                      mon("LC869    LDD   <$01                    ; C869: DC 01         \n");
                                      #endif
    PC = 0xc869; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x01); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x02); 
    Z = A|B; 
    N = A; 
    V = 0; 
  case 0xC86B:
LC86B:
                                                     #ifdef DEBUG
                                      mon("LC86B    BRA   LC86F                   ; C86B: 20 02         \n");
                                      #endif
    PC = 0xc86b; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto LC86F;
    
    // ---------------------------------------------------------------------------
  case 0xC86D:
LC86D:
                                                     #ifdef DEBUG
                                      mon("LC86D    LDD   <$01                    ; C86D: DC 01         \n");
                                      #endif
    PC = 0xc86d; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x01); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x02); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0xC86F:
LC86F:
                                                     #ifdef DEBUG
                                      mon("LC86F    STD   ,Y++                    ; C86F: ED A1         \n");
                                      #endif
    PC = 0xc86f; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
  case 0xC871:
LC871:
                                                     #ifdef DEBUG
                                      mon("LC871    LDA   ,X+                     ; C871: A6 80         \n");
                                      #endif
    PC = 0xc871; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    val = (UINT8)rd_mem(X); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    X = X + 1; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LC884                   ; C873: 26 0F         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LC884;
    }
                                                     #ifdef DEBUG
                                      mon("         TST   $4AEC                   ; C875: 7D 4A EC      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4aec); 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BMI   LC87F                   ; C878: 2B 05         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LC87F;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $3054                   ; C87A: FC 30 54      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x3054); // Care needed with I/O space and word fetches
    B = rd_mem(0x3055); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LC882                   ; C87D: 20 03         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LC882;
    
    // ---------------------------------------------------------------------------
  case 0xC87F:
LC87F:
                                                     #ifdef DEBUG
                                      mon("LC87F    LDD   $3002                   ; C87F: FC 30 02      \n");
                                      #endif
    PC = 0xc87f; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x3002); // Care needed with I/O space and word fetches
    B = rd_mem(0x3003); 
    Z = A|B; 
    N = A; 
    V = 0; 
  case 0xC882:
LC882:
                                                     #ifdef DEBUG
                                      mon("LC882    BRA   LC887                   ; C882: 20 03         \n");
                                      #endif
    PC = 0xc882; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto LC887;
    
    // ---------------------------------------------------------------------------
  case 0xC884:
LC884:
                                                     #ifdef DEBUG
                                      mon("LC884    ASLA                          ; C884: 48            \n");
                                      #endif
    PC = 0xc884; 
    INSTRUCTION_START
    val = (UINT8)A; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   A,U                     ; C885: EC C6         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + (SINT8)A); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0xC887:
LC887:
                                                     #ifdef DEBUG
                                      mon("LC887    STD   ,Y++                    ; C887: ED A1         \n");
                                      #endif
    PC = 0xc887; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         TST   $4AEC                   ; C889: 7D 4A EC      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4aec); 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BMI   LC8A9                   ; C88C: 2B 1B         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LC8A9;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4AEE                   ; C88E: B6 4A EE      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4aee); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$01                    ; C891: 81 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x01; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   LC8A5                   ; C893: 26 10         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LC8A5;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4843                   ; C895: B6 48 43      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4843); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$01                    ; C898: 84 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x01; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LC8A1                   ; C89A: 26 05         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LC8A1;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $4B10                   ; C89C: FC 4B 10      \n");
                                      #endif // Attract text colour/intensity for fading
    clockticks = clockticks + 5; 
    A = rd_mem(0x4b10); // Care needed with I/O space and word fetches
    B = rd_mem(0x4b11); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LC8A3                   ; C89F: 20 02         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LC8A3;
    
    // ---------------------------------------------------------------------------
  case 0xC8A1:
LC8A1:
                                                     #ifdef DEBUG
                                      mon("LC8A1    LDD   <$01                    ; C8A1: DC 01         \n");
                                      #endif
    PC = 0xc8a1; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x01); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x02); 
    Z = A|B; 
    N = A; 
    V = 0; 
  case 0xC8A3:
LC8A3:
                                                     #ifdef DEBUG
                                      mon("LC8A3    BRA   LC8A7                   ; C8A3: 20 02         \n");
                                      #endif
    PC = 0xc8a3; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto LC8A7;
    
    // ---------------------------------------------------------------------------
  case 0xC8A5:
LC8A5:
                                                     #ifdef DEBUG
                                      mon("LC8A5    LDD   <$01                    ; C8A5: DC 01         \n");
                                      #endif
    PC = 0xc8a5; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x01); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x02); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0xC8A7:
LC8A7:
                                                     #ifdef DEBUG
                                      mon("LC8A7    STD   ,Y++                    ; C8A7: ED A1         \n");
                                      #endif
    PC = 0xc8a7; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
  case 0xC8A9:
LC8A9:
                                                     #ifdef DEBUG
                                      mon("LC8A9    LDA   ,X+                     ; C8A9: A6 80         \n");
                                      #endif
    PC = 0xc8a9; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    val = (UINT8)rd_mem(X); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    X = X + 1; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LC8BC                   ; C8AB: 26 0F         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LC8BC;
    }
                                                     #ifdef DEBUG
                                      mon("         TST   $4AEC                   ; C8AD: 7D 4A EC      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4aec); 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BMI   LC8B7                   ; C8B0: 2B 05         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LC8B7;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $3054                   ; C8B2: FC 30 54      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x3054); // Care needed with I/O space and word fetches
    B = rd_mem(0x3055); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LC8BA                   ; C8B5: 20 03         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LC8BA;
    
    // ---------------------------------------------------------------------------
  case 0xC8B7:
LC8B7:
                                                     #ifdef DEBUG
                                      mon("LC8B7    LDD   $3002                   ; C8B7: FC 30 02      \n");
                                      #endif
    PC = 0xc8b7; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x3002); // Care needed with I/O space and word fetches
    B = rd_mem(0x3003); 
    Z = A|B; 
    N = A; 
    V = 0; 
  case 0xC8BA:
LC8BA:
                                                     #ifdef DEBUG
                                      mon("LC8BA    BRA   LC8BF                   ; C8BA: 20 03         \n");
                                      #endif
    PC = 0xc8ba; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto LC8BF;
    
    // ---------------------------------------------------------------------------
  case 0xC8BC:
LC8BC:
                                                     #ifdef DEBUG
                                      mon("LC8BC    ASLA                          ; C8BC: 48            \n");
                                      #endif
    PC = 0xc8bc; 
    INSTRUCTION_START
    val = (UINT8)A; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   A,U                     ; C8BD: EC C6         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + (SINT8)A); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0xC8BF:
LC8BF:
                                                     #ifdef DEBUG
                                      mon("LC8BF    STD   ,Y++                    ; C8BF: ED A1         \n");
                                      #endif
    PC = 0xc8bf; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         TST   $4AEC                   ; C8C1: 7D 4A EC      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4aec); 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BMI   LC8E1                   ; C8C4: 2B 1B         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LC8E1;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4AEE                   ; C8C6: B6 4A EE      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4aee); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$02                    ; C8C9: 81 02         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x02; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   LC8DD                   ; C8CB: 26 10         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LC8DD;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4843                   ; C8CD: B6 48 43      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4843); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$01                    ; C8D0: 84 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x01; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LC8D9                   ; C8D2: 26 05         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LC8D9;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $4B10                   ; C8D4: FC 4B 10      \n");
                                      #endif // Attract text colour/intensity for fading
    clockticks = clockticks + 5; 
    A = rd_mem(0x4b10); // Care needed with I/O space and word fetches
    B = rd_mem(0x4b11); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LC8DB                   ; C8D7: 20 02         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LC8DB;
    
    // ---------------------------------------------------------------------------
  case 0xC8D9:
LC8D9:
                                                     #ifdef DEBUG
                                      mon("LC8D9    LDD   <$01                    ; C8D9: DC 01         \n");
                                      #endif
    PC = 0xc8d9; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x01); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x02); 
    Z = A|B; 
    N = A; 
    V = 0; 
  case 0xC8DB:
LC8DB:
                                                     #ifdef DEBUG
                                      mon("LC8DB    BRA   LC8DF                   ; C8DB: 20 02         \n");
                                      #endif
    PC = 0xc8db; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto LC8DF;
    
    // ---------------------------------------------------------------------------
  case 0xC8DD:
LC8DD:
                                                     #ifdef DEBUG
                                      mon("LC8DD    LDD   <$01                    ; C8DD: DC 01         \n");
                                      #endif
    PC = 0xc8dd; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x01); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x02); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0xC8DF:
LC8DF:
                                                     #ifdef DEBUG
                                      mon("LC8DF    STD   ,Y++                    ; C8DF: ED A1         \n");
                                      #endif
    PC = 0xc8df; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
  case 0xC8E1:
LC8E1:
                                                     #ifdef DEBUG
                                      mon("LC8E1    LDA   ,X+                     ; C8E1: A6 80         \n");
                                      #endif
    PC = 0xc8e1; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    val = (UINT8)rd_mem(X); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    X = X + 1; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LC8F4                   ; C8E3: 26 0F         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LC8F4;
    }
                                                     #ifdef DEBUG
                                      mon("         TST   $4AEC                   ; C8E5: 7D 4A EC      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4aec); 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BMI   LC8EF                   ; C8E8: 2B 05         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LC8EF;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $3054                   ; C8EA: FC 30 54      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x3054); // Care needed with I/O space and word fetches
    B = rd_mem(0x3055); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LC8F2                   ; C8ED: 20 03         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LC8F2;
    
    // ---------------------------------------------------------------------------
  case 0xC8EF:
LC8EF:
                                                     #ifdef DEBUG
                                      mon("LC8EF    LDD   $3002                   ; C8EF: FC 30 02      \n");
                                      #endif
    PC = 0xc8ef; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x3002); // Care needed with I/O space and word fetches
    B = rd_mem(0x3003); 
    Z = A|B; 
    N = A; 
    V = 0; 
  case 0xC8F2:
LC8F2:
                                                     #ifdef DEBUG
                                      mon("LC8F2    BRA   LC8F7                   ; C8F2: 20 03         \n");
                                      #endif
    PC = 0xc8f2; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto LC8F7;
    
    // ---------------------------------------------------------------------------
  case 0xC8F4:
LC8F4:
                                                     #ifdef DEBUG
                                      mon("LC8F4    ASLA                          ; C8F4: 48            \n");
                                      #endif
    PC = 0xc8f4; 
    INSTRUCTION_START
    val = (UINT8)A; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   A,U                     ; C8F5: EC C6         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + (SINT8)A); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0xC8F7:
LC8F7:
                                                     #ifdef DEBUG
                                      mon("LC8F7    STD   ,Y++                    ; C8F7: ED A1         \n");
                                      #endif
    PC = 0xc8f7; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$01                    ; C8F9: DC 01         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x01); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x02); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; C8FB: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$8040                  ; C8FD: CC 80 40      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; C900: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDU   $4AF1                   ; C902: FE 4A F1      \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4af1)<<8; 
    ea = ea | rd_mem(0x4af2); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   ,U                      ; C905: EC C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(U); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(U+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; C907: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$1F38                  ; C909: CC 1F 38      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x1f; 
    B = 0x38; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; C90C: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4AEA                   ; C90E: B6 4A EA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4aea); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         INCA                          ; C911: 4C            \n");
                                      #endif
    val = (UINT8)A; 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$0A                    ; C912: 81 0A         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x0a; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   LC918                   ; C914: 25 02         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LC918;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$10                    ; C916: 86 10         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x10; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xC918:
LC918:
                                                     #ifdef DEBUG
                                      mon("LC918    LDB   #$01                    ; C918: C6 01         \n");
                                      #endif
    PC = 0xc918; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x01; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STB   <$AD                    ; C91A: D7 AD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xad; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   Display_Vect_BCD        ; C91C: BD E7 90      \n");
                                      #endif // Display BCD numbers
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x1f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc9); 
    clockticks = clockticks + 1; 
    goto LE790;
  case 0xC91F:
LC91F:
                                                     #ifdef DEBUG
                                      mon("LC91F    LDD   #$B8DC                  ; C91F: CC B8 DC      \n");
                                      #endif
    PC = 0xc91f; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0xb8; 
    B = 0xdc; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; C922: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$8040                  ; C924: CC 80 40      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; C927: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $4AEA                   ; C929: F6 4A EA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4aea); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; C92C: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; C92D: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4A8E                  ; C92E: 8E 4A 8E      \n");
                                      #endif // High scores RAM
    clockticks = clockticks + 3; 
    X = 0x4a8e; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; C931: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         LDU   $4AF1                   ; C932: FE 4A F1      \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4af1)<<8; 
    ea = ea | rd_mem(0x4af2); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   ,U++                    ; C935: EC C1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    A = rd_mem(U); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(U+1)); 
    U = U + 2; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; C937: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$1FF0                  ; C939: CC 1F F0      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x1f; 
    B = 0xf0; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; C93C: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         STU   $4AF1                   ; C93E: FF 4A F1      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    wr_mem(0x4af1, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem(0x4af2, (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$06                    ; C941: C6 06         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x06; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STB   <$AD                    ; C943: D7 AD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xad; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LE764                   ; C945: BD E7 64      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x48); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xc9); 
    clockticks = clockticks + 1; 
    goto LE764;
  case 0xC948:
LC948:
                                                     #ifdef DEBUG
                                      mon("LC948    LEAX  $04,X                   ; C948: 30 04         \n");
                                      #endif
    PC = 0xc948; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    X = (X + 0x0004); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$8040                  ; C94A: CC 80 40      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; C94D: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         INC   $4AEA                   ; C94F: 7C 4A EA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4aea); 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    wr_mem(0x4aea, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4AEA                   ; C952: B6 4A EA      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4aea); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$0A                    ; C955: 81 0A         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x0a; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         LBCS  LC826                   ; C957: 10 25 FE CB   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if (C) {
    clockticks = clockticks + 1; 
    goto LC826;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$7200                  ; C95B: CC 72 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x72; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; C95E: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   $4AEC                   ; C960: FC 4A EC      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x4aec); // Care needed with I/O space and word fetches
    B = rd_mem(0x4aed); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LC966                   ; C963: 2A 01         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LC966;
    }
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; C965: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
  case 0xC966:
LC966:
                                                     #ifdef DEBUG
                                      mon("LC966    LDD   #$6480                  ; C966: CC 64 80      \n");
                                      #endif
    PC = 0xc966; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x64; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; C969: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$CBA8                  ; C96B: 8E CB A8      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0xcba8; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #$3018                  ; C96E: CE 30 18      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x3018; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0xC971:
LC971:
                                                     #ifdef DEBUG
                                      mon("LC971    LDD   $02,X                   ; C971: EC 02         \n");
                                      #endif
    PC = 0xc971; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + 0x0002); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$1F                    ; C973: 84 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x1f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; C975: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   ,X                      ; C977: EC 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(X); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(X+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$1F                    ; C979: 84 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x1f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; C97B: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   ,U++                    ; C97D: EC C1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    A = rd_mem(U); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(U+1)); 
    U = U + 2; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; C97F: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$8040                  ; C981: CC 80 40      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; C984: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LEAX  $04,X                   ; C986: 30 04         \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + 0x0004); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #word_CC10              ; C988: 8C CC 10      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0xcc10; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LC971                   ; C98B: 25 E4         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LC971;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   word_CBA6               ; C98D: FC CB A6      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0xcba6); // Care needed with I/O space and word fetches
    B = rd_mem(0xcba7); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$1F                    ; C990: 84 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x1f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; C992: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   word_CBA4               ; C994: FC CB A4      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0xcba4); // Care needed with I/O space and word fetches
    B = rd_mem(0xcba5); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$1F                    ; C997: 84 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x1f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; C999: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   $3054                   ; C99B: FC 30 54      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x3054); // Care needed with I/O space and word fetches
    B = rd_mem(0x3055); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; C99E: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$7200                  ; C9A0: CC 72 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x72; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; C9A3: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$8040                  ; C9A5: CC 80 40      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; C9A8: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $4AEF                   ; C9AA: F6 4A EF      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4aef); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$1B                    ; C9AD: C1 1B         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x1b; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   LC9B6                   ; C9AF: 26 05         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LC9B6;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$6750                  ; C9B1: CC 67 50      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x67; 
    B = 0x50; 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LC9B9                   ; C9B4: 20 03         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LC9B9;
    
    // ---------------------------------------------------------------------------
  case 0xC9B6:
LC9B6:
                                                     #ifdef DEBUG
                                      mon("LC9B6    LDD   #$6450                  ; C9B6: CC 64 50      \n");
                                      #endif
    PC = 0xc9b6; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x64; 
    B = 0x50; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0xC9B9:
LC9B9:
                                                     #ifdef DEBUG
                                      mon("LC9B9    STD   ,Y++                    ; C9B9: ED A1         \n");
                                      #endif
    PC = 0xc9b9; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   $02,X                   ; C9BB: EC 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + 0x0002); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$1F                    ; C9BD: 84 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x1f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; C9BF: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   ,X                      ; C9C1: EC 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(X); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(X+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$08                    ; C9C3: 83 00 08      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0008; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$1F                    ; C9C6: 84 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x1f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; C9C8: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$71C0                  ; C9CA: CC 71 C0      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x71; 
    B = 0xc0; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; C9CD: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   $303A                   ; C9CF: FC 30 3A      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x303a); // Care needed with I/O space and word fetches
    B = rd_mem(0x303b); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; C9D2: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   $3040                   ; C9D4: FC 30 40      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x3040); // Care needed with I/O space and word fetches
    B = rd_mem(0x3041); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; C9D7: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   $301A                   ; C9D9: FC 30 1A      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x301a); // Care needed with I/O space and word fetches
    B = rd_mem(0x301b); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; C9DC: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$7200                  ; C9DE: CC 72 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x72; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; C9E1: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$8040                  ; C9E3: CC 80 40      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; C9E6: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $4AEF                   ; C9E8: F6 4A EF      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4aef); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$1C                    ; C9EB: C1 1C         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x1c; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   LC9F4                   ; C9ED: 26 05         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LC9F4;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$6750                  ; C9EF: CC 67 50      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x67; 
    B = 0x50; 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LC9F7                   ; C9F2: 20 03         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LC9F7;
    
    // ---------------------------------------------------------------------------
  case 0xC9F4:
LC9F4:
                                                     #ifdef DEBUG
                                      mon("LC9F4    LDD   #$6450                  ; C9F4: CC 64 50      \n");
                                      #endif
    PC = 0xc9f4; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x64; 
    B = 0x50; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0xC9F7:
LC9F7:
                                                     #ifdef DEBUG
                                      mon("LC9F7    STD   ,Y++                    ; C9F7: ED A1         \n");
                                      #endif
    PC = 0xc9f7; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   $06,X                   ; C9F9: EC 06         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + 0x0006); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$1F                    ; C9FB: 84 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x1f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; C9FD: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   $04,X                   ; C9FF: EC 04         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + 0x0004); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$08                    ; CA01: 83 00 08      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0008; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$1F                    ; CA04: 84 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x1f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; CA06: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$71C0                  ; CA08: CC 71 C0      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x71; 
    B = 0xc0; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; CA0B: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   $3020                   ; CA0D: FC 30 20      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x3020); // Care needed with I/O space and word fetches
    B = rd_mem(0x3021); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; CA10: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   $3032                   ; CA12: FC 30 32      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x3032); // Care needed with I/O space and word fetches
    B = rd_mem(0x3033); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; CA15: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   $301E                   ; CA17: FC 30 1E      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x301e); // Care needed with I/O space and word fetches
    B = rd_mem(0x301f); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; CA1A: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$7200                  ; CA1C: CC 72 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x72; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; CA1F: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$8040                  ; CA21: CC 80 40      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; CA24: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$6780                  ; CA26: CC 67 80      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x67; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; CA29: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $4AEF                   ; CA2B: F6 4A EF      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4aef); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$1B                    ; CA2E: C1 1B         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x1b; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCC   LCA5B                   ; CA30: 24 29         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LCA5B;
    }
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; CA32: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; CA33: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #word_CBA4              ; CA34: 8E CB A4      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0xcba4; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; CA37: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         LDD   $02,X                   ; CA38: EC 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + 0x0002); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$1F                    ; CA3A: 84 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x1f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; CA3C: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   ,X                      ; CA3E: EC 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(X); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(X+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$1F                    ; CA40: 84 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x1f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; CA42: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $4AEF                   ; CA44: F6 4A EF      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4aef); 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LCA4E                   ; CA47: 26 05         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LCA4E;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $3054                   ; CA49: FC 30 54      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x3054); // Care needed with I/O space and word fetches
    B = rd_mem(0x3055); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LCA54                   ; CA4C: 20 06         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LCA54;
    
    // ---------------------------------------------------------------------------
  case 0xCA4E:
LCA4E:
                                                     #ifdef DEBUG
                                      mon("LCA4E    ASLB                          ; CA4E: 58            \n");
                                      #endif
    PC = 0xca4e; 
    INSTRUCTION_START
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$3016                  ; CA4F: 8E 30 16      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x3016; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   B,X                     ; CA52: EC 85         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + (SINT8)B); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0xCA54:
LCA54:
                                                     #ifdef DEBUG
                                      mon("LCA54    STD   ,Y++                    ; CA54: ED A1         \n");
                                      #endif
    PC = 0xca54; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$8040                  ; CA56: CC 80 40      \n");
                                      #endif // Vector CNTR instruction
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; CA59: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
  case 0xCA5B:
LCA5B:
                                                     #ifdef DEBUG
                                      mon("LCA5B    LDD   #$6680                  ; CA5B: CC 66 80      \n");
                                      #endif
    PC = 0xca5b; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x66; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; CA5E: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LB6CC                   ; CA60: BD B6 CC      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x63); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xca); 
    clockticks = clockticks + 1; 
    goto LB6CC;
    // End of function sub_C7FD
    // ---------------------------------------------------------------------------
  case 0xCA63:
LCA63:
                                                     #ifdef DEBUG
                                      mon("LCA63    RTS                           ; CA63: 39            \n");
                                      #endif
    PC = 0xca63; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Score
  case 0xCA8C:
LCA8C:
                                                     #ifdef DEBUG
                                      mon("LCA8C    LDX   #$4A8E                  ; CA8C: 8E 4A 8E      \n");
                                      #endif // High scores RAM
    PC = 0xca8c; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x4a8e; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xCA8F:
LCA8F:
                                                     #ifdef DEBUG
                                      mon("LCA8F    LDD   <$5C                    ; CA8F: DC 5C         \n");
                                      #endif // Score millions
    PC = 0xca8f; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x5c); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x5d); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  ,X                      ; CA91: A3 84         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BHI   LCAA5                   ; CA93: 22 10         \n");
                                      #endif
    // temp hack to force a flush
    if (Z && (!C)) {
    clockticks = clockticks + 3; 
    goto LCAA5;
    }
                                                     #ifdef DEBUG
                                      mon("         BNE   LCA9D                   ; CA95: 26 06         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LCA9D;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   <$5E                    ; CA97: DC 5E         \n");
                                      #endif // Score thousands
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x5e); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x5f); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $02,X                   ; CA99: A3 02         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(X + 0x0002))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(X + 0x0002))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BCC   LCAA5                   ; CA9B: 24 08         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LCAA5;
    }
  case 0xCA9D:
LCA9D:
                                                     #ifdef DEBUG
                                      mon("LCA9D    LEAX  $04,X                   ; CA9D: 30 04         \n");
                                      #endif
    PC = 0xca9d; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    X = (X + 0x0004); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$4AB6                  ; CA9F: 8C 4A B6      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x4ab6; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LCA8F                   ; CAA2: 25 EB         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LCA8F;
    }
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; CAA4: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
  case 0xCAA5:
LCAA5:
                                                     #ifdef DEBUG
                                      mon("LCAA5    JSR   LCAB7                   ; CAA5: BD CA B7      \n");
                                      #endif
    PC = 0xcaa5; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xa8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xca); 
    clockticks = clockticks + 1; 
    goto LCAB7;
  case 0xCAA8:
LCAA8:
                                                     #ifdef DEBUG
                                      mon("LCAA8    LDA   #$00                    ; CAA8: 86 00         \n");
                                      #endif
    PC = 0xcaa8; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4AEE                   ; CAAA: B7 4A EE      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4aee, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; CAAD: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4AEF                   ; CAB0: FD 4A EF      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4aef, A); // Care needed with I/O space and word fetches
    wr_mem(0x4af0, B); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4AB6                  ; CAB3: 8E 4A B6      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x4ab6; 
    Z = X; 
    N = (X) >> 8; 
    V = 0; 
    // End of function sub_CA8C
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; CAB6: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xCAB7:
LCAB7:
                                                     #ifdef DEBUG
                                      mon("LCAB7    STX   $4AEC                   ; CAB7: BF 4A EC      \n");
                                      #endif
    PC = 0xcab7; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = X; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    wr_mem(0x4aec, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem(0x4aed, (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         LDU   #$4AD1                  ; CABA: CE 4A D1      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x4ad1; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4AB2                  ; CABD: 8E 4A B2      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x4ab2; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CPX   $4AEC                   ; CAC0: BC 4A EC      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4aec)<<8; 
    ea = ea | rd_mem(0x4aed); 
    val = X; 
    arg = ea; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LCADE                   ; CAC3: 27 19         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LCADE;
    }
  case 0xCAC5:
LCAC5:
                                                     #ifdef DEBUG
                                      mon("LCAC5    LDD   -4,X                    ; CAC5: EC 1C         \n");
                                      #endif
    PC = 0xcac5; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + 0xfffc); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,X                      ; CAC7: ED 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   -2,X                    ; CAC9: EC 1E         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + 0xfffe); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $02,X                   ; CACB: ED 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x0002); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   -3,U                    ; CACD: EC 5D         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0xfffd); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,U                      ; CACF: ED C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   -1,U                    ; CAD1: A6 5F         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(U + 0xffff)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $02,U                   ; CAD3: A7 42         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(U + 0x0002); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LEAU  -3,U                    ; CAD5: 33 5D         \n");
                                      #endif
    clockticks = clockticks + 5; 
    U = (U + 0xfffd); 
                                                     #ifdef DEBUG
                                      mon("         LEAX  -4,X                    ; CAD7: 30 1C         \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + 0xfffc); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         CPX   $4AEC                   ; CAD9: BC 4A EC      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4aec)<<8; 
    ea = ea | rd_mem(0x4aed); 
    val = X; 
    arg = ea; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BHI   LCAC5                   ; CADC: 22 E7         \n");
                                      #endif
    // temp hack to force a flush
    if (Z && (!C)) {
    clockticks = clockticks + 3; 
    goto LCAC5;
    }
  case 0xCADE:
LCADE:
                                                     #ifdef DEBUG
                                      mon("LCADE    STU   $4AEC                   ; CADE: FF 4A EC      \n");
                                      #endif
    PC = 0xcade; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    wr_mem(0x4aec, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem(0x4aed, (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; CAE1: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   ,U                      ; CAE3: A7 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; CAE5: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $01,U                   ; CAE8: ED 41         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0x0001); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$5C                    ; CAEA: DC 5C         \n");
                                      #endif // Score millions
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x5c); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x5d); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,X                      ; CAEC: ED 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$5E                    ; CAEE: DC 5E         \n");
                                      #endif // Score thousands
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x5e); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x5f); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $02,X                   ; CAF0: ED 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = (UINT16)(X + 0x0002); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    // End of function sub_CAB7
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; CAF2: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xCAF3:
LCAF3:
                                                     #ifdef DEBUG
                                      mon("LCAF3    LDX   $4AEC                   ; CAF3: BE 4A EC      \n");
                                      #endif
    PC = 0xcaf3; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4aec)<<8; 
    ea = ea | rd_mem(0x4aed); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $4AEE                   ; CAF6: F6 4A EE      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4aee); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; CAF9: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         TFR   X,U                     ; CAFA: 1F 13         \n");
                                      #endif
    U = X; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4AEE                   ; CAFC: B6 4A EE      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4aee); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$03                    ; CAFF: 81 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x03; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   LCB08                   ; CB01: 25 05         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LCB08;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   #word_CC10              ; CB03: 8E CC 10      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0xcc10; 
    Z = X; 
    N = (X) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LCB0B                   ; CB06: 20 03         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LCB0B;
    
    // ---------------------------------------------------------------------------
  case 0xCB08:
LCB08:
                                                     #ifdef DEBUG
                                      mon("LCB08    LDX   #word_CBA4              ; CB08: 8E CB A4      \n");
                                      #endif
    PC = 0xcb08; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0xcba4; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xCB0B:
LCB0B:
                                                     #ifdef DEBUG
                                      mon("LCB0B    LDD   $4879                   ; CB0B: FC 48 79      \n");
                                      #endif
    PC = 0xcb0b; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x4879); // Care needed with I/O space and word fetches
    B = rd_mem(0x487a); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$08                    ; CB0E: 83 00 08      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0008; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  ,X                      ; CB11: A3 84         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         TSTA                          ; CB13: 4D            \n");
                                      #endif
    val = (UINT8)A; 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LCB1A                   ; CB14: 2A 04         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LCB1A;
    }
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; CB16: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; CB17: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SBCA  #$FF                    ; CB18: 82 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xff; 
    res = val - (UINT8)arg - (C != 0 ? 1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)res; 
  case 0xCB1A:
LCB1A:
                                                     #ifdef DEBUG
                                      mon("LCB1A    STD   <$01                    ; CB1A: DD 01         \n");
                                      #endif
    PC = 0xcb1a; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x01; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$18                    ; CB1C: 10 83 00 18   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x0018; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCC   LCB49                   ; CB20: 24 27         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LCB49;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $487B                   ; CB22: FC 48 7B      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x487b); // Care needed with I/O space and word fetches
    B = rd_mem(0x487c); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$FF8C                  ; CB25: C3 FF 8C      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0xff8c; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $02,X                   ; CB28: A3 02         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(X + 0x0002))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(X + 0x0002))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         TSTA                          ; CB2A: 4D            \n");
                                      #endif
    val = (UINT8)A; 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LCB31                   ; CB2B: 2A 04         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LCB31;
    }
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; CB2D: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; CB2E: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SBCA  #$FF                    ; CB2F: 82 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xff; 
    res = val - (UINT8)arg - (C != 0 ? 1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)res; 
  case 0xCB31:
LCB31:
                                                     #ifdef DEBUG
                                      mon("LCB31    CMPD  #$18                    ; CB31: 10 83 00 18   \n");
                                      #endif
    PC = 0xcb31; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x0018; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCC   LCB49                   ; CB35: 24 12         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LCB49;
    }
                                                     #ifdef DEBUG
                                      mon("         ADDD  <$01                    ; CB37: D3 01         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x01)<<8; 
    ea = ea | rd_mem(DP|0x02); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$20                    ; CB39: 10 83 00 20   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x0020; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCC   LCB49                   ; CB3D: 24 0A         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LCB49;
    }
                                                     #ifdef DEBUG
                                      mon("         TFR   X,D                     ; CB3F: 1F 10         \n");
                                      #endif
    val = X; 
    A = (UINT8)(val >> 8); 
    B = (UINT8)val; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #word_CBA4              ; CB41: 83 CB A4      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0xcba4; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         LSRB                          ; CB44: 54            \n");
                                      #endif
    val = (UINT8)B; 
 // C = val & 1; 
    val = val >> 1; 
    B = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRB                          ; CB45: 54            \n");
                                      #endif
    val = (UINT8)B; 
 // C = val & 1; 
    val = val >> 1; 
    B = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STB   $4AEF                   ; CB46: F7 4A EF      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4aef, val); 
  case 0xCB49:
LCB49:
                                                     #ifdef DEBUG
                                      mon("LCB49    LEAX  $04,X                   ; CB49: 30 04         \n");
                                      #endif
    PC = 0xcb49; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    X = (X + 0x0004); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #LCC18                  ; CB4B: 8C CC 18      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0xcc18; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LCB0B                   ; CB4E: 25 BB         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LCB0B;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4AEF                   ; CB50: B6 4A EF      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4aef); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$1B                    ; CB53: 81 1B         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x1b; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCC   LCB59                   ; CB55: 24 02         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LCB59;
    }
                                                     #ifdef DEBUG
                                      mon("         STA   ,U                      ; CB57: A7 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, val); 
  case 0xCB59:
LCB59:
                                                     #ifdef DEBUG
                                      mon("LCB59    LDA   <$AC                    ; CB59: 96 AC         \n");
                                      #endif
    PC = 0xcb59; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xac); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$F0                    ; CB5B: 84 F0         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0xf0; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   locret_CBA3             ; CB5D: 27 44         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LCBA3;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4AEF                   ; CB5F: B6 4A EF      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4aef); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$1B                    ; CB62: 81 1B         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x1b; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   LCB82                   ; CB64: 26 1C         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LCB82;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4AEE                   ; CB66: B6 4A EE      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4aee); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$02                    ; CB69: 81 02         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x02; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BHI   LCB71                   ; CB6B: 22 04         \n");
                                      #endif
    // temp hack to force a flush
    if (Z && (!C)) {
    clockticks = clockticks + 3; 
    goto LCB71;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; CB6D: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   ,U                      ; CB6F: A7 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, val); 
  case 0xCB71:
LCB71:
                                                     #ifdef DEBUG
                                      mon("LCB71    LDA   $4AEE                   ; CB71: B6 4A EE      \n");
                                      #endif
    PC = 0xcb71; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4aee); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LCB7D                   ; CB74: 27 07         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LCB7D;
    }
                                                     #ifdef DEBUG
                                      mon("         DEC   $4AEE                   ; CB76: 7A 4A EE      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4aee); 
    res = (UINT8)(val - 1); 
 // N = res; 
 // Z = res; 
 // V = val & ~res; 
    wr_mem(0x4aee, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; CB79: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   -1,U                    ; CB7B: A7 5F         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = (UINT16)(U + 0xffff); 
    wr_mem(ea, val); 
  case 0xCB7D:
LCB7D:
                                                     #ifdef DEBUG
                                      mon("LCB7D    JSR   LBDF8                   ; CB7D: BD BD F8      \n");
                                      #endif
    PC = 0xcb7d; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x80); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xcb); 
    clockticks = clockticks + 1; 
    goto LBDF8;
  case 0xCB80:
LCB80:
                                                     #ifdef DEBUG
                                      mon("LCB80    BRA   locret_CBA3             ; CB80: 20 21         \n");
                                      #endif
    PC = 0xcb80; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto LCBA3;
    
    // ---------------------------------------------------------------------------
  case 0xCB82:
LCB82:
                                                     #ifdef DEBUG
                                      mon("LCB82    CMPA  #$1C                    ; CB82: 81 1C         \n");
                                      #endif
    PC = 0xcb82; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x1c; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   LCB91                   ; CB84: 26 0B         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LCB91;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$FFFF                  ; CB86: CC FF FF      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xff; 
    B = 0xff; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4AEC                   ; CB89: FD 4A EC      \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x4aec, A); // Care needed with I/O space and word fetches
    wr_mem(0x4aed, B); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LBDD5                   ; CB8C: BD BD D5      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x8f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xcb); 
    clockticks = clockticks + 1; 
    goto LBDD5;
  case 0xCB8F:
LCB8F:
                                                     #ifdef DEBUG
                                      mon("LCB8F    BRA   locret_CBA3             ; CB8F: 20 12         \n");
                                      #endif
    PC = 0xcb8f; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto LCBA3;
    
    // ---------------------------------------------------------------------------
  case 0xCB91:
LCB91:
                                                     #ifdef DEBUG
                                      mon("LCB91    INC   $4AEE                   ; CB91: 7C 4A EE      \n");
                                      #endif
    PC = 0xcb91; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4aee); 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    wr_mem(0x4aee, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4AEE                   ; CB94: B6 4A EE      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4aee); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$03                    ; CB97: 81 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x03; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   LCBA0                   ; CB99: 25 05         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LCBA0;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$1C                    ; CB9B: 86 1C         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x1c; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4AEF                   ; CB9D: B7 4A EF      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x4aef, val); 
  case 0xCBA0:
LCBA0:
                                                     #ifdef DEBUG
                                      mon("LCBA0    JSR   LBE16                   ; CBA0: BD BE 16      \n");
                                      #endif
    PC = 0xcba0; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xa3); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xcb); 
    clockticks = clockticks + 1; 
    goto LBE16;
    // End of function sub_CAF3
    // ---------------------------------------------------------------------------
  case 0xCBA3:
LCBA3:
locret_CBA3:
                                                     #ifdef DEBUG
                                      mon("locret_CBA3 RTS                           ; CBA3: 39            \n");
                                      #endif
    PC = 0xcba3; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xCC18:
LCC18:
                                                     #ifdef DEBUG
                                      mon("LCC18    JSR   LCC5B                   ; CC18: BD CC 5B      \n");
                                      #endif
    PC = 0xcc18; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x1b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xcc); 
    clockticks = clockticks + 1; 
    goto LCC5B;
  case 0xCC1B:
LCC1B:
                                                     #ifdef DEBUG
                                      mon("LCC1B    LDA   #$01                    ; CC1B: 86 01         \n");
                                      #endif
    PC = 0xcc1b; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x01; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC2C3                   ; CC1D: BD C2 C3      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x20); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xcc); 
    clockticks = clockticks + 1; 
    goto LC2C3;
  case 0xCC20:
LCC20:
                                                     #ifdef DEBUG
                                      mon("LCC20    BNE   LCC38                   ; CC20: 26 16         \n");
                                      #endif
    PC = 0xcc20; 
    INSTRUCTION_START
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LCC38;
    }
                                                     #ifdef DEBUG
                                      mon("         LDU   #$4AB6                  ; CC22: CE 4A B6      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x4ab6; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4520                  ; CC25: 8E 45 20      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x4520; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$08                    ; CC28: 86 08         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x08; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC6D9                   ; CC2A: BD C6 D9      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x2d); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xcc); 
    clockticks = clockticks + 1; 
    goto LC6D9;
  case 0xCC2D:
LCC2D:
                                                     #ifdef DEBUG
                                      mon("LCC2D    LDU   #$4A8E                  ; CC2D: CE 4A 8E      \n");
                                      #endif // High scores RAM
    PC = 0xcc2d; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0x4a8e; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4508                  ; CC30: 8E 45 08      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x4508; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$0B                    ; CC33: 86 0B         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x0b; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC6D9                   ; CC35: BD C6 D9      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x38); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xcc); 
    clockticks = clockticks + 1; 
    goto LC6D9;
  case 0xCC38:
LCC38:
                                                     #ifdef DEBUG
                                      mon("LCC38    LDX   #$4AB6                  ; CC38: 8E 4A B6      \n");
                                      #endif
    PC = 0xcc38; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x4ab6; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xCC3B:
LCC3B:
                                                     #ifdef DEBUG
                                      mon("LCC3B    LDA   ,X+                     ; CC3B: A6 80         \n");
                                      #endif
    PC = 0xcc3b; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    val = (UINT8)rd_mem(X); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
    X = X + 1; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$1B                    ; CC3D: 81 1B         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x1b; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCC   LCC5B                   ; CC3F: 24 1A         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LCC5B;
    }
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$4AD4                  ; CC41: 8C 4A D4      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x4ad4; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LCC3B                   ; CC44: 25 F5         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LCC3B;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4A8E                  ; CC46: 8E 4A 8E      \n");
                                      #endif // High scores RAM
    clockticks = clockticks + 3; 
    X = 0x4a8e; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xCC49:
LCC49:
                                                     #ifdef DEBUG
                                      mon("LCC49    LDA   ,X+                     ; CC49: A6 80         \n");
                                      #endif
    PC = 0xcc49; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    val = (UINT8)rd_mem(X); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
    X = X + 1; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$A0                    ; CC4B: 81 A0         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xa0; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCC   LCC5B                   ; CC4D: 24 0C         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LCC5B;
    }
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$0F                    ; CC4F: 84 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x0f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$0A                    ; CC51: 81 0A         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x0a; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCC   LCC5B                   ; CC53: 24 06         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LCC5B;
    }
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$4AB6                  ; CC55: 8C 4A B6      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x4ab6; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LCC49                   ; CC58: 25 EF         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LCC49;
    }
    // End of function sub_CC18
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; CC5A: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xCC5B:
LCC5B:
                                                     #ifdef DEBUG
                                      mon("LCC5B    LDX   #$4AB6                  ; CC5B: 8E 4A B6      \n");
                                      #endif
    PC = 0xcc5b; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x4ab6; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #word_CC7A              ; CC5E: CE CC 7A      \n");
                                      #endif // High score names
    clockticks = clockticks + 3; 
    U = 0xcc7a; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0xCC61:
LCC61:
                                                     #ifdef DEBUG
                                      mon("LCC61    LDD   ,U++                    ; CC61: EC C1         \n");
                                      #endif
    PC = 0xcc61; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
    A = rd_mem(U); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(U+1)); 
    U = U + 2; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,X++                    ; CC63: ED 81         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    X = X + 2; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$4AD4                  ; CC65: 8C 4A D4      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x4ad4; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LCC61                   ; CC68: 25 F7         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LCC61;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4A8E                  ; CC6A: 8E 4A 8E      \n");
                                      #endif // High scores RAM
    clockticks = clockticks + 3; 
    X = 0x4a8e; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #word_CC98              ; CC6D: CE CC 98      \n");
                                      #endif // High scores init table
    clockticks = clockticks + 3; 
    U = 0xcc98; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0xCC70:
LCC70:
                                                     #ifdef DEBUG
                                      mon("LCC70    LDD   ,U++                    ; CC70: EC C1         \n");
                                      #endif
    PC = 0xcc70; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
    A = rd_mem(U); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(U+1)); 
    U = U + 2; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,X++                    ; CC72: ED 81         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    X = X + 2; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$4AB6                  ; CC74: 8C 4A B6      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x4ab6; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LCC70                   ; CC77: 25 F7         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LCC70;
    }
    // End of function sub_CC5B
    // ---------------------------------------------------------------------------
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; CC79: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Initialise object?
  case 0xCCC0:
LCCC0:
                                                     #ifdef DEBUG
                                      mon("LCCC0    ORCC  #$01                    ; CCC0: 1A 01         \n");
                                      #endif
    PC = 0xccc0; 
    INSTRUCTION_START
    C = 1; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         ROR   $4684                   ; CCC2: 76 46 84      \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = ((UINT8)rd_mem(0x4684)) | ((C != 0) ? 0x100 : 0); 
    C = res & 1; 
    res = (UINT8)(res >> 1); 
    Z = res; 
    N = res; 
    wr_mem(0x4684, res); 
    clockticks = clockticks + 2; 
    PC = 0xccc5; 
    goto bankswitch_check;
  case 0xCCC5:
LCCC5:
                                                     #ifdef DEBUG
                                      mon("LCCC5    JSR   $670D                   ; CCC5: BD 67 0D      \n");
                                      #endif
    PC = 0xccc5; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xc8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xcc); 
    clockticks = clockticks + 1; 
    PC = 0x670d; 
    JUMP;
  case 0xCCC8:
LCCC8:
                                                     #ifdef DEBUG
                                      mon("LCCC8    CLR   $4684                   ; CCC8: 7F 46 84      \n");
                                      #endif
    PC = 0xccc8; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    wr_mem(0x4684, 0); 
    V = 0; 
    Z = 0; 
    N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
    PC = 0xcccb; 
    goto bankswitch_check;
    // End of function sub_CCC0
  case 0xCCCB:
LCCCB:
                                                     #ifdef DEBUG
                                      mon("LCCCB    RTS                           ; CCCB: 39            \n");
                                      #endif
    PC = 0xcccb; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Copy XYZ data to math RAM
  case 0xCCCC:
LCCCC:
                                                     #ifdef DEBUG
                                      mon("LCCCC    ORCC  #$01                    ; CCCC: 1A 01         \n");
                                      #endif
    PC = 0xcccc; 
    INSTRUCTION_START
    C = 1; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         ROR   $4684                   ; CCCE: 76 46 84      \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = ((UINT8)rd_mem(0x4684)) | ((C != 0) ? 0x100 : 0); 
    C = res & 1; 
    res = (UINT8)(res >> 1); 
    Z = res; 
    N = res; 
    wr_mem(0x4684, res); 
    clockticks = clockticks + 2; 
    PC = 0xccd1; 
    goto bankswitch_check;
  case 0xCCD1:
LCCD1:
                                                     #ifdef DEBUG
                                      mon("LCCD1    JSR   $6724                   ; CCD1: BD 67 24      \n");
                                      #endif
    PC = 0xccd1; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xd4); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xcc); 
    clockticks = clockticks + 1; 
    PC = 0x6724; 
    JUMP;
  case 0xCCD4:
LCCD4:
                                                     #ifdef DEBUG
                                      mon("LCCD4    CLR   $4684                   ; CCD4: 7F 46 84      \n");
                                      #endif
    PC = 0xccd4; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    wr_mem(0x4684, 0); 
    V = 0; 
    Z = 0; 
    N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
    PC = 0xccd7; 
    goto bankswitch_check;
    // End of function sub_CCCC
  case 0xCCD7:
LCCD7:
                                                     #ifdef DEBUG
                                      mon("LCCD7    RTS                           ; CCD7: 39            \n");
                                      #endif
    PC = 0xccd7; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Copy object 3D data to math ram
  case 0xCCD8:
LCCD8:
                                                     #ifdef DEBUG
                                      mon("LCCD8    ORCC  #$01                    ; CCD8: 1A 01         \n");
                                      #endif
    PC = 0xccd8; 
    INSTRUCTION_START
    C = 1; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         ROR   $4684                   ; CCDA: 76 46 84      \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = ((UINT8)rd_mem(0x4684)) | ((C != 0) ? 0x100 : 0); 
    C = res & 1; 
    res = (UINT8)(res >> 1); 
    Z = res; 
    N = res; 
    wr_mem(0x4684, res); 
    clockticks = clockticks + 2; 
    PC = 0xccdd; 
    goto bankswitch_check;
  case 0xCCDD:
LCCDD:
                                                     #ifdef DEBUG
                                      mon("LCCDD    JSR   $6726                   ; CCDD: BD 67 26      \n");
                                      #endif
    PC = 0xccdd; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xe0); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xcc); 
    clockticks = clockticks + 1; 
    PC = 0x6726; 
    JUMP;
  case 0xCCE0:
LCCE0:
                                                     #ifdef DEBUG
                                      mon("LCCE0    CLR   $4684                   ; CCE0: 7F 46 84      \n");
                                      #endif
    PC = 0xcce0; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    wr_mem(0x4684, 0); 
    V = 0; 
    Z = 0; 
    N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
    PC = 0xcce3; 
    goto bankswitch_check;
    // End of function sub_CCD8
  case 0xCCE3:
LCCE3:
                                                     #ifdef DEBUG
                                      mon("LCCE3    RTS                           ; CCE3: 39            \n");
                                      #endif
    PC = 0xcce3; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xCCE4:
LCCE4:
                                                     #ifdef DEBUG
                                      mon("LCCE4    ORCC  #$01                    ; CCE4: 1A 01         \n");
                                      #endif
    PC = 0xcce4; 
    INSTRUCTION_START
    C = 1; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         ROR   $4684                   ; CCE6: 76 46 84      \n");
                                      #endif // Change memory page
    clockticks = clockticks + 5; 
    res = ((UINT8)rd_mem(0x4684)) | ((C != 0) ? 0x100 : 0); 
    C = res & 1; 
    res = (UINT8)(res >> 1); 
    Z = res; 
    N = res; 
    wr_mem(0x4684, res); 
    clockticks = clockticks + 2; 
    PC = 0xcce9; 
    goto bankswitch_check;
  case 0xCCE9:
LCCE9:
                                                     #ifdef DEBUG
                                      mon("LCCE9    JSR   $6761                   ; CCE9: BD 67 61      \n");
                                      #endif
    PC = 0xcce9; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xec); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xcc); 
    clockticks = clockticks + 1; 
    PC = 0x6761; 
    JUMP;
  case 0xCCEC:
LCCEC:
                                                     #ifdef DEBUG
                                      mon("LCCEC    CLR   $4684                   ; CCEC: 7F 46 84      \n");
                                      #endif
    PC = 0xccec; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    wr_mem(0x4684, 0); 
    V = 0; 
    Z = 0; 
    N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
    PC = 0xccef; 
    goto bankswitch_check;
    // End of function sub_CCE4
  case 0xCCEF:
LCCEF:
                                                     #ifdef DEBUG
                                      mon("LCCEF    RTS                           ; CCEF: 39            \n");
                                      #endif
    PC = 0xccef; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Get divider result and multiply by Math result Z, insert VCTR instruction
  case 0xCCF0:
LCCF0:
                                                     #ifdef DEBUG
                                      mon("LCCF0    ORCC  #$01                    ; CCF0: 1A 01         \n");
                                      #endif
    PC = 0xccf0; 
    INSTRUCTION_START
    C = 1; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         ROR   $4684                   ; CCF2: 76 46 84      \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = ((UINT8)rd_mem(0x4684)) | ((C != 0) ? 0x100 : 0); 
    C = res & 1; 
    res = (UINT8)(res >> 1); 
    Z = res; 
    N = res; 
    wr_mem(0x4684, res); 
    clockticks = clockticks + 2; 
    PC = 0xccf5; 
    goto bankswitch_check;
  case 0xCCF5:
LCCF5:
                                                     #ifdef DEBUG
                                      mon("LCCF5    JSR   $6761                   ; CCF5: BD 67 61      \n");
                                      #endif
    PC = 0xccf5; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xcc); 
    clockticks = clockticks + 1; 
    PC = 0x6761; 
    JUMP;
  case 0xCCF8:
LCCF8:
                                                     #ifdef DEBUG
                                      mon("LCCF8    CLR   $4684                   ; CCF8: 7F 46 84      \n");
                                      #endif
    PC = 0xccf8; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    wr_mem(0x4684, 0); 
    V = 0; 
    Z = 0; 
    N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
    PC = 0xccfb; 
    goto bankswitch_check;
    // End of function sub_CCF0
  case 0xCCFB:
LCCFB:
                                                     #ifdef DEBUG
                                      mon("LCCFB    RTS                           ; CCFB: 39            \n");
                                      #endif
    PC = 0xccfb; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Trench floor lines calcs
  case 0xCCFC:
LCCFC:
                                                     #ifdef DEBUG
                                      mon("LCCFC    ORCC  #$01                    ; CCFC: 1A 01         \n");
                                      #endif
    PC = 0xccfc; 
    INSTRUCTION_START
    C = 1; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         ROR   $4684                   ; CCFE: 76 46 84      \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = ((UINT8)rd_mem(0x4684)) | ((C != 0) ? 0x100 : 0); 
    C = res & 1; 
    res = (UINT8)(res >> 1); 
    Z = res; 
    N = res; 
    wr_mem(0x4684, res); 
    clockticks = clockticks + 2; 
    PC = 0xcd01; 
    goto bankswitch_check;
  case 0xCD01:
LCD01:
                                                     #ifdef DEBUG
                                      mon("LCD01    JSR   $6782                   ; CD01: BD 67 82      \n");
                                      #endif
    PC = 0xcd01; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x04); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xcd); 
    clockticks = clockticks + 1; 
    PC = 0x6782; 
    JUMP;
  case 0xCD04:
LCD04:
                                                     #ifdef DEBUG
                                      mon("LCD04    CLR   $4684                   ; CD04: 7F 46 84      \n");
                                      #endif
    PC = 0xcd04; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    wr_mem(0x4684, 0); 
    V = 0; 
    Z = 0; 
    N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
    PC = 0xcd07; 
    goto bankswitch_check;
    // End of function sub_CCFC
  case 0xCD07:
LCD07:
                                                     #ifdef DEBUG
                                      mon("LCD07    RTS                           ; CD07: 39            \n");
                                      #endif
    PC = 0xcd07; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Trench side vertical lines calcs
  case 0xCD08:
LCD08:
                                                     #ifdef DEBUG
                                      mon("LCD08    ORCC  #$01                    ; CD08: 1A 01         \n");
                                      #endif
    PC = 0xcd08; 
    INSTRUCTION_START
    C = 1; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         ROR   $4684                   ; CD0A: 76 46 84      \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = ((UINT8)rd_mem(0x4684)) | ((C != 0) ? 0x100 : 0); 
    C = res & 1; 
    res = (UINT8)(res >> 1); 
    Z = res; 
    N = res; 
    wr_mem(0x4684, res); 
    clockticks = clockticks + 2; 
    PC = 0xcd0d; 
    goto bankswitch_check;
  case 0xCD0D:
LCD0D:
                                                     #ifdef DEBUG
                                      mon("LCD0D    JSR   $67AA                   ; CD0D: BD 67 AA      \n");
                                      #endif
    PC = 0xcd0d; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x10); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xcd); 
    clockticks = clockticks + 1; 
    PC = 0x67aa; 
    JUMP;
  case 0xCD10:
LCD10:
                                                     #ifdef DEBUG
                                      mon("LCD10    CLR   $4684                   ; CD10: 7F 46 84      \n");
                                      #endif
    PC = 0xcd10; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    wr_mem(0x4684, 0); 
    V = 0; 
    Z = 0; 
    N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
    PC = 0xcd13; 
    goto bankswitch_check;
    // End of function sub_CD08
  case 0xCD13:
LCD13:
                                                     #ifdef DEBUG
                                      mon("LCD13    RTS                           ; CD13: 39            \n");
                                      #endif
    PC = 0xcd13; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Math program 0x50. Matrix Multiply - Transposed
    // Then do perspective division?
  case 0xCD14:
LCD14:
                                                     #ifdef DEBUG
                                      mon("LCD14    ORCC  #$01                    ; CD14: 1A 01         \n");
                                      #endif
    PC = 0xcd14; 
    INSTRUCTION_START
    C = 1; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         ROR   $4684                   ; CD16: 76 46 84      \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = ((UINT8)rd_mem(0x4684)) | ((C != 0) ? 0x100 : 0); 
    C = res & 1; 
    res = (UINT8)(res >> 1); 
    Z = res; 
    N = res; 
    wr_mem(0x4684, res); 
    clockticks = clockticks + 2; 
    PC = 0xcd19; 
    goto bankswitch_check;
  case 0xCD19:
LCD19:
                                                     #ifdef DEBUG
                                      mon("LCD19    JSR   $67D2                   ; CD19: BD 67 D2      \n");
                                      #endif
    PC = 0xcd19; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x1c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xcd); 
    clockticks = clockticks + 1; 
    PC = 0x67d2; 
    JUMP;
  case 0xCD1C:
LCD1C:
                                                     #ifdef DEBUG
                                      mon("LCD1C    CLR   $4684                   ; CD1C: 7F 46 84      \n");
                                      #endif
    PC = 0xcd1c; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    wr_mem(0x4684, 0); 
    V = 0; 
    Z = 0; 
    N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
    PC = 0xcd1f; 
    goto bankswitch_check;
    // End of function sub_CD14
  case 0xCD1F:
LCD1F:
                                                     #ifdef DEBUG
                                      mon("LCD1F    RTS                           ; CD1F: 39            \n");
                                      #endif
    PC = 0xcd1f; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Do 3D object transform using Matrix 1
  case 0xCD20:
LCD20:
                                                     #ifdef DEBUG
                                      mon("LCD20    ORCC  #$01                    ; CD20: 1A 01         \n");
                                      #endif
    PC = 0xcd20; 
    INSTRUCTION_START
    C = 1; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         ROR   $4684                   ; CD22: 76 46 84      \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = ((UINT8)rd_mem(0x4684)) | ((C != 0) ? 0x100 : 0); 
    C = res & 1; 
    res = (UINT8)(res >> 1); 
    Z = res; 
    N = res; 
    wr_mem(0x4684, res); 
    clockticks = clockticks + 2; 
    PC = 0xcd25; 
    goto bankswitch_check;
  case 0xCD25:
LCD25:
                                                     #ifdef DEBUG
                                      mon("LCD25    JSR   $67D4                   ; CD25: BD 67 D4      \n");
                                      #endif
    PC = 0xcd25; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x28); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xcd); 
    clockticks = clockticks + 1; 
    PC = 0x67d4; 
    JUMP;
  case 0xCD28:
LCD28:
                                                     #ifdef DEBUG
                                      mon("LCD28    CLR   $4684                   ; CD28: 7F 46 84      \n");
                                      #endif
    PC = 0xcd28; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    wr_mem(0x4684, 0); 
    V = 0; 
    Z = 0; 
    N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
    PC = 0xcd2b; 
    goto bankswitch_check;
    // End of function sub_CD20
  case 0xCD2B:
LCD2B:
                                                     #ifdef DEBUG
                                      mon("LCD2B    RTS                           ; CD2B: 39            \n");
                                      #endif
    PC = 0xcd2b; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Format vectors for ties, and tower/bunker explosions
  case 0xCD2C:
LCD2C:
                                                     #ifdef DEBUG
                                      mon("LCD2C    ORCC  #$01                    ; CD2C: 1A 01         \n");
                                      #endif
    PC = 0xcd2c; 
    INSTRUCTION_START
    C = 1; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         ROR   $4684                   ; CD2E: 76 46 84      \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = ((UINT8)rd_mem(0x4684)) | ((C != 0) ? 0x100 : 0); 
    C = res & 1; 
    res = (UINT8)(res >> 1); 
    Z = res; 
    N = res; 
    wr_mem(0x4684, res); 
    clockticks = clockticks + 2; 
    PC = 0xcd31; 
    goto bankswitch_check;
  case 0xCD31:
LCD31:
                                                     #ifdef DEBUG
                                      mon("LCD31    JSR   $6819                   ; CD31: BD 68 19      \n");
                                      #endif
    PC = 0xcd31; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x34); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xcd); 
    clockticks = clockticks + 1; 
    PC = 0x6819; 
    JUMP;
  case 0xCD34:
LCD34:
                                                     #ifdef DEBUG
                                      mon("LCD34    CLR   $4684                   ; CD34: 7F 46 84      \n");
                                      #endif
    PC = 0xcd34; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    wr_mem(0x4684, 0); 
    V = 0; 
    Z = 0; 
    N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
    PC = 0xcd37; 
    goto bankswitch_check;
    // End of function sub_CD2C
  case 0xCD37:
LCD37:
                                                     #ifdef DEBUG
                                      mon("LCD37    RTS                           ; CD37: 39            \n");
                                      #endif
    PC = 0xcd37; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Trench left side turret calcs
  case 0xCD38:
LCD38:
                                                     #ifdef DEBUG
                                      mon("LCD38    ORCC  #$01                    ; CD38: 1A 01         \n");
                                      #endif
    PC = 0xcd38; 
    INSTRUCTION_START
    C = 1; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         ROR   $4684                   ; CD3A: 76 46 84      \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = ((UINT8)rd_mem(0x4684)) | ((C != 0) ? 0x100 : 0); 
    C = res & 1; 
    res = (UINT8)(res >> 1); 
    Z = res; 
    N = res; 
    wr_mem(0x4684, res); 
    clockticks = clockticks + 2; 
    PC = 0xcd3d; 
    goto bankswitch_check;
  case 0xCD3D:
LCD3D:
                                                     #ifdef DEBUG
                                      mon("LCD3D    JSR   $6864                   ; CD3D: BD 68 64      \n");
                                      #endif
    PC = 0xcd3d; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x40); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xcd); 
    clockticks = clockticks + 1; 
    PC = 0x6864; 
    JUMP;
  case 0xCD40:
LCD40:
                                                     #ifdef DEBUG
                                      mon("LCD40    CLR   $4684                   ; CD40: 7F 46 84      \n");
                                      #endif
    PC = 0xcd40; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    wr_mem(0x4684, 0); 
    V = 0; 
    Z = 0; 
    N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
    PC = 0xcd43; 
    goto bankswitch_check;
    // End of function sub_CD38
  case 0xCD43:
LCD43:
                                                     #ifdef DEBUG
                                      mon("LCD43    RTS                           ; CD43: 39            \n");
                                      #endif
    PC = 0xcd43; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Trench right side turret calcs
  case 0xCD44:
LCD44:
                                                     #ifdef DEBUG
                                      mon("LCD44    ORCC  #$01                    ; CD44: 1A 01         \n");
                                      #endif
    PC = 0xcd44; 
    INSTRUCTION_START
    C = 1; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         ROR   $4684                   ; CD46: 76 46 84      \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = ((UINT8)rd_mem(0x4684)) | ((C != 0) ? 0x100 : 0); 
    C = res & 1; 
    res = (UINT8)(res >> 1); 
    Z = res; 
    N = res; 
    wr_mem(0x4684, res); 
    clockticks = clockticks + 2; 
    PC = 0xcd49; 
    goto bankswitch_check;
  case 0xCD49:
LCD49:
                                                     #ifdef DEBUG
                                      mon("LCD49    JSR   $68C7                   ; CD49: BD 68 C7      \n");
                                      #endif
    PC = 0xcd49; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x4c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xcd); 
    clockticks = clockticks + 1; 
    PC = 0x68c7; 
    JUMP;
  case 0xCD4C:
LCD4C:
                                                     #ifdef DEBUG
                                      mon("LCD4C    CLR   $4684                   ; CD4C: 7F 46 84      \n");
                                      #endif
    PC = 0xcd4c; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    wr_mem(0x4684, 0); 
    V = 0; 
    Z = 0; 
    N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
    PC = 0xcd4f; 
    goto bankswitch_check;
    // End of function sub_CD44
  case 0xCD4F:
LCD4F:
                                                     #ifdef DEBUG
                                      mon("LCD4F    RTS                           ; CD4F: 39            \n");
                                      #endif
    PC = 0xcd4f; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xCD50:
LCD50:
                                                     #ifdef DEBUG
                                      mon("LCD50    ORCC  #$01                    ; CD50: 1A 01         \n");
                                      #endif // Called during towers
    PC = 0xcd50; 
    INSTRUCTION_START
    C = 1; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         ROR   $4684                   ; CD52: 76 46 84      \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = ((UINT8)rd_mem(0x4684)) | ((C != 0) ? 0x100 : 0); 
    C = res & 1; 
    res = (UINT8)(res >> 1); 
    Z = res; 
    N = res; 
    wr_mem(0x4684, res); 
    clockticks = clockticks + 2; 
    PC = 0xcd55; 
    goto bankswitch_check;
  case 0xCD55:
LCD55:
                                                     #ifdef DEBUG
                                      mon("LCD55    JSR   $692D                   ; CD55: BD 69 2D      \n");
                                      #endif
    PC = 0xcd55; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x58); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xcd); 
    clockticks = clockticks + 1; 
    PC = 0x692d; 
    JUMP;
  case 0xCD58:
LCD58:
                                                     #ifdef DEBUG
                                      mon("LCD58    CLR   $4684                   ; CD58: 7F 46 84      \n");
                                      #endif
    PC = 0xcd58; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    wr_mem(0x4684, 0); 
    V = 0; 
    Z = 0; 
    N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
    PC = 0xcd5b; 
    goto bankswitch_check;
    // End of function sub_CD50
  case 0xCD5B:
LCD5B:
                                                     #ifdef DEBUG
                                      mon("LCD5B    RTS                           ; CD5B: 39            \n");
                                      #endif
    PC = 0xcd5b; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Trench calcs
  case 0xCD5C:
LCD5C:
                                                     #ifdef DEBUG
                                      mon("LCD5C    ORCC  #$01                    ; CD5C: 1A 01         \n");
                                      #endif // Called during trench start
    PC = 0xcd5c; 
    INSTRUCTION_START
    C = 1; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         ROR   $4684                   ; CD5E: 76 46 84      \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = ((UINT8)rd_mem(0x4684)) | ((C != 0) ? 0x100 : 0); 
    C = res & 1; 
    res = (UINT8)(res >> 1); 
    Z = res; 
    N = res; 
    wr_mem(0x4684, res); 
    clockticks = clockticks + 2; 
    PC = 0xcd61; 
    goto bankswitch_check;
  case 0xCD61:
LCD61:
                                                     #ifdef DEBUG
                                      mon("LCD61    JSR   $6978                   ; CD61: BD 69 78      \n");
                                      #endif
    PC = 0xcd61; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x64); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xcd); 
    clockticks = clockticks + 1; 
    PC = 0x6978; 
    JUMP;
  case 0xCD64:
LCD64:
                                                     #ifdef DEBUG
                                      mon("LCD64    CLR   $4684                   ; CD64: 7F 46 84      \n");
                                      #endif
    PC = 0xcd64; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    wr_mem(0x4684, 0); 
    V = 0; 
    Z = 0; 
    N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
    PC = 0xcd67; 
    goto bankswitch_check;
    // End of function sub_CD5C
  case 0xCD67:
LCD67:
                                                     #ifdef DEBUG
                                      mon("LCD67    RTS                           ; CD67: 39            \n");
                                      #endif
    PC = 0xcd67; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xCD68:
LCD68:
                                                     #ifdef DEBUG
                                      mon("LCD68    ORCC  #$01                    ; CD68: 1A 01         \n");
                                      #endif // Called during towers
    PC = 0xcd68; 
    INSTRUCTION_START
    C = 1; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         ROR   $4684                   ; CD6A: 76 46 84      \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = ((UINT8)rd_mem(0x4684)) | ((C != 0) ? 0x100 : 0); 
    C = res & 1; 
    res = (UINT8)(res >> 1); 
    Z = res; 
    N = res; 
    wr_mem(0x4684, res); 
    clockticks = clockticks + 2; 
    PC = 0xcd6d; 
    goto bankswitch_check;
  case 0xCD6D:
LCD6D:
                                                     #ifdef DEBUG
                                      mon("LCD6D    JSR   $6A0C                   ; CD6D: BD 6A 0C      \n");
                                      #endif
    PC = 0xcd6d; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x70); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xcd); 
    clockticks = clockticks + 1; 
    PC = 0x6a0c; 
    JUMP;
  case 0xCD70:
LCD70:
                                                     #ifdef DEBUG
                                      mon("LCD70    CLR   $4684                   ; CD70: 7F 46 84      \n");
                                      #endif
    PC = 0xcd70; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    wr_mem(0x4684, 0); 
    V = 0; 
    Z = 0; 
    N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
    PC = 0xcd73; 
    goto bankswitch_check;
    // End of function sub_CD68
  case 0xCD73:
LCD73:
                                                     #ifdef DEBUG
                                      mon("LCD73    RTS                           ; CD73: 39            \n");
                                      #endif
    PC = 0xcd73; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Function select for an object
  case 0xCD74:
LCD74:
                                                     #ifdef DEBUG
                                      mon("LCD74    ORCC  #$01                    ; CD74: 1A 01         \n");
                                      #endif
    PC = 0xcd74; 
    INSTRUCTION_START
    C = 1; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         ROR   $4684                   ; CD76: 76 46 84      \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = ((UINT8)rd_mem(0x4684)) | ((C != 0) ? 0x100 : 0); 
    C = res & 1; 
    res = (UINT8)(res >> 1); 
    Z = res; 
    N = res; 
    wr_mem(0x4684, res); 
    clockticks = clockticks + 2; 
    PC = 0xcd79; 
    goto bankswitch_check;
  case 0xCD79:
LCD79:
                                                     #ifdef DEBUG
                                      mon("LCD79    JSR   $6AA0                   ; CD79: BD 6A A0      \n");
                                      #endif
    PC = 0xcd79; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x7c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xcd); 
    clockticks = clockticks + 1; 
    PC = 0x6aa0; 
    JUMP;
  case 0xCD7C:
LCD7C:
                                                     #ifdef DEBUG
                                      mon("LCD7C    CLR   $4684                   ; CD7C: 7F 46 84      \n");
                                      #endif
    PC = 0xcd7c; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    wr_mem(0x4684, 0); 
    V = 0; 
    Z = 0; 
    N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
    PC = 0xcd7f; 
    goto bankswitch_check;
    // End of function sub_CD74
  case 0xCD7F:
LCD7F:
                                                     #ifdef DEBUG
                                      mon("LCD7F    RTS                           ; CD7F: 39            \n");
                                      #endif
    PC = 0xcd7f; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Starfield
  case 0xCD80:
LCD80:
                                                     #ifdef DEBUG
                                      mon("LCD80    ORCC  #$01                    ; CD80: 1A 01         \n");
                                      #endif // Starfield attract screen 1 + 3 + 4
    PC = 0xcd80; 
    INSTRUCTION_START
    C = 1; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         ROR   $4684                   ; CD82: 76 46 84      \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = ((UINT8)rd_mem(0x4684)) | ((C != 0) ? 0x100 : 0); 
    C = res & 1; 
    res = (UINT8)(res >> 1); 
    Z = res; 
    N = res; 
    wr_mem(0x4684, res); 
    clockticks = clockticks + 2; 
    PC = 0xcd85; 
    goto bankswitch_check;
  case 0xCD85:
LCD85:
                                                     #ifdef DEBUG
                                      mon("LCD85    JSR   $7D9A                   ; CD85: BD 7D 9A      \n");
                                      #endif
    PC = 0xcd85; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x88); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xcd); 
    clockticks = clockticks + 1; 
    PC = 0x7d9a; 
    JUMP;
  case 0xCD88:
LCD88:
                                                     #ifdef DEBUG
                                      mon("LCD88    CLR   $4684                   ; CD88: 7F 46 84      \n");
                                      #endif
    PC = 0xcd88; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    wr_mem(0x4684, 0); 
    V = 0; 
    Z = 0; 
    N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
    PC = 0xcd8b; 
    goto bankswitch_check;
    // End of function sub_CD80
  case 0xCD8B:
LCD8B:
                                                     #ifdef DEBUG
                                      mon("LCD8B    RTS                           ; CD8B: 39            \n");
                                      #endif
    PC = 0xcd8b; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Towers surface dots
  case 0xCD8C:
LCD8C:
                                                     #ifdef DEBUG
                                      mon("LCD8C    ORCC  #$01                    ; CD8C: 1A 01         \n");
                                      #endif
    PC = 0xcd8c; 
    INSTRUCTION_START
    C = 1; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         ROR   $4684                   ; CD8E: 76 46 84      \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = ((UINT8)rd_mem(0x4684)) | ((C != 0) ? 0x100 : 0); 
    C = res & 1; 
    res = (UINT8)(res >> 1); 
    Z = res; 
    N = res; 
    wr_mem(0x4684, res); 
    clockticks = clockticks + 2; 
    PC = 0xcd91; 
    goto bankswitch_check;
  case 0xCD91:
LCD91:
                                                     #ifdef DEBUG
                                      mon("LCD91    JSR   $7EAF                   ; CD91: BD 7E AF      \n");
                                      #endif
    PC = 0xcd91; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x94); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xcd); 
    clockticks = clockticks + 1; 
    PC = 0x7eaf; 
    JUMP;
  case 0xCD94:
LCD94:
                                                     #ifdef DEBUG
                                      mon("LCD94    CLR   $4684                   ; CD94: 7F 46 84      \n");
                                      #endif
    PC = 0xcd94; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    wr_mem(0x4684, 0); 
    V = 0; 
    Z = 0; 
    N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
    PC = 0xcd97; 
    goto bankswitch_check;
    // End of function sub_CD8C
  case 0xCD97:
LCD97:
                                                     #ifdef DEBUG
                                      mon("LCD97    RTS                           ; CD97: 39            \n");
                                      #endif
    PC = 0xcd97; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Unused
  case 0xCD98:
LCD98:
                                                     #ifdef DEBUG
                                      mon("LCD98    ASRA                          ; CD98: 47            \n");
                                      #endif
    PC = 0xcd98; 
    INSTRUCTION_START
    val = (UINT8)A; 
    C = val & 1; 
    val = (UINT8)((SINT8)val >> 1); 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         RORB                          ; CD99: 56            \n");
                                      #endif
    res = ((UINT8)B) | ((C != 0) ? 0x100 : 0); 
 // C = res & 1; 
    res = (UINT8)(res >> 1); 
 // Z = res; 
 // N = res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASRA                          ; CD9A: 47            \n");
                                      #endif
    val = (UINT8)A; 
    C = val & 1; 
    val = (UINT8)((SINT8)val >> 1); 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
    // End of function sub_CD98
                                                     #ifdef DEBUG
                                      mon("         RORB                          ; CD9B: 56            \n");
                                      #endif
    res = ((UINT8)B) | ((C != 0) ? 0x100 : 0); 
 // C = res & 1; 
    res = (UINT8)(res >> 1); 
 // Z = res; 
 // N = res; 
    B = res; 
    clockticks = clockticks + 2; 
    // =============== S U B R O U T I N E =======================================
    // Shift D register right
  case 0xCD9C:
LCD9C:
Shift_D_R_6:
                                                     #ifdef DEBUG
                                      mon("Shift_D_R_6 ASRA                          ; CD9C: 47            \n");
                                      #endif
    PC = 0xcd9c; 
    INSTRUCTION_START
    val = (UINT8)A; 
    C = val & 1; 
    val = (UINT8)((SINT8)val >> 1); 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
    // End of function Shift_D_R_6
                                                     #ifdef DEBUG
                                      mon("         RORB                          ; CD9D: 56            \n");
                                      #endif
    res = ((UINT8)B) | ((C != 0) ? 0x100 : 0); 
 // C = res & 1; 
    res = (UINT8)(res >> 1); 
 // Z = res; 
 // N = res; 
    B = res; 
    clockticks = clockticks + 2; 
    // =============== S U B R O U T I N E =======================================
    // Shift D register right
  case 0xCD9E:
LCD9E:
Shift_D_R_5:
                                                     #ifdef DEBUG
                                      mon("Shift_D_R_5 ASRA                          ; CD9E: 47            \n");
                                      #endif
    PC = 0xcd9e; 
    INSTRUCTION_START
    val = (UINT8)A; 
    C = val & 1; 
    val = (UINT8)((SINT8)val >> 1); 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         RORB                          ; CD9F: 56            \n");
                                      #endif
    res = ((UINT8)B) | ((C != 0) ? 0x100 : 0); 
 // C = res & 1; 
    res = (UINT8)(res >> 1); 
 // Z = res; 
 // N = res; 
    B = res; 
    clockticks = clockticks + 2; 
  case 0xCDA0:
LCDA0:
Shift_D_R_4:
                                                     #ifdef DEBUG
                                      mon("Shift_D_R_4 ASRA                          ; CDA0: 47            \n");
                                      #endif
    PC = 0xcda0; 
    INSTRUCTION_START
    val = (UINT8)A; 
    C = val & 1; 
    val = (UINT8)((SINT8)val >> 1); 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         RORB                          ; CDA1: 56            \n");
                                      #endif
    res = ((UINT8)B) | ((C != 0) ? 0x100 : 0); 
 // C = res & 1; 
    res = (UINT8)(res >> 1); 
 // Z = res; 
 // N = res; 
    B = res; 
    clockticks = clockticks + 2; 
  case 0xCDA2:
LCDA2:
Shift_D_R_3:
                                                     #ifdef DEBUG
                                      mon("Shift_D_R_3 ASRA                          ; CDA2: 47            \n");
                                      #endif
    PC = 0xcda2; 
    INSTRUCTION_START
    val = (UINT8)A; 
    C = val & 1; 
    val = (UINT8)((SINT8)val >> 1); 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         RORB                          ; CDA3: 56            \n");
                                      #endif
    res = ((UINT8)B) | ((C != 0) ? 0x100 : 0); 
 // C = res & 1; 
    res = (UINT8)(res >> 1); 
 // Z = res; 
 // N = res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASRA                          ; CDA4: 47            \n");
                                      #endif
    val = (UINT8)A; 
    C = val & 1; 
    val = (UINT8)((SINT8)val >> 1); 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         RORB                          ; CDA5: 56            \n");
                                      #endif
    res = ((UINT8)B) | ((C != 0) ? 0x100 : 0); 
 // C = res & 1; 
    res = (UINT8)(res >> 1); 
 // Z = res; 
 // N = res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASRA                          ; CDA6: 47            \n");
                                      #endif
    val = (UINT8)A; 
    C = val & 1; 
    val = (UINT8)((SINT8)val >> 1); 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         RORB                          ; CDA7: 56            \n");
                                      #endif
    res = ((UINT8)B) | ((C != 0) ? 0x100 : 0); 
    C = res & 1; 
    res = (UINT8)(res >> 1); 
    Z = res; 
    N = res; 
    B = res; 
    clockticks = clockticks + 2; 
    // End of function Shift_D_R_5
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; CDA8: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Shift D register left
  case 0xCDA9:
LCDA9:
                                                     #ifdef DEBUG
                                      mon("LCDA9    ASLB                          ; CDA9: 58            \n");
                                      #endif
    PC = 0xcda9; 
    INSTRUCTION_START
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
    // End of function sub_CDA9
                                                     #ifdef DEBUG
                                      mon("         ROLA                          ; CDAA: 49            \n");
                                      #endif
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
    // =============== S U B R O U T I N E =======================================
  case 0xCDAB:
LCDAB:
Shift_D_L_7:
                                                     #ifdef DEBUG
                                      mon("Shift_D_L_7 ASLB                          ; CDAB: 58            \n");
                                      #endif
    PC = 0xcdab; 
    INSTRUCTION_START
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLA                          ; CDAC: 49            \n");
                                      #endif
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; CDAD: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLA                          ; CDAE: 49            \n");
                                      #endif
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; CDAF: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLA                          ; CDB0: 49            \n");
                                      #endif
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
  case 0xCDB1:
LCDB1:
Shift_D_L_4:
                                                     #ifdef DEBUG
                                      mon("Shift_D_L_4 ASLB                          ; CDB1: 58            \n");
                                      #endif
    PC = 0xcdb1; 
    INSTRUCTION_START
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLA                          ; CDB2: 49            \n");
                                      #endif
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; CDB3: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLA                          ; CDB4: 49            \n");
                                      #endif
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
  case 0xCDB5:
LCDB5:
Shift_D_L_2:
                                                     #ifdef DEBUG
                                      mon("Shift_D_L_2 ASLB                          ; CDB5: 58            \n");
                                      #endif
    PC = 0xcdb5; 
    INSTRUCTION_START
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLA                          ; CDB6: 49            \n");
                                      #endif
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; CDB7: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLA                          ; CDB8: 49            \n");
                                      #endif
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
    // End of function Shift_D_L_7
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; CDB9: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Do math program run
  case 0xCDBA:
LCDBA:
                                                     #ifdef DEBUG
                                      mon("LCDBA    STA   $4700                   ; CDBA: B7 47 00      \n");
                                      #endif
    PC = 0xcdba; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4700, val); 
  case 0xCDBD:
LCDBD:
Math_Wait_Til_Halt:
                                                     #ifdef DEBUG
                                      mon("Math_Wait_Til_Halt TST   $4320                   ; CDBD: 7D 43 20      \n");
                                      #endif
    PC = 0xcdbd; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4320); 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BMI   Math_Wait_Til_Halt      ; CDC0: 2B FB         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LCDBD;
    }
    // End of function Math_Run_Start
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; CDC2: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Initialise math registers matrix
  case 0xCDC3:
LCDC3:
                                                     #ifdef DEBUG
                                      mon("LCDC3    LDD   #$00                    ; CDC3: CC 00 00      \n");
                                      #endif
    PC = 0xcdc3; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   -10,U                   ; CDC6: ED 56         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0xfff6); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   -2,U                    ; CDC8: ED 5E         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0xfffe); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $06,U                   ; CDCA: ED 46         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0x0006); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $08,U                   ; CDCC: ED 48         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0x0008); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $0A,U                   ; CDCE: ED 4A         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0x000a); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $0C,U                   ; CDD0: ED 4C         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0x000c); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   -14,U                   ; CDD2: ED 52         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0xfff2); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   -12,U                   ; CDD4: ED 54         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0xfff4); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   -8,U                    ; CDD6: ED 58         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0xfff8); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   -4,U                    ; CDD8: ED 5C         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0xfffc); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   ,U                      ; CDDA: ED C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $02,U                   ; CDDC: ED 42         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0x0002); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$40                    ; CDDE: 86 40         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x40; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   -16,U                   ; CDE0: ED 50         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0xfff0); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   -6,U                    ; CDE2: ED 5A         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0xfffa); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $04,U                   ; CDE4: ED 44         \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = (UINT16)(U + 0x0004); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    // End of function sub_CDC3
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; CDE6: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Swap Matrix 2  x, y, z to  x, y, z
  case 0xCDE7:
LCDE7:
                                                     #ifdef DEBUG
                                      mon("LCDE7    LDD   $502A                   ; CDE7: FC 50 2A      \n");
                                      #endif // Ay2
    PC = 0xcde7; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x502a); // Care needed with I/O space and word fetches
    B = rd_mem(0x502b); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   $5030                   ; CDEA: FE 50 30      \n");
                                      #endif // Bx2
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5030)<<8; 
    ea = ea | rd_mem(0x5031); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5030                   ; CDED: FD 50 30      \n");
                                      #endif // Bx2
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5030, A); // Care needed with I/O space and word fetches
    wr_mem(0x5031, B); 
                                                     #ifdef DEBUG
                                      mon("         STU   $502A                   ; CDF0: FF 50 2A      \n");
                                      #endif // Ay2
    clockticks = clockticks + 5; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    wr_mem(0x502a, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem(0x502b, (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $502C                   ; CDF3: FC 50 2C      \n");
                                      #endif // Az2
    clockticks = clockticks + 5; 
    A = rd_mem(0x502c); // Care needed with I/O space and word fetches
    B = rd_mem(0x502d); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   $5038                   ; CDF6: FE 50 38      \n");
                                      #endif // Cx2
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5038)<<8; 
    ea = ea | rd_mem(0x5039); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5038                   ; CDF9: FD 50 38      \n");
                                      #endif // Cx2
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5038, A); // Care needed with I/O space and word fetches
    wr_mem(0x5039, B); 
                                                     #ifdef DEBUG
                                      mon("         STU   $502C                   ; CDFC: FF 50 2C      \n");
                                      #endif // Az2
    clockticks = clockticks + 5; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    wr_mem(0x502c, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem(0x502d, (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $5034                   ; CDFF: FC 50 34      \n");
                                      #endif // Bz2
    clockticks = clockticks + 5; 
    A = rd_mem(0x5034); // Care needed with I/O space and word fetches
    B = rd_mem(0x5035); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   $503A                   ; CE02: FE 50 3A      \n");
                                      #endif // Cy2
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x503a)<<8; 
    ea = ea | rd_mem(0x503b); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $503A                   ; CE05: FD 50 3A      \n");
                                      #endif // Cy2
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x503a, A); // Care needed with I/O space and word fetches
    wr_mem(0x503b, B); 
                                                     #ifdef DEBUG
                                      mon("         STU   $5034                   ; CE08: FF 50 34      \n");
                                      #endif // Bz2
    clockticks = clockticks + 5; 
    val = U; 
    Z = val; 
    N = (UINT8)(val >> 8); 
    V = 0; 
    wr_mem(0x5034, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem(0x5035, (UINT8)val); 
    // End of function sub_CDE7
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; CE0B: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Copy transform data from [BIC] to matrix 2
  case 0xCE0C:
LCE0C:
                                                     #ifdef DEBUG
                                      mon("LCE0C    STA   $4702                   ; CE0C: B7 47 02      \n");
                                      #endif
    PC = 0xce0c; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4702, val); 
                                                     #ifdef DEBUG
                                      mon("         CLR   $4701                   ; CE0F: 7F 47 01      \n");
                                      #endif
    clockticks = clockticks + 5; 
    wr_mem(0x4701, 0); 
 // V = 0; 
 // Z = 0; 
 // N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$77                    ; CE12: 86 77         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x77; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCDBA                   ; CE14: BD CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x17); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xce); 
    clockticks = clockticks + 1; 
    goto LCDBA;
    // End of function sub_CE0C
  case 0xCE17:
LCE17:
                                                     #ifdef DEBUG
                                      mon("LCE17    RTS                           ; CE17: 39            \n");
                                      #endif
    PC = 0xce17; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Run math program $80 Copy [BIC] to Matrix 3
  case 0xCE18:
LCE18:
                                                     #ifdef DEBUG
                                      mon("LCE18    STA   $4702                   ; CE18: B7 47 02      \n");
                                      #endif
    PC = 0xce18; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4702, val); 
                                                     #ifdef DEBUG
                                      mon("         CLR   $4701                   ; CE1B: 7F 47 01      \n");
                                      #endif
    clockticks = clockticks + 5; 
    wr_mem(0x4701, 0); 
 // V = 0; 
 // Z = 0; 
 // N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$80                    ; CE1E: 86 80         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x80; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LCDBA                   ; CE20: BD CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x23); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xce); 
    clockticks = clockticks + 1; 
    goto LCDBA;
    // End of function sub_CE18
  case 0xCE23:
LCE23:
                                                     #ifdef DEBUG
                                      mon("LCE23    RTS                           ; CE23: 39            \n");
                                      #endif
    PC = 0xce23; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Run math program $00 Roll on Matrix 4
  case 0xCE24:
LCE24:
                                                     #ifdef DEBUG
                                      mon("LCE24    LDD   #$10                    ; CE24: CC 00 10      \n");
                                      #endif
    PC = 0xce24; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x10; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4701                   ; CE27: FD 47 01      \n");
                                      #endif // Point BIC to $5080 MReg40 Matrix 4
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4701, A); // Care needed with I/O space and word fetches
    wr_mem(0x4702, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; CE2A: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function sub_CE24
                                                     #ifdef DEBUG
                                      mon("         JMP   LCDBA                   ; CE2C: 7E CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 4; 
    goto LCDBA;
    
    // =============== S U B R O U T I N E =======================================
    // Run math program $0E Pitch on Matrix 4
  case 0xCE2F:
LCE2F:
                                                     #ifdef DEBUG
                                      mon("LCE2F    LDD   #$10                    ; CE2F: CC 00 10      \n");
                                      #endif
    PC = 0xce2f; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x10; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4701                   ; CE32: FD 47 01      \n");
                                      #endif // Point BIC to $5080 MReg40 Matrix 4
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4701, A); // Care needed with I/O space and word fetches
    wr_mem(0x4702, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$0E                    ; CE35: 86 0E         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x0e; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function sub_CE2F
                                                     #ifdef DEBUG
                                      mon("         JMP   LCDBA                   ; CE37: 7E CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 4; 
    goto LCDBA;
    
    // =============== S U B R O U T I N E =======================================
    // Run math program $1C Yaw on Matrix 4
  case 0xCE3A:
LCE3A:
                                                     #ifdef DEBUG
                                      mon("LCE3A    LDD   #$10                    ; CE3A: CC 00 10      \n");
                                      #endif
    PC = 0xce3a; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x10; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4701                   ; CE3D: FD 47 01      \n");
                                      #endif // Point BIC to $5080 MReg40 Matrix 4
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4701, A); // Care needed with I/O space and word fetches
    wr_mem(0x4702, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$1C                    ; CE40: 86 1C         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x1c; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function sub_CE3A
                                                     #ifdef DEBUG
                                      mon("         JMP   LCDBA                   ; CE42: 7E CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 4; 
    goto LCDBA;
    
    // =============== S U B R O U T I N E =======================================
    // Update random numbers
  case 0xCE45:
LCE45:
Gen_Random:
                                                     #ifdef DEBUG
                                      mon("Gen_Random LDD   <$53                    ; CE45: DC 53         \n");
                                      #endif
    PC = 0xce45; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x53); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x54); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$54                    ; CE47: DD 54         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x54; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4703                   ; CE49: B6 47 03      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$53                    ; CE4C: 97 53         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0x53; 
    wr_mem(ea, val); 
    // End of function Gen_Random
    // ---------------------------------------------------------------------------
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; CE4E: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xD660:
LD660:
                                                     #ifdef DEBUG
                                      mon("LD660    JSR   LD68D                   ; D660: BD D6 8D      \n");
                                      #endif // Point U to vector RAM $38
    PC = 0xd660; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x63); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xd6); 
    clockticks = clockticks + 1; 
    goto LD68D;
  case 0xD663:
LD663:
                                                     #ifdef DEBUG
                                      mon("LD663    JSR   LD690                   ; D663: BD D6 90      \n");
                                      #endif // Animate laser target hit
    PC = 0xd663; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x66); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xd6); 
    clockticks = clockticks + 1; 
    goto LD690;
  case 0xD666:
LD666:
                                                     #ifdef DEBUG
                                      mon("LD666    LDD   #$C000                  ; D666: CC C0 00      \n");
                                      #endif // Vector RTSL instruction
    PC = 0xd666; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0xc0; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,U++                    ; D669: ED C1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    U = U + 2; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LD6A0                   ; D66B: BD D6 A0      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x6e); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xd6); 
    clockticks = clockticks + 1; 
    goto LD6A0;
  case 0xD66E:
LD66E:
                                                     #ifdef DEBUG
                                      mon("LD66E    JSR   LD6A3                   ; D66E: BD D6 A3      \n");
                                      #endif
    PC = 0xd66e; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x71); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xd6); 
    clockticks = clockticks + 1; 
    goto LD6A3;
  case 0xD671:
LD671:
                                                     #ifdef DEBUG
                                      mon("LD671    LDD   #$C000                  ; D671: CC C0 00      \n");
                                      #endif
    PC = 0xd671; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0xc0; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,U++                    ; D674: ED C1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    U = U + 2; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LD6BC                   ; D676: BD D6 BC      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x79); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xd6); 
    clockticks = clockticks + 1; 
    goto LD6BC;
  case 0xD679:
LD679:
                                                     #ifdef DEBUG
                                      mon("LD679    JSR   LD6BF                   ; D679: BD D6 BF      \n");
                                      #endif
    PC = 0xd679; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x7c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xd6); 
    clockticks = clockticks + 1; 
    goto LD6BF;
  case 0xD67C:
LD67C:
                                                     #ifdef DEBUG
                                      mon("LD67C    LDD   #$C000                  ; D67C: CC C0 00      \n");
                                      #endif
    PC = 0xd67c; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0xc0; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,U++                    ; D67F: ED C1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    U = U + 2; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LD6E7                   ; D681: BD D6 E7      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x84); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xd6); 
    clockticks = clockticks + 1; 
    goto LD6E7;
  case 0xD684:
LD684:
                                                     #ifdef DEBUG
                                      mon("LD684    JSR   LD6EA                   ; D684: BD D6 EA      \n");
                                      #endif
    PC = 0xd684; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x87); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xd6); 
    clockticks = clockticks + 1; 
    goto LD6EA;
  case 0xD687:
LD687:
                                                     #ifdef DEBUG
                                      mon("LD687    LDD   #$C000                  ; D687: CC C0 00      \n");
                                      #endif
    PC = 0xd687; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0xc0; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,U++                    ; D68A: ED C1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = U; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    U = U + 2; 
    // End of function sub_D660
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; D68C: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Point U to vector RAM $38
    // End of function sub_D68D
  case 0xD68D:
LD68D:
                                                     #ifdef DEBUG
                                      mon("LD68D    LDU   #$38                    ; D68D: CE 00 38      \n");
                                      #endif
    PC = 0xd68d; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0x0038; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
    // =============== S U B R O U T I N E =======================================
    // Animate laser target hit
  case 0xD690:
LD690:
                                                     #ifdef DEBUG
                                      mon("LD690    JSR   LD709                   ; D690: BD D7 09      \n");
                                      #endif // Laser target animation
    PC = 0xd690; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x93); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xd6); 
    clockticks = clockticks + 1; 
    goto LD709;
  case 0xD693:
LD693:
                                                     #ifdef DEBUG
                                      mon("LD693    LDD   ,X++                    ; D693: EC 81         \n");
                                      #endif
    PC = 0xd693; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
    A = rd_mem(X); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(X+1)); 
    X = X + 2; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,U++                    ; D695: ED C1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    U = U + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   ,X++                    ; D697: EC 81         \n");
                                      #endif
    clockticks = clockticks + 7; 
    A = rd_mem(X); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(X+1)); 
    X = X + 2; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,U++                    ; D699: ED C1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    U = U + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   ,X                      ; D69B: EC 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(X); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(X+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,U++                    ; D69D: ED C1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = U; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    U = U + 2; 
    // End of function sub_D690
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; D69F: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // End of function sub_D6A0
  case 0xD6A0:
LD6A0:
                                                     #ifdef DEBUG
                                      mon("LD6A0    LDU   #$46                    ; D6A0: CE 00 46      \n");
                                      #endif
    PC = 0xd6a0; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0x0046; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
    // =============== S U B R O U T I N E =======================================
  case 0xD6A3:
LD6A3:
                                                     #ifdef DEBUG
                                      mon("LD6A3    JSR   LD709                   ; D6A3: BD D7 09      \n");
                                      #endif // Laser target animation
    PC = 0xd6a3; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xa6); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xd6); 
    clockticks = clockticks + 1; 
    goto LD709;
  case 0xD6A6:
LD6A6:
                                                     #ifdef DEBUG
                                      mon("LD6A6    LDD   ,X++                    ; D6A6: EC 81         \n");
                                      #endif
    PC = 0xd6a6; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
    A = rd_mem(X); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(X+1)); 
    X = X + 2; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; D6A8: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
 // C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$1F                    ; D6A9: C4 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x1f; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,U++                    ; D6AB: ED C1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    U = U + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   ,X++                    ; D6AD: EC 81         \n");
                                      #endif
    clockticks = clockticks + 7; 
    A = rd_mem(X); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(X+1)); 
    X = X + 2; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; D6AF: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
 // C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ORB   #$E0                    ; D6B0: CA E0         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = B | (UINT8)0xe0; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,U++                    ; D6B2: ED C1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    U = U + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   ,X                      ; D6B4: EC 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(X); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(X+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; D6B6: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$1F                    ; D6B7: C4 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x1f; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,U++                    ; D6B9: ED C1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = U; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    U = U + 2; 
    // End of function sub_D6A3
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; D6BB: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // End of function sub_D6BC
  case 0xD6BC:
LD6BC:
                                                     #ifdef DEBUG
                                      mon("LD6BC    LDU   #$54                    ; D6BC: CE 00 54      \n");
                                      #endif
    PC = 0xd6bc; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0x0054; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
    // =============== S U B R O U T I N E =======================================
  case 0xD6BF:
LD6BF:
                                                     #ifdef DEBUG
                                      mon("LD6BF    JSR   LD709                   ; D6BF: BD D7 09      \n");
                                      #endif // Laser target animation
    PC = 0xd6bf; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xc2); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xd6); 
    clockticks = clockticks + 1; 
    goto LD709;
  case 0xD6C2:
LD6C2:
                                                     #ifdef DEBUG
                                      mon("LD6C2    LDD   ,X++                    ; D6C2: EC 81         \n");
                                      #endif
    PC = 0xd6c2; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
    A = rd_mem(X); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(X+1)); 
    X = X + 2; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         NEGA                          ; D6C4: 40            \n");
                                      #endif
    val = (UINT8)A; 
    res = -val; 
 // V = val & (UINT8)res; 
 // C = res & 0x100; 
    val = (UINT8)res; 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$1F                    ; D6C5: 84 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x1f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORA   #$40                    ; D6C7: 8A 40         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A | (UINT8)0x40; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; D6C9: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
 // C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$1F                    ; D6CA: C4 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x1f; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,U++                    ; D6CC: ED C1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    U = U + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   ,X++                    ; D6CE: EC 81         \n");
                                      #endif
    clockticks = clockticks + 7; 
    A = rd_mem(X); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(X+1)); 
    X = X + 2; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         NEGA                          ; D6D0: 40            \n");
                                      #endif
    val = (UINT8)A; 
    res = -val; 
 // V = val & (UINT8)res; 
 // C = res & 0x100; 
    val = (UINT8)res; 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$1F                    ; D6D1: 84 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x1f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORA   #$40                    ; D6D3: 8A 40         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A | (UINT8)0x40; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; D6D5: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
 // C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ORB   #$E0                    ; D6D6: CA E0         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = B | (UINT8)0xe0; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,U++                    ; D6D8: ED C1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    U = U + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   ,X                      ; D6DA: EC 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(X); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(X+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         NEGA                          ; D6DC: 40            \n");
                                      #endif
    val = (UINT8)A; 
    res = -val; 
 // V = val & (UINT8)res; 
 // C = res & 0x100; 
    val = (UINT8)res; 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$1F                    ; D6DD: 84 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x1f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORA   #$40                    ; D6DF: 8A 40         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A | (UINT8)0x40; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; D6E1: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$1F                    ; D6E2: C4 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x1f; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,U++                    ; D6E4: ED C1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = U; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    U = U + 2; 
    // End of function sub_D6BF
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; D6E6: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // End of function sub_D6E7
  case 0xD6E7:
LD6E7:
                                                     #ifdef DEBUG
                                      mon("LD6E7    LDU   #$62                    ; D6E7: CE 00 62      \n");
                                      #endif
    PC = 0xd6e7; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0x0062; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
    // =============== S U B R O U T I N E =======================================
  case 0xD6EA:
LD6EA:
                                                     #ifdef DEBUG
                                      mon("LD6EA    JSR   LD709                   ; D6EA: BD D7 09      \n");
                                      #endif // Laser target animation
    PC = 0xd6ea; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xed); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xd6); 
    clockticks = clockticks + 1; 
    goto LD709;
  case 0xD6ED:
LD6ED:
                                                     #ifdef DEBUG
                                      mon("LD6ED    LDD   ,X++                    ; D6ED: EC 81         \n");
                                      #endif
    PC = 0xd6ed; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
    A = rd_mem(X); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(X+1)); 
    X = X + 2; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         NEGA                          ; D6EF: 40            \n");
                                      #endif
    val = (UINT8)A; 
    res = -val; 
 // V = val & (UINT8)res; 
 // C = res & 0x100; 
    val = (UINT8)res; 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$1F                    ; D6F0: 84 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x1f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORA   #$40                    ; D6F2: 8A 40         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A | (UINT8)0x40; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,U++                    ; D6F4: ED C1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    U = U + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   ,X++                    ; D6F6: EC 81         \n");
                                      #endif
    clockticks = clockticks + 7; 
    A = rd_mem(X); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(X+1)); 
    X = X + 2; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         NEGA                          ; D6F8: 40            \n");
                                      #endif
    val = (UINT8)A; 
    res = -val; 
 // V = val & (UINT8)res; 
 // C = res & 0x100; 
    val = (UINT8)res; 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$1F                    ; D6F9: 84 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x1f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORA   #$40                    ; D6FB: 8A 40         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A | (UINT8)0x40; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,U++                    ; D6FD: ED C1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    U = U + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   ,X                      ; D6FF: EC 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(X); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(X+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         NEGA                          ; D701: 40            \n");
                                      #endif
    val = (UINT8)A; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$1F                    ; D702: 84 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x1f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORA   #$40                    ; D704: 8A 40         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A | (UINT8)0x40; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,U++                    ; D706: ED C1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = U; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    U = U + 2; 
    // End of function sub_D6EA
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; D708: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Laser target animation
  case 0xD709:
LD709:
                                                     #ifdef DEBUG
                                      mon("LD709    LDA   $4703                   ; D709: B6 47 03      \n");
                                      #endif // Get random number
    PC = 0xd709; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$0F                    ; D70C: 84 0F         \n");
                                      #endif // Mask 0-15
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x0f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$06                    ; D70E: C6 06         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x06; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         MUL                           ; D710: 3D            \n");
                                      #endif // Multiply by 6 for 0- 90 range
    res = (UINT16)(A * B); 
 // Z = res; 
    C = res & 0x80; 
    A = res >> 8; 
    B = (UINT8)res; 
    clockticks = clockticks + 11; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #word_D716              ; D711: 8E D7 16      \n");
                                      #endif // Table of vector SVEC instructions for laser hit target animation
    clockticks = clockticks + 3; 
    X = 0xd716; 
    Z = X; 
    N = (X) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; D714: 3A            \n");
                                      #endif // Point X reg to word from table
    X = X + B; 
    clockticks = clockticks + 3; 
    // End of function sub_D709
    // ---------------------------------------------------------------------------
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; D715: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Check coin inputs
  case 0xD776:
LD776:
                                                     #ifdef DEBUG
                                      mon("LD776    LDA   $4300                   ; D776: B6 43 00      \n");
                                      #endif
    PC = 0xd776; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4300); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$0F                    ; D779: 84 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x0f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$0F                    ; D77B: 81 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x0f; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LD783                   ; D77D: 27 04         \n");
                                      #endif // Check for coin or slam inputs
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LD783;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$FF                    ; D77F: 86 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xff; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$18                    ; D781: 97 18         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x18; 
    wr_mem(ea, val); 
  case 0xD783:
LD783:
                                                     #ifdef DEBUG
                                      mon("LD783    LDA   <$18                    ; D783: 96 18         \n");
                                      #endif
    PC = 0xd783; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x18); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LD788                   ; D785: 26 01         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LD788;
    }
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; D787: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
  case 0xD788:
LD788:
                                                     #ifdef DEBUG
                                      mon("LD788    DEC   <$18                    ; D788: 0A 18         \n");
                                      #endif
    PC = 0xd788; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x18); 
    res = (UINT8)(val - 1); 
 // N = res; 
 // Z = res; 
 // V = val & ~res; 
    wr_mem(DP|0x18, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$12                    ; D78A: 86 12         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x12; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  <$14                    ; D78C: 91 14         \n");
                                      #endif // Credits
    clockticks = clockticks + 4; 
    val = (UINT8)A; 
    arg = rd_mem(DP|0x14); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCC   LD792                   ; D78E: 24 02         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LD792;
    }
                                                     #ifdef DEBUG
                                      mon("         STA   <$14                    ; D790: 97 14         \n");
                                      #endif // Credits
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x14; 
    wr_mem(ea, val); 
  case 0xD792:
LD792:
                                                     #ifdef DEBUG
                                      mon("LD792    LDA   <$17                    ; D792: 96 17         \n");
                                      #endif
    PC = 0xd792; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x17); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4681                   ; D794: B7 46 81      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4681, val); 
                                                     #ifdef DEBUG
                                      mon("         LDB   <$16                    ; D797: D6 16         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x16); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STB   $4680                   ; D799: F7 46 80      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4680, val); 
                                                     #ifdef DEBUG
                                      mon("         ORA   <$16                    ; D79C: 9A 16         \n");
                                      #endif
    clockticks = clockticks + 4; 
    res = A | (UINT8)rd_mem(DP|0x16); 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORA   <$15                    ; D79E: 9A 15         \n");
                                      #endif
    clockticks = clockticks + 4; 
    res = A | (UINT8)rd_mem(DP|0x15); 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LD7A6                   ; D7A0: 27 04         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LD7A6;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$FF                    ; D7A2: 86 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xff; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$18                    ; D7A4: 97 18         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x18; 
    wr_mem(ea, val); 
  case 0xD7A6:
LD7A6:
                                                     #ifdef DEBUG
                                      mon("LD7A6    LDA   $4300                   ; D7A6: B6 43 00      \n");
                                      #endif
    PC = 0xd7a6; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4300); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$10                    ; D7A9: 84 10         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x10; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LD7B0                   ; D7AB: 26 03         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LD7B0;
    }
                                                     #ifdef DEBUG
                                      mon("         JMP   LD8AE                   ; D7AD: 7E D8 AE      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LD8AE;
    
    // ---------------------------------------------------------------------------
  case 0xD7B0:
LD7B0:
                                                     #ifdef DEBUG
                                      mon("LD7B0    LDA   $4590                   ; D7B0: B6 45 90      \n");
                                      #endif
    PC = 0xd7b0; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4590); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLA                          ; D7B3: 48            \n");
                                      #endif
    val = (UINT8)A; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLA                          ; D7B4: 48            \n");
                                      #endif
    val = (UINT8)A; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLA                          ; D7B5: 48            \n");
                                      #endif
    val = (UINT8)A; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLA                          ; D7B6: 48            \n");
                                      #endif
    val = (UINT8)A; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$09                    ; D7B7: 97 09         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x09; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4591                   ; D7B9: B6 45 91      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4591); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$0F                    ; D7BC: 84 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x0f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORA   <$09                    ; D7BE: 9A 09         \n");
                                      #endif
    clockticks = clockticks + 4; 
    res = A | (UINT8)rd_mem(DP|0x09); 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$09                    ; D7C0: 97 09         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x09; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$0A                    ; D7C2: 96 0A         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x0a); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$03                    ; D7C4: 84 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x03; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LD7CB                   ; D7C6: 26 03         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LD7CB;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   LC09D                   ; D7C8: BD C0 9D      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xcb); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xd7); 
    clockticks = clockticks + 1; 
    goto LC09D;
  case 0xD7CB:
LD7CB:
                                                     #ifdef DEBUG
                                      mon("LD7CB    LDX   #$480E                  ; D7CB: 8E 48 0E      \n");
                                      #endif
    PC = 0xd7cb; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x480e; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xD7CE:
LD7CE:
                                                     #ifdef DEBUG
                                      mon("LD7CE    LDA   $4300                   ; D7CE: B6 43 00      \n");
                                      #endif
    PC = 0xd7ce; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4300); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$480D                  ; D7D1: 8C 48 0D      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x480d; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LD7D9                   ; D7D4: 27 03         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LD7D9;
    }
                                                     #ifdef DEBUG
                                      mon("         BCC   LD7DA                   ; D7D6: 24 02         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LD7DA;
    }
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; D7D8: 44            \n");
                                      #endif
    val = (UINT8)A; 
 // C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
  case 0xD7D9:
LD7D9:
                                                     #ifdef DEBUG
                                      mon("LD7D9    LSRA                          ; D7D9: 44            \n");
                                      #endif
    PC = 0xd7d9; 
    INSTRUCTION_START
    val = (UINT8)A; 
 // C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
  case 0xD7DA:
LD7DA:
                                                     #ifdef DEBUG
                                      mon("LD7DA    LSRA                          ; D7DA: 44            \n");
                                      #endif
    PC = 0xd7da; 
    INSTRUCTION_START
    val = (UINT8)A; 
    C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   ,X                      ; D7DB: A6 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(X); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$1F                    ; D7DD: 84 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x1f; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LD812                   ; D7DF: 25 31         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LD812;
    }
                                                     #ifdef DEBUG
                                      mon("         BEQ   LD7EF                   ; D7E1: 27 0C         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LD7EF;
    }
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$1B                    ; D7E3: 81 1B         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x1b; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCC   LD7ED                   ; D7E5: 24 06         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LD7ED;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   <$0A                    ; D7E7: D6 0A         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x0a); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$01                    ; D7E9: C4 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x01; 
    B = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LD7EF                   ; D7EB: 26 02         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LD7EF;
    }
  case 0xD7ED:
LD7ED:
                                                     #ifdef DEBUG
                                      mon("LD7ED    SUBA  #$01                    ; D7ED: 80 01         \n");
                                      #endif
    PC = 0xd7ed; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x01; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)(res); 
  case 0xD7EF:
LD7EF:
                                                     #ifdef DEBUG
                                      mon("LD7EF    STA   ,X                      ; D7EF: A7 84         \n");
                                      #endif
    PC = 0xd7ef; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4300                   ; D7F1: B6 43 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4300); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$08                    ; D7F4: 84 08         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x08; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LD7FC                   ; D7F6: 26 04         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LD7FC;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$F0                    ; D7F8: 86 F0         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xf0; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$0B                    ; D7FA: 97 0B         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x0b; 
    wr_mem(ea, val); 
  case 0xD7FC:
LD7FC:
                                                     #ifdef DEBUG
                                      mon("LD7FC    LDA   <$0B                    ; D7FC: 96 0B         \n");
                                      #endif
    PC = 0xd7fc; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x0b); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LD808                   ; D7FE: 27 08         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LD808;
    }
                                                     #ifdef DEBUG
                                      mon("         DEC   <$0B                    ; D800: 0A 0B         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x0b); 
    res = (UINT8)(val - 1); 
 // N = res; 
 // Z = res; 
 // V = val & ~res; 
    wr_mem(DP|0x0b, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; D802: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   ,X                      ; D804: A7 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   $03,X                   ; D806: A7 03         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0003); 
    wr_mem(ea, val); 
  case 0xD808:
LD808:
                                                     #ifdef DEBUG
                                      mon("LD808    LDA   $03,X                   ; D808: A6 03         \n");
                                      #endif
    PC = 0xd808; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0003)); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LD860                   ; D80A: 27 54         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LD860;
    }
                                                     #ifdef DEBUG
                                      mon("         DEC   $03,X                   ; D80C: 6A 03         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0003)); 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    wr_mem((UINT16)(X + 0x0003), res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LD82F                   ; D80E: 27 1F         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LD82F;
    }
                                                     #ifdef DEBUG
                                      mon("         BRA   LD860                   ; D810: 20 4E         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LD860;
    
    // ---------------------------------------------------------------------------
  case 0xD812:
LD812:
                                                     #ifdef DEBUG
                                      mon("LD812    CMPA  #$1B                    ; D812: 81 1B         \n");
                                      #endif
    PC = 0xd812; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x1b; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCC   LD81E                   ; D814: 24 08         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LD81E;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   ,X                      ; D816: A6 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(X); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDA  #$20                    ; D818: 8B 20         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x20; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
    V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BCC   LD7EF                   ; D81A: 24 D3         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LD7EF;
    }
                                                     #ifdef DEBUG
                                      mon("         BNE   LD822                   ; D81C: 26 04         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LD822;
    }
  case 0xD81E:
LD81E:
                                                     #ifdef DEBUG
                                      mon("LD81E    LDA   #$1F                    ; D81E: 86 1F         \n");
                                      #endif
    PC = 0xd81e; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x1f; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LD7EF                   ; D820: 20 CD         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LD7EF;
    
    // ---------------------------------------------------------------------------
  case 0xD822:
LD822:
                                                     #ifdef DEBUG
                                      mon("LD822    LDA   #$1F                    ; D822: 86 1F         \n");
                                      #endif
    PC = 0xd822; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x1f; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   ,X                      ; D824: A7 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDB   $03,X                   ; D826: E6 03         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0003)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$78                    ; D828: 86 78         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x78; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $03,X                   ; D82A: A7 03         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0003); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         TSTB                          ; D82C: 5D            \n");
                                      #endif
    val = (UINT8)B; 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LD860                   ; D82D: 27 31         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LD860;
    }
  case 0xD82F:
LD82F:
                                                     #ifdef DEBUG
                                      mon("LD82F    CLRA                          ; D82F: 4F            \n");
                                      #endif
    PC = 0xd82f; 
    INSTRUCTION_START
    A = 0; // SEARCH_ME
 // V = 0; 
 // Z = 0; 
 // N = 0; 
 // C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$480D                  ; D830: 8C 48 0D      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x480d; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LD853                   ; D833: 25 1E         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LD853;
    }
                                                     #ifdef DEBUG
                                      mon("         BEQ   LD84B                   ; D835: 27 14         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LD84B;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   <$09                    ; D837: 96 09         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x09); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$0C                    ; D839: 84 0C         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x0c; 
    A = res; 
 // Z = res; 
 // N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; D83B: 44            \n");
                                      #endif
    val = (UINT8)A; 
 // C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; D83C: 44            \n");
                                      #endif
    val = (UINT8)A; 
    C = val & 1; 
    val = val >> 1; 
    A = val; 
    N = 0; 
    Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LD853                   ; D83D: 27 14         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LD853;
    }
                                                     #ifdef DEBUG
                                      mon("         ADDA  #$02                    ; D83F: 8B 02         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x02; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
    V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
    // ---------------------------------------------------------------------------
                                                     #ifdef DEBUG
                                      mon("         BRA   LD853                   ; D841: 20 10         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LD853;
    
    // ---------------------------------------------------------------------------
  case 0xD84B:
LD84B:
                                                     #ifdef DEBUG
                                      mon("LD84B    LDA   <$09                    ; D84B: 96 09         \n");
                                      #endif
    PC = 0xd84b; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x09); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$10                    ; D84D: 84 10         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x10; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LD853                   ; D84F: 27 02         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LD853;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$01                    ; D851: 86 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x01; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xD853:
LD853:
                                                     #ifdef DEBUG
                                      mon("LD853    INCA                          ; D853: 4C            \n");
                                      #endif
    PC = 0xd853; 
    INSTRUCTION_START
    val = (UINT8)A; 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         TFR   A,B                     ; D854: 1F 89         \n");
                                      #endif
    B = (UINT8)A; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         ADDB  <$13                    ; D856: DB 13         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)B; 
    arg = rd_mem(DP|0x13); 
    res = val + (UINT8)arg; 
 // C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STB   <$13                    ; D858: D7 13         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x13; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         ADDA  <$12                    ; D85A: 9B 12         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)A; 
    arg = rd_mem(DP|0x12); 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$12                    ; D85C: 97 12         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x12; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         INC   $09,X                   ; D85E: 6C 09         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0009)); 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    wr_mem((UINT16)(X + 0x0009), res); 
    clockticks = clockticks + 2; 
  case 0xD860:
LD860:
                                                     #ifdef DEBUG
                                      mon("LD860    LEAX  -1,X                    ; D860: 30 1F         \n");
                                      #endif
    PC = 0xd860; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    X = (X + 0xffff); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$480C                  ; D862: 8C 48 0C      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x480c; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         LBGE  LD7CE                   ; D865: 10 2C FF 65   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if ((SINT8)(N^V) >= 0) {
    clockticks = clockticks + 1; 
    goto LD7CE;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   <$09                    ; D869: 96 09         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x09); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; D86B: 44            \n");
                                      #endif
    val = (UINT8)A; 
 // C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; D86C: 44            \n");
                                      #endif
    val = (UINT8)A; 
 // C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; D86D: 44            \n");
                                      #endif
    val = (UINT8)A; 
 // C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; D86E: 44            \n");
                                      #endif
    val = (UINT8)A; 
 // C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; D86F: 44            \n");
                                      #endif
    val = (UINT8)A; 
 // C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   <$13                    ; D870: D6 13         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x13); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; D872: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #byte_D843              ; D873: 8E D8 43      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0xd843; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBB  A,X                     ; D876: E0 86         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)B; 
    arg = rd_mem((UINT16)(X + (SINT8)A)); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
    B = (UINT8)(res); 
                                                     #ifdef DEBUG
                                      mon("         BCS   LD88B                   ; D878: 25 11         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LD88B;
    }
                                                     #ifdef DEBUG
                                      mon("         ASL   <$13                    ; D87A: 08 13         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x13); 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    wr_mem(DP|0x13, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         RORB                          ; D87C: 56            \n");
                                      #endif
    res = ((UINT8)B) | ((C != 0) ? 0x100 : 0); 
 // C = res & 1; 
    res = (UINT8)(res >> 1); 
 // Z = res; 
 // N = res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$03                    ; D87D: 81 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x03; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LD885                   ; D87F: 27 04         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LD885;
    }
                                                     #ifdef DEBUG
                                      mon("         ADDB  #$80                    ; D881: CB 80         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x80; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
    V = (UINT8)(val ^ arg ^ res ^ C); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BCC   LD889                   ; D883: 24 04         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LD889;
    }
  case 0xD885:
LD885:
                                                     #ifdef DEBUG
                                      mon("LD885    INC   <$12                    ; D885: 0C 12         \n");
                                      #endif
    PC = 0xd885; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x12); 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    wr_mem(DP|0x12, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         INC   <$12                    ; D887: 0C 12         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x12); 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    wr_mem(DP|0x12, res); 
    clockticks = clockticks + 2; 
  case 0xD889:
LD889:
                                                     #ifdef DEBUG
                                      mon("LD889    STB   <$13                    ; D889: D7 13         \n");
                                      #endif
    PC = 0xd889; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x13; 
    wr_mem(ea, val); 
  case 0xD88B:
LD88B:
                                                     #ifdef DEBUG
                                      mon("LD88B    LDA   <$09                    ; D88B: 96 09         \n");
                                      #endif
    PC = 0xd88b; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x09); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$03                    ; D88D: 84 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x03; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LD8AC                   ; D88F: 27 1B         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LD8AC;
    }
                                                     #ifdef DEBUG
                                      mon("         TFR   A,B                     ; D891: 1F 89         \n");
                                      #endif
    B = (UINT8)A; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         NEGA                          ; D893: 40            \n");
                                      #endif
    val = (UINT8)A; 
    res = -val; 
 // V = val & (UINT8)res; 
 // C = res & 0x100; 
    val = (UINT8)res; 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASRA                          ; D894: 47            \n");
                                      #endif
    val = (UINT8)A; 
 // C = val & 1; 
    val = (UINT8)((SINT8)val >> 1); 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ADDA  <$12                    ; D895: 9B 12         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)A; 
    arg = rd_mem(DP|0x12); 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
    V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LD8A4                   ; D897: 2A 0B         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LD8A4;
    }
                                                     #ifdef DEBUG
                                      mon("         TST   <$13                    ; D899: 0D 13         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x13); 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LD8AE                   ; D89B: 2A 11         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LD8AE;
    }
                                                     #ifdef DEBUG
                                      mon("         INCA                          ; D89D: 4C            \n");
                                      #endif
    val = (UINT8)A; 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BMI   LD8AE                   ; D89E: 2B 0E         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LD8AE;
    }
                                                     #ifdef DEBUG
                                      mon("         ASL   <$13                    ; D8A0: 08 13         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x13); 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    wr_mem(DP|0x13, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSR   <$13                    ; D8A2: 04 13         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x13); 
 // C = val & 1; 
    val = val >> 1; 
    wr_mem(DP|0x13, val); 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
  case 0xD8A4:
LD8A4:
                                                     #ifdef DEBUG
                                      mon("LD8A4    CMPB  #$01                    ; D8A4: C1 01         \n");
                                      #endif
    PC = 0xd8a4; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x01; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   LD8AA                   ; D8A6: 26 02         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LD8AA;
    }
                                                     #ifdef DEBUG
                                      mon("         INC   <$14                    ; D8A8: 0C 14         \n");
                                      #endif // Credits
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x14); 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    wr_mem(DP|0x14, res); 
    clockticks = clockticks + 2; 
  case 0xD8AA:
LD8AA:
                                                     #ifdef DEBUG
                                      mon("LD8AA    INC   <$14                    ; D8AA: 0C 14         \n");
                                      #endif // Credits
    PC = 0xd8aa; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x14); 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    wr_mem(DP|0x14, res); 
    clockticks = clockticks + 2; 
  case 0xD8AC:
LD8AC:
                                                     #ifdef DEBUG
                                      mon("LD8AC    STA   <$12                    ; D8AC: 97 12         \n");
                                      #endif
    PC = 0xd8ac; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x12; 
    wr_mem(ea, val); 
  case 0xD8AE:
LD8AE:
                                                     #ifdef DEBUG
                                      mon("LD8AE    LDB   <$0A                    ; D8AE: D6 0A         \n");
                                      #endif
    PC = 0xd8ae; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x0a); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$0F                    ; D8B0: C4 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x0f; 
    B = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   locret_D8DE             ; D8B2: 26 2A         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LD8DE;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4817                  ; D8B4: 8E 48 17      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x4817; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xD8B7:
LD8B7:
                                                     #ifdef DEBUG
                                      mon("LD8B7    LDA   ,X                      ; D8B7: A6 84         \n");
                                      #endif
    PC = 0xd8b7; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(X); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LD8C0                   ; D8B9: 2A 05         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LD8C0;
    }
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$7F                    ; D8BB: 84 7F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x7f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         INCB                          ; D8BD: 5C            \n");
                                      #endif
    val = (UINT8)B; 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   ,X                      ; D8BE: A7 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, val); 
  case 0xD8C0:
LD8C0:
                                                     #ifdef DEBUG
                                      mon("LD8C0    LEAX  -1,X                    ; D8C0: 30 1F         \n");
                                      #endif
    PC = 0xd8c0; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    X = (X + 0xffff); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$4815                  ; D8C2: 8C 48 15      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x4815; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BGE   LD8B7                   ; D8C5: 2C F0         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) >= 0) {
    clockticks = clockticks + 3; 
    goto LD8B7;
    }
                                                     #ifdef DEBUG
                                      mon("         TSTB                          ; D8C7: 5D            \n");
                                      #endif
    val = (UINT8)B; 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BNE   locret_D8DE             ; D8C8: 26 14         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LD8DE;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4817                  ; D8CA: 8E 48 17      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x4817; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xD8CD:
LD8CD:
                                                     #ifdef DEBUG
                                      mon("LD8CD    LDA   ,X                      ; D8CD: A6 84         \n");
                                      #endif
    PC = 0xd8cd; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(X); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LD8D7                   ; D8CF: 27 06         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LD8D7;
    }
                                                     #ifdef DEBUG
                                      mon("         ADDA  #$7F                    ; D8D1: 8B 7F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x7f; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STA   ,X                      ; D8D3: A7 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = X; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         BRA   locret_D8DE             ; D8D5: 20 07         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LD8DE;
    
    // ---------------------------------------------------------------------------
  case 0xD8D7:
LD8D7:
                                                     #ifdef DEBUG
                                      mon("LD8D7    LEAX  -1,X                    ; D8D7: 30 1F         \n");
                                      #endif
    PC = 0xd8d7; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    X = (X + 0xffff); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$4815                  ; D8D9: 8C 48 15      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x4815; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BGE   LD8CD                   ; D8DC: 2C EF         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) >= 0) {
    clockticks = clockticks + 3; 
    goto LD8CD;
    }
    // End of function sub_D776
  case 0xD8DE:
LD8DE:
locret_D8DE:
                                                     #ifdef DEBUG
                                      mon("locret_D8DE RTS                           ; D8DE: 39            \n");
                                      #endif
    PC = 0xd8de; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Called from select screen, attract screen 1 + 3 when writing text
  case 0xD8DF:
LD8DF:
                                                     #ifdef DEBUG
                                      mon("LD8DF    LDX   #$4A52                  ; D8DF: 8E 4A 52      \n");
                                      #endif
    PC = 0xd8df; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x4a52; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CPX   $4AD9                   ; D8E2: BC 4A D9      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4ad9)<<8; 
    ea = ea | rd_mem(0x4ada); 
    val = X; 
    arg = ea; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCC   LD8F1                   ; D8E5: 24 0A         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LD8F1;
    }
  case 0xD8E7:
LD8E7:
                                                     #ifdef DEBUG
                                      mon("LD8E7    CMPA  ,X+                     ; D8E7: A1 80         \n");
                                      #endif
    PC = 0xd8e7; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    val = (UINT8)A; 
    arg = rd_mem(X); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
    X = X + 1; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LD8EC                   ; D8E9: 26 01         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LD8EC;
    }
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; D8EB: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
  case 0xD8EC:
LD8EC:
                                                     #ifdef DEBUG
                                      mon("LD8EC    CPX   $4AD9                   ; D8EC: BC 4A D9      \n");
                                      #endif
    PC = 0xd8ec; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4ad9)<<8; 
    ea = ea | rd_mem(0x4ada); 
    val = X; 
    arg = ea; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LD8E7                   ; D8EF: 25 F6         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LD8E7;
    }
  case 0xD8F1:
LD8F1:
                                                     #ifdef DEBUG
                                      mon("LD8F1    STA   ,X+                     ; D8F1: A7 80         \n");
                                      #endif
    PC = 0xd8f1; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, val); 
    X = X + 1; 
                                                     #ifdef DEBUG
                                      mon("         STX   $4AD9                   ; D8F3: BF 4A D9      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = X; 
    Z = val; 
    N = (UINT8)(val >> 8); 
    V = 0; 
    wr_mem(0x4ad9, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem(0x4ada, (UINT8)val); 
    // End of function sub_D8DF
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; D8F6: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Doesnt seem to be used anywhere
  case 0xD8F7:
LD8F7:
                                                     #ifdef DEBUG
                                      mon("LD8F7    LDX   #$4A52                  ; D8F7: 8E 4A 52      \n");
                                      #endif
    PC = 0xd8f7; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x4a52; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xD8FA:
LD8FA:
                                                     #ifdef DEBUG
                                      mon("LD8FA    CMPA  ,X                      ; D8FA: A1 84         \n");
                                      #endif
    PC = 0xd8fa; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)A; 
    arg = rd_mem(X); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   LD912                   ; D8FC: 26 14         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LD912;
    }
                                                     #ifdef DEBUG
                                      mon("         LDU   $4AD9                   ; D8FE: FE 4A D9      \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4ad9)<<8; 
    ea = ea | rd_mem(0x4ada); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPU  #$4A52                  ; D901: 11 83 4A 52   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
    arg = 0x4a52; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BLS   LD912                   ; D905: 23 0B         \n");
                                      #endif
    // temp hack to force a flush
    if ((!Z) || C) {
    clockticks = clockticks + 3; 
    goto LD912;
    }
                                                     #ifdef DEBUG
                                      mon("         LEAU  -1,U                    ; D907: 33 5F         \n");
                                      #endif
    clockticks = clockticks + 5; 
    U = (U + 0xffff); 
                                                     #ifdef DEBUG
                                      mon("         LDA   ,U                      ; D909: A6 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(U); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   ,X                      ; D90B: A7 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STU   $4AD9                   ; D90D: FF 4A D9      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    wr_mem(0x4ad9, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem(0x4ada, (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         LEAX  ,U                      ; D910: 30 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    X = U; 
 // Z = X; 
  case 0xD912:
LD912:
                                                     #ifdef DEBUG
                                      mon("LD912    LEAX  $01,X                   ; D912: 30 01         \n");
                                      #endif
    PC = 0xd912; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    X = (X + 0x0001); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         CPX   $4AD9                   ; D914: BC 4A D9      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4ad9)<<8; 
    ea = ea | rd_mem(0x4ada); 
    val = X; 
    arg = ea; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LD8FA                   ; D917: 25 E1         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LD8FA;
    }
    // End of function sub_D8F7
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; D919: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xD91A:
LD91A:
                                                     #ifdef DEBUG
                                      mon("LD91A    LDX   #$4A52                  ; D91A: 8E 4A 52      \n");
                                      #endif
    PC = 0xd91a; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x4a52; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CLR   ,X                      ; D91D: 6F 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    wr_mem(X, 0); 
 // V = 0; 
 // Z = 0; 
 // N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STX   $4AD9                   ; D91F: BF 4A D9      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = X; 
    Z = val; 
    N = (UINT8)(val >> 8); 
    V = 0; 
    wr_mem(0x4ad9, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem(0x4ada, (UINT8)val); 
    // End of function sub_D91A
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; D922: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Called from attract screen 1
  case 0xD923:
LD923:
                                                     #ifdef DEBUG
                                      mon("LD923    LDU   #$4A52                  ; D923: CE 4A 52      \n");
                                      #endif
    PC = 0xd923; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0x4a52; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPU  $4AD9                   ; D926: 11 B3 4A D9   \n");
                                      #endif
    clockticks = clockticks + 7; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4ad9)<<8; 
    ea = ea | rd_mem(0x4ada); 
    val = U; 
    arg = ea; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCC   locret_D941             ; D92A: 24 15         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LD941;
    }
  case 0xD92C:
LD92C:
                                                     #ifdef DEBUG
                                      mon("LD92C    LDB   ,U+                     ; D92C: E6 C0         \n");
                                      #endif
    PC = 0xd92c; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    val = (UINT8)rd_mem(U); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
    U = U + 1; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$D6                    ; D92E: C1 D6         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0xd6; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCC   LD93B                   ; D930: 24 09         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LD93B;
    }
                                                     #ifdef DEBUG
                                      mon("         STB   $48AE                   ; D932: F7 48 AE      \n");
                                      #endif // Text string index
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x48ae, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LE7DD                   ; D935: BD E7 DD      \n");
                                      #endif // Insert text colour vector instruction
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x38); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xd9); 
    clockticks = clockticks + 1; 
    goto LE7DD;
  case 0xD938:
LD938:
                                                     #ifdef DEBUG
                                      mon("LD938    JSR   LE7FC                   ; D938: BD E7 FC      \n");
                                      #endif
    PC = 0xd938; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x3b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xd9); 
    clockticks = clockticks + 1; 
    goto LE7FC;
  case 0xD93B:
LD93B:
                                                     #ifdef DEBUG
                                      mon("LD93B    CMPU  $4AD9                   ; D93B: 11 B3 4A D9   \n");
                                      #endif
    PC = 0xd93b; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4ad9)<<8; 
    ea = ea | rd_mem(0x4ada); 
    val = U; 
    arg = ea; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LD92C                   ; D93F: 25 EB         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LD92C;
    }
    // End of function sub_D923
  case 0xD941:
LD941:
locret_D941:
                                                     #ifdef DEBUG
                                      mon("locret_D941 RTS                           ; D941: 39            \n");
                                      #endif
    PC = 0xd941; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Called from Attract screen 3 + 4
  case 0xD942:
LD942:
                                                     #ifdef DEBUG
                                      mon("LD942    LDU   #$4A52                  ; D942: CE 4A 52      \n");
                                      #endif
    PC = 0xd942; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0x4a52; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPU  $4AD9                   ; D945: 11 B3 4A D9   \n");
                                      #endif
    clockticks = clockticks + 7; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4ad9)<<8; 
    ea = ea | rd_mem(0x4ada); 
    val = U; 
    arg = ea; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCC   locret_D95D             ; D949: 24 12         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LD95D;
    }
  case 0xD94B:
LD94B:
                                                     #ifdef DEBUG
                                      mon("LD94B    LDB   ,U+                     ; D94B: E6 C0         \n");
                                      #endif
    PC = 0xd94b; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    val = (UINT8)rd_mem(U); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
    U = U + 1; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$D6                    ; D94D: C1 D6         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0xd6; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCC   LD957                   ; D94F: 24 06         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LD957;
    }
                                                     #ifdef DEBUG
                                      mon("         STB   $48AE                   ; D951: F7 48 AE      \n");
                                      #endif // Text string index
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x48ae, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LE7FC                   ; D954: BD E7 FC      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x57); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xd9); 
    clockticks = clockticks + 1; 
    goto LE7FC;
  case 0xD957:
LD957:
                                                     #ifdef DEBUG
                                      mon("LD957    CMPU  $4AD9                   ; D957: 11 B3 4A D9   \n");
                                      #endif
    PC = 0xd957; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4ad9)<<8; 
    ea = ea | rd_mem(0x4ada); 
    val = U; 
    arg = ea; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LD94B                   ; D95B: 25 EE         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LD94B;
    }
    // End of function sub_D942
  case 0xD95D:
LD95D:
locret_D95D:
                                                     #ifdef DEBUG
                                      mon("locret_D95D RTS                           ; D95D: 39            \n");
                                      #endif
    PC = 0xd95d; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Attract screen 2 text position control
  case 0xD95E:
LD95E:
                                                     #ifdef DEBUG
                                      mon("LD95E    LDU   $4ADD                   ; D95E: FE 4A DD      \n");
                                      #endif
    PC = 0xd95e; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4add)<<8; 
    ea = ea | rd_mem(0x4ade); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   ,U+                     ; D961: A7 C0         \n");
                                      #endif
    clockticks = clockticks + 6; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, val); 
    U = U + 1; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; D963: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,U++                    ; D966: ED C1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    U = U + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0100                  ; D968: CC 01 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x01; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,U++                    ; D96B: ED C1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    U = U + 2; 
                                                     #ifdef DEBUG
                                      mon("         STU   $4ADD                   ; D96D: FF 4A DD      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
    Z = val; 
    N = (UINT8)(val >> 8); 
    V = 0; 
    wr_mem(0x4add, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem(0x4ade, (UINT8)val); 
    // End of function sub_D95E
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; D970: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xD971:
LD971:
                                                     #ifdef DEBUG
                                      mon("LD971    LDU   #$4A66                  ; D971: CE 4A 66      \n");
                                      #endif
    PC = 0xd971; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0x4a66; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0xD974:
LD974:
                                                     #ifdef DEBUG
                                      mon("LD974    CMPA  ,U                      ; D974: A1 C4         \n");
                                      #endif
    PC = 0xd974; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)A; 
    arg = rd_mem(U); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   LD97C                   ; D976: 26 04         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LD97C;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; D978: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,U                      ; D97A: ED C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
  case 0xD97C:
LD97C:
                                                     #ifdef DEBUG
                                      mon("LD97C    LEAU  $05,U                   ; D97C: 33 45         \n");
                                      #endif
    PC = 0xd97c; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    U = (U + 0x0005); 
                                                     #ifdef DEBUG
                                      mon("         CMPU  $4ADD                   ; D97E: 11 B3 4A DD   \n");
                                      #endif
    clockticks = clockticks + 7; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4add)<<8; 
    ea = ea | rd_mem(0x4ade); 
    val = U; 
    arg = ea; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LD974                   ; D982: 25 F0         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LD974;
    }
    // End of function sub_D971
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; D984: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xD985:
LD985:
                                                     #ifdef DEBUG
                                      mon("LD985    LDU   #$4A66                  ; D985: CE 4A 66      \n");
                                      #endif
    PC = 0xd985; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0x4a66; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPU  $4ADD                   ; D988: 11 B3 4A DD   \n");
                                      #endif
    clockticks = clockticks + 7; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4add)<<8; 
    ea = ea | rd_mem(0x4ade); 
    val = U; 
    arg = ea; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCC   locret_D9DB             ; D98C: 24 4D         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LD9DB;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$7200                  ; D98E: CC 72 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x72; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; D991: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
  case 0xD993:
LD993:
                                                     #ifdef DEBUG
                                      mon("LD993    LDA   ,U+                     ; D993: A6 C0         \n");
                                      #endif
    PC = 0xd993; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    val = (UINT8)rd_mem(U); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
    U = U + 1; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LD9D3                   ; D995: 27 3C         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LD9D3;
    }
                                                     #ifdef DEBUG
                                      mon("         STA   $48AE                   ; D997: B7 48 AE      \n");
                                      #endif // Text string index
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x48ae, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0198                  ; D99A: CC 01 98      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x01; 
    B = 0x98; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; D99D: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; D99F: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; D9A2: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   ,U                      ; D9A4: E6 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(U); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$71                    ; D9A6: 86 71         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x71; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; D9A8: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         COMB                          ; D9AA: 53            \n");
                                      #endif
    val = (UINT8)B ^ 0xff; 
    B = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ADDB  #$10                    ; D9AB: CB 10         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x10; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$62                    ; D9AD: 86 62         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x62; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; D9AF: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #off_E99E               ; D9B1: 8E E9 9E      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0xe99e; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $48AE                   ; D9B4: F6 48 AE      \n");
                                      #endif // Text string index
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x48ae); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; D9B7: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; D9B8: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$1DD0                  ; D9B9: CC 1D D0      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x1d; 
    B = 0xd0; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; D9BC: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   ,X                      ; D9BE: EC 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(X); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(X+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$1F                    ; D9C0: 84 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x1f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORA   #$00                    ; D9C2: 8A 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A | (UINT8)0x00; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; D9C4: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LE821                   ; D9C6: BD E8 21      \n");
                                      #endif // Text handling
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xc9); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xd9); 
    clockticks = clockticks + 1; 
    goto LE821;
  case 0xD9C9:
LD9C9:
                                                     #ifdef DEBUG
                                      mon("LD9C9    LDD   #$7200                  ; D9C9: CC 72 00      \n");
                                      #endif
    PC = 0xd9c9; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x72; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; D9CC: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$8040                  ; D9CE: CC 80 40      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; D9D1: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
  case 0xD9D3:
LD9D3:
                                                     #ifdef DEBUG
                                      mon("LD9D3    LEAU  $04,U                   ; D9D3: 33 44         \n");
                                      #endif
    PC = 0xd9d3; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    U = (U + 0x0004); 
                                                     #ifdef DEBUG
                                      mon("         CMPU  $4ADD                   ; D9D5: 11 B3 4A DD   \n");
                                      #endif
    clockticks = clockticks + 7; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4add)<<8; 
    ea = ea | rd_mem(0x4ade); 
    val = U; 
    arg = ea; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LD993                   ; D9D9: 25 B8         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LD993;
    }
    // End of function sub_D985
  case 0xD9DB:
LD9DB:
locret_D9DB:
                                                     #ifdef DEBUG
                                      mon("locret_D9DB RTS                           ; D9DB: 39            \n");
                                      #endif
    PC = 0xd9db; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Initialise before game start
  case 0xD9DC:
LD9DC:
                                                     #ifdef DEBUG
                                      mon("LD9DC    LDD   #$00                    ; D9DC: CC 00 00      \n");
                                      #endif
    PC = 0xd9dc; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4AE4                   ; D9DF: FD 4A E4      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4ae4, A); // Care needed with I/O space and word fetches
    wr_mem(0x4ae5, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$6018                  ; D9E2: CC 60 18      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x60; 
    B = 0x18; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4AE6                   ; D9E5: FD 4A E6      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4ae6, A); // Care needed with I/O space and word fetches
    wr_mem(0x4ae7, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$4A66                  ; D9E8: CC 4A 66      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x4a; 
    B = 0x66; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4ADD                   ; D9EB: FD 4A DD      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4add, A); // Care needed with I/O space and word fetches
    wr_mem(0x4ade, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   word_DB2F               ; D9EE: FC DB 2F      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0xdb2f); // Care needed with I/O space and word fetches
    B = rd_mem(0xdb30); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4AE2                   ; D9F1: FD 4A E2      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4ae2, A); // Care needed with I/O space and word fetches
    wr_mem(0x4ae3, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$51                    ; D9F4: 86 51         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x51; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4ADF                   ; D9F6: B7 4A DF      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x4adf, val); 
    // End of function sub_D9DC
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; D9F9: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Attract screen 2 large Star Wars logo handling
  case 0xD9FA:
LD9FA:
                                                     #ifdef DEBUG
                                      mon("LD9FA    LDD   $4AE4                   ; D9FA: FC 4A E4      \n");
                                      #endif
    PC = 0xd9fa; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x4ae4); // Care needed with I/O space and word fetches
    B = rd_mem(0x4ae5); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$01                    ; D9FD: C3 00 01      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0001; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4AE4                   ; DA00: FD 4A E4      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4ae4, A); // Care needed with I/O space and word fetches
    wr_mem(0x4ae5, B); 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$F8                    ; DA03: 10 83 00 F8   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x00f8; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         LBCC  LDA94                   ; DA07: 10 24 00 89   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if (!C) {
    clockticks = clockticks + 1; 
    goto LDA94;
    }
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$40                    ; DA0B: 10 83 00 40   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x0040; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCC   LDA1E                   ; DA0F: 24 0D         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LDA1E;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $4AE6                   ; DA11: FC 4A E6      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x4ae6); // Care needed with I/O space and word fetches
    B = rd_mem(0x4ae7); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDB  #$03                    ; DA14: CB 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x03; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4AE6                   ; DA16: FD 4A E6      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4ae6, A); // Care needed with I/O space and word fetches
    wr_mem(0x4ae7, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$40                    ; DA19: CC 00 40      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x40; 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LDA2A                   ; DA1C: 20 0C         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LDA2A;
    
    // ---------------------------------------------------------------------------
  case 0xDA1E:
LDA1E:
                                                     #ifdef DEBUG
                                      mon("LDA1E    LDD   $4AE4                   ; DA1E: FC 4A E4      \n");
                                      #endif
    PC = 0xda1e; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x4ae4); // Care needed with I/O space and word fetches
    B = rd_mem(0x4ae5); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         COMB                          ; DA21: 53            \n");
                                      #endif
    val = (UINT8)B ^ 0xff; 
    B = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ADDB  #$18                    ; DA22: CB 18         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x18; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4AE6                   ; DA24: FD 4A E6      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4ae6, A); // Care needed with I/O space and word fetches
    wr_mem(0x4ae7, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $4AE4                   ; DA27: FC 4A E4      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x4ae4); // Care needed with I/O space and word fetches
    B = rd_mem(0x4ae5); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0xDA2A:
LDA2A:
                                                     #ifdef DEBUG
                                      mon("LDA2A    ORA   #$73                    ; DA2A: 8A 73         \n");
                                      #endif
    PC = 0xda2a; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    res = A | (UINT8)0x73; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4AE8                   ; DA2C: FD 4A E8      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4ae8, A); // Care needed with I/O space and word fetches
    wr_mem(0x4ae9, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $4AE6                   ; DA2F: FC 4A E6      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x4ae6); // Care needed with I/O space and word fetches
    B = rd_mem(0x4ae7); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORA   #$61                    ; DA32: 8A 61         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A | (UINT8)0x61; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; DA34: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0198                  ; DA36: CC 01 98      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x01; 
    B = 0x98; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y                      ; DA39: ED A4         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $08,Y                   ; DA3B: ED 28         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(Y + 0x0008); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $10,Y                   ; DA3D: ED A8 10      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(Y + (SINT8)0x10); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $18,Y                   ; DA40: ED A8 18      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(Y + (SINT8)0x18); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $20,Y                   ; DA43: ED A8 20      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(Y + (SINT8)0x20); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $28,Y                   ; DA46: ED A8 28      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(Y + (SINT8)0x28); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; DA49: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $02,Y                   ; DA4C: ED 22         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(Y + 0x0002); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $0A,Y                   ; DA4E: ED 2A         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(Y + 0x000a); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $12,Y                   ; DA50: ED A8 12      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(Y + (SINT8)0x12); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $1A,Y                   ; DA53: ED A8 1A      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(Y + (SINT8)0x1a); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $22,Y                   ; DA56: ED A8 22      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(Y + (SINT8)0x22); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $2A,Y                   ; DA59: ED A8 2A      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(Y + (SINT8)0x2a); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $4AE8                   ; DA5C: FC 4A E8      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x4ae8); // Care needed with I/O space and word fetches
    B = rd_mem(0x4ae9); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $04,Y                   ; DA5F: ED 24         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(Y + 0x0004); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $0C,Y                   ; DA61: ED 2C         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(Y + 0x000c); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $14,Y                   ; DA63: ED A8 14      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(Y + (SINT8)0x14); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $1C,Y                   ; DA66: ED A8 1C      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(Y + (SINT8)0x1c); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $24,Y                   ; DA69: ED A8 24      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(Y + (SINT8)0x24); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $2C,Y                   ; DA6C: ED A8 2C      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(Y + (SINT8)0x2c); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$B400                  ; DA6F: CC B4 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xb4; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $06,Y                   ; DA72: ED 26         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(Y + 0x0006); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$B434                  ; DA74: CC B4 34      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xb4; 
    B = 0x34; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $0E,Y                   ; DA77: ED 2E         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(Y + 0x000e); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$B458                  ; DA79: CC B4 58      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xb4; 
    B = 0x58; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $16,Y                   ; DA7C: ED A8 16      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(Y + (SINT8)0x16); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$B488                  ; DA7F: CC B4 88      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xb4; 
    B = 0x88; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $1E,Y                   ; DA82: ED A8 1E      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(Y + (SINT8)0x1e); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$B4AE                  ; DA85: CC B4 AE      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xb4; 
    B = 0xae; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $26,Y                   ; DA88: ED A8 26      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(Y + (SINT8)0x26); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$B4D2                  ; DA8B: CC B4 D2      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xb4; 
    B = 0xd2; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $2E,Y                   ; DA8E: ED A8 2E      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(Y + (SINT8)0x2e); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LEAY  $30,Y                   ; DA91: 31 A8 30      \n");
                                      #endif
    clockticks = clockticks + 5; 
    Y = (Y + (SINT8)0x30); 
 // Z = Y; 
  case 0xDA94:
LDA94:
                                                     #ifdef DEBUG
                                      mon("LDA94    LDX   #$4A66                  ; DA94: 8E 4A 66      \n");
                                      #endif
    PC = 0xda94; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x4a66; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CPX   $4ADD                   ; DA97: BC 4A DD      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4add)<<8; 
    ea = ea | rd_mem(0x4ade); 
    val = X; 
    arg = ea; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCC   LDAF5                   ; DA9A: 24 59         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LDAF5;
    }
  case 0xDA9C:
LDA9C:
                                                     #ifdef DEBUG
                                      mon("LDA9C    LDD   $4AE4                   ; DA9C: FC 4A E4      \n");
                                      #endif
    PC = 0xda9c; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x4ae4); // Care needed with I/O space and word fetches
    B = rd_mem(0x4ae5); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$E0                    ; DA9F: 10 83 00 E0   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x00e0; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCC   LDAB3                   ; DAA3: 24 0E         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LDAB3;
    }
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$40                    ; DAA5: 10 83 00 40   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x0040; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LDAB1                   ; DAA9: 25 06         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LDAB1;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $01,X                   ; DAAB: EC 01         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + 0x0001); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $03,X                   ; DAAD: E3 03         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(X + 0x0003))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(X + 0x0003))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $01,X                   ; DAAF: ED 01         \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = (UINT16)(X + 0x0001); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
  case 0xDAB1:
LDAB1:
                                                     #ifdef DEBUG
                                      mon("LDAB1    BRA   LDAEE                   ; DAB1: 20 3B         \n");
                                      #endif
    PC = 0xdab1; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto LDAEE;
    
    // ---------------------------------------------------------------------------
  case 0xDAB3:
LDAB3:
                                                     #ifdef DEBUG
                                      mon("LDAB3    CMPD  #$0160                  ; DAB3: 10 83 01 60   \n");
                                      #endif
    PC = 0xdab3; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x0160; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCC   LDAC1                   ; DAB7: 24 08         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LDAC1;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0400                  ; DAB9: CC 04 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x04; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4A69                   ; DABC: FD 4A 69      \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x4a69, A); // Care needed with I/O space and word fetches
    wr_mem(0x4a6a, B); 
                                                     #ifdef DEBUG
                                      mon("         BRA   LDAEE                   ; DABF: 20 2D         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LDAEE;
    
    // ---------------------------------------------------------------------------
  case 0xDAC1:
LDAC1:
                                                     #ifdef DEBUG
                                      mon("LDAC1    LDD   $01,X                   ; DAC1: EC 01         \n");
                                      #endif
    PC = 0xdac1; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + 0x0001); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $03,X                   ; DAC3: E3 03         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(X + 0x0003))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(X + 0x0003))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $01,X                   ; DAC5: ED 01         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x0001); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$F000                  ; DAC7: 10 83 F0 00   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0xf000; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LDAEE                   ; DACB: 25 21         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LDAEE;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   ,X                      ; DACD: A6 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(X); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         INCA                          ; DACF: 4C            \n");
                                      #endif
    val = (UINT8)A; 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #$4A66                  ; DAD0: CE 4A 66      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x4a66; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0xDAD3:
LDAD3:
                                                     #ifdef DEBUG
                                      mon("LDAD3    CMPA  ,U                      ; DAD3: A1 C4         \n");
                                      #endif
    PC = 0xdad3; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)A; 
    arg = rd_mem(U); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   LDADF                   ; DAD5: 26 08         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LDADF;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0400                  ; DAD7: CC 04 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x04; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $03,U                   ; DADA: ED 43         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(U + 0x0003); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDU   $4ADD                   ; DADC: FE 4A DD      \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4add)<<8; 
    ea = ea | rd_mem(0x4ade); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0xDADF:
LDADF:
                                                     #ifdef DEBUG
                                      mon("LDADF    LEAU  $05,U                   ; DADF: 33 45         \n");
                                      #endif
    PC = 0xdadf; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    U = (U + 0x0005); 
                                                     #ifdef DEBUG
                                      mon("         CMPU  $4ADD                   ; DAE1: 11 B3 4A DD   \n");
                                      #endif
    clockticks = clockticks + 7; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4add)<<8; 
    ea = ea | rd_mem(0x4ade); 
    val = U; 
    arg = ea; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LDAD3                   ; DAE5: 25 EC         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LDAD3;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   ,X                      ; DAE7: A6 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(X); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LD971                   ; DAE9: BD D9 71      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xec); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xda); 
    clockticks = clockticks + 1; 
    goto LD971;
  case 0xDAEC:
LDAEC:
                                                     #ifdef DEBUG
                                      mon("LDAEC    LEAX  -5,X                    ; DAEC: 30 1B         \n");
                                      #endif
    PC = 0xdaec; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    X = (X + 0xfffb); 
 // Z = X; 
  case 0xDAEE:
LDAEE:
                                                     #ifdef DEBUG
                                      mon("LDAEE    LEAX  $05,X                   ; DAEE: 30 05         \n");
                                      #endif
    PC = 0xdaee; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    X = (X + 0x0005); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         CPX   $4ADD                   ; DAF0: BC 4A DD      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4add)<<8; 
    ea = ea | rd_mem(0x4ade); 
    val = X; 
    arg = ea; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LDA9C                   ; DAF3: 25 A7         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LDA9C;
    }
  case 0xDAF5:
LDAF5:
                                                     #ifdef DEBUG
                                      mon("LDAF5    LDD   $4AE4                   ; DAF5: FC 4A E4      \n");
                                      #endif
    PC = 0xdaf5; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x4ae4); // Care needed with I/O space and word fetches
    B = rd_mem(0x4ae5); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$0200                  ; DAF8: 10 83 02 00   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x0200; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LDB03                   ; DAFC: 25 05         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LDB03;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$07                    ; DAFE: 86 07         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x07; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4841                   ; DB00: B7 48 41      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4841, val); 
  case 0xDB03:
LDB03:
                                                     #ifdef DEBUG
                                      mon("LDB03    CMPD  $4AE2                   ; DB03: 10 B3 4A E2   \n");
                                      #endif
    PC = 0xdb03; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4ae2)<<8; 
    ea = ea | rd_mem(0x4ae3); 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = ea; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
    clockticks = clockticks + 1; 
                                                     #ifdef DEBUG
                                      mon("         BCS   locret_DB2E             ; DB07: 25 25         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LDB2E;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4ADF                   ; DB09: B6 4A DF      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4adf); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LD95E                   ; DB0C: BD D9 5E      \n");
                                      #endif // Attract screen 2 text position control
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x0f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xdb); 
    clockticks = clockticks + 1; 
    goto LD95E;
  case 0xDB0F:
LDB0F:
                                                     #ifdef DEBUG
                                      mon("LDB0F    LDA   $4ADF                   ; DB0F: B6 4A DF      \n");
                                      #endif
    PC = 0xdb0f; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4adf); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         INCA                          ; DB12: 4C            \n");
                                      #endif
    val = (UINT8)A; 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$59                    ; DB13: 81 59         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x59; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   LDB1F                   ; DB15: 25 08         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LDB1F;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$FFFF                  ; DB17: CC FF FF      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xff; 
    B = 0xff; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4AE2                   ; DB1A: FD 4A E2      \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x4ae2, A); // Care needed with I/O space and word fetches
    wr_mem(0x4ae3, B); 
                                                     #ifdef DEBUG
                                      mon("         BRA   locret_DB2E             ; DB1D: 20 0F         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LDB2E;
    
    // ---------------------------------------------------------------------------
  case 0xDB1F:
LDB1F:
                                                     #ifdef DEBUG
                                      mon("LDB1F    STA   $4ADF                   ; DB1F: B7 4A DF      \n");
                                      #endif
    PC = 0xdb1f; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4adf, val); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$DA8D                  ; DB22: 8E DA 8D      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0xda8d; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         TFR   A,B                     ; DB25: 1F 89         \n");
                                      #endif
    B = (UINT8)A; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; DB27: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; DB28: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         LDD   ,X                      ; DB29: EC 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(X); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(X+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4AE2                   ; DB2B: FD 4A E2      \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x4ae2, A); // Care needed with I/O space and word fetches
    wr_mem(0x4ae3, B); 
    // End of function sub_D9FA
    // ---------------------------------------------------------------------------
  case 0xDB2E:
LDB2E:
locret_DB2E:
                                                     #ifdef DEBUG
                                      mon("locret_DB2E RTS                           ; DB2E: 39            \n");
                                      #endif
    PC = 0xdb2e; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
                   // FCB   $80                     ; DB38:  ' ' 80 00          SUBA  #$00 ; 
                   // FCB   $90                     ; DB3A:  ' ' 90 00          SUBA  <$00 ; 
                   // FCB   $A0                     ; DB3C:  ' ' A0 00          SUBA  0,X ; 
                   // FCB   $20                     ; DB49:  ' ' 20 31          BRA   $DB7C ; 
                   // FCB   $31                     ; DB4A:  '1' 31 39          LEAY  -7,Y ; 
                   // FCB   $39                     ; DB4B:  '9' 39             RTS   ; 
                   // FCB   $38                     ; DB4C:  '8' 38             Invalid ; 
                   // FCB   $33                     ; DB4D:  '3' 33 20          LEAU  0,Y ; 
                   // FCB   $20                     ; DB4E:  ' ' 20 4C          BRA   $DB9C ; 
                   // FCB   $4C                     ; DB4F:  'L' 4C             INCA  ; 
                   // FCB   $55                     ; DB50:  'U' 55             Invalid ; 
                   // FCB   $43                     ; DB51:  'C' 43             COMA  ; 
                   // FCB   $41                     ; DB52:  'A' 41             Invalid ; 
                   // FCB   $53                     ; DB53:  'S' 53             COMB  ; 
                   // FCB   $46                     ; DB54:  'F' 46             RORA  ; 
                   // FCB   $49                     ; DB55:  'I' 49             ROLA  ; 
                   // FCB   $4C                     ; DB56:  'L' 4C             INCA  ; 
                   // FCB   $4D                     ; DB57:  'M' 4D             TSTA  ; 
                   // FCB   $20                     ; DB58:  ' ' 20 4C          BRA   $DBA6 ; 
                   // FCB   $4C                     ; DB59:  'L' 4C             INCA  ; 
                   // FCB   $54                     ; DB5A:  'T' 54             LSRB  ; 
                   // FCB   $44                     ; DB5B:  'D' 44             LSRA  ; 
                   // FCB   $2E                     ; DB5C:  '.' 2E 20          BGT   $DB7E ; 
                   // FCB   $20                     ; DB5D:  ' ' 20 41          BRA   $DBA0 ; 
                   // FCB   $41                     ; DB5E:  'A' 41             Invalid ; 
                   // FCB   $4E                     ; DB5F:  'N' 4E             Invalid ; 
                   // FCB   $44                     ; DB60:  'D' 44             LSRA  ; 
                   // FCB   $20                     ; DB61:  ' ' 20 41          BRA   $DBA4 ; 
                   // FCB   $41                     ; DB62:  'A' 41             Invalid ; 
                   // FCB   $54                     ; DB63:  'T' 54             LSRB  ; 
                   // FCB   $41                     ; DB64:  'A' 41             Invalid ; 
                   // FCB   $52                     ; DB65:  'R' 52             Invalid ; 
                   // FCB   $49                     ; DB66:  'I' 49             ROLA  ; 
                   // FCB   $2C                     ; DB67:  ',' 2C 49          BGE   $DBB2 ; 
                   // FCB   $49                     ; DB68:  'I' 49             ROLA  ; 
                   // FCB   $4E                     ; DB69:  'N' 4E             Invalid ; 
                   // FCB   $43                     ; DB6A:  'C' 43             COMA  ; 
                   // FCB   $AE                     ; DB6B:  ' ' AE 41          LDX   1,U ; 
                   // FCB   $41                     ; DB6C:  'A' 41             Invalid ; 
                   // FCB   $4C                     ; DB6D:  'L' 4C             INCA  ; 
                   // FCB   $4C                     ; DB6E:  'L' 4C             INCA  ; 
                   // FCB   $20                     ; DB6F:  ' ' 20 52          BRA   $DBC3 ; 
                   // FCB   $52                     ; DB70:  'R' 52             Invalid ; 
                   // FCB   $49                     ; DB71:  'I' 49             ROLA  ; 
                   // FCB   $47                     ; DB72:  'G' 47             ASRA  ; 
                   // FCB   $48                     ; DB73:  'H' 48             ASLA  ; 
                   // FCB   $54                     ; DB74:  'T' 54             LSRB  ; 
                   // FCB   $53                     ; DB75:  'S' 53             COMB  ; 
                   // FCB   $20                     ; DB76:  ' ' 20 52          BRA   $DBCA ; 
                   // FCB   $52                     ; DB77:  'R' 52             Invalid ; 
                   // FCB   $45                     ; DB78:  'E' 45             Invalid ; 
                   // FCB   $53                     ; DB79:  'S' 53             COMB  ; 
                   // FCB   $45                     ; DB7A:  'E' 45             Invalid ; 
                   // FCB   $52                     ; DB7B:  'R' 52             Invalid ; 
                   // FCB   $56                     ; DB7C:  'V' 56             RORB  ; 
                   // FCB   $45                     ; DB7D:  'E' 45             Invalid ; 
                   // FCB   $44                     ; DB7E:  'D' 44             LSRA  ; 
                   // FCB   $AE                     ; DB7F:  ' ' AE 4C          LDX   12,U ; 
                   // FCB   $4C                     ; DB80:  'L' 4C             INCA  ; 
                   // FCB   $55                     ; DB81:  'U' 55             Invalid ; 
                   // FCB   $43                     ; DB82:  'C' 43             COMA  ; 
                   // FCB   $41                     ; DB83:  'A' 41             Invalid ; 
                   // FCB   $53                     ; DB84:  'S' 53             COMB  ; 
                   // FCB   $46                     ; DB85:  'F' 46             RORA  ; 
                   // FCB   $49                     ; DB86:  'I' 49             ROLA  ; 
                   // FCB   $4C                     ; DB87:  'L' 4C             INCA  ; 
                   // FCB   $4D                     ; DB88:  'M' 4D             TSTA  ; 
                   // FCB   $20                     ; DB89:  ' ' 20 54          BRA   $DBDF ; 
                   // FCB   $54                     ; DB8A:  'T' 54             LSRB  ; 
                   // FCB   $52                     ; DB8B:  'R' 52             Invalid ; 
                   // FCB   $41                     ; DB8C:  'A' 41             Invalid ; 
                   // FCB   $44                     ; DB8D:  'D' 44             LSRA  ; 
                   // FCB   $45                     ; DB8E:  'E' 45             Invalid ; 
                   // FCB   $4D                     ; DB8F:  'M' 4D             TSTA  ; 
                   // FCB   $41                     ; DB90:  'A' 41             Invalid ; 
                   // FCB   $52                     ; DB91:  'R' 52             Invalid ; 
                   // FCB   $4B                     ; DB92:  'K' 4B             Invalid ; 
                   // FCB   $53                     ; DB93:  'S' 53             COMB  ; 
                   // FCB   $20                     ; DB94:  ' ' 20 55          BRA   $DBEB ; 
                   // FCB   $55                     ; DB95:  'U' 55             Invalid ; 
                   // FCB   $53                     ; DB96:  'S' 53             COMB  ; 
                   // FCB   $45                     ; DB97:  'E' 45             Invalid ; 
                   // FCB   $44                     ; DB98:  'D' 44             LSRA  ; 
                   // FCB   $20                     ; DB99:  ' ' 20 55          BRA   $DBF0 ; 
                   // FCB   $55                     ; DB9A:  'U' 55             Invalid ; 
                   // FCB   $4E                     ; DB9B:  'N' 4E             Invalid ; 
                   // FCB   $44                     ; DB9C:  'D' 44             LSRA  ; 
                   // FCB   $45                     ; DB9D:  'E' 45             Invalid ; 
                   // FCB   $52                     ; DB9E:  'R' 52             Invalid ; 
                   // FCB   $20                     ; DB9F:  ' ' 20 4C          BRA   $DBED ; 
                   // FCB   $4C                     ; DBA0:  'L' 4C             INCA  ; 
                   // FCB   $49                     ; DBA1:  'I' 49             ROLA  ; 
                   // FCB   $43                     ; DBA2:  'C' 43             COMA  ; 
                   // FCB   $45                     ; DBA3:  'E' 45             Invalid ; 
                   // FCB   $4E                     ; DBA4:  'N' 4E             Invalid ; 
                   // FCB   $53                     ; DBA5:  'S' 53             COMB  ; 
                   // FCB   $45                     ; DBA6:  'E' 45             Invalid ; 
                   // FCB   $AE                     ; DBA7:  ' ' AE 47          LDX   7,U ; 
                   // FCB   $49                     ; DC7E:  'I' 49             ROLA  ; 
                   // FCB   $4C                     ; DC7F:  'L' 4C             INCA  ; 
                   // FCB   $4C                     ; DC80:  'L' 4C             INCA  ; 
                   // FCB   $20                     ; DC81:  ' ' 20 50          BRA   $DCD3 ; 
                   // FCB   $50                     ; DC82:  'P' 50             NEGB  ; 
                   // FCB   $52                     ; DC83:  'R' 52             Invalid ; 
                   // FCB   $4F                     ; DC84:  'O' 4F             CLRA  ; 
                   // FCB   $54                     ; DC85:  'T' 54             LSRB  ; 
                   // FCB   $45                     ; DC86:  'E' 45             Invalid ; 
                   // FCB   $43                     ; DC87:  'C' 43             COMA  ; 
                   // FCB   $54                     ; DC88:  'T' 54             LSRB  ; 
                   // FCB   $20                     ; DC89:  ' ' 20 59          BRA   $DCE4 ; 
                   // FCB   $59                     ; DC8A:  'Y' 59             ROLB  ; 
                   // FCB   $4F                     ; DC8B:  'O' 4F             CLRA  ; 
                   // FCB   $55                     ; DC8C:  'U' 55             Invalid ; 
                   // FCB   $20                     ; DC8D:  ' ' 20 46          BRA   $DCD5 ; 
                   // FCB   $46                     ; DC8E:  'F' 46             RORA  ; 
                   // FCB   $4F                     ; DC8F:  'O' 4F             CLRA  ; 
                   // FCB   $52                     ; DC90:  'R' 52             Invalid ; 
                   // FCB   $20                     ; DC91:  ' ' 20 20          BRA   $DCB3 ; 
                   // FCB   $20                     ; DC92:  ' ' 20 20          BRA   $DCB4 ; 
                   // FCB   $20                     ; DC93:  ' ' 20 43          BRA   $DCD8 ; 
                   // FCB   $43                     ; DC94:  'C' 43             COMA  ; 
                   // FCB   $4F                     ; DC95:  'O' 4F             CLRA  ; 
                   // FCB   $4C                     ; DC96:  'L' 4C             INCA  ; 
                   // FCB   $4C                     ; DC97:  'L' 4C             INCA  ; 
                   // FCB   $49                     ; DC98:  'I' 49             ROLA  ; 
                   // FCB   $53                     ; DC99:  'S' 53             COMB  ; 
                   // FCB   $49                     ; DC9A:  'I' 49             ROLA  ; 
                   // FCB   $4F                     ; DC9B:  'O' 4F             CLRA  ; 
                   // FCB   $4E                     ; DC9C:  'N' 4E             Invalid ; 
                   // FCB   $53                     ; DC9D:  'S' 53             COMB  ; 
                   // FCB   $AE                     ; DC9E:  ' ' AE 32          LDX   -14,Y ; 
                   // FCB   $52                     ; DD04:  'R' 52             Invalid ; 
                   // FCB   $45                     ; DD05:  'E' 45             Invalid ; 
                   // FCB   $4E                     ; DD06:  'N' 4E             Invalid ; 
                   // FCB   $43                     ; DD07:  'C' 43             COMA  ; 
                   // FCB   $48                     ; DD08:  'H' 48             ASLA  ; 
                   // FCB   $20                     ; DD09:  ' ' 20 43          BRA   $DD4E ; 
                   // FCB   $43                     ; DD0A:  'C' 43             COMA  ; 
                   // FCB   $41                     ; DD0B:  'A' 41             Invalid ; 
                   // FCB   $54                     ; DD0C:  'T' 54             LSRB  ; 
                   // FCB   $57                     ; DD0D:  'W' 57             ASRB  ; 
                   // FCB   $41                     ; DD0E:  'A' 41             Invalid ; 
                   // FCB   $4C                     ; DD0F:  'L' 4C             INCA  ; 
                   // FCB   $4B                     ; DD10:  'K' 4B             Invalid ; 
                   // FCB   $AE                     ; DD11:  ' ' AE 33          LDX   -13,Y ; 
                   // FCB   $4F                     ; DD57:  'O' 4F             CLRA  ; 
                   // FCB   $57                     ; DD58:  'W' 57             ASRB  ; 
                   // FCB   $45                     ; DD59:  'E' 45             Invalid ; 
                   // FCB   $52                     ; DD5A:  'R' 52             Invalid ; 
                   // FCB   $20                     ; DD5B:  ' ' 20 54          BRA   $DDB1 ; 
                   // FCB   $54                     ; DD5C:  'T' 54             LSRB  ; 
                   // FCB   $4F                     ; DD5D:  'O' 4F             CLRA  ; 
                   // FCB   $50                     ; DD5E:  'P' 50             NEGB  ; 
                   // FCB   $53                     ; DD5F:  'S' 53             COMB  ; 
                   // FCB   $20                     ; DD60:  ' ' 20 41          BRA   $DDA3 ; 
                   // FCB   $41                     ; DD61:  'A' 41             Invalid ; 
                   // FCB   $4E                     ; DD62:  'N' 4E             Invalid ; 
                   // FCB   $44                     ; DD63:  'D' 44             LSRA  ; 
                   // FCB   $20                     ; DD64:  ' ' 20 54          BRA   $DDBA ; 
                   // FCB   $54                     ; DD65:  'T' 54             LSRB  ; 
                   // FCB   $52                     ; DD66:  'R' 52             Invalid ; 
                   // FCB   $45                     ; DD67:  'E' 45             Invalid ; 
                   // FCB   $4E                     ; DD68:  'N' 4E             Invalid ; 
                   // FCB   $43                     ; DD69:  'C' 43             COMA  ; 
                   // FCB   $48                     ; DD6A:  'H' 48             ASLA  ; 
                   // FCB   $20                     ; DD6B:  ' ' 20 54          BRA   $DDC1 ; 
                   // FCB   $54                     ; DD6C:  'T' 54             LSRB  ; 
                   // FCB   $55                     ; DD6D:  'U' 55             Invalid ; 
                   // FCB   $52                     ; DD6E:  'R' 52             Invalid ; 
                   // FCB   $52                     ; DD6F:  'R' 52             Invalid ; 
                   // FCB   $45                     ; DD70:  'E' 45             Invalid ; 
                   // FCB   $54                     ; DD71:  'T' 54             LSRB  ; 
                   // FCB   $53                     ; DD72:  'S' 53             COMB  ; 
                   // FCB   $AE                     ; DD73:  ' ' AE 34          LDX   -12,Y ; 
                   // FCB   $4D                     ; DD94:  'M' 4D             TSTA  ; 
                   // FCB   $50                     ; DD95:  'P' 50             NEGB  ; 
                   // FCB   $41                     ; DD96:  'A' 41             Invalid ; 
                   // FCB   $43                     ; DD97:  'C' 43             COMA  ; 
                   // FCB   $54                     ; DD98:  'T' 54             LSRB  ; 
                   // FCB   $20                     ; DD99:  ' ' 20 59          BRA   $DDF4 ; 
                   // FCB   $59                     ; DD9A:  'Y' 59             ROLB  ; 
                   // FCB   $4F                     ; DD9B:  'O' 4F             CLRA  ; 
                   // FCB   $55                     ; DD9C:  'U' 55             Invalid ; 
                   // FCB   $52                     ; DD9D:  'R' 52             Invalid ; 
                   // FCB   $20                     ; DD9E:  ' ' 20 53          BRA   $DDF3 ; 
                   // FCB   $53                     ; DD9F:  'S' 53             COMB  ; 
                   // FCB   $48                     ; DDA0:  'H' 48             ASLA  ; 
                   // FCB   $49                     ; DDA1:  'I' 49             ROLA  ; 
                   // FCB   $45                     ; DDA2:  'E' 45             Invalid ; 
                   // FCB   $4C                     ; DDA3:  'L' 4C             INCA  ; 
                   // FCB   $44                     ; DDA4:  'D' 44             LSRA  ; 
                   // FCB   $AE                     ; DDA5:  ' ' AE 35          LDX   -11,Y ; 
                   // FCB   $4F                     ; DDCA:  'O' 4F             CLRA  ; 
                   // FCB   $55                     ; DDCB:  'U' 55             Invalid ; 
                   // FCB   $20                     ; DDCC:  ' ' 20 54          BRA   $DE22 ; 
                   // FCB   $54                     ; DDCD:  'T' 54             LSRB  ; 
                   // FCB   $4F                     ; DDCE:  'O' 4F             CLRA  ; 
                   // FCB   $20                     ; DDCF:  ' ' 20 53          BRA   $DE24 ; 
                   // FCB   $53                     ; DDD0:  'S' 53             COMB  ; 
                   // FCB   $54                     ; DDD1:  'T' 54             LSRB  ; 
                   // FCB   $4F                     ; DDD2:  'O' 4F             CLRA  ; 
                   // FCB   $50                     ; DDD3:  'P' 50             NEGB  ; 
                   // FCB   $20                     ; DDD4:  ' ' 20 54          BRA   $DE2A ; 
                   // FCB   $54                     ; DDD5:  'T' 54             LSRB  ; 
                   // FCB   $48                     ; DDD6:  'H' 48             ASLA  ; 
                   // FCB   $45                     ; DDD7:  'E' 45             Invalid ; 
                   // FCB   $20                     ; DDD8:  ' ' 20 45          BRA   $DE1F ; 
                   // FCB   $45                     ; DDD9:  'E' 45             Invalid ; 
                   // FCB   $4D                     ; DDDA:  'M' 4D             TSTA  ; 
                   // FCB   $50                     ; DDDB:  'P' 50             NEGB  ; 
                   // FCB   $49                     ; DDDC:  'I' 49             ROLA  ; 
                   // FCB   $52                     ; DDDD:  'R' 52             Invalid ; 
                   // FCB   $45                     ; DDDE:  'E' 45             Invalid ; 
                   // FCB   $20                     ; DDDF:  ' ' 20 42          BRA   $DE23 ; 
                   // FCB   $42                     ; DDE0:  'B' 42             Invalid ; 
                   // FCB   $59                     ; DDE1:  'Y' 59             ROLB  ; 
                   // FCB   $20                     ; DDE2:  ' ' 20 42          BRA   $DE26 ; 
                   // FCB   $42                     ; DDE3:  'B' 42             Invalid ; 
                   // FCB   $4C                     ; DDE4:  'L' 4C             INCA  ; 
                   // FCB   $4F                     ; DDE5:  'O' 4F             CLRA  ; 
                   // FCB   $57                     ; DDE6:  'W' 57             ASRB  ; 
                   // FCB   $49                     ; DDE7:  'I' 49             ROLA  ; 
                   // FCB   $4E                     ; DDE8:  'N' 4E             Invalid ; 
                   // FCB   $C7                     ; DDE9:  ' ' C7             Invalid ; 
                   // FCB   $55                     ; DDEA:  'U' 55             Invalid ; 
                   // FCB   $50                     ; DDEB:  'P' 50             NEGB  ; 
                   // FCB   $20                     ; DDEC:  ' ' 20 54          BRA   $DE42 ; 
                   // FCB   $54                     ; DDED:  'T' 54             LSRB  ; 
                   // FCB   $48                     ; DDEE:  'H' 48             ASLA  ; 
                   // FCB   $45                     ; DDEF:  'E' 45             Invalid ; 
                   // FCB   $20                     ; DDF0:  ' ' 20 44          BRA   $DE36 ; 
                   // FCB   $44                     ; DDF1:  'D' 44             LSRA  ; 
                   // FCB   $45                     ; DDF2:  'E' 45             Invalid ; 
                   // FCB   $41                     ; DDF3:  'A' 41             Invalid ; 
                   // FCB   $54                     ; DDF4:  'T' 54             LSRB  ; 
                   // FCB   $48                     ; DDF5:  'H' 48             ASLA  ; 
                   // FCB   $20                     ; DDF6:  ' ' 20 53          BRA   $DE4B ; 
                   // FCB   $53                     ; DDF7:  'S' 53             COMB  ; 
                   // FCB   $54                     ; DDF8:  'T' 54             LSRB  ; 
                   // FCB   $41                     ; DDF9:  'A' 41             Invalid ; 
                   // FCB   $52                     ; DDFA:  'R' 52             Invalid ; 
                   // FCB   $AE                     ; DDFB:  ' ' AE B6          LDX   [A,Y] ; 
                   // FCB   $B6                     ; DDFC:  ' ' B6 B7 B8       LDA   $B7B8 ; 
                   // FCB   $B9                     ; DDFF:  ' ' B9 53 43       ADCA  $5343 ; 
                   // FCB   $53                     ; DE00:  'S' 53             COMB  ; 
                   // FCB   $43                     ; DE01:  'C' 43             COMA  ; 
                   // FCB   $4F                     ; DE02:  'O' 4F             CLRA  ; 
                   // FCB   $52                     ; DE03:  'R' 52             Invalid ; 
                   // FCB   $49                     ; DE04:  'I' 49             ROLA  ; 
                   // FCB   $4E                     ; DE05:  'N' 4E             Invalid ; 
                   // FCB   $C7                     ; DE06:  ' ' C7             Invalid ; 
                   // FCB   $54                     ; DE07:  'T' 54             LSRB  ; 
                   // FCB   $49                     ; DE08:  'I' 49             ROLA  ; 
                   // FCB   $45                     ; DE09:  'E' 45             Invalid ; 
                   // FCB   $20                     ; DE0A:  ' ' 20 46          BRA   $DE52 ; 
                   // FCB   $46                     ; DE0B:  'F' 46             RORA  ; 
                   // FCB   $49                     ; DE0C:  'I' 49             ROLA  ; 
                   // FCB   $47                     ; DE0D:  'G' 47             ASRA  ; 
                   // FCB   $48                     ; DE0E:  'H' 48             ASLA  ; 
                   // FCB   $54                     ; DE0F:  'T' 54             LSRB  ; 
                   // FCB   $45                     ; DE10:  'E' 45             Invalid ; 
                   // FCB   $52                     ; DE11:  'R' 52             Invalid ; 
                   // FCB   $53                     ; DE12:  'S' 53             COMB  ; 
                   // FCB   $20                     ; DE13:  ' ' 20 20          BRA   $DE35 ; 
                   // FCB   $20                     ; DE14:  ' ' 20 20          BRA   $DE36 ; 
                   // FCB   $20                     ; DE15:  ' ' 20 20          BRA   $DE37 ; 
                   // FCB   $20                     ; DE16:  ' ' 20 20          BRA   $DE38 ; 
                   // FCB   $20                     ; DE17:  ' ' 20 20          BRA   $DE39 ; 
                   // FCB   $20                     ; DE18:  ' ' 20 20          BRA   $DE3A ; 
                   // FCB   $20                     ; DE19:  ' ' 20 20          BRA   $DE3B ; 
                   // FCB   $20                     ; DE1A:  ' ' 20 20          BRA   $DE3C ; 
                   // FCB   $20                     ; DE1B:  ' ' 20 20          BRA   $DE3D ; 
                   // FCB   $20                     ; DE1C:  ' ' 20 20          BRA   $DE3E ; 
                   // FCB   $20                     ; DE1D:  ' ' 20 20          BRA   $DE3F ; 
                   // FCB   $20                     ; DE1E:  ' ' 20 20          BRA   $DE40 ; 
                   // FCB   $20                     ; DE1F:  ' ' 20 20          BRA   $DE41 ; 
                   // FCB   $20                     ; DE20:  ' ' 20 20          BRA   $DE42 ; 
                   // FCB   $20                     ; DE21:  ' ' 20 20          BRA   $DE43 ; 
                   // FCB   $20                     ; DE22:  ' ' 20 20          BRA   $DE44 ; 
                   // FCB   $20                     ; DE23:  ' ' 20 31          BRA   $DE56 ; 
                   // FCB   $31                     ; DE24:  '1' 31 2C          LEAY  12,Y ; 
                   // FCB   $2C                     ; DE25:  ',' 2C 30          BGE   $DE57 ; 
                   // FCB   $30                     ; DE26:  '0' 30 30          LEAX  -16,Y ; 
                   // FCB   $30                     ; DE27:  '0' 30 B0          LEAX  ??? ; 
                   // FCB   $B0                     ; DE28:  ' ' B0 44 41       SUBA  $4441 ; 
                   // FCB   $20                     ; DE36:  ' ' 20 53          BRA   $DE8B ; 
                   // FCB   $53                     ; DE37:  'S' 53             COMB  ; 
                   // FCB   $48                     ; DE38:  'H' 48             ASLA  ; 
                   // FCB   $49                     ; DE39:  'I' 49             ROLA  ; 
                   // FCB   $50                     ; DE3A:  'P' 50             NEGB  ; 
                   // FCB   $20                     ; DE3B:  ' ' 20 20          BRA   $DE5D ; 
                   // FCB   $20                     ; DE3C:  ' ' 20 20          BRA   $DE5E ; 
                   // FCB   $20                     ; DE3D:  ' ' 20 20          BRA   $DE5F ; 
                   // FCB   $20                     ; DE3E:  ' ' 20 20          BRA   $DE60 ; 
                   // FCB   $20                     ; DE3F:  ' ' 20 20          BRA   $DE61 ; 
                   // FCB   $20                     ; DE40:  ' ' 20 20          BRA   $DE62 ; 
                   // FCB   $20                     ; DE41:  ' ' 20 20          BRA   $DE63 ; 
                   // FCB   $20                     ; DE42:  ' ' 20 20          BRA   $DE64 ; 
                   // FCB   $20                     ; DE43:  ' ' 20 20          BRA   $DE65 ; 
                   // FCB   $20                     ; DE44:  ' ' 20 20          BRA   $DE66 ; 
                   // FCB   $20                     ; DE45:  ' ' 20 32          BRA   $DE79 ; 
                   // FCB   $32                     ; DE46:  '2' 32 2C          LEAS  12,Y ; 
                   // FCB   $2C                     ; DE47:  ',' 2C 30          BGE   $DE79 ; 
                   // FCB   $30                     ; DE48:  '0' 30 30          LEAX  -16,Y ; 
                   // FCB   $30                     ; DE49:  '0' 30 B0          LEAX  ??? ; 
                   // FCB   $B0                     ; DE4A:  ' ' B0 4C 41       SUBA  $4C41 ; 
                   // FCB   $4C                     ; DE4B:  'L' 4C             INCA  ; 
                   // FCB   $41                     ; DE4C:  'A' 41             Invalid ; 
                   // FCB   $53                     ; DE4D:  'S' 53             COMB  ; 
                   // FCB   $45                     ; DE4E:  'E' 45             Invalid ; 
                   // FCB   $52                     ; DE4F:  'R' 52             Invalid ; 
                   // FCB   $20                     ; DE50:  ' ' 20 42          BRA   $DE94 ; 
                   // FCB   $42                     ; DE51:  'B' 42             Invalid ; 
                   // FCB   $55                     ; DE52:  'U' 55             Invalid ; 
                   // FCB   $4E                     ; DE53:  'N' 4E             Invalid ; 
                   // FCB   $4B                     ; DE54:  'K' 4B             Invalid ; 
                   // FCB   $45                     ; DE55:  'E' 45             Invalid ; 
                   // FCB   $52                     ; DE56:  'R' 52             Invalid ; 
                   // FCB   $53                     ; DE57:  'S' 53             COMB  ; 
                   // FCB   $20                     ; DE58:  ' ' 20 20          BRA   $DE7A ; 
                   // FCB   $20                     ; DE59:  ' ' 20 20          BRA   $DE7B ; 
                   // FCB   $20                     ; DE5A:  ' ' 20 20          BRA   $DE7C ; 
                   // FCB   $20                     ; DE5B:  ' ' 20 20          BRA   $DE7D ; 
                   // FCB   $20                     ; DE5C:  ' ' 20 20          BRA   $DE7E ; 
                   // FCB   $20                     ; DE5D:  ' ' 20 20          BRA   $DE7F ; 
                   // FCB   $20                     ; DE5E:  ' ' 20 20          BRA   $DE80 ; 
                   // FCB   $20                     ; DE5F:  ' ' 20 20          BRA   $DE81 ; 
                   // FCB   $20                     ; DE60:  ' ' 20 20          BRA   $DE82 ; 
                   // FCB   $20                     ; DE61:  ' ' 20 20          BRA   $DE83 ; 
                   // FCB   $20                     ; DE62:  ' ' 20 20          BRA   $DE84 ; 
                   // FCB   $20                     ; DE63:  ' ' 20 20          BRA   $DE85 ; 
                   // FCB   $20                     ; DE64:  ' ' 20 20          BRA   $DE86 ; 
                   // FCB   $20                     ; DE65:  ' ' 20 20          BRA   $DE87 ; 
                   // FCB   $20                     ; DE66:  ' ' 20 20          BRA   $DE88 ; 
                   // FCB   $20                     ; DE67:  ' ' 20 20          BRA   $DE89 ; 
                   // FCB   $20                     ; DE68:  ' ' 20 20          BRA   $DE8A ; 
                   // FCB   $20                     ; DE69:  ' ' 20 32          BRA   $DE9D ; 
                   // FCB   $32                     ; DE6A:  '2' 32 30          LEAS  -16,Y ; 
                   // FCB   $30                     ; DE6B:  '0' 30 B0          LEAX  ??? ; 
                   // FCB   $B0                     ; DE6C:  ' ' B0 4C 41       SUBA  $4C41 ; 
                   // FCB   $4C                     ; DE6D:  'L' 4C             INCA  ; 
                   // FCB   $41                     ; DE6E:  'A' 41             Invalid ; 
                   // FCB   $53                     ; DE6F:  'S' 53             COMB  ; 
                   // FCB   $45                     ; DE70:  'E' 45             Invalid ; 
                   // FCB   $52                     ; DE71:  'R' 52             Invalid ; 
                   // FCB   $20                     ; DE72:  ' ' 20 54          BRA   $DEC8 ; 
                   // FCB   $54                     ; DE73:  'T' 54             LSRB  ; 
                   // FCB   $4F                     ; DE74:  'O' 4F             CLRA  ; 
                   // FCB   $57                     ; DE75:  'W' 57             ASRB  ; 
                   // FCB   $45                     ; DE76:  'E' 45             Invalid ; 
                   // FCB   $52                     ; DE77:  'R' 52             Invalid ; 
                   // FCB   $53                     ; DE78:  'S' 53             COMB  ; 
                   // FCB   $20                     ; DE79:  ' ' 20 20          BRA   $DE9B ; 
                   // FCB   $20                     ; DE7A:  ' ' 20 20          BRA   $DE9C ; 
                   // FCB   $20                     ; DE7B:  ' ' 20 20          BRA   $DE9D ; 
                   // FCB   $20                     ; DE7C:  ' ' 20 20          BRA   $DE9E ; 
                   // FCB   $20                     ; DE7D:  ' ' 20 20          BRA   $DE9F ; 
                   // FCB   $20                     ; DE7E:  ' ' 20 20          BRA   $DEA0 ; 
                   // FCB   $20                     ; DE7F:  ' ' 20 20          BRA   $DEA1 ; 
                   // FCB   $20                     ; DE80:  ' ' 20 20          BRA   $DEA2 ; 
                   // FCB   $20                     ; DE81:  ' ' 20 20          BRA   $DEA3 ; 
                   // FCB   $20                     ; DE82:  ' ' 20 20          BRA   $DEA4 ; 
                   // FCB   $20                     ; DE83:  ' ' 20 20          BRA   $DEA5 ; 
                   // FCB   $20                     ; DE84:  ' ' 20 20          BRA   $DEA6 ; 
                   // FCB   $20                     ; DE85:  ' ' 20 20          BRA   $DEA7 ; 
                   // FCB   $20                     ; DE86:  ' ' 20 20          BRA   $DEA8 ; 
                   // FCB   $20                     ; DE87:  ' ' 20 20          BRA   $DEA9 ; 
                   // FCB   $20                     ; DE88:  ' ' 20 20          BRA   $DEAA ; 
                   // FCB   $20                     ; DE89:  ' ' 20 20          BRA   $DEAB ; 
                   // FCB   $20                     ; DE8A:  ' ' 20 20          BRA   $DEAC ; 
                   // FCB   $20                     ; DE8B:  ' ' 20 32          BRA   $DEBF ; 
                   // FCB   $32                     ; DE8C:  '2' 32 30          LEAS  -16,Y ; 
                   // FCB   $30                     ; DE8D:  '0' 30 B0          LEAX  ??? ; 
                   // FCB   $B0                     ; DE8E:  ' ' B0 54 52       SUBA  $5452 ; 
                   // FCB   $54                     ; DE8F:  'T' 54             LSRB  ; 
                   // FCB   $52                     ; DE90:  'R' 52             Invalid ; 
                   // FCB   $45                     ; DE91:  'E' 45             Invalid ; 
                   // FCB   $4E                     ; DE92:  'N' 4E             Invalid ; 
                   // FCB   $43                     ; DE93:  'C' 43             COMA  ; 
                   // FCB   $48                     ; DE94:  'H' 48             ASLA  ; 
                   // FCB   $20                     ; DE95:  ' ' 20 54          BRA   $DEEB ; 
                   // FCB   $54                     ; DE96:  'T' 54             LSRB  ; 
                   // FCB   $55                     ; DE97:  'U' 55             Invalid ; 
                   // FCB   $52                     ; DE98:  'R' 52             Invalid ; 
                   // FCB   $52                     ; DE99:  'R' 52             Invalid ; 
                   // FCB   $45                     ; DE9A:  'E' 45             Invalid ; 
                   // FCB   $54                     ; DE9B:  'T' 54             LSRB  ; 
                   // FCB   $53                     ; DE9C:  'S' 53             COMB  ; 
                   // FCB   $20                     ; DE9D:  ' ' 20 20          BRA   $DEBF ; 
                   // FCB   $20                     ; DE9E:  ' ' 20 20          BRA   $DEC0 ; 
                   // FCB   $20                     ; DE9F:  ' ' 20 20          BRA   $DEC1 ; 
                   // FCB   $20                     ; DEA0:  ' ' 20 20          BRA   $DEC2 ; 
                   // FCB   $20                     ; DEA1:  ' ' 20 20          BRA   $DEC3 ; 
                   // FCB   $20                     ; DEA2:  ' ' 20 20          BRA   $DEC4 ; 
                   // FCB   $20                     ; DEA3:  ' ' 20 20          BRA   $DEC5 ; 
                   // FCB   $20                     ; DEA4:  ' ' 20 20          BRA   $DEC6 ; 
                   // FCB   $20                     ; DEA5:  ' ' 20 20          BRA   $DEC7 ; 
                   // FCB   $20                     ; DEA6:  ' ' 20 20          BRA   $DEC8 ; 
                   // FCB   $20                     ; DEA7:  ' ' 20 20          BRA   $DEC9 ; 
                   // FCB   $20                     ; DEA8:  ' ' 20 20          BRA   $DECA ; 
                   // FCB   $20                     ; DEA9:  ' ' 20 20          BRA   $DECB ; 
                   // FCB   $20                     ; DEAA:  ' ' 20 20          BRA   $DECC ; 
                   // FCB   $20                     ; DEAB:  ' ' 20 20          BRA   $DECD ; 
                   // FCB   $20                     ; DEAC:  ' ' 20 20          BRA   $DECE ; 
                   // FCB   $20                     ; DEAD:  ' ' 20 31          BRA   $DEE0 ; 
                   // FCB   $31                     ; DEAE:  '1' 31 30          LEAY  -16,Y ; 
                   // FCB   $30                     ; DEAF:  '0' 30 B0          LEAX  ??? ; 
                   // FCB   $B0                     ; DEB0:  ' ' B0 46 49       SUBA  $4649 ; 
                   // FCB   $46                     ; DEB1:  'F' 46             RORA  ; 
                   // FCB   $49                     ; DEB2:  'I' 49             ROLA  ; 
                   // FCB   $52                     ; DEB3:  'R' 52             Invalid ; 
                   // FCB   $45                     ; DEB4:  'E' 45             Invalid ; 
                   // FCB   $42                     ; DEB5:  'B' 42             Invalid ; 
                   // FCB   $41                     ; DEB6:  'A' 41             Invalid ; 
                   // FCB   $4C                     ; DEB7:  'L' 4C             INCA  ; 
                   // FCB   $4C                     ; DEB8:  'L' 4C             INCA  ; 
                   // FCB   $53                     ; DEB9:  'S' 53             COMB  ; 
                   // FCB   $20                     ; DEBA:  ' ' 20 20          BRA   $DEDC ; 
                   // FCB   $20                     ; DEBB:  ' ' 20 20          BRA   $DEDD ; 
                   // FCB   $20                     ; DEBC:  ' ' 20 20          BRA   $DEDE ; 
                   // FCB   $20                     ; DEBD:  ' ' 20 20          BRA   $DEDF ; 
                   // FCB   $20                     ; DEBE:  ' ' 20 20          BRA   $DEE0 ; 
                   // FCB   $20                     ; DEBF:  ' ' 20 20          BRA   $DEE1 ; 
                   // FCB   $20                     ; DEC0:  ' ' 20 20          BRA   $DEE2 ; 
                   // FCB   $20                     ; DEC1:  ' ' 20 20          BRA   $DEE3 ; 
                   // FCB   $20                     ; DEC2:  ' ' 20 20          BRA   $DEE4 ; 
                   // FCB   $20                     ; DEC3:  ' ' 20 20          BRA   $DEE5 ; 
                   // FCB   $20                     ; DEC4:  ' ' 20 20          BRA   $DEE6 ; 
                   // FCB   $20                     ; DEC5:  ' ' 20 20          BRA   $DEE7 ; 
                   // FCB   $20                     ; DEC6:  ' ' 20 20          BRA   $DEE8 ; 
                   // FCB   $20                     ; DEC7:  ' ' 20 20          BRA   $DEE9 ; 
                   // FCB   $20                     ; DEC8:  ' ' 20 20          BRA   $DEEA ; 
                   // FCB   $20                     ; DEC9:  ' ' 20 20          BRA   $DEEB ; 
                   // FCB   $20                     ; DECA:  ' ' 20 20          BRA   $DEEC ; 
                   // FCB   $20                     ; DECB:  ' ' 20 20          BRA   $DEED ; 
                   // FCB   $20                     ; DECC:  ' ' 20 20          BRA   $DEEE ; 
                   // FCB   $20                     ; DECD:  ' ' 20 20          BRA   $DEEF ; 
                   // FCB   $20                     ; DECE:  ' ' 20 20          BRA   $DEF0 ; 
                   // FCB   $20                     ; DECF:  ' ' 20 20          BRA   $DEF1 ; 
                   // FCB   $20                     ; DED0:  ' ' 20 33          BRA   $DF05 ; 
                   // FCB   $33                     ; DED1:  '3' 33 B3          LEAU  [,--Y] ; 
                   // FCB   $B3                     ; DED2:  ' ' B3 45 58       SUBD  $4558 ; 
                   // FCB   $45                     ; DED3:  'E' 45             Invalid ; 
                   // FCB   $58                     ; DED4:  'X' 58             ASLB  ; 
                   // FCB   $48                     ; DED5:  'H' 48             ASLA  ; 
                   // FCB   $41                     ; DED6:  'A' 41             Invalid ; 
                   // FCB   $55                     ; DED7:  'U' 55             Invalid ; 
                   // FCB   $53                     ; DED8:  'S' 53             COMB  ; 
                   // FCB   $54                     ; DED9:  'T' 54             LSRB  ; 
                   // FCB   $20                     ; DEDA:  ' ' 20 50          BRA   $DF2C ; 
                   // FCB   $50                     ; DEDB:  'P' 50             NEGB  ; 
                   // FCB   $4F                     ; DEDC:  'O' 4F             CLRA  ; 
                   // FCB   $52                     ; DEDD:  'R' 52             Invalid ; 
                   // FCB   $54                     ; DEDE:  'T' 54             LSRB  ; 
                   // FCB   $20                     ; DEDF:  ' ' 20 20          BRA   $DF01 ; 
                   // FCB   $20                     ; DEE0:  ' ' 20 20          BRA   $DF02 ; 
                   // FCB   $20                     ; DEE1:  ' ' 20 20          BRA   $DF03 ; 
                   // FCB   $20                     ; DEE2:  ' ' 20 20          BRA   $DF04 ; 
                   // FCB   $20                     ; DEE3:  ' ' 20 20          BRA   $DF05 ; 
                   // FCB   $20                     ; DEE4:  ' ' 20 20          BRA   $DF06 ; 
                   // FCB   $20                     ; DEE5:  ' ' 20 20          BRA   $DF07 ; 
                   // FCB   $20                     ; DEE6:  ' ' 20 20          BRA   $DF08 ; 
                   // FCB   $20                     ; DEE7:  ' ' 20 20          BRA   $DF09 ; 
                   // FCB   $20                     ; DEE8:  ' ' 20 20          BRA   $DF0A ; 
                   // FCB   $20                     ; DEE9:  ' ' 20 20          BRA   $DF0B ; 
                   // FCB   $20                     ; DEEA:  ' ' 20 20          BRA   $DF0C ; 
                   // FCB   $20                     ; DEEB:  ' ' 20 20          BRA   $DF0D ; 
                   // FCB   $20                     ; DEEC:  ' ' 20 20          BRA   $DF0E ; 
                   // FCB   $20                     ; DEED:  ' ' 20 20          BRA   $DF0F ; 
                   // FCB   $20                     ; DEEE:  ' ' 20 32          BRA   $DF22 ; 
                   // FCB   $32                     ; DEEF:  '2' 32 35          LEAS  -11,Y ; 
                   // FCB   $35                     ; DEF0:  '5' 35 2C          PULS  Y,DP,B ; 
                   // FCB   $2C                     ; DEF1:  ',' 2C 30          BGE   $DF23 ; 
                   // FCB   $30                     ; DEF2:  '0' 30 30          LEAX  -16,Y ; 
                   // FCB   $30                     ; DEF3:  '0' 30 B0          LEAX  ??? ; 
                   // FCB   $B0                     ; DEF4:  ' ' B0 44 45       SUBA  $4445 ; 
                   // FCB   $44                     ; DEF5:  'D' 44             LSRA  ; 
                   // FCB   $45                     ; DEF6:  'E' 45             Invalid ; 
                   // FCB   $53                     ; DEF7:  'S' 53             COMB  ; 
                   // FCB   $54                     ; DEF8:  'T' 54             LSRB  ; 
                   // FCB   $52                     ; DEF9:  'R' 52             Invalid ; 
                   // FCB   $4F                     ; DEFA:  'O' 4F             CLRA  ; 
                   // FCB   $59                     ; DEFB:  'Y' 59             ROLB  ; 
                   // FCB   $49                     ; DEFC:  'I' 49             ROLA  ; 
                   // FCB   $4E                     ; DEFD:  'N' 4E             Invalid ; 
                   // FCB   $47                     ; DEFE:  'G' 47             ASRA  ; 
                   // FCB   $20                     ; DEFF:  ' ' 20 41          BRA   $DF42 ; 
                   // FCB   $41                     ; DF00:  'A' 41             Invalid ; 
                   // FCB   $4C                     ; DF01:  'L' 4C             INCA  ; 
                   // FCB   $4C                     ; DF02:  'L' 4C             INCA  ; 
                   // FCB   $20                     ; DF03:  ' ' 20 54          BRA   $DF59 ; 
                   // FCB   $54                     ; DF04:  'T' 54             LSRB  ; 
                   // FCB   $4F                     ; DF05:  'O' 4F             CLRA  ; 
                   // FCB   $57                     ; DF06:  'W' 57             ASRB  ; 
                   // FCB   $45                     ; DF07:  'E' 45             Invalid ; 
                   // FCB   $52                     ; DF08:  'R' 52             Invalid ; 
                   // FCB   $20                     ; DF09:  ' ' 20 54          BRA   $DF5F ; 
                   // FCB   $54                     ; DF0A:  'T' 54             LSRB  ; 
                   // FCB   $4F                     ; DF0B:  'O' 4F             CLRA  ; 
                   // FCB   $50                     ; DF0C:  'P' 50             NEGB  ; 
                   // FCB   $53                     ; DF0D:  'S' 53             COMB  ; 
                   // FCB   $20                     ; DF0E:  ' ' 20 20          BRA   $DF30 ; 
                   // FCB   $20                     ; DF0F:  ' ' 20 20          BRA   $DF31 ; 
                   // FCB   $20                     ; DF10:  ' ' 20 35          BRA   $DF47 ; 
                   // FCB   $35                     ; DF11:  '5' 35 30          PULS  Y,X ; 
                   // FCB   $30                     ; DF12:  '0' 30 2C          LEAX  12,Y ; 
                   // FCB   $2C                     ; DF13:  ',' 2C 30          BGE   $DF45 ; 
                   // FCB   $30                     ; DF14:  '0' 30 30          LEAX  -16,Y ; 
                   // FCB   $30                     ; DF15:  '0' 30 B0          LEAX  ??? ; 
                   // FCB   $B0                     ; DF16:  ' ' B0 53 45       SUBA  $5345 ; 
                   // FCB   $41                     ; DF62:  'A' 41             Invalid ; 
                   // FCB   $56                     ; DF63:  'V' 56             RORB  ; 
                   // FCB   $45                     ; DF64:  'E' 45             Invalid ; 
                   // FCB   $20                     ; DF65:  ' ' 20 B1          BRA   $DF18 ; 
                   // FCB   $B1                     ; DF66:  ' ' B1 57 41       CMPA  $5741 ; 
                   // FCB   $57                     ; DF67:  'W' 57             ASRB  ; 
                   // FCB   $41                     ; DF68:  'A' 41             Invalid ; 
                   // FCB   $56                     ; DF69:  'V' 56             RORB  ; 
                   // FCB   $45                     ; DF6A:  'E' 45             Invalid ; 
                   // FCB   $20                     ; DF6B:  ' ' 20 B3          BRA   $DF20 ; 
                   // FCB   $B3                     ; DF6C:  ' ' B3 57 41       SUBD  $5741 ; 
                   // FCB   $57                     ; DF6D:  'W' 57             ASRB  ; 
                   // FCB   $41                     ; DF6E:  'A' 41             Invalid ; 
                   // FCB   $56                     ; DF6F:  'V' 56             RORB  ; 
                   // FCB   $45                     ; DF70:  'E' 45             Invalid ; 
                   // FCB   $20                     ; DF71:  ' ' 20 B5          BRA   $DF28 ; 
                   // FCB   $B5                     ; DF72:  ' ' B5 42 4F       BITA  $424F ; 
                   // FCB   $30                     ; DF81:  '0' 30 30          LEAX  -16,Y ; 
                   // FCB   $30                     ; DF82:  '0' 30 2C          LEAX  12,Y ; 
                   // FCB   $2C                     ; DF83:  ',' 2C 30          BGE   $DFB5 ; 
                   // FCB   $30                     ; DF84:  '0' 30 30          LEAX  -16,Y ; 
                   // FCB   $30                     ; DF85:  '0' 30 B0          LEAX  ??? ; 
                   // FCB   $B0                     ; DF86:  ' ' B0 38 30       SUBA  $3830 ; 
                   // FCB   $38                     ; DF87:  '8' 38             Invalid ; 
                   // FCB   $30                     ; DF88:  '0' 30 30          LEAX  -16,Y ; 
                   // FCB   $30                     ; DF89:  '0' 30 2C          LEAX  12,Y ; 
                   // FCB   $2C                     ; DF8A:  ',' 2C 30          BGE   $DFBC ; 
                   // FCB   $30                     ; DF8B:  '0' 30 30          LEAX  -16,Y ; 
                   // FCB   $30                     ; DF8C:  '0' 30 B0          LEAX  ??? ; 
                   // FCB   $B0                     ; DF8D:  ' ' B0 4D 45       SUBA  $4D45 ; 
                   // FCB   $52                     ; E164:  'R' 52             Invalid ; 
                   // FCB   $45                     ; E165:  'E' 45             Invalid ; 
                   // FCB   $53                     ; E166:  'S' 53             COMB  ; 
                   // FCB   $45                     ; E167:  'E' 45             Invalid ; 
                   // FCB   $4E                     ; E168:  'N' 4E             Invalid ; 
                   // FCB   $43                     ; E169:  'C' 43             COMA  ; 
                   // FCB   $45                     ; E16A:  'E' 45             Invalid ; 
                   // FCB   $20                     ; E16B:  ' ' 20 49          BRA   $E1B6 ; 
                   // FCB   $49                     ; E16C:  'I' 49             ROLA  ; 
                   // FCB   $53                     ; E16D:  'S' 53             COMB  ; 
                   // FCB   $20                     ; E16E:  ' ' 20 46          BRA   $E1B6 ; 
                   // FCB   $46                     ; E16F:  'F' 46             RORA  ; 
                   // FCB   $45                     ; E170:  'E' 45             Invalid ; 
                   // FCB   $4C                     ; E171:  'L' 4C             INCA  ; 
                   // FCB   $54                     ; E172:  'T' 54             LSRB  ; 
                   // FCB   $20                     ; E173:  ' ' 20 57          BRA   $E1CC ; 
                   // FCB   $57                     ; E174:  'W' 57             ASRB  ; 
                   // FCB   $49                     ; E175:  'I' 49             ROLA  ; 
                   // FCB   $54                     ; E176:  'T' 54             LSRB  ; 
                   // FCB   $48                     ; E177:  'H' 48             ASLA  ; 
                   // FCB   $49                     ; E178:  'I' 49             ROLA  ; 
                   // FCB   $4E                     ; E179:  'N' 4E             Invalid ; 
                   // FCB   $20                     ; E17A:  ' ' 20 54          BRA   $E1D0 ; 
                   // FCB   $54                     ; E17B:  'T' 54             LSRB  ; 
                   // FCB   $48                     ; E17C:  'H' 48             ASLA  ; 
                   // FCB   $45                     ; E17D:  'E' 45             Invalid ; 
                   // FCB   $20                     ; E17E:  ' ' 20 46          BRA   $E1C6 ; 
                   // FCB   $46                     ; E17F:  'F' 46             RORA  ; 
                   // FCB   $4F                     ; E180:  'O' 4F             CLRA  ; 
                   // FCB   $52                     ; E181:  'R' 52             Invalid ; 
                   // FCB   $43                     ; E182:  'C' 43             COMA  ; 
                   // FCB   $45                     ; E183:  'E' 45             Invalid ; 
                   // FCB   $AE                     ; E184:  ' ' AE 54          LDX   -12,U ; 
                   // FCB   $45                     ; E1E9:  'E' 45             Invalid ; 
                   // FCB   $42                     ; E1EA:  'B' 42             Invalid ; 
                   // FCB   $45                     ; E1EB:  'E' 45             Invalid ; 
                   // FCB   $4C                     ; E1EC:  'L' 4C             INCA  ; 
                   // FCB   $4C                     ; E1ED:  'L' 4C             INCA  ; 
                   // FCB   $49                     ; E1EE:  'I' 49             ROLA  ; 
                   // FCB   $4F                     ; E1EF:  'O' 4F             CLRA  ; 
                   // FCB   $4E                     ; E1F0:  'N' 4E             Invalid ; 
                   // FCB   $20                     ; E1F1:  ' ' 20 54          BRA   $E247 ; 
                   // FCB   $54                     ; E1F2:  'T' 54             LSRB  ; 
                   // FCB   $4F                     ; E1F3:  'O' 4F             CLRA  ; 
                   // FCB   $20                     ; E1F4:  ' ' 20 53          BRA   $E249 ; 
                   // FCB   $53                     ; E1F5:  'S' 53             COMB  ; 
                   // FCB   $54                     ; E1F6:  'T' 54             LSRB  ; 
                   // FCB   $4F                     ; E1F7:  'O' 4F             CLRA  ; 
                   // FCB   $50                     ; E1F8:  'P' 50             NEGB  ; 
                   // FCB   $20                     ; E1F9:  ' ' 20 54          BRA   $E24F ; 
                   // FCB   $54                     ; E1FA:  'T' 54             LSRB  ; 
                   // FCB   $48                     ; E1FB:  'H' 48             ASLA  ; 
                   // FCB   $45                     ; E1FC:  'E' 45             Invalid ; 
                   // FCB   $20                     ; E1FD:  ' ' 20 45          BRA   $E244 ; 
                   // FCB   $45                     ; E1FE:  'E' 45             Invalid ; 
                   // FCB   $4D                     ; E1FF:  'M' 4D             TSTA  ; 
                   // FCB   $50                     ; E200:  'P' 50             NEGB  ; 
                   // FCB   $49                     ; E201:  'I' 49             ROLA  ; 
                   // FCB   $52                     ; E202:  'R' 52             Invalid ; 
                   // FCB   $45                     ; E203:  'E' 45             Invalid ; 
                   // FCB   $AE                     ; E204:  ' ' AE 54          LDX   -12,U ; 
                   // FCB   $54                     ; E205:  'T' 54             LSRB  ; 
                   // FCB   $48                     ; E206:  'H' 48             ASLA  ; 
                   // FCB   $45                     ; E207:  'E' 45             Invalid ; 
                   // FCB   $20                     ; E208:  ' ' 20 46          BRA   $E250 ; 
                   // FCB   $46                     ; E209:  'F' 46             RORA  ; 
                   // FCB   $4F                     ; E20A:  'O' 4F             CLRA  ; 
                   // FCB   $52                     ; E20B:  'R' 52             Invalid ; 
                   // FCB   $43                     ; E20C:  'C' 43             COMA  ; 
                   // FCB   $45                     ; E20D:  'E' 45             Invalid ; 
                   // FCB   $20                     ; E20E:  ' ' 20 57          BRA   $E267 ; 
                   // FCB   $57                     ; E20F:  'W' 57             ASRB  ; 
                   // FCB   $49                     ; E210:  'I' 49             ROLA  ; 
                   // FCB   $4C                     ; E211:  'L' 4C             INCA  ; 
                   // FCB   $4C                     ; E212:  'L' 4C             INCA  ; 
                   // FCB   $20                     ; E213:  ' ' 20 42          BRA   $E257 ; 
                   // FCB   $42                     ; E214:  'B' 42             Invalid ; 
                   // FCB   $45                     ; E215:  'E' 45             Invalid ; 
                   // FCB   $20                     ; E216:  ' ' 20 57          BRA   $E26F ; 
                   // FCB   $57                     ; E217:  'W' 57             ASRB  ; 
                   // FCB   $49                     ; E218:  'I' 49             ROLA  ; 
                   // FCB   $54                     ; E219:  'T' 54             LSRB  ; 
                   // FCB   $48                     ; E21A:  'H' 48             ASLA  ; 
                   // FCB   $20                     ; E21B:  ' ' 20 59          BRA   $E276 ; 
                   // FCB   $59                     ; E21C:  'Y' 59             ROLB  ; 
                   // FCB   $4F                     ; E21D:  'O' 4F             CLRA  ; 
                   // FCB   $55                     ; E21E:  'U' 55             Invalid ; 
                   // FCB   $AE                     ; E21F:  ' ' AE 41          LDX   1,U ; 
                   // FCB   $55                     ; E3DD:  'U' 55             Invalid ; 
                   // FCB   $4C                     ; E3DE:  'L' 4C             INCA  ; 
                   // FCB   $4C                     ; E3DF:  'L' 4C             INCA  ; 
                   // FCB   $20                     ; E3E0:  ' ' 20 4C          BRA   $E42E ; 
                   // FCB   $4C                     ; E3E1:  'L' 4C             INCA  ; 
                   // FCB   $45                     ; E3E2:  'E' 45             Invalid ; 
                   // FCB   $46                     ; E3E3:  'F' 46             RORA  ; 
                   // FCB   $54                     ; E3E4:  'T' 54             LSRB  ; 
                   // FCB   $20                     ; E3E5:  ' ' 20 46          BRA   $E42D ; 
                   // FCB   $46                     ; E3E6:  'F' 46             RORA  ; 
                   // FCB   $49                     ; E3E7:  'I' 49             ROLA  ; 
                   // FCB   $52                     ; E3E8:  'R' 52             Invalid ; 
                   // FCB   $45                     ; E3E9:  'E' 45             Invalid ; 
                   // FCB   $20                     ; E3EA:  ' ' 20 54          BRA   $E440 ; 
                   // FCB   $54                     ; E3EB:  'T' 54             LSRB  ; 
                   // FCB   $4F                     ; E3EC:  'O' 4F             CLRA  ; 
                   // FCB   $20                     ; E3ED:  ' ' 20 43          BRA   $E432 ; 
                   // FCB   $43                     ; E3EE:  'C' 43             COMA  ; 
                   // FCB   $48                     ; E3EF:  'H' 48             ASLA  ; 
                   // FCB   $41                     ; E3F0:  'A' 41             Invalid ; 
                   // FCB   $4E                     ; E3F1:  'N' 4E             Invalid ; 
                   // FCB   $47                     ; E3F2:  'G' 47             ASRA  ; 
                   // FCB   $45                     ; E3F3:  'E' 45             Invalid ; 
                   // FCB   $20                     ; E3F4:  ' ' 20 53          BRA   $E449 ; 
                   // FCB   $53                     ; E3F5:  'S' 53             COMB  ; 
                   // FCB   $45                     ; E3F6:  'E' 45             Invalid ; 
                   // FCB   $54                     ; E3F7:  'T' 54             LSRB  ; 
                   // FCB   $54                     ; E3F8:  'T' 54             LSRB  ; 
                   // FCB   $49                     ; E3F9:  'I' 49             ROLA  ; 
                   // FCB   $4E                     ; E3FA:  'N' 4E             Invalid ; 
                   // FCB   $C7                     ; E3FB:  ' ' C7             Invalid ; 
                   // FCB   $B2                     ; E41F:  ' ' B2 B1 B4       SBCA  $B1B4 ; 
                   // FCB   $B1                     ; E420:  ' ' B1 B4 B5       CMPA  $B4B5 ; 
                   // FCB   $B4                     ; E421:  ' ' B4 B5 B6       ANDA  $B5B6 ; 
                   // FCB   $B5                     ; E422:  ' ' B5 B6 4E       BITA  $B64E ; 
                   // FCB   $B6                     ; E423:  ' ' B6 4E 4F       LDA   $4E4F ; 
                   // FCB   $20                     ; E429:  ' ' 20 47          BRA   $E472 ; 
                   // FCB   $47                     ; E42A:  'G' 47             ASRA  ; 
                   // FCB   $49                     ; E42B:  'I' 49             ROLA  ; 
                   // FCB   $56                     ; E42C:  'V' 56             RORB  ; 
                   // FCB   $45                     ; E42D:  'E' 45             Invalid ; 
                   // FCB   $53                     ; E42E:  'S' 53             COMB  ; 
                   // FCB   $20                     ; E42F:  ' ' 20 B1          BRA   $E3E2 ; 
                   // FCB   $B1                     ; E430:  ' ' B1 34 20       CMPA  $3420 ; 
                   // FCB   $34                     ; E431:  '4' 34 20          PSHS  Y ; 
                   // FCB   $20                     ; E432:  ' ' 20 47          BRA   $E47B ; 
                   // FCB   $47                     ; E433:  'G' 47             ASRA  ; 
                   // FCB   $49                     ; E434:  'I' 49             ROLA  ; 
                   // FCB   $56                     ; E435:  'V' 56             RORB  ; 
                   // FCB   $45                     ; E436:  'E' 45             Invalid ; 
                   // FCB   $53                     ; E437:  'S' 53             COMB  ; 
                   // FCB   $20                     ; E438:  ' ' 20 B1          BRA   $E3EB ; 
                   // FCB   $B1                     ; E439:  ' ' B1 34 20       CMPA  $3420 ; 
                   // FCB   $34                     ; E43A:  '4' 34 20          PSHS  Y ; 
                   // FCB   $20                     ; E43B:  ' ' 20 47          BRA   $E484 ; 
                   // FCB   $47                     ; E43C:  'G' 47             ASRA  ; 
                   // FCB   $49                     ; E43D:  'I' 49             ROLA  ; 
                   // FCB   $56                     ; E43E:  'V' 56             RORB  ; 
                   // FCB   $45                     ; E43F:  'E' 45             Invalid ; 
                   // FCB   $53                     ; E440:  'S' 53             COMB  ; 
                   // FCB   $20                     ; E441:  ' ' 20 B2          BRA   $E3F5 ; 
                   // FCB   $B2                     ; E442:  ' ' B2 35 20       SBCA  $3520 ; 
                   // FCB   $35                     ; E443:  '5' 35 20          PULS  Y ; 
                   // FCB   $20                     ; E444:  ' ' 20 47          BRA   $E48D ; 
                   // FCB   $47                     ; E445:  'G' 47             ASRA  ; 
                   // FCB   $49                     ; E446:  'I' 49             ROLA  ; 
                   // FCB   $56                     ; E447:  'V' 56             RORB  ; 
                   // FCB   $45                     ; E448:  'E' 45             Invalid ; 
                   // FCB   $53                     ; E449:  'S' 53             COMB  ; 
                   // FCB   $20                     ; E44A:  ' ' 20 B1          BRA   $E3FD ; 
                   // FCB   $B1                     ; E44B:  ' ' B1 33 20       CMPA  $3320 ; 
                   // FCB   $33                     ; E44C:  '3' 33 20          LEAU  0,Y ; 
                   // FCB   $20                     ; E44D:  ' ' 20 47          BRA   $E496 ; 
                   // FCB   $47                     ; E44E:  'G' 47             ASRA  ; 
                   // FCB   $49                     ; E44F:  'I' 49             ROLA  ; 
                   // FCB   $56                     ; E450:  'V' 56             RORB  ; 
                   // FCB   $45                     ; E451:  'E' 45             Invalid ; 
                   // FCB   $53                     ; E452:  'S' 53             COMB  ; 
                   // FCB   $20                     ; E453:  ' ' 20 B1          BRA   $E406 ; 
                   // FCB   $B1                     ; E454:  ' ' B1 4E 4F       CMPA  $4E4F ; 
                   // FCB   $B9                     ; E45C:  ' ' B9 45 41       ADCA  $4541 ; 
                   // FCB   $B1                     ; E475:  ' ' B1 B2 B3       CMPA  $B2B3 ; 
                   // FCB   $B2                     ; E476:  ' ' B2 B3 59       SBCA  $B359 ; 
                   // FCB   $B3                     ; E477:  ' ' B3 59 45       SUBD  $5945 ; 
                   // FCB   $50                     ; E4C1:  'P' 50             NEGB  ; 
                   // FCB   $41                     ; E4C2:  'A' 41             Invalid ; 
                   // FCB   $52                     ; E4C3:  'R' 52             Invalid ; 
                   // FCB   $45                     ; E4C4:  'E' 45             Invalid ; 
                   // FCB   $20                     ; E4C5:  ' ' 20 B1          BRA   $E478 ; 
                   // FCB   $B1                     ; E4C6:  ' ' B1 53 45       CMPA  $5345 ; 
                   // FCB   $49                     ; E4E6:  'I' 49             ROLA  ; 
                   // FCB   $47                     ; E4E7:  'G' 47             ASRA  ; 
                   // FCB   $48                     ; E4E8:  'H' 48             ASLA  ; 
                   // FCB   $54                     ; E4E9:  'T' 54             LSRB  ; 
                   // FCB   $20                     ; E4EA:  ' ' 20 43          BRA   $E52F ; 
                   // FCB   $43                     ; E4EB:  'C' 43             COMA  ; 
                   // FCB   $4F                     ; E4EC:  'O' 4F             CLRA  ; 
                   // FCB   $49                     ; E4ED:  'I' 49             ROLA  ; 
                   // FCB   $CE                     ; E4EE:  ' ' CE A0 4C       LDU   #$A04C ; 
                   // FCB   $A0                     ; E4EF:  ' ' A0 4C          SUBA  12,U ; 
                   // FCB   $50                     ; E506:  'P' 50             NEGB  ; 
                   // FCB   $41                     ; E507:  'A' 41             Invalid ; 
                   // FCB   $52                     ; E508:  'R' 52             Invalid ; 
                   // FCB   $45                     ; E509:  'E' 45             Invalid ; 
                   // FCB   $20                     ; E50A:  ' ' 20 B2          BRA   $E4BE ; 
                   // FCB   $B2                     ; E50B:  ' ' B2 A0 50       SBCA  $A050 ; 
                   // FCB   $A0                     ; E50C:  ' ' A0 50          SUBA  -16,U ; 
                   // FCB   $41                     ; E549:  'A' 41             Invalid ; 
                   // FCB   $54                     ; E54A:  'T' 54             LSRB  ; 
                   // FCB   $48                     ; E54B:  'H' 48             ASLA  ; 
                   // FCB   $20                     ; E54C:  ' ' 20 52          BRA   $E5A0 ; 
                   // FCB   $52                     ; E54D:  'R' 52             Invalid ; 
                   // FCB   $41                     ; E54E:  'A' 41             Invalid ; 
                   // FCB   $4D                     ; E54F:  'M' 4D             TSTA  ; 
                   // FCB   $20                     ; E550:  ' ' 20 41          BRA   $E593 ; 
                   // FCB   $41                     ; E551:  'A' 41             Invalid ; 
                   // FCB   $54                     ; E552:  'T' 54             LSRB  ; 
                   // FCB   $20                     ; E553:  ' ' 20 35          BRA   $E58A ; 
                   // FCB   $35                     ; E554:  '5' 35 C6          PULS  PC,U,B,A ; 
                   // FCB   $C6                     ; E555:  ' ' C6 4D          LDB   #$4D ; 
                   // FCB   $47                     ; E565:  'G' 47             ASRA  ; 
                   // FCB   $20                     ; E566:  ' ' 20 52          BRA   $E5BA ; 
                   // FCB   $52                     ; E567:  'R' 52             Invalid ; 
                   // FCB   $41                     ; E568:  'A' 41             Invalid ; 
                   // FCB   $4D                     ; E569:  'M' 4D             TSTA  ; 
                   // FCB   $30                     ; E56A:  '0' 30 20          LEAX  0,Y ; 
                   // FCB   $20                     ; E56B:  ' ' 20 41          BRA   $E5AE ; 
                   // FCB   $41                     ; E56C:  'A' 41             Invalid ; 
                   // FCB   $54                     ; E56D:  'T' 54             LSRB  ; 
                   // FCB   $20                     ; E56E:  ' ' 20 33          BRA   $E5A3 ; 
                   // FCB   $33                     ; E56F:  '3' 33 CC 56       LEAU  $56,PC ; 
                   // FCB   $CC                     ; E570:  ' ' CC 56 47       LDD   #$5647 ; 
                   // FCB   $47                     ; E58C:  'G' 47             ASRA  ; 
                   // FCB   $20                     ; E58D:  ' ' 20 52          BRA   $E5E1 ; 
                   // FCB   $52                     ; E58E:  'R' 52             Invalid ; 
                   // FCB   $41                     ; E58F:  'A' 41             Invalid ; 
                   // FCB   $4D                     ; E590:  'M' 4D             TSTA  ; 
                   // FCB   $33                     ; E591:  '3' 33 20          LEAU  0,Y ; 
                   // FCB   $20                     ; E592:  ' ' 20 41          BRA   $E5D5 ; 
                   // FCB   $41                     ; E593:  'A' 41             Invalid ; 
                   // FCB   $54                     ; E594:  'T' 54             LSRB  ; 
                   // FCB   $20                     ; E595:  ' ' 20 34          BRA   $E5CB ; 
                   // FCB   $34                     ; E596:  '4' 34 CC          PSHS  PC,U,DP,B ; 
                   // FCB   $CC                     ; E597:  ' ' CC 56 47       LDD   #$5647 ; 
                   // FCB   $52                     ; E5C9:  'R' 52             Invalid ; 
                   // FCB   $4F                     ; E5CA:  'O' 4F             CLRA  ; 
                   // FCB   $47                     ; E5CB:  'G' 47             ASRA  ; 
                   // FCB   $52                     ; E5CC:  'R' 52             Invalid ; 
                   // FCB   $41                     ; E5CD:  'A' 41             Invalid ; 
                   // FCB   $4D                     ; E5CE:  'M' 4D             TSTA  ; 
                   // FCB   $20                     ; E5CF:  ' ' 20 52          BRA   $E623 ; 
                   // FCB   $52                     ; E5D0:  'R' 52             Invalid ; 
                   // FCB   $4F                     ; E5D1:  'O' 4F             CLRA  ; 
                   // FCB   $4D                     ; E5D2:  'M' 4D             TSTA  ; 
                   // FCB   $30                     ; E5D3:  '0' 30 20          LEAX  0,Y ; 
                   // FCB   $20                     ; E5D4:  ' ' 20 41          BRA   $E617 ; 
                   // FCB   $41                     ; E5D5:  'A' 41             Invalid ; 
                   // FCB   $54                     ; E5D6:  'T' 54             LSRB  ; 
                   // FCB   $20                     ; E5D7:  ' ' 20 31          BRA   $E60A ; 
                   // FCB   $31                     ; E5D8:  '1' 31 C6          LEAY  A,U ; 
                   // FCB   $C6                     ; E5D9:  ' ' C6 50          LDB   #$50 ; 
                   // FCB   $52                     ; E601:  'R' 52             Invalid ; 
                   // FCB   $4F                     ; E602:  'O' 4F             CLRA  ; 
                   // FCB   $47                     ; E603:  'G' 47             ASRA  ; 
                   // FCB   $52                     ; E604:  'R' 52             Invalid ; 
                   // FCB   $41                     ; E605:  'A' 41             Invalid ; 
                   // FCB   $4D                     ; E606:  'M' 4D             TSTA  ; 
                   // FCB   $20                     ; E607:  ' ' 20 52          BRA   $E65B ; 
                   // FCB   $52                     ; E608:  'R' 52             Invalid ; 
                   // FCB   $4F                     ; E609:  'O' 4F             CLRA  ; 
                   // FCB   $4D                     ; E60A:  'M' 4D             TSTA  ; 
                   // FCB   $33                     ; E60B:  '3' 33 20          LEAU  0,Y ; 
                   // FCB   $20                     ; E60C:  ' ' 20 41          BRA   $E64F ; 
                   // FCB   $41                     ; E60D:  'A' 41             Invalid ; 
                   // FCB   $54                     ; E60E:  'T' 54             LSRB  ; 
                   // FCB   $20                     ; E60F:  ' ' 20 31          BRA   $E642 ; 
                   // FCB   $31                     ; E610:  '1' 31 4B          LEAY  11,U ; 
                   // FCB   $4B                     ; E611:  'K' 4B             Invalid ; 
                   // FCB   $CC                     ; E612:  ' ' CC 50 52       LDD   #$5052 ; 
                   // FCB   $47                     ; E626:  'G' 47             ASRA  ; 
                   // FCB   $20                     ; E627:  ' ' 20 52          BRA   $E67B ; 
                   // FCB   $52                     ; E628:  'R' 52             Invalid ; 
                   // FCB   $4F                     ; E629:  'O' 4F             CLRA  ; 
                   // FCB   $4D                     ; E62A:  'M' 4D             TSTA  ; 
                   // FCB   $20                     ; E62B:  ' ' 20 41          BRA   $E66E ; 
                   // FCB   $41                     ; E62C:  'A' 41             Invalid ; 
                   // FCB   $54                     ; E62D:  'T' 54             LSRB  ; 
                   // FCB   $20                     ; E62E:  ' ' 20 31          BRA   $E661 ; 
                   // FCB   $31                     ; E62F:  '1' 31 CC 4D       LEAY  $4D,PC ; 
                   // FCB   $CC                     ; E630:  ' ' CC 4D 41       LDD   #$4D41 ; 
                   // FCB   $4F                     ; E6E9:  'O' 4F             CLRA  ; 
                   // FCB   $46                     ; E6EA:  'F' 46             RORA  ; 
                   // FCB   $C6                     ; E6EB:  ' ' C6 31          LDB   #$31 ; 
    // =============== S U B R O U T I N E =======================================
  case 0xE764:
LE764:
                                                     #ifdef DEBUG
                                      mon("LE764    LDA   ,X                      ; E764: A6 84         \n");
                                      #endif
    PC = 0xe764; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(X); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Display_Vect_BCD        ; E766: BD E7 90      \n");
                                      #endif // Display BCD numbers
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x69); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xe7); 
    clockticks = clockticks + 1; 
    goto LE790;
  case 0xE769:
LE769:
                                                     #ifdef DEBUG
                                      mon("LE769    LDA   <$AD                    ; E769: 96 AD         \n");
                                      #endif
    PC = 0xe769; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xad); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BGT   LE772                   ; E76B: 2E 05         \n");
                                      #endif // Display BCD number text
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto LE772;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$B913                  ; E76D: CC B9 13      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xb9; 
    B = 0x13; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
    // End of function sub_E764
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; E770: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
    // =============== S U B R O U T I N E =======================================
    // Display BCD number text
  case 0xE772:
LE772:
                                                     #ifdef DEBUG
                                      mon("LE772    LDA   $01,X                   ; E772: A6 01         \n");
                                      #endif
    PC = 0xe772; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0001)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Display_Vect_BCD        ; E774: BD E7 90      \n");
                                      #endif // Display BCD numbers
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x77); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xe7); 
    clockticks = clockticks + 1; 
    goto LE790;
  case 0xE777:
LE777:
                                                     #ifdef DEBUG
                                      mon("LE777    LDA   $02,X                   ; E777: A6 02         \n");
                                      #endif
    PC = 0xe777; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0002)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; E779: 44            \n");
                                      #endif
    val = (UINT8)A; 
 // C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; E77A: 44            \n");
                                      #endif
    val = (UINT8)A; 
 // C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; E77B: 44            \n");
                                      #endif
    val = (UINT8)A; 
 // C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; E77C: 44            \n");
                                      #endif
    val = (UINT8)A; 
    C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LE7AD                   ; E77D: BD E7 AD      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x80); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xe7); 
    clockticks = clockticks + 1; 
    goto LE7AD;
  case 0xE780:
LE780:
                                                     #ifdef DEBUG
                                      mon("LE780    LDA   <$AD                    ; E780: 96 AD         \n");
                                      #endif
    PC = 0xe780; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xad); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BGT   LE789                   ; E782: 2E 05         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto LE789;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$B913                  ; E784: CC B9 13      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xb9; 
    B = 0x13; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; E787: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
  case 0xE789:
LE789:
                                                     #ifdef DEBUG
                                      mon("LE789    LDA   $02,X                   ; E789: A6 02         \n");
                                      #endif
    PC = 0xe789; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0002)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LE7AD                   ; E78B: BD E7 AD      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x8e); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xe7); 
    clockticks = clockticks + 1; 
    goto LE7AD;
    // End of function sub_E772
  case 0xE78E:
LE78E:
                                                     #ifdef DEBUG
                                      mon("LE78E    LDA   $03,X                   ; E78E: A6 03         \n");
                                      #endif
    PC = 0xe78e; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0003)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
    // =============== S U B R O U T I N E =======================================
    // Display BCD numbers
  case 0xE790:
LE790:
Display_Vect_BCD:
                                                     #ifdef DEBUG
                                      mon("Display_Vect_BCD TFR   A,B                     ; E790: 1F 89         \n");
                                      #endif
    PC = 0xe790; 
    INSTRUCTION_START
    B = (UINT8)A; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         LSRB                          ; E792: 54            \n");
                                      #endif
    val = (UINT8)B; 
 // C = val & 1; 
    val = val >> 1; 
    B = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRB                          ; E793: 54            \n");
                                      #endif
    val = (UINT8)B; 
 // C = val & 1; 
    val = val >> 1; 
    B = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRB                          ; E794: 54            \n");
                                      #endif
    val = (UINT8)B; 
    C = val & 1; 
    val = val >> 1; 
    B = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$1E                    ; E795: C4 1E         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x1e; 
    B = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LE7A2                   ; E797: 26 09         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LE7A2;
    }
                                                     #ifdef DEBUG
                                      mon("         TST   <$AD                    ; E799: 0D AD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xad); 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BLE   LE7A2                   ; E79B: 2F 05         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto LE7A2;
    }
                                                     #ifdef DEBUG
                                      mon("         LDU   $3002                   ; E79D: FE 30 02      \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x3002)<<8; 
    ea = ea | rd_mem(0x3003); 
    U = ea; 
    Z = U; 
    N = (U) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LE7A9                   ; E7A0: 20 07         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LE7A9;
    
    // ---------------------------------------------------------------------------
  case 0xE7A2:
LE7A2:
                                                     #ifdef DEBUG
                                      mon("LE7A2    CLR   <$AD                    ; E7A2: 0F AD         \n");
                                      #endif
    PC = 0xe7a2; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    wr_mem(DP|0xad, 0); 
 // V = 0; 
 // Z = 0; 
 // N = 0; 
 // C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #$3004                  ; E7A4: CE 30 04      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x3004; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   B,U                     ; E7A7: EE C5         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + (SINT8)B))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + (SINT8)B))+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0xE7A9:
LE7A9:
                                                     #ifdef DEBUG
                                      mon("LE7A9    DEC   <$AD                    ; E7A9: 0A AD         \n");
                                      #endif
    PC = 0xe7a9; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xad); 
    res = (UINT8)(val - 1); 
 // N = res; 
 // Z = res; 
 // V = val & ~res; 
    wr_mem(DP|0xad, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STU   ,Y++                    ; E7AB: EF A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
    Y = Y + 2; 
  case 0xE7AD:
LE7AD:
                                                     #ifdef DEBUG
                                      mon("LE7AD    ASLA                          ; E7AD: 48            \n");
                                      #endif
    PC = 0xe7ad; 
    INSTRUCTION_START
    val = (UINT8)A; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$1E                    ; E7AE: 84 1E         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x1e; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LE7BB                   ; E7B0: 26 09         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LE7BB;
    }
                                                     #ifdef DEBUG
                                      mon("         TST   <$AD                    ; E7B2: 0D AD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xad); 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BLE   LE7BB                   ; E7B4: 2F 05         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto LE7BB;
    }
                                                     #ifdef DEBUG
                                      mon("         LDU   $3002                   ; E7B6: FE 30 02      \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x3002)<<8; 
    ea = ea | rd_mem(0x3003); 
    U = ea; 
    Z = U; 
    N = (U) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LE7C2                   ; E7B9: 20 07         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LE7C2;
    
    // ---------------------------------------------------------------------------
  case 0xE7BB:
LE7BB:
                                                     #ifdef DEBUG
                                      mon("LE7BB    CLR   <$AD                    ; E7BB: 0F AD         \n");
                                      #endif
    PC = 0xe7bb; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    wr_mem(DP|0xad, 0); 
 // V = 0; 
 // Z = 0; 
 // N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #$3004                  ; E7BD: CE 30 04      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x3004; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   A,U                     ; E7C0: EE C6         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + (SINT8)A))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + (SINT8)A))+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0xE7C2:
LE7C2:
                                                     #ifdef DEBUG
                                      mon("LE7C2    DEC   <$AD                    ; E7C2: 0A AD         \n");
                                      #endif
    PC = 0xe7c2; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xad); 
    res = (UINT8)(val - 1); 
 // N = res; 
 // Z = res; 
 // V = val & ~res; 
    wr_mem(DP|0xad, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STU   ,Y++                    ; E7C4: EF A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    val = U; 
    Z = val; 
    N = (UINT8)(val >> 8); 
    V = 0; 
    ea = Y; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
    Y = Y + 2; 
    // End of function Display_Vect_BCD
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; E7C6: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Print text string from pointer table
  case 0xE7C7:
LE7C7:
                                                     #ifdef DEBUG
                                      mon("LE7C7    CMPB  #$D6                    ; E7C7: C1 D6         \n");
                                      #endif
    PC = 0xe7c7; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0xd6; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCC   locret_E7D2             ; E7C9: 24 07         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LE7D2;
    }
                                                     #ifdef DEBUG
                                      mon("         STB   $48AE                   ; E7CB: F7 48 AE      \n");
                                      #endif // Text string index
    clockticks = clockticks + 5; 
    val = B; 
    Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x48ae, val); 
                                                     #ifdef DEBUG
                                      mon("         BSR   LE7DD                   ; E7CE: 8D 0D         \n");
                                      #endif // Insert text colour vector instruction
    --S;
    wr_mem(S, 0xd0); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xe7); 
    clockticks = clockticks + 1; 
    clockticks = clockticks + 7; 
    goto LE7DD;
  case 0xE7D0:
LE7D0:
                                                     #ifdef DEBUG
                                      mon("LE7D0    BSR   LE7EA                   ; E7D0: 8D 18         \n");
                                      #endif // Insert text position vector instruction
    PC = 0xe7d0; 
    INSTRUCTION_START
    --S;
    wr_mem(S, 0xd2); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xe7); 
    clockticks = clockticks + 1; 
    clockticks = clockticks + 7; 
    goto LE7EA;
    // End of function sub_E7C7
  case 0xE7D2:
LE7D2:
locret_E7D2:
                                                     #ifdef DEBUG
                                      mon("locret_E7D2 RTS                           ; E7D2: 39            \n");
                                      #endif
    PC = 0xe7d2; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xE7D3:
LE7D3:
                                                     #ifdef DEBUG
                                      mon("LE7D3    CMPB  #$D6                    ; E7D3: C1 D6         \n");
                                      #endif
    PC = 0xe7d3; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0xd6; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCC   locret_E7DC             ; E7D5: 24 05         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LE7DC;
    }
                                                     #ifdef DEBUG
                                      mon("         STB   $48AE                   ; E7D7: F7 48 AE      \n");
                                      #endif // Text string index
    clockticks = clockticks + 5; 
    val = B; 
    Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x48ae, val); 
                                                     #ifdef DEBUG
                                      mon("         BSR   LE7EA                   ; E7DA: 8D 0E         \n");
                                      #endif // Insert text position vector instruction
    --S;
    wr_mem(S, 0xdc); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xe7); 
    clockticks = clockticks + 1; 
    clockticks = clockticks + 7; 
    goto LE7EA;
    // End of function sub_E7D3
  case 0xE7DC:
LE7DC:
locret_E7DC:
                                                     #ifdef DEBUG
                                      mon("locret_E7DC RTS                           ; E7DC: 39            \n");
                                      #endif
    PC = 0xe7dc; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Insert text colour vector instruction
  case 0xE7DD:
LE7DD:
                                                     #ifdef DEBUG
                                      mon("LE7DD    LDB   $48AE                   ; E7DD: F6 48 AE      \n");
                                      #endif // Text string index
    PC = 0xe7dd; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x48ae); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #word_EDA8              ; E7E0: 8E ED A8      \n");
                                      #endif // Text string colour
    clockticks = clockticks + 3; 
    X = 0xeda8; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; E7E3: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; E7E4: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         LDD   ,X                      ; E7E5: EC 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(X); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(X+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; E7E7: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
    // End of function sub_E7DD
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; E7E9: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Insert text position vector instruction
  case 0xE7EA:
LE7EA:
                                                     #ifdef DEBUG
                                      mon("LE7EA    LDB   $48AE                   ; E7EA: F6 48 AE      \n");
                                      #endif // Text string index
    PC = 0xe7ea; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x48ae); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #word_EA50              ; E7ED: 8E EA 50      \n");
                                      #endif // Text string position
    clockticks = clockticks + 3; 
    X = 0xea50; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; E7F0: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; E7F1: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; E7F2: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; E7F3: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         LDD   $02,X                   ; E7F4: EC 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + 0x0002); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; E7F6: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   ,X                      ; E7F8: EC 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(X); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(X+1)); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LE811                   ; E7FA: 20 15         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LE811;
    
    // ---------------------------------------------------------------------------
  case 0xE7FC:
LE7FC:
                                                     #ifdef DEBUG
                                      mon("LE7FC    LDB   $48AE                   ; E7FC: F6 48 AE      \n");
                                      #endif // Text string index
    PC = 0xe7fc; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x48ae); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #word_EA50              ; E7FF: 8E EA 50      \n");
                                      #endif // Text string position
    clockticks = clockticks + 3; 
    X = 0xea50; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; E802: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; E803: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; E804: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; E805: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         LDD   $02,X                   ; E806: EC 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + 0x0002); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $48AF                   ; E808: B3 48 AF      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x48af)<<8; 
    ea = ea | rd_mem(0x48b0); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$1F                    ; E80B: 84 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x1f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; E80D: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   ,X                      ; E80F: EC 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(X); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(X+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0xE811:
LE811:
                                                     #ifdef DEBUG
                                      mon("LE811    STD   ,Y++                    ; E811: ED A1         \n");
                                      #endif
    PC = 0xe811; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LE821                   ; E813: BD E8 21      \n");
                                      #endif // Text handling
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x16); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xe8); 
    clockticks = clockticks + 1; 
    goto LE821;
  case 0xE816:
LE816:
                                                     #ifdef DEBUG
                                      mon("LE816    LDD   #$7200                  ; E816: CC 72 00      \n");
                                      #endif // Vector SCAL 2,0 instruction
    PC = 0xe816; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x72; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; E819: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$8040                  ; E81B: CC 80 40      \n");
                                      #endif // Vector CNTR instruction
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; E81E: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
    // End of function sub_E7EA
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; E820: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Text handling
  case 0xE821:
LE821:
                                                     #ifdef DEBUG
                                      mon("LE821    LDX   #ptrText                ; E821: 8E E8 94      \n");
                                      #endif
    PC = 0xe821; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0xe894; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $48AE                   ; E824: F6 48 AE      \n");
                                      #endif // Text string index
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x48ae); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; E827: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; E828: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         LDX   ,X                      ; E829: AE 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xE82B:
LE82B:
                                                     #ifdef DEBUG
                                      mon("LE82B    LDB   ,X+                     ; E82B: E6 80         \n");
                                      #endif
    PC = 0xe82b; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    val = (UINT8)rd_mem(X); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
    X = X + 1; 
                                                     #ifdef DEBUG
                                      mon("         STX   $48B1                   ; E82D: BF 48 B1      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = X; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    wr_mem(0x48b1, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem(0x48b2, (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; E830: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$82                    ; E831: C1 82         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x82; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   LE83C                   ; E833: 25 07         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LE83C;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   #$3016                  ; E835: 8E 30 16      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x3016; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$7F                    ; E838: C4 7F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x7f; 
    B = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LE888                   ; E83A: 20 4C         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LE888;
    
    // ---------------------------------------------------------------------------
  case 0xE83C:
LE83C:
                                                     #ifdef DEBUG
                                      mon("LE83C    CMPB  #$74                    ; E83C: C1 74         \n");
                                      #endif
    PC = 0xe83c; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x74; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   LE845                   ; E83E: 26 05         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LE845;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   #$2FDE                  ; E840: 8E 2F DE      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x2fde; 
    Z = X; 
    N = (X) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LE888                   ; E843: 20 43         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LE888;
    
    // ---------------------------------------------------------------------------
  case 0xE845:
LE845:
                                                     #ifdef DEBUG
                                      mon("LE845    CMPB  #$80                    ; E845: C1 80         \n");
                                      #endif
    PC = 0xe845; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x80; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   LE84F                   ; E847: 26 06         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LE84F;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   #$3058                  ; E849: 8E 30 58      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x3058; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CLRB                          ; E84C: 5F            \n");
                                      #endif
    B = 0; // SEARCH_ME
    V = 0; 
    Z = 0; 
    N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LE888                   ; E84D: 20 39         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LE888;
    
    // ---------------------------------------------------------------------------
  case 0xE84F:
LE84F:
                                                     #ifdef DEBUG
                                      mon("LE84F    CMPB  #$60                    ; E84F: C1 60         \n");
                                      #endif
    PC = 0xe84f; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x60; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   LE858                   ; E851: 25 05         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LE858;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   #$2FA4                  ; E853: 8E 2F A4      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x2fa4; 
    Z = X; 
    N = (X) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LE888                   ; E856: 20 30         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LE888;
    
    // ---------------------------------------------------------------------------
  case 0xE858:
LE858:
                                                     #ifdef DEBUG
                                      mon("LE858    CMPB  #$40                    ; E858: C1 40         \n");
                                      #endif
    PC = 0xe858; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x40; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   LE861                   ; E85A: 26 05         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LE861;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   #$2FC2                  ; E85C: 8E 2F C2      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x2fc2; 
    Z = X; 
    N = (X) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LE888                   ; E85F: 20 27         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LE888;
    
    // ---------------------------------------------------------------------------
  case 0xE861:
LE861:
                                                     #ifdef DEBUG
                                      mon("LE861    CMPB  #$4E                    ; E861: C1 4E         \n");
                                      #endif
    PC = 0xe861; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x4e; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   LE86A                   ; E863: 26 05         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LE86A;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   #$2FFE                  ; E865: 8E 2F FE      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x2ffe; 
    Z = X; 
    N = (X) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LE888                   ; E868: 20 1E         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LE888;
    
    // ---------------------------------------------------------------------------
  case 0xE86A:
LE86A:
                                                     #ifdef DEBUG
                                      mon("LE86A    CMPB  #$58                    ; E86A: C1 58         \n");
                                      #endif
    PC = 0xe86a; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x58; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   LE873                   ; E86C: 26 05         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LE873;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   #$2FF6                  ; E86E: 8E 2F F6      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x2ff6; 
    Z = X; 
    N = (X) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LE888                   ; E871: 20 15         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LE888;
    
    // ---------------------------------------------------------------------------
  case 0xE873:
LE873:
                                                     #ifdef DEBUG
                                      mon("LE873    CMPB  #$5A                    ; E873: C1 5A         \n");
                                      #endif
    PC = 0xe873; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x5a; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   LE87C                   ; E875: 26 05         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LE87C;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   #$3000                  ; E877: 8E 30 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x3000; 
    Z = X; 
    N = (X) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LE888                   ; E87A: 20 0C         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LE888;
    
    // ---------------------------------------------------------------------------
  case 0xE87C:
LE87C:
                                                     #ifdef DEBUG
                                      mon("LE87C    CMPB  #$4A                    ; E87C: C1 4A         \n");
                                      #endif
    PC = 0xe87c; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x4a; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   LE885                   ; E87E: 26 05         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LE885;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   #$300C                  ; E880: 8E 30 0C      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x300c; 
    Z = X; 
    N = (X) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LE888                   ; E883: 20 03         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LE888;
    
    // ---------------------------------------------------------------------------
  case 0xE885:
LE885:
                                                     #ifdef DEBUG
                                      mon("LE885    LDX   #$2FF4                  ; E885: 8E 2F F4      \n");
                                      #endif
    PC = 0xe885; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x2ff4; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xE888:
LE888:
                                                     #ifdef DEBUG
                                      mon("LE888    LDD   B,X                     ; E888: EC 85         \n");
                                      #endif
    PC = 0xe888; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + (SINT8)B); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; E88A: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDX   $48B1                   ; E88C: BE 48 B1      \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x48b1)<<8; 
    ea = ea | rd_mem(0x48b2); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         TST   -1,X                    ; E88F: 6D 1F         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0xffff)); 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LE82B                   ; E891: 2A 98         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LE82B;
    }
    // End of function sub_E821
    // ---------------------------------------------------------------------------
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; E893: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Attributes: noreturn
    // End of function BADIRQ
  case 0xEF54:
LEF54:
BADIRQ:
                                                     #ifdef DEBUG
                                      mon("BADIRQ   BRA   BADIRQ                  ; EF54: 20 FE         \n");
                                      #endif // public BADIRQ
    PC = 0xef54; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto LEF54;
    
    // =============== S U B R O U T I N E =======================================
  case 0xEF56:
LEF56:
IRQ:
                                                     #ifdef DEBUG
                                      mon("IRQ      LDX   $0A,S                   ; EF56: AE 6A         \n");
                                      #endif // public IRQ
    PC = 0xef56; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(S + 0x000a))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(S + 0x000a))+1)); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$6000                  ; EF58: 8C 60 00      \n");
                                      #endif // Bounds check for return address in ROM
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x6000; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCC   LEF5E                   ; EF5B: 24 01         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LEF5E;
    }
                                                     #ifdef DEBUG
                                      mon("         SWI                           ; EF5D: 3F            \n");
                                      #endif
    clockticks = clockticks + 19; 
    --S;
    wr_mem(S, 0x5e); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xef); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, U); 
    --S;
    wr_mem(S, U >> 8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, Y); 
    --S;
    wr_mem(S, Y >> 8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, X); 
    --S;
    wr_mem(S, X >> 8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, (DP >> 8)); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, B); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, A); 
    clockticks = clockticks + 1; 
    simplify_flags();
    CC = (((((((((((((E<<1) | F)<<1) | H)<<1) |I)<<1) | N)<<1) | Z)<<1) | V)<<1) | C; // Placeholder for now
    restore_flags();
    --S;
    wr_mem(S, CC); 
    clockticks = clockticks + 1; 
    PC = (rd_mem(0xfffa)<<8)|rd_mem(0xfffb); 
    JUMP;
  case 0xEF5E:
LEF5E:
                                                     #ifdef DEBUG
                                      mon("LEF5E    CMPX  #BADIRQ                 ; EF5E: 8C EF 54      \n");
                                      #endif // Only allow IRQ calls from lower in ROM than BADIRQ function
    PC = 0xef5e; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0xef54; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LEF64                   ; EF61: 25 01         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LEF64;
    }
                                                     #ifdef DEBUG
                                      mon("         SWI                           ; EF63: 3F            \n");
                                      #endif
    clockticks = clockticks + 19; 
    --S;
    wr_mem(S, 0x64); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xef); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, U); 
    --S;
    wr_mem(S, U >> 8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, Y); 
    --S;
    wr_mem(S, Y >> 8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, X); 
    --S;
    wr_mem(S, X >> 8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, (DP >> 8)); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, B); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, A); 
    clockticks = clockticks + 1; 
    simplify_flags();
    CC = (((((((((((((E<<1) | F)<<1) | H)<<1) |I)<<1) | N)<<1) | Z)<<1) | V)<<1) | C; // Placeholder for now
    restore_flags();
    --S;
    wr_mem(S, CC); 
    clockticks = clockticks + 1; 
    PC = (rd_mem(0xfffa)<<8)|rd_mem(0xfffb); 
    JUMP;
  case 0xEF64:
LEF64:
                                                     #ifdef DEBUG
                                      mon("LEF64    LDA   #$48                    ; EF64: 86 48         \n");
                                      #endif
    PC = 0xef64; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x48; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         TFR   A,DP                    ; EF66: 1F 8B         \n");
                                      #endif
    DP = (A) << 8; checkDP(); 
    // memory_DP = &memory[DP];
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4640                   ; EF68: B7 46 40      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4640, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$00                    ; EF6B: 96 00         \n");
                                      #endif // Check sanity byte is $3F
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x00); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$3F                    ; EF6D: 81 3F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x3f; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LEF72                   ; EF6F: 27 01         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LEF72;
    }
                                                     #ifdef DEBUG
                                      mon("         SWI                           ; EF71: 3F            \n");
                                      #endif
    clockticks = clockticks + 19; 
    --S;
    wr_mem(S, 0x72); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xef); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, U); 
    --S;
    wr_mem(S, U >> 8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, Y); 
    --S;
    wr_mem(S, Y >> 8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, X); 
    --S;
    wr_mem(S, X >> 8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, (DP >> 8)); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, B); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, A); 
    clockticks = clockticks + 1; 
    simplify_flags();
    CC = (((((((((((((E<<1) | F)<<1) | H)<<1) |I)<<1) | N)<<1) | Z)<<1) | V)<<1) | C; // Placeholder for now
    restore_flags();
    --S;
    wr_mem(S, CC); 
    clockticks = clockticks + 1; 
    PC = (rd_mem(0xfffa)<<8)|rd_mem(0xfffb); 
    JUMP;
  case 0xEF72:
LEF72:
                                                     #ifdef DEBUG
                                      mon("LEF72    DEC   <$3E                    ; EF72: 0A 3E         \n");
                                      #endif
    PC = 0xef72; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x3e); 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    wr_mem(DP|0x3e, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LEF7F                   ; EF74: 2A 09         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LEF7F;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$0B                    ; EF76: 86 0B         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x0b; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$3E                    ; EF78: 97 3E         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x3e; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         INC   <$3D                    ; EF7A: 0C 3D         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x3d); 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    wr_mem(DP|0x3d, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BVC   LEF7F                   ; EF7C: 28 01         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)V >= 0) {
    clockticks = clockticks + 3; 
    goto LEF7F;
    }
                                                     #ifdef DEBUG
                                      mon("         SWI                           ; EF7E: 3F            \n");
                                      #endif
    clockticks = clockticks + 19; 
    --S;
    wr_mem(S, 0x7f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xef); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, U); 
    --S;
    wr_mem(S, U >> 8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, Y); 
    --S;
    wr_mem(S, Y >> 8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, X); 
    --S;
    wr_mem(S, X >> 8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, (DP >> 8)); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, B); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, A); 
    clockticks = clockticks + 1; 
    simplify_flags();
    CC = (((((((((((((E<<1) | F)<<1) | H)<<1) |I)<<1) | N)<<1) | Z)<<1) | V)<<1) | C; // Placeholder for now
    restore_flags();
    --S;
    wr_mem(S, CC); 
    clockticks = clockticks + 1; 
    PC = (rd_mem(0xfffa)<<8)|rd_mem(0xfffb); 
    JUMP;
  case 0xEF7F:
LEF7F:
                                                     #ifdef DEBUG
                                      mon("LEF7F    INC   <$0A                    ; EF7F: 0C 0A         \n");
                                      #endif
    PC = 0xef7f; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x0a); 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    wr_mem(DP|0x0a, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LD776                   ; EF81: BD D7 76      \n");
                                      #endif // Check coin inputs
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x84); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xef); 
    clockticks = clockticks + 1; 
    goto LD776;
  case 0xEF84:
LEF84:
                                                     #ifdef DEBUG
                                      mon("LEF84    LDA   <$14                    ; EF84: 96 14         \n");
                                      #endif // Credits
    PC = 0xef84; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x14); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$24                    ; EF86: 81 24         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x24; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   LEF8B                   ; EF88: 25 01         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LEF8B;
    }
                                                     #ifdef DEBUG
                                      mon("         SWI                           ; EF8A: 3F            \n");
                                      #endif
    clockticks = clockticks + 19; 
    --S;
    wr_mem(S, 0x8b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xef); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, U); 
    --S;
    wr_mem(S, U >> 8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, Y); 
    --S;
    wr_mem(S, Y >> 8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, X); 
    --S;
    wr_mem(S, X >> 8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, (DP >> 8)); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, B); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, A); 
    clockticks = clockticks + 1; 
    simplify_flags();
    CC = (((((((((((((E<<1) | F)<<1) | H)<<1) |I)<<1) | N)<<1) | Z)<<1) | V)<<1) | C; // Placeholder for now
    restore_flags();
    --S;
    wr_mem(S, CC); 
    clockticks = clockticks + 1; 
    PC = (rd_mem(0xfffa)<<8)|rd_mem(0xfffb); 
    JUMP;
  case 0xEF8B:
LEF8B:
                                                     #ifdef DEBUG
                                      mon("LEF8B    LDX   #$481C                  ; EF8B: 8E 48 1C      \n");
                                      #endif
    PC = 0xef8b; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x481c; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4300                   ; EF8E: B6 43 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4300); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LF133                   ; EF91: BD F1 33      \n");
                                      #endif // Inputs debounce
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x94); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xef); 
    clockticks = clockticks + 1; 
    goto LF133;
  case 0xEF94:
LEF94:
                                                     #ifdef DEBUG
                                      mon("LEF94    LDA   $4320                   ; EF94: B6 43 20      \n");
                                      #endif
    PC = 0xef94; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4320); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LF133                   ; EF97: BD F1 33      \n");
                                      #endif // Inputs debounce
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x9a); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xef); 
    clockticks = clockticks + 1; 
    goto LF133;
  case 0xEF9A:
LEF9A:
                                                     #ifdef DEBUG
                                      mon("LEF9A    LDA   $4340                   ; EF9A: B6 43 40      \n");
                                      #endif
    PC = 0xef9a; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4340); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LF133                   ; EF9D: BD F1 33      \n");
                                      #endif // Inputs debounce
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xa0); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xef); 
    clockticks = clockticks + 1; 
    goto LF133;
  case 0xEFA0:
LEFA0:
                                                     #ifdef DEBUG
                                      mon("LEFA0    LDA   $4360                   ; EFA0: B6 43 60      \n");
                                      #endif
    PC = 0xefa0; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4360); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LF133                   ; EFA3: BD F1 33      \n");
                                      #endif // Inputs debounce
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xa6); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xef); 
    clockticks = clockticks + 1; 
    goto LF133;
  case 0xEFA6:
LEFA6:
                                                     #ifdef DEBUG
                                      mon("LEFA6    LDA   <$33                    ; EFA6: 96 33         \n");
                                      #endif
    PC = 0xefa6; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x33); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$34                    ; EFA8: 97 34         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x34; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4821                   ; EFAA: B6 48 21      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4821); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$30                    ; EFAD: 84 30         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x30; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   -1,S                    ; EFAF: A7 7F         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(S + 0xffff); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $481E                   ; EFB1: B6 48 1E      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x481e); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$CF                    ; EFB4: 84 CF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0xcf; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORA   -1,S                    ; EFB6: AA 7F         \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = A | (UINT8)rd_mem((UINT16)(S + 0xffff)); 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$33                    ; EFB8: 97 33         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x33; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         EORA  <$34                    ; EFBA: 98 34         \n");
                                      #endif
    clockticks = clockticks + 4; 
    res = A ^ rd_mem(DP|0x34); 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  <$34                    ; EFBC: 94 34         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)A; 
    res = val & rd_mem(DP|0x34); 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$32                    ; EFBE: 97 32         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x32; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$32                    ; EFC0: 96 32         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x32); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$F0                    ; EFC2: 84 F0         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0xf0; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LEFCA                   ; EFC4: 27 04         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LEFCA;
    }
                                                     #ifdef DEBUG
                                      mon("         ORA   <$31                    ; EFC6: 9A 31         \n");
                                      #endif
    clockticks = clockticks + 4; 
    res = A | (UINT8)rd_mem(DP|0x31); 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$31                    ; EFC8: 97 31         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x31; 
    wr_mem(ea, val); 
  case 0xEFCA:
LEFCA:
                                                     #ifdef DEBUG
                                      mon("LEFCA    JSR   LF146                   ; EFCA: BD F1 46      \n");
                                      #endif // Joystick processing
    PC = 0xefca; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xcd); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xef); 
    clockticks = clockticks + 1; 
    goto LF146;
  case 0xEFCD:
LEFCD:
                                                     #ifdef DEBUG
                                      mon("LEFCD    LDA   <$0A                    ; EFCD: 96 0A         \n");
                                      #endif
    PC = 0xefcd; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x0a); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LEFE6                   ; EFCF: 26 15         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LEFE6;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4401                   ; EFD1: B6 44 01      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4401); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLA                          ; EFD4: 48            \n");
                                      #endif
    val = (UINT8)A; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
    Z = res; 
    N = res; 
    V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LEFDE                   ; EFD5: 2A 07         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LEFDE;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4400                   ; EFD7: B6 44 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4400); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$5A                    ; EFDA: 81 5A         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x5a; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LEFE6                   ; EFDC: 27 08         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LEFE6;
    }
  case 0xEFDE:
LEFDE:
                                                     #ifdef DEBUG
                                      mon("LEFDE    STA   $46E0                   ; EFDE: B7 46 E0      \n");
                                      #endif
    PC = 0xefde; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x46e0, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; EFE1: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4400                   ; EFE3: B7 44 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4400, val); 
  case 0xEFE6:
LEFE6:
                                                     #ifdef DEBUG
                                      mon("LEFE6    LDA   <$0A                    ; EFE6: 96 0A         \n");
                                      #endif
    PC = 0xefe6; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x0a); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$03                    ; EFE8: 84 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x03; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LF034                   ; EFEA: 26 48         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LF034;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $481B                   ; EFEC: B6 48 1B      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x481b); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDA  #$01                    ; EFEF: 8B 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x01; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$FA                    ; EFF1: 81 FA         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xfa; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   LEFF7                   ; EFF3: 25 02         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LEFF7;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; EFF5: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xEFF7:
LEFF7:
                                                     #ifdef DEBUG
                                      mon("LEFF7    STA   $481B                   ; EFF7: B7 48 1B      \n");
                                      #endif
    PC = 0xeff7; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x481b, val); 
                                                     #ifdef DEBUG
                                      mon("         BNE   LF034                   ; EFFA: 26 38         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LF034;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $481A                   ; EFFC: B6 48 1A      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x481a); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDA  #$01                    ; EFFF: 8B 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x01; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         DAA                           ; F001: 19            \n");
                                      #endif
    res = A; 
    msn = res & 0xf0; 
    lsn = res & 0x0f; 
    res = res + (((lsn > 0x09) || (H & 0x10)) ? 0x06 : 0); 
    res = res + ((((UINT8)msn > 0x80U) && ((UINT8)lsn > 0x09U)) || (((UINT8)msn > 0x90U) || (C != 0)) ? 0x60 : 0); 
    C = C | (res & 0x100); 
    res = (UINT8)res; 
    A = res; 
 // N = res; 
 // Z = res; 
 // V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $481A                   ; F002: B7 48 1A      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x481a, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4819                   ; F005: B6 48 19      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4819); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADCA  #$00                    ; F008: 89 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    arg = A; 
    val = (SINT8)0x00; 
    res = arg + val + (C != 0 ? 1:0); 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = arg ^ val ^ (UINT8)res ^ C; 
 // V = arg ^ val ^ (UINT8)res ^ C; 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         DAA                           ; F00A: 19            \n");
                                      #endif
    res = A; 
    msn = res & 0xf0; 
    lsn = res & 0x0f; 
    res = res + (((lsn > 0x09) || (H & 0x10)) ? 0x06 : 0); 
    res = res + ((((UINT8)msn > 0x80U) && ((UINT8)lsn > 0x09U)) || (((UINT8)msn > 0x90U) || (C != 0)) ? 0x60 : 0); 
    C = C | (res & 0x100); 
    res = (UINT8)res; 
    A = res; 
    N = res; 
    Z = res; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LF010                   ; F00B: 25 03         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LF010;
    }
                                                     #ifdef DEBUG
                                      mon("         STA   $4819                   ; F00D: B7 48 19      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4819, val); 
  case 0xF010:
LF010:
                                                     #ifdef DEBUG
                                      mon("LF010    LDA   $4B07                   ; F010: B6 4B 07      \n");
                                      #endif
    PC = 0xf010; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b07); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDA  #$01                    ; F013: 8B 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x01; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         DAA                           ; F015: 19            \n");
                                      #endif
    res = A; 
    msn = res & 0xf0; 
    lsn = res & 0x0f; 
    res = res + (((lsn > 0x09) || (H & 0x10)) ? 0x06 : 0); 
    res = res + ((((UINT8)msn > 0x80U) && ((UINT8)lsn > 0x09U)) || (((UINT8)msn > 0x90U) || (C != 0)) ? 0x60 : 0); 
    C = C | (res & 0x100); 
    res = (UINT8)res; 
    A = res; 
 // N = res; 
 // Z = res; 
 // V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B07                   ; F016: B7 4B 07      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b07, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B06                   ; F019: B6 4B 06      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b06); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADCA  #$00                    ; F01C: 89 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    arg = A; 
    val = (SINT8)0x00; 
    res = arg + val + (C != 0 ? 1:0); 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = arg ^ val ^ (UINT8)res ^ C; 
 // V = arg ^ val ^ (UINT8)res ^ C; 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         DAA                           ; F01E: 19            \n");
                                      #endif
    res = A; 
    msn = res & 0xf0; 
    lsn = res & 0x0f; 
    res = res + (((lsn > 0x09) || (H & 0x10)) ? 0x06 : 0); 
    res = res + ((((UINT8)msn > 0x80U) && ((UINT8)lsn > 0x09U)) || (((UINT8)msn > 0x90U) || (C != 0)) ? 0x60 : 0); 
    C = C | (res & 0x100); 
    res = (UINT8)res; 
    A = res; 
 // N = res; 
 // Z = res; 
 // V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B06                   ; F01F: B7 4B 06      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b06, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B05                   ; F022: B6 4B 05      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b05); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADCA  #$00                    ; F025: 89 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    arg = A; 
    val = (SINT8)0x00; 
    res = arg + val + (C != 0 ? 1:0); 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = arg ^ val ^ (UINT8)res ^ C; 
 // V = arg ^ val ^ (UINT8)res ^ C; 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         DAA                           ; F027: 19            \n");
                                      #endif
    res = A; 
    msn = res & 0xf0; 
    lsn = res & 0x0f; 
    res = res + (((lsn > 0x09) || (H & 0x10)) ? 0x06 : 0); 
    res = res + ((((UINT8)msn > 0x80U) && ((UINT8)lsn > 0x09U)) || (((UINT8)msn > 0x90U) || (C != 0)) ? 0x60 : 0); 
    C = C | (res & 0x100); 
    res = (UINT8)res; 
    A = res; 
 // N = res; 
 // Z = res; 
 // V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B05                   ; F028: B7 4B 05      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b05, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B04                   ; F02B: B6 4B 04      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b04); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADCA  #$00                    ; F02E: 89 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    arg = A; 
    val = (SINT8)0x00; 
    res = arg + val + (C != 0 ? 1:0); 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = arg ^ val ^ (UINT8)res ^ C; 
 // V = arg ^ val ^ (UINT8)res ^ C; 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         DAA                           ; F030: 19            \n");
                                      #endif
    res = A; 
    msn = res & 0xf0; 
    lsn = res & 0x0f; 
    res = res + (((lsn > 0x09) || (H & 0x10)) ? 0x06 : 0); 
    res = res + ((((UINT8)msn > 0x80U) && ((UINT8)lsn > 0x09U)) || (((UINT8)msn > 0x90U) || (C != 0)) ? 0x60 : 0); 
    C = C | (res & 0x100); 
    res = (UINT8)res; 
    A = res; 
 // N = res; 
 // Z = res; 
 // V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B04                   ; F031: B7 4B 04      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b04, val); 
  case 0xF034:
LF034:
                                                     #ifdef DEBUG
                                      mon("LF034    DEC   <$40                    ; F034: 0A 40         \n");
                                      #endif
    PC = 0xf034; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x40); 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    wr_mem(DP|0x40, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BVC   LF041                   ; F036: 28 09         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)V >= 0) {
    clockticks = clockticks + 3; 
    goto LF041;
    }
                                                     #ifdef DEBUG
                                      mon("         STA   $4620                   ; F038: B7 46 20      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x4620, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   $611E                   ; F03B: BD 61 1E      \n");
                                      #endif // Copies Star Wars logo vector data to vector RAM
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x3e); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xf0); 
    clockticks = clockticks + 1; 
    PC = 0x611e; 
    JUMP;
  case 0xF03E:
LF03E:
                                                     #ifdef DEBUG
                                      mon("LF03E    JMP   LF12F                   ; F03E: 7E F1 2F      \n");
                                      #endif
    PC = 0xf03e; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    goto LF12F;
    
    // ---------------------------------------------------------------------------
  case 0xF041:
LF041:
                                                     #ifdef DEBUG
                                      mon("LF041    LBPL  LF12F                   ; F041: 10 2A 00 EA   \n");
                                      #endif
    PC = 0xf041; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 1; 
    goto LF12F;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4320                   ; F045: B6 43 20      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4320); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLA                          ; F048: 48            \n");
                                      #endif
    val = (UINT8)A; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
    Z = res; 
    N = res; 
    V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LBPL  LF12F                   ; F049: 10 2A 00 E2   \n");
                                      #endif // If VGHALT is high, VG is ready
    clockticks = clockticks + 5; 
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 1; 
    goto LF12F;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   <$3F                    ; F04D: 96 3F         \n");
                                      #endif // Vector pointer state
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x3f); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LF06A                   ; F04F: 2A 19         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LF06A;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $00                     ; F051: B6 00 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x0000); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$0A                    ; F054: 84 0A         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x0a; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LF05A                   ; F056: 27 02         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LF05A;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$14                    ; F058: 86 14         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x14; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xF05A:
LF05A:
                                                     #ifdef DEBUG
                                      mon("LF05A    ORA   #$00                    ; F05A: 8A 00         \n");
                                      #endif // What the heck is going on here???
    PC = 0xf05a; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    res = A | (UINT8)0x00; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$3F                    ; F05C: 97 3F         \n");
                                      #endif // Vector pointer state
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x3f; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$38                    ; F05E: C6 38         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x38; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; F060: 44            \n");
                                      #endif
    val = (UINT8)A; 
    C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$0A                    ; F061: 84 0A         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x0a; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         EORA  #$0A                    ; F063: 88 0A         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A ^ (SINT8)0x0a; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORA   #$E0                    ; F065: 8A E0         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A | (UINT8)0xe0; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $00                     ; F067: FD 00 00      \n");
                                      #endif // Seems to toggle vector address $0000 from $E038 and $EA38 JMPL $038 and $A38
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x0000, A); // Care needed with I/O space and word fetches
    wr_mem(0x0001, B); 
  case 0xF06A:
LF06A:
                                                     #ifdef DEBUG
                                      mon("LF06A    DEC   <$28                    ; F06A: 0A 28         \n");
                                      #endif
    PC = 0xf06a; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x28); 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    wr_mem(DP|0x28, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LF073                   ; F06C: 2A 05         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LF073;
    }
                                                     #ifdef DEBUG
                                      mon("         CLR   <$28                    ; F06E: 0F 28         \n");
                                      #endif
    clockticks = clockticks + 4; 
    wr_mem(DP|0x28, 0); 
 // V = 0; 
 // Z = 0; 
 // N = 0; 
 // C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LF18D                   ; F070: BD F1 8D      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xf0); 
    clockticks = clockticks + 1; 
    goto LF18D;
  case 0xF073:
LF073:
                                                     #ifdef DEBUG
                                      mon("LF073    JSR   LF22B                   ; F073: BD F2 2B      \n");
                                      #endif
    PC = 0xf073; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x76); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xf0); 
    clockticks = clockticks + 1; 
    goto LF22B;
  case 0xF076:
LF076:
                                                     #ifdef DEBUG
                                      mon("LF076    LDB   <$3A                    ; F076: D6 3A         \n");
                                      #endif
    PC = 0xf076; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x3a); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDB  #$02                    ; F078: CB 02         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x02; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$20                    ; F07A: C1 20         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x20; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   LF07F                   ; F07C: 25 01         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LF07F;
    }
                                                     #ifdef DEBUG
                                      mon("         CLRB                          ; F07E: 5F            \n");
                                      #endif
    B = 0; // SEARCH_ME
 // V = 0; 
 // Z = 0; 
 // N = 0; 
 // C = 0; 
    clockticks = clockticks + 2; 
  case 0xF07F:
LF07F:
                                                     #ifdef DEBUG
                                      mon("LF07F    STB   <$3A                    ; F07F: D7 3A         \n");
                                      #endif // Colour cycle blue/cyan for lasers
    PC = 0xf07f; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x3a; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$04                    ; F081: 8E 00 04      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x0004; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; F084: 3A            \n");
                                      #endif // Points to jump table that jump into vector ROM for laser colour cycle
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #word_D620              ; F085: CE D6 20      \n");
                                      #endif // Copies vector JMPL instructions into vector RAM
    clockticks = clockticks + 3; 
    U = 0xd620; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0xF088:
LF088:
                                                     #ifdef DEBUG
                                      mon("LF088    LDD   ,U++                    ; F088: EC C1         \n");
                                      #endif
    PC = 0xf088; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
    A = rd_mem(U); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(U+1)); 
    U = U + 2; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,--X                    ; F08A: ED 83         \n");
                                      #endif
    clockticks = clockticks + 7; 
    X = X - 2; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$02                    ; F08C: 8C 00 02      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x0002; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BGT   LF088                   ; F08F: 2E F7         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto LF088;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   #$22                    ; F091: 8E 00 22      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x0022; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xF094:
LF094:
                                                     #ifdef DEBUG
                                      mon("LF094    CMPU  #word_D640              ; F094: 11 83 D6 40   \n");
                                      #endif
    PC = 0xf094; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = U; 
    arg = 0xd640; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCC   LF0A0                   ; F098: 24 06         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LF0A0;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   ,U++                    ; F09A: EC C1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    A = rd_mem(U); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(U+1)); 
    U = U + 2; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,--X                    ; F09C: ED 83         \n");
                                      #endif
    clockticks = clockticks + 7; 
    X = X - 2; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = X; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         BRA   LF094                   ; F09E: 20 F4         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LF094;
    
    // ---------------------------------------------------------------------------
  case 0xF0A0:
LF0A0:
                                                     #ifdef DEBUG
                                      mon("LF0A0    LDB   <$3B                    ; F0A0: D6 3B         \n");
                                      #endif
    PC = 0xf0a0; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x3b); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDB  #$02                    ; F0A2: CB 02         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x02; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$08                    ; F0A4: C1 08         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x08; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   LF0A9                   ; F0A6: 25 01         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LF0A9;
    }
                                                     #ifdef DEBUG
                                      mon("         CLRB                          ; F0A8: 5F            \n");
                                      #endif
    B = 0; // SEARCH_ME
 // V = 0; 
 // Z = 0; 
 // N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
  case 0xF0A9:
LF0A9:
                                                     #ifdef DEBUG
                                      mon("LF0A9    STB   <$3B                    ; F0A9: D7 3B         \n");
                                      #endif
    PC = 0xf0a9; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x3b; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDU   #word_D640              ; F0AB: CE D6 40      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0xd640; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   B,U                     ; F0AE: EC C5         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + (SINT8)B); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $22                     ; F0B0: FD 00 22      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x0022, A); // Care needed with I/O space and word fetches
    wr_mem(0x0023, B); 
                                                     #ifdef DEBUG
                                      mon("         DEC   <$36                    ; F0B3: 0A 36         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x36); 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    wr_mem(DP|0x36, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BGT   LF0D8                   ; F0B5: 2E 21         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto LF0D8;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   #$04                    ; F0B7: C6 04         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x04; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STB   <$36                    ; F0B9: D7 36         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x36; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDB   <$37                    ; F0BB: D6 37         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x37); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDB  #$02                    ; F0BD: CB 02         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x02; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$08                    ; F0BF: C1 08         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x08; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   LF0C4                   ; F0C1: 25 01         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LF0C4;
    }
                                                     #ifdef DEBUG
                                      mon("         CLRB                          ; F0C3: 5F            \n");
                                      #endif
    B = 0; // SEARCH_ME
 // V = 0; 
 // Z = 0; 
 // N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
  case 0xF0C4:
LF0C4:
                                                     #ifdef DEBUG
                                      mon("LF0C4    STB   <$37                    ; F0C4: D7 37         \n");
                                      #endif
    PC = 0xf0c4; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x37; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDU   #word_D648              ; F0C6: CE D6 48      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0xd648; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   B,U                     ; F0C9: EC C5         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + (SINT8)B); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $2A                     ; F0CB: FD 00 2A      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x002a, A); // Care needed with I/O space and word fetches
    wr_mem(0x002b, B); 
                                                     #ifdef DEBUG
                                      mon("         LDB   <$37                    ; F0CE: D6 37         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x37); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #word_D650              ; F0D0: CE D6 50      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0xd650; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   B,U                     ; F0D3: EC C5         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + (SINT8)B); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $2E                     ; F0D5: FD 00 2E      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x002e, A); // Care needed with I/O space and word fetches
    wr_mem(0x002f, B); 
  case 0xF0D8:
LF0D8:
                                                     #ifdef DEBUG
                                      mon("LF0D8    DEC   <$38                    ; F0D8: 0A 38         \n");
                                      #endif
    PC = 0xf0d8; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x38); 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    wr_mem(DP|0x38, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BGT   LF0F3                   ; F0DA: 2E 17         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto LF0F3;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   #$01                    ; F0DC: C6 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x01; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STB   <$38                    ; F0DE: D7 38         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x38; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDB   <$39                    ; F0E0: D6 39         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x39); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDB  #$02                    ; F0E2: CB 02         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x02; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$08                    ; F0E4: C1 08         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x08; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   LF0E9                   ; F0E6: 25 01         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LF0E9;
    }
                                                     #ifdef DEBUG
                                      mon("         CLRB                          ; F0E8: 5F            \n");
                                      #endif
    B = 0; // SEARCH_ME
 // V = 0; 
 // Z = 0; 
 // N = 0; 
 // C = 0; 
    clockticks = clockticks + 2; 
  case 0xF0E9:
LF0E9:
                                                     #ifdef DEBUG
                                      mon("LF0E9    STB   <$39                    ; F0E9: D7 39         \n");
                                      #endif
    PC = 0xf0e9; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x39; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDU   #word_D658              ; F0EB: CE D6 58      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0xd658; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   B,U                     ; F0EE: EC C5         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + (SINT8)B); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $2C                     ; F0F0: FD 00 2C      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x002c, A); // Care needed with I/O space and word fetches
    wr_mem(0x002d, B); 
  case 0xF0F3:
LF0F3:
                                                     #ifdef DEBUG
                                      mon("LF0F3    LDB   <$35                    ; F0F3: D6 35         \n");
                                      #endif
    PC = 0xf0f3; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x35); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDB  #$02                    ; F0F5: CB 02         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x02; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$0E                    ; F0F7: C1 0E         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x0e; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   LF0FC                   ; F0F9: 25 01         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LF0FC;
    }
                                                     #ifdef DEBUG
                                      mon("         CLRB                          ; F0FB: 5F            \n");
                                      #endif
    B = 0; // SEARCH_ME
 // V = 0; 
 // Z = 0; 
 // N = 0; 
 // C = 0; 
    clockticks = clockticks + 2; 
  case 0xF0FC:
LF0FC:
                                                     #ifdef DEBUG
                                      mon("LF0FC    STB   <$35                    ; F0FC: D7 35         \n");
                                      #endif
    PC = 0xf0fc; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x35; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDU   #word_D604              ; F0FE: CE D6 04      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0xd604; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   B,U                     ; F101: EC C5         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + (SINT8)B); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $30                     ; F103: FD 00 30      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x0030, A); // Care needed with I/O space and word fetches
    wr_mem(0x0031, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$C000                  ; F106: CC C0 00      \n");
                                      #endif // Vector RTSL
    clockticks = clockticks + 3; 
    A = 0xc0; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $32                     ; F109: FD 00 32      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x0032, A); // Care needed with I/O space and word fetches
    wr_mem(0x0033, B); 
                                                     #ifdef DEBUG
                                      mon("         LDB   <$3C                    ; F10C: D6 3C         \n");
                                      #endif // Cycle through 7 colours
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x3c); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDB  #$02                    ; F10E: CB 02         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x02; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$0E                    ; F110: C1 0E         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x0e; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   LF115                   ; F112: 25 01         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LF115;
    }
                                                     #ifdef DEBUG
                                      mon("         CLRB                          ; F114: 5F            \n");
                                      #endif
    B = 0; // SEARCH_ME
 // V = 0; 
 // Z = 0; 
 // N = 0; 
 // C = 0; 
    clockticks = clockticks + 2; 
  case 0xF115:
LF115:
                                                     #ifdef DEBUG
                                      mon("LF115    STB   <$3C                    ; F115: D7 3C         \n");
                                      #endif // Vector colour cycle count
    PC = 0xf115; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x3c; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDU   #word_D612              ; F117: CE D6 12      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0xd612; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   B,U                     ; F11A: EC C5         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + (SINT8)B); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $34                     ; F11C: FD 00 34      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x0034, A); // Care needed with I/O space and word fetches
    wr_mem(0x0035, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$C000                  ; F11F: CC C0 00      \n");
                                      #endif // Vector RTSL
    clockticks = clockticks + 3; 
    A = 0xc0; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $36                     ; F122: FD 00 36      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x0036, A); // Care needed with I/O space and word fetches
    wr_mem(0x0037, B); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LD660                   ; F125: BD D6 60      \n");
                                      #endif // Update laser target hit vector animations
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x28); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xf1); 
    clockticks = clockticks + 1; 
    goto LD660;
  case 0xF128:
LF128:
                                                     #ifdef DEBUG
                                      mon("LF128    STA   $4600                   ; F128: B7 46 00      \n");
                                      #endif // Start vector generator run
    PC = 0xf128; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4600, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$05                    ; F12B: 86 05         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x05; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$40                    ; F12D: 97 40         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x40; 
    wr_mem(ea, val); 
  case 0xF12F:
LF12F:
                                                     #ifdef DEBUG
                                      mon("LF12F    STA   $4660                   ; F12F: B7 46 60      \n");
                                      #endif
    PC = 0xf12f; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4660, val); 
    // End of function IRQ
                                                     #ifdef DEBUG
                                      mon("         RTI                           ; F132: 3B            \n");
                                      #endif
    {
    res=E;
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    CC = rd_mem(S); 
    S++;
    C = CC; V = C>>1; Z = V>>1; N = Z>>1; I = N>>1; H = I>>1; F = H>>1; E = (F>>1)&1; F &= 1; H &= 1; I &= 1; N &= 1; Z &= 1; V &= 1; C &= 1; 
    restore_flags();
    if (res) {
    clockticks = clockticks + 9; 
    clockticks = clockticks + 1; 
    A = rd_mem(S); 
    S++;
    clockticks = clockticks + 1; 
    B = rd_mem(S); 
    S++;
    clockticks = clockticks + 1; 
    DP = rd_mem(S); 
    S++;
    DP = DP << 8; checkDP(); 
    // memory_DP = &memory[DP];
    clockticks = clockticks + 1; 
    X = rd_mem(S)<<8; 
    S++;
    X = X | rd_mem(S); 
    S++;
    clockticks = clockticks + 1; 
    Y = rd_mem(S)<<8; 
    S++;
    Y = Y | rd_mem(S); 
    S++;
    clockticks = clockticks + 1; 
    U = rd_mem(S)<<8; 
    S++;
    U = U | rd_mem(S); 
    S++;
    }
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    }
    
    // =============== S U B R O U T I N E =======================================
    // Inputs debounce
  case 0xF133:
LF133:
                                                     #ifdef DEBUG
                                      mon("LF133    LDB   ,X                      ; F133: E6 84         \n");
                                      #endif // Inputs debounce
    PC = 0xf133; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(X); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STB   $01,X                   ; F135: E7 01         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0001); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   ,X                      ; F137: A7 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         ANDA  $01,X                   ; F139: A4 01         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    res = val & rd_mem((UINT16)(X + 0x0001)); 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORA   $02,X                   ; F13B: AA 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = A | (UINT8)rd_mem((UINT16)(X + 0x0002)); 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $02,X                   ; F13D: A7 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0002); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         ORB   ,X++                    ; F13F: EA 81         \n");
                                      #endif
    clockticks = clockticks + 7; 
    res = B | (UINT8)rd_mem(X); 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
    X = X + 2; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  ,X                      ; F141: E4 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)B; 
    res = val & rd_mem(X); 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STB   ,X+                     ; F143: E7 80         \n");
                                      #endif
    clockticks = clockticks + 6; 
    val = B; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = X; 
    wr_mem(ea, val); 
    X = X + 1; 
    // End of function sub_F133
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; F145: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Joystick processing
  case 0xF146:
LF146:
                                                     #ifdef DEBUG
                                      mon("LF146    LDA   <$0A                    ; F146: 96 0A         \n");
                                      #endif
    PC = 0xf146; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x0a); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; F148: 44            \n");
                                      #endif
    val = (UINT8)A; 
    C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDY   #$4829                  ; F149: 10 8E 48 29   \n");
                                      #endif
    clockticks = clockticks + 4; 
    Y = 0x4829; 
    Z = Y; 
    N = (Y) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LF153                   ; F14D: 25 04         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LF153;
    }
                                                     #ifdef DEBUG
                                      mon("         LDY   #$482B                  ; F14F: 10 8E 48 2B   \n");
                                      #endif
    clockticks = clockticks + 4; 
    Y = 0x482b; 
 // Z = Y; 
 // N = (Y) >> 8; 
 // V = 0; 
  case 0xF153:
LF153:
                                                     #ifdef DEBUG
                                      mon("LF153    LDB   $01,Y                   ; F153: E6 21         \n");
                                      #endif
    PC = 0xf153; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(Y + 0x0001)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4380                   ; F155: B6 43 80      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4380); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $01,Y                   ; F158: A7 21         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(Y + 0x0001); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         CMPA  ,Y                      ; F15A: A1 A4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)A; 
    arg = rd_mem(Y); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   LF16C                   ; F15C: 25 0E         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LF16C;
    }
                                                     #ifdef DEBUG
                                      mon("         CMPB  ,Y                      ; F15E: E1 A4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)B; 
    arg = rd_mem(Y); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BLS   LF16A                   ; F160: 23 08         \n");
                                      #endif
    // temp hack to force a flush
    if ((!Z) || C) {
    clockticks = clockticks + 3; 
    goto LF16A;
    }
                                                     #ifdef DEBUG
                                      mon("         CMPB  $01,Y                   ; F162: E1 21         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)B; 
    arg = rd_mem((UINT16)(Y + 0x0001)); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BLS   LF168                   ; F164: 23 02         \n");
                                      #endif
    // temp hack to force a flush
    if ((!Z) || C) {
    clockticks = clockticks + 3; 
    goto LF168;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   $01,Y                   ; F166: E6 21         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(Y + 0x0001)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xF168:
LF168:
                                                     #ifdef DEBUG
                                      mon("LF168    STB   ,Y                      ; F168: E7 A4         \n");
                                      #endif
    PC = 0xf168; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = B; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = Y; 
    wr_mem(ea, val); 
  case 0xF16A:
LF16A:
                                                     #ifdef DEBUG
                                      mon("LF16A    BRA   LF178                   ; F16A: 20 0C         \n");
                                      #endif
    PC = 0xf16a; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto LF178;
    
    // ---------------------------------------------------------------------------
  case 0xF16C:
LF16C:
                                                     #ifdef DEBUG
                                      mon("LF16C    CMPB  ,Y                      ; F16C: E1 A4         \n");
                                      #endif
    PC = 0xf16c; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)B; 
    arg = rd_mem(Y); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCC   LF178                   ; F16E: 24 08         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LF178;
    }
                                                     #ifdef DEBUG
                                      mon("         CMPB  $01,Y                   ; F170: E1 21         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)B; 
    arg = rd_mem((UINT16)(Y + 0x0001)); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCC   LF176                   ; F172: 24 02         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LF176;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   $01,Y                   ; F174: E6 21         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(Y + 0x0001)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xF176:
LF176:
                                                     #ifdef DEBUG
                                      mon("LF176    STB   ,Y                      ; F176: E7 A4         \n");
                                      #endif
    PC = 0xf176; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, val); 
  case 0xF178:
LF178:
                                                     #ifdef DEBUG
                                      mon("LF178    CMPY  #$4829                  ; F178: 10 8C 48 29   \n");
                                      #endif
    PC = 0xf178; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = Y; 
    arg = 0x4829; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LF186                   ; F17C: 26 08         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LF186;
    }
                                                     #ifdef DEBUG
                                      mon("         STA   $46C0                   ; F17E: B7 46 C0      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x46c0, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   $46C0                   ; F181: B7 46 C0      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x46c0, val); 
                                                     #ifdef DEBUG
                                      mon("         BRA   locret_F18C             ; F184: 20 06         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LF18C;
    
    // ---------------------------------------------------------------------------
  case 0xF186:
LF186:
                                                     #ifdef DEBUG
                                      mon("LF186    STA   $46C1                   ; F186: B7 46 C1      \n");
                                      #endif
    PC = 0xf186; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x46c1, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   $46C1                   ; F189: B7 46 C1      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x46c1, val); 
    // End of function sub_F146
  case 0xF18C:
LF18C:
locret_F18C:
                                                     #ifdef DEBUG
                                      mon("locret_F18C RTS                           ; F18C: 39            \n");
                                      #endif
    PC = 0xf18c; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xF18D:
LF18D:
                                                     #ifdef DEBUG
                                      mon("LF18D    LDX   #$4866                  ; F18D: 8E 48 66      \n");
                                      #endif // Joystick pitch data structure
    PC = 0xf18d; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x4866; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$2B                    ; F190: 96 2B         \n");
                                      #endif // Joystick Y
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x2b); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         NOP                           ; F192: 12            \n");
                                      #endif
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LF1C6                   ; F193: BD F1 C6      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x96); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xf1); 
    clockticks = clockticks + 1; 
    goto LF1C6;
  case 0xF196:
LF196:
                                                     #ifdef DEBUG
                                      mon("LF196    LDA   $04,X                   ; F196: A6 04         \n");
                                      #endif
    PC = 0xf196; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0004)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$78                    ; F198: 81 78         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x78; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BLE   LF19E                   ; F19A: 2F 02         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto LF19E;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$78                    ; F19C: 86 78         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x78; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xF19E:
LF19E:
                                                     #ifdef DEBUG
                                      mon("LF19E    CMPA  #$98                    ; F19E: 81 98         \n");
                                      #endif
    PC = 0xf19e; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x98; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BGE   LF1A4                   ; F1A0: 2C 02         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) >= 0) {
    clockticks = clockticks + 3; 
    goto LF1A4;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$98                    ; F1A2: 86 98         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x98; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xF1A4:
LF1A4:
                                                     #ifdef DEBUG
                                      mon("LF1A4    STA   $04,X                   ; F1A4: A7 04         \n");
                                      #endif
    PC = 0xf1a4; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0004); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LF1FD                   ; F1A6: BD F1 FD      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xa9); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xf1); 
    clockticks = clockticks + 1; 
    goto LF1FD;
  case 0xF1A9:
LF1A9:
                                                     #ifdef DEBUG
                                      mon("LF1A9    LDX   #$486F                  ; F1A9: 8E 48 6F      \n");
                                      #endif // Joystick roll data structure
    PC = 0xf1a9; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x486f; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$29                    ; F1AC: 96 29         \n");
                                      #endif // Joystick X
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x29); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         NOP                           ; F1AE: 12            \n");
                                      #endif
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LF1C6                   ; F1AF: BD F1 C6      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xb2); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xf1); 
    clockticks = clockticks + 1; 
    goto LF1C6;
  case 0xF1B2:
LF1B2:
                                                     #ifdef DEBUG
                                      mon("LF1B2    LDA   $04,X                   ; F1B2: A6 04         \n");
                                      #endif
    PC = 0xf1b2; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0004)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$70                    ; F1B4: 81 70         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x70; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BLE   LF1BA                   ; F1B6: 2F 02         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto LF1BA;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$70                    ; F1B8: 86 70         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x70; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xF1BA:
LF1BA:
                                                     #ifdef DEBUG
                                      mon("LF1BA    CMPA  #$90                    ; F1BA: 81 90         \n");
                                      #endif
    PC = 0xf1ba; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x90; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BGE   LF1C0                   ; F1BC: 2C 02         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) >= 0) {
    clockticks = clockticks + 3; 
    goto LF1C0;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$90                    ; F1BE: 86 90         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x90; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xF1C0:
LF1C0:
                                                     #ifdef DEBUG
                                      mon("LF1C0    STA   $04,X                   ; F1C0: A7 04         \n");
                                      #endif
    PC = 0xf1c0; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = (UINT16)(X + 0x0004); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LF1FD                   ; F1C2: BD F1 FD      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xc5); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xf1); 
    clockticks = clockticks + 1; 
    goto LF1FD;
    // End of function sub_F18D
  case 0xF1C5:
LF1C5:
                                                     #ifdef DEBUG
                                      mon("LF1C5    RTS                           ; F1C5: 39            \n");
                                      #endif
    PC = 0xf1c5; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xF1C6:
LF1C6:
                                                     #ifdef DEBUG
                                      mon("LF1C6    CMPA  ,X                      ; F1C6: A1 84         \n");
                                      #endif
    PC = 0xf1c6; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)A; 
    arg = rd_mem(X); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCC   LF1D0                   ; F1C8: 24 06         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LF1D0;
    }
                                                     #ifdef DEBUG
                                      mon("         CMPA  $01,X                   ; F1CA: A1 01         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    arg = rd_mem((UINT16)(X + 0x0001)); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   LF1D0                   ; F1CC: 25 02         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LF1D0;
    }
                                                     #ifdef DEBUG
                                      mon("         DEC   ,X                      ; F1CE: 6A 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(X); 
    res = (UINT8)(val - 1); 
 // N = res; 
 // Z = res; 
 // V = val & ~res; 
    wr_mem(X, res); 
    clockticks = clockticks + 2; 
  case 0xF1D0:
LF1D0:
                                                     #ifdef DEBUG
                                      mon("LF1D0    STA   $01,X                   ; F1D0: A7 01         \n");
                                      #endif
    PC = 0xf1d0; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0001); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         CMPA  ,X                      ; F1D2: A1 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)A; 
    arg = rd_mem(X); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCC   LF1D8                   ; F1D4: 24 02         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LF1D8;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   ,X                      ; F1D6: A6 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(X); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xF1D8:
LF1D8:
                                                     #ifdef DEBUG
                                      mon("LF1D8    SUBA  ,X                      ; F1D8: A0 84         \n");
                                      #endif
    PC = 0xf1d8; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)A; 
    arg = rd_mem(X); 
    res = val - (UINT8)arg; 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)(res); 
                                                     #ifdef DEBUG
                                      mon("         STA   <$51                    ; F1DA: 97 51         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x51; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDB   $02,X                   ; F1DC: E6 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0002)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         MUL                           ; F1DE: 3D            \n");
                                      #endif
    res = (UINT16)(A * B); 
 // Z = res; 
 // C = res & 0x80; 
    A = res >> 8; 
    B = (UINT8)res; 
    clockticks = clockticks + 11; 
                                                     #ifdef DEBUG
                                      mon("         ADDA  <$51                    ; F1DF: 9B 51         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)A; 
    arg = rd_mem(DP|0x51); 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
    V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LF1E5                   ; F1E1: 26 02         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LF1E5;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$01                    ; F1E3: 86 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x01; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
  case 0xF1E5:
LF1E5:
                                                     #ifdef DEBUG
                                      mon("LF1E5    BCS   LF1EB                   ; F1E5: 25 04         \n");
                                      #endif
    PC = 0xf1e5; 
    INSTRUCTION_START
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LF1EB;
    }
                                                     #ifdef DEBUG
                                      mon("         CLR   $03,X                   ; F1E7: 6F 03         \n");
                                      #endif
    clockticks = clockticks + 5; 
    wr_mem((UINT16)(X + 0x0003), 0); 
    V = 0; 
    Z = 0; 
    N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LF1F7                   ; F1E9: 20 0C         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LF1F7;
    
    // ---------------------------------------------------------------------------
  case 0xF1EB:
LF1EB:
                                                     #ifdef DEBUG
                                      mon("LF1EB    LDA   #$FF                    ; F1EB: 86 FF         \n");
                                      #endif
    PC = 0xf1eb; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0xff; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         INC   $03,X                   ; F1ED: 6C 03         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0003)); 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    wr_mem((UINT16)(X + 0x0003), res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $03,X                   ; F1EF: E6 03         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0003)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$02                    ; F1F1: C1 02         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x02; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   LF1F7                   ; F1F3: 25 02         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LF1F7;
    }
                                                     #ifdef DEBUG
                                      mon("         DEC   $02,X                   ; F1F5: 6A 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0002)); 
    res = (UINT8)(val - 1); 
 // N = res; 
 // Z = res; 
 // V = val & ~res; 
    wr_mem((UINT16)(X + 0x0002), res); 
    clockticks = clockticks + 2; 
  case 0xF1F7:
LF1F7:
                                                     #ifdef DEBUG
                                      mon("LF1F7    CLRB                          ; F1F7: 5F            \n");
                                      #endif
    PC = 0xf1f7; 
    INSTRUCTION_START
    B = 0; // SEARCH_ME
 // V = 0; 
 // Z = 0; 
 // N = 0; 
 // C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SUBA  #$80                    ; F1F8: 80 80         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x80; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)(res); 
                                                     #ifdef DEBUG
                                      mon("         STA   $04,X                   ; F1FA: A7 04         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = (UINT16)(X + 0x0004); 
    wr_mem(ea, val); 
    // End of function sub_F1C6
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; F1FC: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xF1FD:
LF1FD:
                                                     #ifdef DEBUG
                                      mon("LF1FD    CLR   <$51                    ; F1FD: 0F 51         \n");
                                      #endif
    PC = 0xf1fd; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    wr_mem(DP|0x51, 0); 
 // V = 0; 
 // Z = 0; 
 // N = 0; 
 // C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $04,X                   ; F1FF: A6 04         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0004)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$80                    ; F201: C6 80         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x80; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $05,X                   ; F203: A3 05         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(X + 0x0005))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(X + 0x0005))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BGE   LF20A                   ; F205: 2C 03         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) >= 0) {
    clockticks = clockticks + 3; 
    goto LF20A;
    }
                                                     #ifdef DEBUG
                                      mon("         NEGA                          ; F207: 40            \n");
                                      #endif
    val = (UINT8)A; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         DEC   <$51                    ; F208: 0A 51         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x51); 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    wr_mem(DP|0x51, res); 
    clockticks = clockticks + 2; 
  case 0xF20A:
LF20A:
                                                     #ifdef DEBUG
                                      mon("LF20A    BLE   LF20F                   ; F20A: 2F 03         \n");
                                      #endif
    PC = 0xf20a; 
    INSTRUCTION_START
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto LF20F;
    }
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$FF                    ; F20C: C3 00 FF      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x00ff; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
  case 0xF20F:
LF20F:
                                                     #ifdef DEBUG
                                      mon("LF20F    CMPA  #$F8                    ; F20F: 81 F8         \n");
                                      #endif
    PC = 0xf20f; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xf8; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BLS   LF215                   ; F211: 23 02         \n");
                                      #endif
    // temp hack to force a flush
    if ((!Z) || C) {
    clockticks = clockticks + 3; 
    goto LF215;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$F8                    ; F213: 86 F8         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xf8; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xF215:
LF215:
                                                     #ifdef DEBUG
                                      mon("LF215    LDB   #$60                    ; F215: C6 60         \n");
                                      #endif
    PC = 0xf215; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x60; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$40                    ; F217: 81 40         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x40; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCC   LF21D                   ; F219: 24 02         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LF21D;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   #$30                    ; F21B: C6 30         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x30; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xF21D:
LF21D:
                                                     #ifdef DEBUG
                                      mon("LF21D    MUL                           ; F21D: 3D            \n");
                                      #endif
    PC = 0xf21d; 
    INSTRUCTION_START
    res = (UINT16)(A * B); 
 // Z = res; 
    C = res & 0x80; 
    A = res >> 8; 
    B = (UINT8)res; 
    clockticks = clockticks + 11; 
                                                     #ifdef DEBUG
                                      mon("         TST   <$51                    ; F21E: 0D 51         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x51); 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LF226                   ; F220: 2A 04         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LF226;
    }
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; F222: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; F223: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SBCA  #$FF                    ; F224: 82 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xff; 
    res = val - (UINT8)arg - (C != 0 ? 1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)res; 
  case 0xF226:
LF226:
                                                     #ifdef DEBUG
                                      mon("LF226    ADDD  $05,X                   ; F226: E3 05         \n");
                                      #endif
    PC = 0xf226; 
    INSTRUCTION_START
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(X + 0x0005))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(X + 0x0005))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $05,X                   ; F228: ED 05         \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = (UINT16)(X + 0x0005); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    // End of function sub_F1FD
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; F22A: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xF22B:
LF22B:
                                                     #ifdef DEBUG
                                      mon("LF22B    LDB   <$6B                    ; F22B: D6 6B         \n");
                                      #endif
    PC = 0xf22b; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x6b); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$6C                    ; F22D: 96 6C         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x6c); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$C0                    ; F22F: 84 C0         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0xc0; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLA                          ; F231: 48            \n");
                                      #endif
    val = (UINT8)A; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLB                          ; F232: 59            \n");
                                      #endif
    val = (UINT8)B; 
    res = (val << 1) + (C != 0 ?1:0); 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)res ^ val; 
    B = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BCC   LF237                   ; F233: 24 02         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LF237;
    }
                                                     #ifdef DEBUG
                                      mon("         ORA   #$3F                    ; F235: 8A 3F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A | (UINT8)0x3f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
  case 0xF237:
LF237:
                                                     #ifdef DEBUG
                                      mon("LF237    ROLA                          ; F237: 49            \n");
                                      #endif
    PC = 0xf237; 
    INSTRUCTION_START
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
    C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLB                          ; F238: 59            \n");
                                      #endif
    val = (UINT8)B; 
    res = (val << 1) + (C != 0 ?1:0); 
    C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)res ^ val; 
    B = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLA                          ; F239: 49            \n");
                                      #endif
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$2F                    ; F23A: DD 2F         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x2f; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$FF98                  ; F23C: C3 FF 98      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0xff98; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$1F                    ; F23F: 84 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x1f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $24                     ; F241: FD 00 24      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x0024, A); // Care needed with I/O space and word fetches
    wr_mem(0x0025, B); 
                                                     #ifdef DEBUG
                                      mon("         LDB   <$74                    ; F244: D6 74         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x74); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$75                    ; F246: 96 75         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x75); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$C0                    ; F248: 84 C0         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0xc0; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLA                          ; F24A: 48            \n");
                                      #endif
    val = (UINT8)A; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLB                          ; F24B: 59            \n");
                                      #endif
    val = (UINT8)B; 
    res = (val << 1) + (C != 0 ?1:0); 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)res ^ val; 
    B = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BCC   LF250                   ; F24C: 24 02         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LF250;
    }
                                                     #ifdef DEBUG
                                      mon("         ORA   #$3F                    ; F24E: 8A 3F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A | (UINT8)0x3f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
  case 0xF250:
LF250:
                                                     #ifdef DEBUG
                                      mon("LF250    ROLA                          ; F250: 49            \n");
                                      #endif
    PC = 0xf250; 
    INSTRUCTION_START
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
    C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLB                          ; F251: 59            \n");
                                      #endif
    val = (UINT8)B; 
    res = (val << 1) + (C != 0 ?1:0); 
    C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)res ^ val; 
    B = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLA                          ; F252: 49            \n");
                                      #endif
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
    C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$2D                    ; F253: DD 2D         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x2d; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$1F                    ; F255: 84 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x1f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $26                     ; F257: FD 00 26      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x0026, A); // Care needed with I/O space and word fetches
    wr_mem(0x0027, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$C000                  ; F25A: CC C0 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xc0; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $28                     ; F25D: FD 00 28      \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x0028, A); // Care needed with I/O space and word fetches
    wr_mem(0x0029, B); 
    // End of function sub_F22B
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; F260: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
    // START OF FUNCTION CHUNK FOR sub_6532
  case 0xF261:
LF261:
                                                     #ifdef DEBUG
                                      mon("LF261    ORCC  #$10                    ; F261: 1A 10         \n");
                                      #endif // public Reset
    PC = 0xf261; 
    INSTRUCTION_START
    I = 1; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         CLR   $4684                   ; F263: 7F 46 84      \n");
                                      #endif
    clockticks = clockticks + 5; 
    wr_mem(0x4684, 0); 
 // V = 0; 
 // Z = 0; 
 // N = 0; 
 // C = 0; 
    clockticks = clockticks + 2; 
    PC = 0xf266; 
    goto bankswitch_check;
  case 0xF266:
LF266:
                                                     #ifdef DEBUG
                                      mon("LF266    LDA   #$00                    ; F266: 86 00         \n");
                                      #endif
    PC = 0xf266; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4686                   ; F268: B7 46 86      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4686, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   $4683                   ; F26B: B7 46 83      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4683, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   $4682                   ; F26E: B7 46 82      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4682, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; F271: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4685                   ; F273: B7 46 85      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4685, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$80                    ; F276: 86 80         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x80; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4685                   ; F278: B7 46 85      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4685, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   $4620                   ; F27B: B7 46 20      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4620, val); 
                                                     #ifdef DEBUG
                                      mon("         LDU   #$00                    ; F27E: CE 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x0000; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0xF281:
LF281:
                                                     #ifdef DEBUG
                                      mon("LF281    STA   $4640                   ; F281: B7 46 40      \n");
                                      #endif
    PC = 0xf281; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4640, val); 
                                                     #ifdef DEBUG
                                      mon("         LEAU  -1,U                    ; F284: 33 5F         \n");
                                      #endif
    clockticks = clockticks + 5; 
    U = (U + 0xffff); 
                                                     #ifdef DEBUG
                                      mon("         CMPU  #$00                    ; F286: 11 83 00 00   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
    arg = 0x0000; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LF281                   ; F28A: 26 F5         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LF281;
    }
                                                     #ifdef DEBUG
                                      mon("         LDS   #$4FFF                  ; F28C: 10 CE 4F FF   \n");
                                      #endif // Stack top at $4FFF
    clockticks = clockticks + 4; 
    S = 0x4fff; 
 // Z = S; 
 // N = (S) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$48                    ; F290: 86 48         \n");
                                      #endif // H      ; Direct Page at $4800
    clockticks = clockticks + 2; 
    val = (UINT8)0x48; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         TFR   A,DP                    ; F292: 1F 8B         \n");
                                      #endif
    DP = (A) << 8; checkDP(); 
    // memory_DP = &memory[DP];
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         STA   $46E0                   ; F294: B7 46 E0      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x46e0, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; F297: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4400                   ; F299: B7 44 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4400, val); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4800                  ; F29C: 8E 48 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x4800; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; F29F: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0xF2A2:
LF2A2:
                                                     #ifdef DEBUG
                                      mon("LF2A2    STD   ,X++                    ; F2A2: ED 81         \n");
                                      #endif
    PC = 0xf2a2; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    X = X + 2; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$5000                  ; F2A4: 8C 50 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x5000; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LF2A2                   ; F2A7: 25 F9         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LF2A2;
    }
                                                     #ifdef DEBUG
                                      mon("         STA   $4640                   ; F2A9: B7 46 40      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4640, val); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$5000                  ; F2AC: 8E 50 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x5000; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; F2AF: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0xF2B2:
LF2B2:
                                                     #ifdef DEBUG
                                      mon("LF2B2    STD   ,X++                    ; F2B2: ED 81         \n");
                                      #endif
    PC = 0xf2b2; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    X = X + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4640                   ; F2B4: B7 46 40      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4640, val); 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$6000                  ; F2B7: 8C 60 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x6000; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LF2B2                   ; F2BA: 25 F6         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LF2B2;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   #$00                    ; F2BC: 8E 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x0000; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; F2BF: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0xF2C2:
LF2C2:
                                                     #ifdef DEBUG
                                      mon("LF2C2    STD   ,X++                    ; F2C2: ED 81         \n");
                                      #endif
    PC = 0xf2c2; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    X = X + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4640                   ; F2C4: B7 46 40      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4640, val); 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$3000                  ; F2C7: 8C 30 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x3000; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LF2C2                   ; F2CA: 25 F6         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LF2C2;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4300                   ; F2CC: B6 43 00      \n");
                                      #endif // Check self test switch
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4300); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$10                    ; F2CF: 84 10         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x10; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LF2D6                   ; F2D1: 26 03         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LF2D6;
    }
                                                     #ifdef DEBUG
                                      mon("         JMP   LF36E                   ; F2D3: 7E F3 6E      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LF36E;
    
    // ---------------------------------------------------------------------------
  case 0xF2D6:
LF2D6:
                                                     #ifdef DEBUG
                                      mon("LF2D6    LDA   $4340                   ; F2D6: B6 43 40      \n");
                                      #endif // Read option switches
    PC = 0xf2d6; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4340); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $4360                   ; F2D9: F6 43 60      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4360); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xF2DC:
LF2DC:
                                                     #ifdef DEBUG
                                      mon("LF2DC    STA   <$24                    ; F2DC: 97 24         \n");
                                      #endif
    PC = 0xf2dc; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x24; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STB   <$27                    ; F2DE: D7 27         \n");
                                      #endif // Store in shadow RAM
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x27; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$0800                  ; F2E0: 8E 08 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x0800; 
 // Z = X; 
    N = (X) >> 8; 
    V = 0; 
  case 0xF2E3:
LF2E3:
                                                     #ifdef DEBUG
                                      mon("LF2E3    LEAX  -1,X                    ; F2E3: 30 1F         \n");
                                      #endif
    PC = 0xf2e3; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    X = (X + 0xffff); 
    Z = X; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LF2E3                   ; F2E5: 26 FC         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LF2E3;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4340                   ; F2E7: B6 43 40      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4340); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $4360                   ; F2EA: F6 43 60      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4360); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  <$24                    ; F2ED: 91 24         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)A; 
    arg = rd_mem(DP|0x24); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   LF2DC                   ; F2EF: 26 EB         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LF2DC;
    }
                                                     #ifdef DEBUG
                                      mon("         CMPB  <$27                    ; F2F1: D1 27         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)B; 
    arg = rd_mem(DP|0x27); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   LF2DC                   ; F2F3: 26 E7         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LF2DC;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$2020                  ; F2F5: CC 20 20      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x20; 
    B = 0x20; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$00                    ; F2F8: 8E 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x0000; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xF2FB:
LF2FB:
                                                     #ifdef DEBUG
                                      mon("LF2FB    STD   ,X++                    ; F2FB: ED 81         \n");
                                      #endif // Clear vector RAM to HALT instructions
    PC = 0xf2fb; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    X = X + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4640                   ; F2FD: B7 46 40      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4640, val); 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$2800                  ; F300: 8C 28 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x2800; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LF2FB                   ; F303: 25 F6         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LF2FB;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$E038                  ; F305: CC E0 38      \n");
                                      #endif // Set up first vector instruction to JSRL 38
    clockticks = clockticks + 3; 
    A = 0xe0; 
    B = 0x38; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $00                     ; F308: FD 00 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x0000, A); // Care needed with I/O space and word fetches
    wr_mem(0x0001, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$FF                    ; F30B: 86 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xff; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$3F                    ; F30D: 97 3F         \n");
                                      #endif // Vector pointer state
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x3f; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$3F                    ; F30F: 86 3F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x3f; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$00                    ; F311: 97 00         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x00; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$40                    ; F313: 86 40         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x40; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$28                    ; F315: 97 28         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x28; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LC306                   ; F317: BD C3 06      \n");
                                      #endif // Read NOVRAM
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x1a); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xf3); 
    clockticks = clockticks + 1; 
    goto LC306;
  case 0xF31A:
LF31A:
                                                     #ifdef DEBUG
                                      mon("LF31A    STA   $4640                   ; F31A: B7 46 40      \n");
                                      #endif
    PC = 0xf31a; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4640, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$FF                    ; F31D: 86 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xff; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4686                   ; F31F: B7 46 86      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4686, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   $4683                   ; F322: B7 46 83      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4683, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   $4682                   ; F325: B7 46 82      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4682, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   $4660                   ; F328: B7 46 60      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x4660, val); 
    // END OF FUNCTION CHUNK FOR sub_6532
    // ---------------------------------------------------------------------------
                                                     #ifdef DEBUG
                                      mon("         JMP   $6036                   ; F32B: 7E 60 36      \n");
                                      #endif // Jump to main game loop
    clockticks = clockticks + 4; 
    PC = 0x6036; 
    JUMP;
    
    // ---------------------------------------------------------------------------
    // START OF FUNCTION CHUNK FOR sub_6532
  case 0xF36E:
LF36E:
                                                     #ifdef DEBUG
                                      mon("LF36E    LDA   $4320                   ; F36E: B6 43 20      \n");
                                      #endif // Self test
    PC = 0xf36e; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4320); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$04                    ; F371: 84 04         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x04; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LF380                   ; F373: 26 0B         \n");
                                      #endif // Check Aux coin
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LF380;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4340                   ; F375: B6 43 40      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4340); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; F378: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$7F                    ; F379: 84 7F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x7f; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LF380                   ; F37B: 27 03         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LF380;
    }
                                                     #ifdef DEBUG
                                      mon("         JMP   Check_Test_Diag         ; F37D: 7E FD 07      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LFD07;
    
    // ---------------------------------------------------------------------------
  case 0xF380:
LF380:
                                                     #ifdef DEBUG
                                      mon("LF380    LDS   #$00                    ; F380: 10 CE 00 00   \n");
                                      #endif
    PC = 0xf380; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    S = 0x0000; 
 // Z = S; 
 // N = (S) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #word_F32E              ; F384: CE F3 2E      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0xf32e; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0xF387:
LF387:
                                                     #ifdef DEBUG
                                      mon("LF387    LDX   ,U++                    ; F387: AE C1         \n");
                                      #endif
    PC = 0xf387; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
    clockticks = clockticks + 1; 
    ea = rd_mem(U)<<8; 
    ea = ea | rd_mem((UINT16)((U)+1)); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
    U = U + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDY   #$0800                  ; F389: 10 8E 08 00   \n");
                                      #endif
    clockticks = clockticks + 4; 
    Y = 0x0800; 
 // Z = Y; 
 // N = (Y) >> 8; 
 // V = 0; 
  case 0xF38D:
LF38D:
                                                     #ifdef DEBUG
                                      mon("LF38D    LDA   ,X                      ; F38D: A6 84         \n");
                                      #endif
    PC = 0xf38d; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(X); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LF39D                   ; F38F: 27 0C         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LF39D;
    }
                                                     #ifdef DEBUG
                                      mon("         TFR   S,D                     ; F391: 1F 40         \n");
                                      #endif
    val = S; 
    A = (UINT8)(val >> 8); 
    B = (UINT8)val; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         ORA   $1E,U                   ; F393: AA C8 1E      \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = A | (UINT8)rd_mem((UINT16)(U + (SINT8)0x1e)); 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORB   $1F,U                   ; F396: EA C8 1F      \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = B | (UINT8)rd_mem((UINT16)(U + (SINT8)0x1f)); 
    B = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         TFR   D,S                     ; F399: 1F 04         \n");
                                      #endif
    S = ((A << 8) | B); 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LF3DC                   ; F39B: 20 3F         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LF3DC;
    
    // ---------------------------------------------------------------------------
  case 0xF39D:
LF39D:
                                                     #ifdef DEBUG
                                      mon("LF39D    LDA   #$80                    ; F39D: 86 80         \n");
                                      #endif
    PC = 0xf39d; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x80; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLA                          ; F39F: 48            \n");
                                      #endif
    val = (UINT8)A; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
  case 0xF3A0:
LF3A0:
                                                     #ifdef DEBUG
                                      mon("LF3A0    ROLA                          ; F3A0: 49            \n");
                                      #endif
    PC = 0xf3a0; 
    INSTRUCTION_START
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
    C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   ,X                      ; F3A1: A7 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         TFR   A,B                     ; F3A3: 1F 89         \n");
                                      #endif
    B = (UINT8)A; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         EORB  ,X                      ; F3A5: E8 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    res = B ^ rd_mem(X); 
    B = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LF3B5                   ; F3A7: 27 0C         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LF3B5;
    }
                                                     #ifdef DEBUG
                                      mon("         TFR   S,D                     ; F3A9: 1F 40         \n");
                                      #endif
    val = S; 
    A = (UINT8)(val >> 8); 
    B = (UINT8)val; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         ORA   $1E,U                   ; F3AB: AA C8 1E      \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = A | (UINT8)rd_mem((UINT16)(U + (SINT8)0x1e)); 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORB   $1F,U                   ; F3AE: EA C8 1F      \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = B | (UINT8)rd_mem((UINT16)(U + (SINT8)0x1f)); 
    B = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         TFR   D,S                     ; F3B1: 1F 04         \n");
                                      #endif
    S = ((A << 8) | B); 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LF3DC                   ; F3B3: 20 27         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LF3DC;
    
    // ---------------------------------------------------------------------------
  case 0xF3B5:
LF3B5:
                                                     #ifdef DEBUG
                                      mon("LF3B5    BCC   LF3BE                   ; F3B5: 24 07         \n");
                                      #endif
    PC = 0xf3b5; 
    INSTRUCTION_START
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LF3BE;
    }
                                                     #ifdef DEBUG
                                      mon("         TSTA                          ; F3B7: 4D            \n");
                                      #endif
    val = (UINT8)A; 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LF3A0                   ; F3B8: 26 E6         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LF3A0;
    }
                                                     #ifdef DEBUG
                                      mon("         ADDA  #$FF                    ; F3BA: 8B FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xff; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
    V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LF3A0                   ; F3BC: 20 E2         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LF3A0;
    
    // ---------------------------------------------------------------------------
  case 0xF3BE:
LF3BE:
                                                     #ifdef DEBUG
                                      mon("LF3BE    TFR   A,B                     ; F3BE: 1F 89         \n");
                                      #endif
    PC = 0xf3be; 
    INSTRUCTION_START
    B = (UINT8)A; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         INCB                          ; F3C0: 5C            \n");
                                      #endif
    val = (UINT8)B; 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LF3A0                   ; F3C1: 26 DD         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LF3A0;
    }
                                                     #ifdef DEBUG
                                      mon("         STA   $4640                   ; F3C3: B7 46 40      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4640, val); 
                                                     #ifdef DEBUG
                                      mon("         CMPU  #word_F332              ; F3C6: 11 83 F3 32   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
    arg = 0xf332; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LF3D2                   ; F3CA: 27 06         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LF3D2;
    }
                                                     #ifdef DEBUG
                                      mon("         CMPU  #word_F334              ; F3CC: 11 83 F3 34   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
    arg = 0xf334; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LF3D6                   ; F3D0: 26 04         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LF3D6;
    }
  case 0xF3D2:
LF3D2:
                                                     #ifdef DEBUG
                                      mon("LF3D2    LEAX  $02,X                   ; F3D2: 30 02         \n");
                                      #endif
    PC = 0xf3d2; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    X = (X + 0x0002); 
    Z = X; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LF3D8                   ; F3D4: 20 02         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LF3D8;
    
    // ---------------------------------------------------------------------------
  case 0xF3D6:
LF3D6:
                                                     #ifdef DEBUG
                                      mon("LF3D6    LEAX  $01,X                   ; F3D6: 30 01         \n");
                                      #endif
    PC = 0xf3d6; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    X = (X + 0x0001); 
 // Z = X; 
  case 0xF3D8:
LF3D8:
                                                     #ifdef DEBUG
                                      mon("LF3D8    LEAY  -1,Y                    ; F3D8: 31 3F         \n");
                                      #endif
    PC = 0xf3d8; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    Y = (Y + 0xffff); 
    Z = Y; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LF38D                   ; F3DA: 26 B1         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LF38D;
    }
  case 0xF3DC:
LF3DC:
                                                     #ifdef DEBUG
                                      mon("LF3DC    CMPU  #off_F340               ; F3DC: 11 83 F3 40   \n");
                                      #endif
    PC = 0xf3dc; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = U; 
    arg = 0xf340; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LF387                   ; F3E0: 25 A5         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LF387;
    }
                                                     #ifdef DEBUG
                                      mon("         LDU   #word_F32E              ; F3E2: CE F3 2E      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0xf32e; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0xF3E5:
LF3E5:
                                                     #ifdef DEBUG
                                      mon("LF3E5    LDX   ,U++                    ; F3E5: AE C1         \n");
                                      #endif
    PC = 0xf3e5; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
    clockticks = clockticks + 1; 
    ea = rd_mem(U)<<8; 
    ea = ea | rd_mem((UINT16)((U)+1)); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
    U = U + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDY   #$0800                  ; F3E7: 10 8E 08 00   \n");
                                      #endif
    clockticks = clockticks + 4; 
    Y = 0x0800; 
 // Z = Y; 
 // N = (Y) >> 8; 
 // V = 0; 
  case 0xF3EB:
LF3EB:
                                                     #ifdef DEBUG
                                      mon("LF3EB    INC   ,X                      ; F3EB: 6C 84         \n");
                                      #endif
    PC = 0xf3eb; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(X); 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    wr_mem(X, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LF3FB                   ; F3ED: 27 0C         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LF3FB;
    }
                                                     #ifdef DEBUG
                                      mon("         TFR   S,D                     ; F3EF: 1F 40         \n");
                                      #endif
    val = S; 
    A = (UINT8)(val >> 8); 
    B = (UINT8)val; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         ORA   $1E,U                   ; F3F1: AA C8 1E      \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = A | (UINT8)rd_mem((UINT16)(U + (SINT8)0x1e)); 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORB   $1F,U                   ; F3F4: EA C8 1F      \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = B | (UINT8)rd_mem((UINT16)(U + (SINT8)0x1f)); 
    B = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         TFR   D,S                     ; F3F7: 1F 04         \n");
                                      #endif
    S = ((A << 8) | B); 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LF424                   ; F3F9: 20 29         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LF424;
    
    // ---------------------------------------------------------------------------
  case 0xF3FB:
LF3FB:
                                                     #ifdef DEBUG
                                      mon("LF3FB    LDA   ,X                      ; F3FB: A6 84         \n");
                                      #endif
    PC = 0xf3fb; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(X); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LF40B                   ; F3FD: 27 0C         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LF40B;
    }
                                                     #ifdef DEBUG
                                      mon("         TFR   S,D                     ; F3FF: 1F 40         \n");
                                      #endif
    val = S; 
    A = (UINT8)(val >> 8); 
    B = (UINT8)val; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         ORA   $1E,U                   ; F401: AA C8 1E      \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = A | (UINT8)rd_mem((UINT16)(U + (SINT8)0x1e)); 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORB   $1F,U                   ; F404: EA C8 1F      \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = B | (UINT8)rd_mem((UINT16)(U + (SINT8)0x1f)); 
    B = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         TFR   D,S                     ; F407: 1F 04         \n");
                                      #endif
    S = ((A << 8) | B); 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LF424                   ; F409: 20 19         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LF424;
    
    // ---------------------------------------------------------------------------
  case 0xF40B:
LF40B:
                                                     #ifdef DEBUG
                                      mon("LF40B    STA   $4640                   ; F40B: B7 46 40      \n");
                                      #endif
    PC = 0xf40b; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4640, val); 
                                                     #ifdef DEBUG
                                      mon("         CMPU  #word_F332              ; F40E: 11 83 F3 32   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
    arg = 0xf332; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LF41A                   ; F412: 27 06         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LF41A;
    }
                                                     #ifdef DEBUG
                                      mon("         CMPU  #word_F334              ; F414: 11 83 F3 34   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
    arg = 0xf334; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LF41E                   ; F418: 26 04         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LF41E;
    }
  case 0xF41A:
LF41A:
                                                     #ifdef DEBUG
                                      mon("LF41A    LEAX  $02,X                   ; F41A: 30 02         \n");
                                      #endif
    PC = 0xf41a; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    X = (X + 0x0002); 
    Z = X; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LF420                   ; F41C: 20 02         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LF420;
    
    // ---------------------------------------------------------------------------
  case 0xF41E:
LF41E:
                                                     #ifdef DEBUG
                                      mon("LF41E    LEAX  $01,X                   ; F41E: 30 01         \n");
                                      #endif
    PC = 0xf41e; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    X = (X + 0x0001); 
 // Z = X; 
  case 0xF420:
LF420:
                                                     #ifdef DEBUG
                                      mon("LF420    LEAY  -1,Y                    ; F420: 31 3F         \n");
                                      #endif
    PC = 0xf420; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    Y = (Y + 0xffff); 
    Z = Y; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LF3EB                   ; F422: 26 C7         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LF3EB;
    }
  case 0xF424:
LF424:
                                                     #ifdef DEBUG
                                      mon("LF424    CMPU  #off_F340               ; F424: 11 83 F3 40   \n");
                                      #endif
    PC = 0xf424; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = U; 
    arg = 0xf340; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LF3E5                   ; F428: 25 BB         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LF3E5;
    }
                                                     #ifdef DEBUG
                                      mon("         TFR   S,D                     ; F42A: 1F 40         \n");
                                      #endif
    val = S; 
    A = (UINT8)(val >> 8); 
    B = (UINT8)val; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$01                    ; F42C: C4 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x01; 
    B = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LF43F                   ; F42E: 26 0F         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LF43F;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4500                  ; F430: 8E 45 00      \n");
                                      #endif // NOVRAM
    clockticks = clockticks + 3; 
    X = 0x4500; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #$4C00                  ; F433: CE 4C 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x4c00; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0xF436:
LF436:
                                                     #ifdef DEBUG
                                      mon("LF436    LDD   ,X++                    ; F436: EC 81         \n");
                                      #endif
    PC = 0xf436; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
    A = rd_mem(X); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(X+1)); 
    X = X + 2; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,U++                    ; F438: ED C1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    U = U + 2; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$4600                  ; F43A: 8C 46 00      \n");
                                      #endif // NOVRAM
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x4600; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LF436                   ; F43D: 25 F7         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LF436;
    }
  case 0xF43F:
LF43F:
                                                     #ifdef DEBUG
                                      mon("LF43F    LDU   #word_F342              ; F43F: CE F3 42      \n");
                                      #endif
    PC = 0xf43f; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0xf342; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4500                  ; F442: 8E 45 00      \n");
                                      #endif // NOVRAM
    clockticks = clockticks + 3; 
    X = 0x4500; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; F445: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0xF448:
LF448:
                                                     #ifdef DEBUG
                                      mon("LF448    STD   ,X++                    ; F448: ED 81         \n");
                                      #endif
    PC = 0xf448; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    X = X + 2; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$4600                  ; F44A: 8C 46 00      \n");
                                      #endif // NOVRAM
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x4600; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LF448                   ; F44D: 25 F9         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LF448;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4500                  ; F44F: 8E 45 00      \n");
                                      #endif // NOVRAM
    clockticks = clockticks + 3; 
    X = 0x4500; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xF452:
LF452:
                                                     #ifdef DEBUG
                                      mon("LF452    LDA   ,X                      ; F452: A6 84         \n");
                                      #endif
    PC = 0xf452; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(X); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$0F                    ; F454: 84 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x0f; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LF464                   ; F456: 27 0C         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LF464;
    }
                                                     #ifdef DEBUG
                                      mon("         TFR   S,D                     ; F458: 1F 40         \n");
                                      #endif
    val = S; 
    A = (UINT8)(val >> 8); 
    B = (UINT8)val; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         ORA   $1E,U                   ; F45A: AA C8 1E      \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = A | (UINT8)rd_mem((UINT16)(U + (SINT8)0x1e)); 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORB   $1F,U                   ; F45D: EA C8 1F      \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = B | (UINT8)rd_mem((UINT16)(U + (SINT8)0x1f)); 
    B = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         TFR   D,S                     ; F460: 1F 04         \n");
                                      #endif
    S = ((A << 8) | B); 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LF4B7                   ; F462: 20 53         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LF4B7;
    
    // ---------------------------------------------------------------------------
  case 0xF464:
LF464:
                                                     #ifdef DEBUG
                                      mon("LF464    LDA   #$80                    ; F464: 86 80         \n");
                                      #endif
    PC = 0xf464; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x80; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLA                          ; F466: 48            \n");
                                      #endif
    val = (UINT8)A; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDY   #$04                    ; F467: 10 8E 00 04   \n");
                                      #endif
    clockticks = clockticks + 4; 
    Y = 0x0004; 
 // Z = Y; 
 // N = (Y) >> 8; 
 // V = 0; 
  case 0xF46B:
LF46B:
                                                     #ifdef DEBUG
                                      mon("LF46B    ROLA                          ; F46B: 49            \n");
                                      #endif
    PC = 0xf46b; 
    INSTRUCTION_START
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
    C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   ,X                      ; F46C: A7 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         TFR   A,B                     ; F46E: 1F 89         \n");
                                      #endif
    B = (UINT8)A; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         EORB  ,X                      ; F470: E8 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    res = B ^ rd_mem(X); 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$0F                    ; F472: C4 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x0f; 
    B = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LF482                   ; F474: 27 0C         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LF482;
    }
                                                     #ifdef DEBUG
                                      mon("         TFR   S,D                     ; F476: 1F 40         \n");
                                      #endif
    val = S; 
    A = (UINT8)(val >> 8); 
    B = (UINT8)val; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         ORA   $1E,U                   ; F478: AA C8 1E      \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = A | (UINT8)rd_mem((UINT16)(U + (SINT8)0x1e)); 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORB   $1F,U                   ; F47B: EA C8 1F      \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = B | (UINT8)rd_mem((UINT16)(U + (SINT8)0x1f)); 
    B = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         TFR   D,S                     ; F47E: 1F 04         \n");
                                      #endif
    S = ((A << 8) | B); 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LF4B7                   ; F480: 20 35         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LF4B7;
    
    // ---------------------------------------------------------------------------
  case 0xF482:
LF482:
                                                     #ifdef DEBUG
                                      mon("LF482    LEAY  -1,Y                    ; F482: 31 3F         \n");
                                      #endif
    PC = 0xf482; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    Y = (Y + 0xffff); 
    Z = Y; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LF46B                   ; F484: 26 E5         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LF46B;
    }
                                                     #ifdef DEBUG
                                      mon("         TSTA                          ; F486: 4D            \n");
                                      #endif
    val = (UINT8)A; 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BMI   LF491                   ; F487: 2B 08         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LF491;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$FF                    ; F489: 86 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xff; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDY   #$05                    ; F48B: 10 8E 00 05   \n");
                                      #endif
    clockticks = clockticks + 4; 
    Y = 0x0005; 
    Z = Y; 
    N = (Y) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LF46B                   ; F48F: 20 DA         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LF46B;
    
    // ---------------------------------------------------------------------------
  case 0xF491:
LF491:
                                                     #ifdef DEBUG
                                      mon("LF491    STA   $4640                   ; F491: B7 46 40      \n");
                                      #endif
    PC = 0xf491; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4640, val); 
                                                     #ifdef DEBUG
                                      mon("         LEAX  $01,X                   ; F494: 30 01         \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + 0x0001); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$4600                  ; F496: 8C 46 00      \n");
                                      #endif // NOVRAM
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x4600; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LF452                   ; F499: 25 B7         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LF452;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4500                  ; F49B: 8E 45 00      \n");
                                      #endif // NOVRAM
    clockticks = clockticks + 3; 
    X = 0x4500; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xF49E:
LF49E:
                                                     #ifdef DEBUG
                                      mon("LF49E    INC   ,X                      ; F49E: 6C 84         \n");
                                      #endif
    PC = 0xf49e; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(X); 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    wr_mem(X, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   ,X+                     ; F4A0: A6 80         \n");
                                      #endif
    clockticks = clockticks + 6; 
    val = (UINT8)rd_mem(X); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
    X = X + 1; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$0F                    ; F4A2: 84 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x0f; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LF4B2                   ; F4A4: 27 0C         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LF4B2;
    }
                                                     #ifdef DEBUG
                                      mon("         TFR   S,D                     ; F4A6: 1F 40         \n");
                                      #endif
    val = S; 
    A = (UINT8)(val >> 8); 
    B = (UINT8)val; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         ORA   $1E,U                   ; F4A8: AA C8 1E      \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = A | (UINT8)rd_mem((UINT16)(U + (SINT8)0x1e)); 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORB   $1F,U                   ; F4AB: EA C8 1F      \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = B | (UINT8)rd_mem((UINT16)(U + (SINT8)0x1f)); 
    B = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         TFR   D,S                     ; F4AE: 1F 04         \n");
                                      #endif
    S = ((A << 8) | B); 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LF4B7                   ; F4B0: 20 05         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LF4B7;
    
    // ---------------------------------------------------------------------------
  case 0xF4B2:
LF4B2:
                                                     #ifdef DEBUG
                                      mon("LF4B2    CMPX  #$4600                  ; F4B2: 8C 46 00      \n");
                                      #endif // NOVRAM
    PC = 0xf4b2; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x4600; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LF49E                   ; F4B5: 25 E7         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LF49E;
    }
  case 0xF4B7:
LF4B7:
                                                     #ifdef DEBUG
                                      mon("LF4B7    TFR   S,D                     ; F4B7: 1F 40         \n");
                                      #endif
    PC = 0xf4b7; 
    INSTRUCTION_START
    val = S; 
    A = (UINT8)(val >> 8); 
    B = (UINT8)val; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$01                    ; F4B9: C4 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x01; 
    B = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LF4CE                   ; F4BB: 26 11         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LF4CE;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4C00                  ; F4BD: 8E 4C 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x4c00; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #$4500                  ; F4C0: CE 45 00      \n");
                                      #endif // NOVRAM
    clockticks = clockticks + 3; 
    U = 0x4500; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0xF4C3:
LF4C3:
                                                     #ifdef DEBUG
                                      mon("LF4C3    LDD   ,X++                    ; F4C3: EC 81         \n");
                                      #endif
    PC = 0xf4c3; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
    A = rd_mem(X); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(X+1)); 
    X = X + 2; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,U++                    ; F4C5: ED C1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    U = U + 2; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$4D00                  ; F4C7: 8C 4D 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x4d00; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LF4C3                   ; F4CA: 25 F7         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LF4C3;
    }
                                                     #ifdef DEBUG
                                      mon("         BRA   LF4EC                   ; F4CC: 20 1E         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LF4EC;
    
    // ---------------------------------------------------------------------------
  case 0xF4CE:
LF4CE:
                                                     #ifdef DEBUG
                                      mon("LF4CE    LDA   #$FF                    ; F4CE: 86 FF         \n");
                                      #endif
    PC = 0xf4ce; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0xff; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4687                   ; F4D0: B7 46 87      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4687, val); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$0100                  ; F4D3: 8E 01 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x0100; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xF4D6:
LF4D6:
                                                     #ifdef DEBUG
                                      mon("LF4D6    STA   $4640                   ; F4D6: B7 46 40      \n");
                                      #endif
    PC = 0xf4d6; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x4640, val); 
                                                     #ifdef DEBUG
                                      mon("         LEAX  -1,X                    ; F4D9: 30 1F         \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + 0xffff); 
    Z = X; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LF4D6                   ; F4DB: 26 F9         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LF4D6;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; F4DD: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4687                   ; F4DF: B7 46 87      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4687, val); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$A000                  ; F4E2: 8E A0 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0xa000; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xF4E5:
LF4E5:
                                                     #ifdef DEBUG
                                      mon("LF4E5    STA   $4640                   ; F4E5: B7 46 40      \n");
                                      #endif
    PC = 0xf4e5; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x4640, val); 
                                                     #ifdef DEBUG
                                      mon("         LEAX  -1,X                    ; F4E8: 30 1F         \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + 0xffff); 
    Z = X; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LF4E5                   ; F4EA: 26 F9         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LF4E5;
    }
  case 0xF4EC:
LF4EC:
                                                     #ifdef DEBUG
                                      mon("LF4EC    STA   $4640                   ; F4EC: B7 46 40      \n");
                                      #endif
    PC = 0xf4ec; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4640, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; F4EF: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4684                   ; F4F1: B7 46 84      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4684, val); 
    PC = 0xf4f4; 
    goto bankswitch_check;
  case 0xF4F4:
LF4F4:
                                                     #ifdef DEBUG
                                      mon("LF4F4    LDX   word_F342               ; F4F4: BE F3 42      \n");
                                      #endif
    PC = 0xf4f4; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0xf342)<<8; 
    ea = ea | rd_mem(0xf343); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDY   #$2000                  ; F4F7: 10 8E 20 00   \n");
                                      #endif
    clockticks = clockticks + 4; 
    Y = 0x2000; 
 // Z = Y; 
 // N = (Y) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         TFR   X,D                     ; F4FB: 1F 10         \n");
                                      #endif
    val = X; 
    A = (UINT8)(val >> 8); 
    B = (UINT8)val; 
    clockticks = clockticks + 6; 
  case 0xF4FD:
LF4FD:
                                                     #ifdef DEBUG
                                      mon("LF4FD    ADCB  $01,X                   ; F4FD: E9 01         \n");
                                      #endif
    PC = 0xf4fd; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    arg = B; 
    val = rd_mem((UINT16)(X + 0x0001)); 
    res = arg + val + (C != 0 ? 1:0); 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // H = arg ^ val ^ (UINT8)res ^ C; 
 // V = arg ^ val ^ (UINT8)res ^ C; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         ADCA  ,X++                    ; F4FF: A9 81         \n");
                                      #endif
    clockticks = clockticks + 7; 
    arg = A; 
    val = rd_mem(X); 
    res = arg + val + (C != 0 ? 1:0); 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = arg ^ val ^ (UINT8)res ^ C; 
 // V = arg ^ val ^ (UINT8)res ^ C; 
    A = (UINT8)res; 
    X = X + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4640                   ; F501: B7 46 40      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x4640, val); 
                                                     #ifdef DEBUG
                                      mon("         LEAY  -2,Y                    ; F504: 31 3E         \n");
                                      #endif
    clockticks = clockticks + 5; 
    Y = (Y + 0xfffe); 
    Z = Y; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LF4FD                   ; F506: 26 F5         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LF4FD;
    }
                                                     #ifdef DEBUG
                                      mon("         TFR   D,X                     ; F508: 1F 01         \n");
                                      #endif
    X = ((A << 8) | B); 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$FF                    ; F50A: 86 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xff; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4684                   ; F50C: B7 46 84      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4684, val); 
    PC = 0xf50f; 
    goto bankswitch_check;
  case 0xF50F:
LF50F:
                                                     #ifdef DEBUG
                                      mon("LF50F    LDU   #word_F344              ; F50F: CE F3 44      \n");
                                      #endif // Point to ROM start address table
    PC = 0xf50f; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0xf344; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         TFR   X,D                     ; F512: 1F 10         \n");
                                      #endif
    val = X; 
    A = (UINT8)(val >> 8); 
    B = (UINT8)val; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         LDY   #$2000                  ; F514: 10 8E 20 00   \n");
                                      #endif // Size of each ROM
    clockticks = clockticks + 4; 
    Y = 0x2000; 
 // Z = Y; 
 // N = (Y) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDX   word_F342               ; F518: BE F3 42      \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0xf342)<<8; 
    ea = ea | rd_mem(0xf343); 
    X = ea; 
    Z = X; 
    N = (X) >> 8; 
    V = 0; 
    // END OF FUNCTION CHUNK FOR sub_6532
                                                     #ifdef DEBUG
                                      mon("         BRA   LF528                   ; F51B: 20 0B         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LF528;
    
    // =============== S U B R O U T I N E =======================================
    // End of function sub_F51D
  case 0xF51D:
LF51D:
                                                     #ifdef DEBUG
                                      mon("LF51D    LDU   #word_F344              ; F51D: CE F3 44      \n");
                                      #endif // Point to ROM start address table
    PC = 0xf51d; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0xf344; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
    // START OF FUNCTION CHUNK FOR sub_6532
  case 0xF520:
LF520:
                                                     #ifdef DEBUG
                                      mon("LF520    LDX   ,U++                    ; F520: AE C1         \n");
                                      #endif // Next ROM address start
    PC = 0xf520; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
    clockticks = clockticks + 1; 
    ea = rd_mem(U)<<8; 
    ea = ea | rd_mem((UINT16)((U)+1)); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
    U = U + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDY   #$2000                  ; F522: 10 8E 20 00   \n");
                                      #endif // Size of ROM
    clockticks = clockticks + 4; 
    Y = 0x2000; 
 // Z = Y; 
 // N = (Y) >> 8; 
 // V = 0; 
  case 0xF526:
LF526:
                                                     #ifdef DEBUG
                                      mon("LF526    TFR   X,D                     ; F526: 1F 10         \n");
                                      #endif
    PC = 0xf526; 
    INSTRUCTION_START
    val = X; 
    A = (UINT8)(val >> 8); 
    B = (UINT8)val; 
    clockticks = clockticks + 6; 
  case 0xF528:
LF528:
                                                     #ifdef DEBUG
                                      mon("LF528    ADCB  $01,X                   ; F528: E9 01         \n");
                                      #endif
    PC = 0xf528; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    arg = B; 
    val = rd_mem((UINT16)(X + 0x0001)); 
    res = arg + val + (C != 0 ? 1:0); 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // H = arg ^ val ^ (UINT8)res ^ C; 
 // V = arg ^ val ^ (UINT8)res ^ C; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         ADCA  ,X++                    ; F52A: A9 81         \n");
                                      #endif
    clockticks = clockticks + 7; 
    arg = A; 
    val = rd_mem(X); 
    res = arg + val + (C != 0 ? 1:0); 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = arg ^ val ^ (UINT8)res ^ C; 
 // V = arg ^ val ^ (UINT8)res ^ C; 
    A = (UINT8)res; 
    X = X + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4640                   ; F52C: B7 46 40      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x4640, val); 
                                                     #ifdef DEBUG
                                      mon("         LEAY  -2,Y                    ; F52F: 31 3E         \n");
                                      #endif
    clockticks = clockticks + 5; 
    Y = (Y + 0xfffe); 
    Z = Y; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LF528                   ; F531: 26 F5         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LF528;
    }
                                                     #ifdef DEBUG
                                      mon("         STD   $5593,U                 ; F533: ED C9 55 93   \n");
                                      #endif
    clockticks = clockticks + 8; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = (UINT16)(U + 0x5593); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LF543                   ; F537: 27 0A         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LF543;
    }
                                                     #ifdef DEBUG
                                      mon("         TFR   S,D                     ; F539: 1F 40         \n");
                                      #endif
    val = S; 
    A = (UINT8)(val >> 8); 
    B = (UINT8)val; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         ORA   $1E,U                   ; F53B: AA C8 1E      \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = A | (UINT8)rd_mem((UINT16)(U + (SINT8)0x1e)); 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORB   $1F,U                   ; F53E: EA C8 1F      \n");
                                      #endif
    clockticks = clockticks + 5; 
    res = B | (UINT8)rd_mem((UINT16)(U + (SINT8)0x1f)); 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         TFR   D,S                     ; F541: 1F 04         \n");
                                      #endif
    S = ((A << 8) | B); 
    clockticks = clockticks + 6; 
  case 0xF543:
LF543:
                                                     #ifdef DEBUG
                                      mon("LF543    CMPU  #word_F34C              ; F543: 11 83 F3 4C   \n");
                                      #endif
    PC = 0xf543; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = U; 
    arg = 0xf34c; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LF520                   ; F547: 25 D7         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LF520;
    }
                                                     #ifdef DEBUG
                                      mon("         CMPU  #word_F34E              ; F549: 11 83 F3 4E   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
    arg = 0xf34e; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCC   LF557                   ; F54D: 24 08         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LF557;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   ,U++                    ; F54F: AE C1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    clockticks = clockticks + 1; 
    ea = rd_mem(U)<<8; 
    ea = ea | rd_mem((UINT16)((U)+1)); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
    U = U + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDY   #$1000                  ; F551: 10 8E 10 00   \n");
                                      #endif
    clockticks = clockticks + 4; 
    Y = 0x1000; 
    Z = Y; 
    N = (Y) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LF526                   ; F555: 20 CF         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LF526;
    
    // ---------------------------------------------------------------------------
  case 0xF557:
LF557:
                                                     #ifdef DEBUG
                                      mon("LF557    LDA   #$FF                    ; F557: 86 FF         \n");
                                      #endif
    PC = 0xf557; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0xff; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4686                   ; F559: B7 46 86      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4686, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   $4683                   ; F55C: B7 46 83      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4683, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   $4682                   ; F55F: B7 46 82      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4682, val); 
                                                     #ifdef DEBUG
                                      mon("         CLR   <$D1                    ; F562: 0F D1         \n");
                                      #endif
    clockticks = clockticks + 4; 
    wr_mem(DP|0xd1, 0); 
 // V = 0; 
 // Z = 0; 
 // N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4320                   ; F564: B6 43 20      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4320); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$04                    ; F567: 84 04         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x04; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LF56E                   ; F569: 26 03         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LF56E;
    }
                                                     #ifdef DEBUG
                                      mon("         JMP   Check_Test_Diag         ; F56B: 7E FD 07      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LFD07;
    
    // ---------------------------------------------------------------------------
  case 0xF56E:
LF56E:
                                                     #ifdef DEBUG
                                      mon("LF56E    STA   $4640                   ; F56E: B7 46 40      \n");
                                      #endif
    PC = 0xf56e; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4640, val); 
                                                     #ifdef DEBUG
                                      mon("         STS   <$D2                    ; F571: 10 DF D2      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = S; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = DP|0xd2; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         TFR   S,D                     ; F574: 1F 40         \n");
                                      #endif
    val = S; 
    A = (UINT8)(val >> 8); 
    B = (UINT8)val; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$01                    ; F576: C4 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x01; 
    B = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LF5ED                   ; F578: 26 73         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LF5ED;
    }
                                                     #ifdef DEBUG
                                      mon("         LDY   #$00                    ; F57A: 10 8E 00 00   \n");
                                      #endif
    clockticks = clockticks + 4; 
    Y = 0x0000; 
 // Z = Y; 
 // N = (Y) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$6000                  ; F57E: CC 60 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x60; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F581: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$BFAE                  ; F583: CC BF AE      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xbf; 
    B = 0xae; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F586: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$8040                  ; F588: CC 80 40      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F58B: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$48                    ; F58D: 86 48         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x48; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         TFR   A,DP                    ; F58F: 1F 8B         \n");
                                      #endif
    DP = (A) << 8; checkDP(); 
    // memory_DP = &memory[DP];
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         STS   <$CC                    ; F591: 10 DF CC      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = S; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = DP|0xcc; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         LDS   #$4FFF                  ; F594: 10 CE 4F FF   \n");
                                      #endif
    clockticks = clockticks + 4; 
    S = 0x4fff; 
 // Z = S; 
 // N = (S) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$D3                    ; F598: C6 D3         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xd3; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LE7C7                   ; F59A: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x9d); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xf5); 
    clockticks = clockticks + 1; 
    goto LE7C7;
  case 0xF59D:
LF59D:
                                                     #ifdef DEBUG
                                      mon("LF59D    LDB   #$B0                    ; F59D: C6 B0         \n");
                                      #endif
    PC = 0xf59d; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0xb0; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LE7C7                   ; F59F: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xa2); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xf5); 
    clockticks = clockticks + 1; 
    goto LE7C7;
  case 0xF5A2:
LF5A2:
                                                     #ifdef DEBUG
                                      mon("LF5A2    LDB   #$B2                    ; F5A2: C6 B2         \n");
                                      #endif
    PC = 0xf5a2; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0xb2; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STB   <$CE                    ; F5A4: D7 CE         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xce; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$CC                    ; F5A6: DC CC         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0xcc); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0xcd); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LF5B1                   ; F5A8: 26 07         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LF5B1;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   #$B1                    ; F5AA: C6 B1         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xb1; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LE7C7                   ; F5AC: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xaf); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xf5); 
    clockticks = clockticks + 1; 
    goto LE7C7;
  case 0xF5AF:
LF5AF:
                                                     #ifdef DEBUG
                                      mon("LF5AF    BRA   LF5EB                   ; F5AF: 20 3A         \n");
                                      #endif
    PC = 0xf5af; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto LF5EB;
    
    // ---------------------------------------------------------------------------
  case 0xF5B1:
LF5B1:
                                                     #ifdef DEBUG
                                      mon("LF5B1    LSRA                          ; F5B1: 44            \n");
                                      #endif
    PC = 0xf5b1; 
    INSTRUCTION_START
    val = (UINT8)A; 
    C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         RORB                          ; F5B2: 56            \n");
                                      #endif
    res = ((UINT8)B) | ((C != 0) ? 0x100 : 0); 
    C = res & 1; 
    res = (UINT8)(res >> 1); 
 // Z = res; 
 // N = res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$CC                    ; F5B3: DD CC         \n");
                                      #endif
    clockticks = clockticks + 4; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = DP|0xcc; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         BCC   LF5E5                   ; F5B5: 24 2E         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LF5E5;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   <$CE                    ; F5B7: D6 CE         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xce); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LE7C7                   ; F5B9: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xbc); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xf5); 
    clockticks = clockticks + 1; 
    goto LE7C7;
  case 0xF5BC:
LF5BC:
                                                     #ifdef DEBUG
                                      mon("LF5BC    LDB   <$CE                    ; F5BC: D6 CE         \n");
                                      #endif
    PC = 0xf5bc; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xce); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBB  #$BC                    ; F5BE: C0 BC         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0xbc; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
    B = (UINT8)(res); 
                                                     #ifdef DEBUG
                                      mon("         BCS   LF5E5                   ; F5C0: 25 23         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LF5E5;
    }
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; F5C2: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$F743                  ; F5C3: 8E F7 43      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0xf743; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; F5C6: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         LDU   ,X                      ; F5C7: EE 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STU   ,Y++                    ; F5C9: EF A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #$0120                  ; F5CB: CE 01 20      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x0120; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STU   ,Y++                    ; F5CE: EF A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$48D7                  ; F5D0: 8E 48 D7      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x48d7; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; F5D3: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         LDA   ,X+                     ; F5D4: A6 80         \n");
                                      #endif
    clockticks = clockticks + 6; 
    val = (UINT8)rd_mem(X); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
    X = X + 1; 
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; F5D6: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Display_Vect_BCD        ; F5D7: BD E7 90      \n");
                                      #endif // Display BCD numbers
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xda); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xf5); 
    clockticks = clockticks + 1; 
    goto LE790;
  case 0xF5DA:
LF5DA:
                                                     #ifdef DEBUG
                                      mon("LF5DA    LDA   ,X                      ; F5DA: A6 84         \n");
                                      #endif
    PC = 0xf5da; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(X); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; F5DC: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Display_Vect_BCD        ; F5DD: BD E7 90      \n");
                                      #endif // Display BCD numbers
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xe0); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xf5); 
    clockticks = clockticks + 1; 
    goto LE790;
  case 0xF5E0:
LF5E0:
                                                     #ifdef DEBUG
                                      mon("LF5E0    LDD   #$8040                  ; F5E0: CC 80 40      \n");
                                      #endif
    PC = 0xf5e0; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F5E3: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
  case 0xF5E5:
LF5E5:
                                                     #ifdef DEBUG
                                      mon("LF5E5    INC   <$CE                    ; F5E5: 0C CE         \n");
                                      #endif
    PC = 0xf5e5; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xce); 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    wr_mem(DP|0xce, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$CC                    ; F5E7: DC CC         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0xcc); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0xcd); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LF5B1                   ; F5E9: 26 C6         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LF5B1;
    }
  case 0xF5EB:
LF5EB:
                                                     #ifdef DEBUG
                                      mon("LF5EB    BRA   LF643                   ; F5EB: 20 56         \n");
                                      #endif
    PC = 0xf5eb; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto LF643;
    
    // ---------------------------------------------------------------------------
  case 0xF5ED:
LF5ED:
                                                     #ifdef DEBUG
                                      mon("LF5ED    LDX   #$08                    ; F5ED: 8E 00 08      \n");
                                      #endif
    PC = 0xf5ed; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x0008; 
 // Z = X; 
 // N = (X) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         TFR   S,D                     ; F5F0: 1F 40         \n");
                                      #endif
    val = S; 
    A = (UINT8)(val >> 8); 
    B = (UINT8)val; 
    clockticks = clockticks + 6; 
  case 0xF5F2:
LF5F2:
                                                     #ifdef DEBUG
                                      mon("LF5F2    LSRB                          ; F5F2: 54            \n");
                                      #endif
    PC = 0xf5f2; 
    INSTRUCTION_START
    val = (UINT8)B; 
    C = val & 1; 
    val = val >> 1; 
    B = val; 
    N = 0; 
    Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BCC   LF5F9                   ; F5F3: 24 04         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LF5F9;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$29                    ; F5F5: 86 29         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x29; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LF5FB                   ; F5F7: 20 02         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LF5FB;
    
    // ---------------------------------------------------------------------------
  case 0xF5F9:
LF5F9:
                                                     #ifdef DEBUG
                                      mon("LF5F9    LDA   #$3B                    ; F5F9: 86 3B         \n");
                                      #endif
    PC = 0xf5f9; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x3b; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xF5FB:
LF5FB:
                                                     #ifdef DEBUG
                                      mon("LF5FB    STA   $4400                   ; F5FB: B7 44 00      \n");
                                      #endif
    PC = 0xf5fb; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4400, val); 
                                                     #ifdef DEBUG
                                      mon("         LDU   #$00                    ; F5FE: CE 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x0000; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0xF601:
LF601:
                                                     #ifdef DEBUG
                                      mon("LF601    STB   $4640                   ; F601: F7 46 40      \n");
                                      #endif
    PC = 0xf601; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4640, val); 
                                                     #ifdef DEBUG
                                      mon("         LEAU  $01,U                   ; F604: 33 41         \n");
                                      #endif
    clockticks = clockticks + 5; 
    U = (U + 0x0001); 
                                                     #ifdef DEBUG
                                      mon("         CMPU  #$A000                  ; F606: 11 83 A0 00   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
    arg = 0xa000; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LF601                   ; F60A: 25 F5         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LF601;
    }
                                                     #ifdef DEBUG
                                      mon("         LEAX  -1,X                    ; F60C: 30 1F         \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + 0xffff); 
    Z = X; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LF5F2                   ; F60E: 26 E2         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LF5F2;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   #$08                    ; F610: 8E 00 08      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x0008; 
 // Z = X; 
 // N = (X) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         TFR   S,D                     ; F613: 1F 40         \n");
                                      #endif
    val = S; 
    A = (UINT8)(val >> 8); 
    B = (UINT8)val; 
    clockticks = clockticks + 6; 
  case 0xF615:
LF615:
                                                     #ifdef DEBUG
                                      mon("LF615    LSRA                          ; F615: 44            \n");
                                      #endif
    PC = 0xf615; 
    INSTRUCTION_START
    val = (UINT8)A; 
    C = val & 1; 
    val = val >> 1; 
    A = val; 
    N = 0; 
    Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BCC   LF61C                   ; F616: 24 04         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LF61C;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   #$29                    ; F618: C6 29         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x29; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LF61E                   ; F61A: 20 02         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LF61E;
    
    // ---------------------------------------------------------------------------
  case 0xF61C:
LF61C:
                                                     #ifdef DEBUG
                                      mon("LF61C    LDB   #$3B                    ; F61C: C6 3B         \n");
                                      #endif
    PC = 0xf61c; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x3b; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xF61E:
LF61E:
                                                     #ifdef DEBUG
                                      mon("LF61E    STB   $4400                   ; F61E: F7 44 00      \n");
                                      #endif
    PC = 0xf61e; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4400, val); 
                                                     #ifdef DEBUG
                                      mon("         LDU   #$00                    ; F621: CE 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x0000; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0xF624:
LF624:
                                                     #ifdef DEBUG
                                      mon("LF624    STA   $4640                   ; F624: B7 46 40      \n");
                                      #endif
    PC = 0xf624; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4640, val); 
                                                     #ifdef DEBUG
                                      mon("         LEAU  $01,U                   ; F627: 33 41         \n");
                                      #endif
    clockticks = clockticks + 5; 
    U = (U + 0x0001); 
                                                     #ifdef DEBUG
                                      mon("         CMPU  #$A000                  ; F629: 11 83 A0 00   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
    arg = 0xa000; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LF624                   ; F62D: 25 F5         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LF624;
    }
                                                     #ifdef DEBUG
                                      mon("         LEAX  -1,X                    ; F62F: 30 1F         \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + 0xffff); 
    Z = X; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LF615                   ; F631: 26 E2         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LF615;
    }
                                                     #ifdef DEBUG
                                      mon("         LDU   #$00                    ; F633: CE 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x0000; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0xF636:
LF636:
                                                     #ifdef DEBUG
                                      mon("LF636    STA   $4640                   ; F636: B7 46 40      \n");
                                      #endif
    PC = 0xf636; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4640, val); 
                                                     #ifdef DEBUG
                                      mon("         LEAU  $01,U                   ; F639: 33 41         \n");
                                      #endif
    clockticks = clockticks + 5; 
    U = (U + 0x0001); 
                                                     #ifdef DEBUG
                                      mon("         CMPU  #$FF00                  ; F63B: 11 83 FF 00   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
    arg = 0xff00; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LF636                   ; F63F: 25 F5         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LF636;
    }
                                                     #ifdef DEBUG
                                      mon("         BRA   LF5ED                   ; F641: 20 AA         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LF5ED;
    
    // ---------------------------------------------------------------------------
  case 0xF643:
LF643:
                                                     #ifdef DEBUG
                                      mon("LF643    LDD   #$2020                  ; F643: CC 20 20      \n");
                                      #endif
    PC = 0xf643; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x20; 
    B = 0x20; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F646: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #off_F723               ; F648: CE F7 23      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0xf723; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CLR   <$C0                    ; F64B: 0F C0         \n");
                                      #endif
    clockticks = clockticks + 4; 
    wr_mem(DP|0xc0, 0); 
 // V = 0; 
 // Z = 0; 
 // N = 0; 
 // C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$03                    ; F64D: 86 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x03; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$C5                    ; F64F: 97 C5         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xc5; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   <$C6                    ; F651: 97 C6         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xc6; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   <$C7                    ; F653: 97 C7         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xc7; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   <$D6                    ; F655: 97 D6         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xd6; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #word_F34E              ; F657: 8E F3 4E      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0xf34e; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STX   <$D4                    ; F65A: 9F D4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = DP|0xd4; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
  case 0xF65C:
LF65C:
                                                     #ifdef DEBUG
                                      mon("LF65C    LDD   #$01                    ; F65C: CC 00 01      \n");
                                      #endif
    PC = 0xf65c; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x01; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$00                    ; F65F: 8E 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x0000; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xF662:
LF662:
                                                     #ifdef DEBUG
                                      mon("LF662    STA   $4640                   ; F662: B7 46 40      \n");
                                      #endif
    PC = 0xf662; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4640, val); 
                                                     #ifdef DEBUG
                                      mon("         LEAX  D,X                     ; F665: 30 8B         \n");
                                      #endif
    clockticks = clockticks + 8; 
    X = (X + (((UINT8)A<<8)|(UINT8)B)); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$0708                  ; F667: 8C 07 08      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x0708; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LF662                   ; F66A: 25 F6         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LF662;
    }
                                                     #ifdef DEBUG
                                      mon("         STA   $4620                   ; F66C: B7 46 20      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4620, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4320                   ; F66F: B6 43 20      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4320); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$04                    ; F672: 84 04         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x04; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LF679                   ; F674: 26 03         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LF679;
    }
                                                     #ifdef DEBUG
                                      mon("         JMP   LF720                   ; F676: 7E F7 20      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LF720;
    
    // ---------------------------------------------------------------------------
  case 0xF679:
LF679:
                                                     #ifdef DEBUG
                                      mon("LF679    LDA   $4300                   ; F679: B6 43 00      \n");
                                      #endif
    PC = 0xf679; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4300); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$04                    ; F67C: 84 04         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x04; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LF69F                   ; F67E: 26 1F         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LF69F;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   <$C5                    ; F680: 96 C5         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xc5); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LF69D                   ; F682: 27 19         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LF69D;
    }
                                                     #ifdef DEBUG
                                      mon("         DECA                          ; F684: 4A            \n");
                                      #endif
    val = (UINT8)A; 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LF69D                   ; F685: 26 16         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LF69D;
    }
                                                     #ifdef DEBUG
                                      mon("         LEAU  $02,U                   ; F687: 33 42         \n");
                                      #endif
    clockticks = clockticks + 5; 
    U = (U + 0x0002); 
                                                     #ifdef DEBUG
                                      mon("         CMPU  #word_F735              ; F689: 11 83 F7 35   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
    arg = 0xf735; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LF692                   ; F68D: 25 03         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LF692;
    }
                                                     #ifdef DEBUG
                                      mon("         LDU   #off_F725               ; F68F: CE F7 25      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0xf725; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0xF692:
LF692:
                                                     #ifdef DEBUG
                                      mon("LF692    LDD   #$00                    ; F692: CC 00 00      \n");
                                      #endif
    PC = 0xf692; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$C2                    ; F695: DD C2         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0xc2; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STA   <$C4                    ; F697: 97 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xc4; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   <$C0                    ; F699: 97 C0         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xc0; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$80                    ; F69B: 86 80         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x80; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
  case 0xF69D:
LF69D:
                                                     #ifdef DEBUG
                                      mon("LF69D    BRA   LF6A1                   ; F69D: 20 02         \n");
                                      #endif
    PC = 0xf69d; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto LF6A1;
    
    // ---------------------------------------------------------------------------
  case 0xF69F:
LF69F:
                                                     #ifdef DEBUG
                                      mon("LF69F    LDA   #$03                    ; F69F: 86 03         \n");
                                      #endif
    PC = 0xf69f; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x03; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xF6A1:
LF6A1:
                                                     #ifdef DEBUG
                                      mon("LF6A1    STA   <$C5                    ; F6A1: 97 C5         \n");
                                      #endif
    PC = 0xf6a1; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xc5; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4300                   ; F6A3: B6 43 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4300); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; F6A6: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$C0                    ; F6A7: 84 C0         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0xc0; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LF6C7                   ; F6A9: 27 1C         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LF6C7;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   <$C6                    ; F6AB: 96 C6         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xc6); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LF6C5                   ; F6AD: 27 16         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LF6C5;
    }
                                                     #ifdef DEBUG
                                      mon("         DECA                          ; F6AF: 4A            \n");
                                      #endif
    val = (UINT8)A; 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LF6C5                   ; F6B0: 26 13         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LF6C5;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   <$C0                    ; F6B2: D6 C0         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xc0); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDB  #$02                    ; F6B4: CB 02         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x02; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$0E                    ; F6B6: C1 0E         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x0e; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   LF6BB                   ; F6B8: 25 01         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LF6BB;
    }
                                                     #ifdef DEBUG
                                      mon("         CLRB                          ; F6BA: 5F            \n");
                                      #endif
    B = 0; // SEARCH_ME
 // V = 0; 
 // Z = 0; 
 // N = 0; 
 // C = 0; 
    clockticks = clockticks + 2; 
  case 0xF6BB:
LF6BB:
                                                     #ifdef DEBUG
                                      mon("LF6BB    STB   <$C0                    ; F6BB: D7 C0         \n");
                                      #endif
    PC = 0xf6bb; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xc0; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$04                    ; F6BD: C1 04         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x04; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   LF6C3                   ; F6BF: 26 02         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LF6C3;
    }
                                                     #ifdef DEBUG
                                      mon("         CLR   <$C1                    ; F6C1: 0F C1         \n");
                                      #endif
    clockticks = clockticks + 4; 
    wr_mem(DP|0xc1, 0); 
 // V = 0; 
 // Z = 0; 
 // N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
  case 0xF6C3:
LF6C3:
                                                     #ifdef DEBUG
                                      mon("LF6C3    LDA   #$80                    ; F6C3: 86 80         \n");
                                      #endif
    PC = 0xf6c3; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x80; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
  case 0xF6C5:
LF6C5:
                                                     #ifdef DEBUG
                                      mon("LF6C5    BRA   LF6C9                   ; F6C5: 20 02         \n");
                                      #endif
    PC = 0xf6c5; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto LF6C9;
    
    // ---------------------------------------------------------------------------
  case 0xF6C7:
LF6C7:
                                                     #ifdef DEBUG
                                      mon("LF6C7    LDA   #$03                    ; F6C7: 86 03         \n");
                                      #endif
    PC = 0xf6c7; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x03; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xF6C9:
LF6C9:
                                                     #ifdef DEBUG
                                      mon("LF6C9    STA   <$C6                    ; F6C9: 97 C6         \n");
                                      #endif
    PC = 0xf6c9; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xc6; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         CMPU  #off_F733               ; F6CB: 11 83 F7 33   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
    arg = 0xf733; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LF6F0                   ; F6CF: 26 1F         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LF6F0;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4320                   ; F6D1: B6 43 20      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4320); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; F6D4: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$30                    ; F6D5: 84 30         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x30; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LF6EA                   ; F6D7: 27 11         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LF6EA;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   <$C7                    ; F6D9: 96 C7         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xc7); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LF6E8                   ; F6DB: 27 0B         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LF6E8;
    }
                                                     #ifdef DEBUG
                                      mon("         DECA                          ; F6DD: 4A            \n");
                                      #endif
    val = (UINT8)A; 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LF6E8                   ; F6DE: 26 08         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LF6E8;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   <$C1                    ; F6E0: D6 C1         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xc1); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         EORB  #$01                    ; F6E2: C8 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = B ^ (SINT8)0x01; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STB   <$C1                    ; F6E4: D7 C1         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xc1; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$80                    ; F6E6: 86 80         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x80; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
  case 0xF6E8:
LF6E8:
                                                     #ifdef DEBUG
                                      mon("LF6E8    BRA   LF6EC                   ; F6E8: 20 02         \n");
                                      #endif
    PC = 0xf6e8; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto LF6EC;
    
    // ---------------------------------------------------------------------------
  case 0xF6EA:
LF6EA:
                                                     #ifdef DEBUG
                                      mon("LF6EA    LDA   #$03                    ; F6EA: 86 03         \n");
                                      #endif
    PC = 0xf6ea; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x03; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xF6EC:
LF6EC:
                                                     #ifdef DEBUG
                                      mon("LF6EC    STA   <$C7                    ; F6EC: 97 C7         \n");
                                      #endif
    PC = 0xf6ec; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0xc7; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         BRA   LF6F2                   ; F6EE: 20 02         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LF6F2;
    
    // ---------------------------------------------------------------------------
  case 0xF6F0:
LF6F0:
                                                     #ifdef DEBUG
                                      mon("LF6F0    CLR   <$C1                    ; F6F0: 0F C1         \n");
                                      #endif
    PC = 0xf6f0; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    wr_mem(DP|0xc1, 0); 
 // V = 0; 
 // Z = 0; 
 // N = 0; 
 // C = 0; 
    clockticks = clockticks + 2; 
  case 0xF6F2:
LF6F2:
                                                     #ifdef DEBUG
                                      mon("LF6F2    LDY   #$00                    ; F6F2: 10 8E 00 00   \n");
                                      #endif
    PC = 0xf6f2; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    Y = 0x0000; 
 // Z = Y; 
 // N = (Y) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   <$C0                    ; F6F6: D6 C0         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xc0); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #word_F735              ; F6F8: 8E F7 35      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0xf735; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   B,X                     ; F6FB: EC 85         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + (SINT8)B); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$6780                  ; F6FD: 10 83 67 80   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x6780; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LF709                   ; F701: 26 06         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LF709;
    }
                                                     #ifdef DEBUG
                                      mon("         TST   <$C1                    ; F703: 0D C1         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xc1); 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LF709                   ; F705: 27 02         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LF709;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   #$20                    ; F707: C6 20         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x20; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xF709:
LF709:
                                                     #ifdef DEBUG
                                      mon("LF709    STD   ,Y++                    ; F709: ED A1         \n");
                                      #endif
    PC = 0xf709; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
    // END OF FUNCTION CHUNK FOR sub_6532
                                                     #ifdef DEBUG
                                      mon("         JMP   [,U]                    ; F70B: 6E D4         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 4; 
    clockticks = clockticks + 2; 
    clockticks = clockticks + 1; 
    ea = rd_mem(U)<<8; 
    ea = ea | rd_mem((UINT16)((U)+1)); 
    PC = ea; 
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xF70D:
LF70D:
                                                     #ifdef DEBUG
                                      mon("LF70D    LDD   #$2020                  ; F70D: CC 20 20      \n");
                                      #endif
    PC = 0xf70d; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x20; 
    B = 0x20; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F710: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F712: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
  case 0xF714:
LF714:
                                                     #ifdef DEBUG
                                      mon("LF714    STA   $4600                   ; F714: B7 46 00      \n");
                                      #endif
    PC = 0xf714; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4600, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4300                   ; F717: B6 43 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4300); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$10                    ; F71A: 84 10         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x10; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
    // End of function sub_F70D
                                                     #ifdef DEBUG
                                      mon("         LBEQ  LF65C                   ; F71C: 10 27 FF 3C   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if (!Z) {
    clockticks = clockticks + 1; 
    goto LF65C;
    }
    // START OF FUNCTION CHUNK FOR sub_6532
    // END OF FUNCTION CHUNK FOR sub_6532
    // ---------------------------------------------------------------------------
  case 0xF720:
LF720:
                                                     #ifdef DEBUG
                                      mon("LF720    JMP   LF720                   ; F720: 7E F7 20      \n");
                                      #endif
    PC = 0xf720; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    goto LF720;
    
    // =============== S U B R O U T I N E =======================================
  case 0xF74F:
LF74F:
                                                     #ifdef DEBUG
                                      mon("LF74F    DEC   <$D6                    ; F74F: 0A D6         \n");
                                      #endif
    PC = 0xf74f; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xd6); 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    wr_mem(DP|0xd6, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LF77C                   ; F751: 2A 29         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LF77C;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$10                    ; F753: 86 10         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x10; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$D6                    ; F755: 97 D6         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xd6; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDX   <$D4                    ; F757: 9E D4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xd4)<<8; 
    ea = ea | rd_mem(DP|0xd5); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$D2                    ; F759: DC D2         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0xd2); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0xd3); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  ,X                      ; F75B: A4 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)A; 
    res = val & rd_mem(X); 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LF767                   ; F75D: 26 08         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LF767;
    }
                                                     #ifdef DEBUG
                                      mon("         ANDB  $01,X                   ; F75F: E4 01         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)B; 
    res = val & rd_mem((UINT16)(X + 0x0001)); 
    B = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LF767                   ; F761: 26 04         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LF767;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$3B                    ; F763: 86 3B         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x3b; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LF769                   ; F765: 20 02         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LF769;
    
    // ---------------------------------------------------------------------------
  case 0xF767:
LF767:
                                                     #ifdef DEBUG
                                      mon("LF767    LDA   #$29                    ; F767: 86 29         \n");
                                      #endif
    PC = 0xf767; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x29; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xF769:
LF769:
                                                     #ifdef DEBUG
                                      mon("LF769    STA   $4400                   ; F769: B7 44 00      \n");
                                      #endif
    PC = 0xf769; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4400, val); 
                                                     #ifdef DEBUG
                                      mon("         LEAX  $02,X                   ; F76C: 30 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + 0x0002); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #LF36E                  ; F76E: 8C F3 6E      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0xf36e; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LF77A                   ; F771: 25 07         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LF77A;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$20                    ; F773: 86 20         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x20; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$D6                    ; F775: 97 D6         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xd6; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #word_F34E              ; F777: 8E F3 4E      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0xf34e; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xF77A:
LF77A:
                                                     #ifdef DEBUG
                                      mon("LF77A    STX   <$D4                    ; F77A: 9F D4         \n");
                                      #endif
    PC = 0xf77a; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = X; 
    Z = val; 
    N = (UINT8)(val >> 8); 
    V = 0; 
    ea = DP|0xd4; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
    // End of function sub_F74F
  case 0xF77C:
LF77C:
                                                     #ifdef DEBUG
                                      mon("LF77C    JMP   LF714                   ; F77C: 7E F7 14      \n");
                                      #endif
    PC = 0xf77c; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    goto LF714;
    
    // =============== S U B R O U T I N E =======================================
  case 0xF77F:
LF77F:
                                                     #ifdef DEBUG
                                      mon("LF77F    STA   $46C0                   ; F77F: B7 46 C0      \n");
                                      #endif
    PC = 0xf77f; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x46c0, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   $46C0                   ; F782: B7 46 C0      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x46c0, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$BFAE                  ; F785: CC BF AE      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xbf; 
    B = 0xae; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F788: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$8040                  ; F78A: CC 80 40      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F78D: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDS   #$4FFF                  ; F78F: 10 CE 4F FF   \n");
                                      #endif
    clockticks = clockticks + 4; 
    S = 0x4fff; 
 // Z = S; 
 // N = (S) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$9E                    ; F793: C6 9E         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x9e; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LE7C7                   ; F795: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x98); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xf7); 
    clockticks = clockticks + 1; 
    goto LE7C7;
  case 0xF798:
LF798:
                                                     #ifdef DEBUG
                                      mon("LF798    LDB   #$D3                    ; F798: C6 D3         \n");
                                      #endif
    PC = 0xf798; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0xd3; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LE7C7                   ; F79A: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x9d); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xf7); 
    clockticks = clockticks + 1; 
    goto LE7C7;
  case 0xF79D:
LF79D:
                                                     #ifdef DEBUG
                                      mon("LF79D    LDB   #$9F                    ; F79D: C6 9F         \n");
                                      #endif
    PC = 0xf79d; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x9f; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STB   <$CE                    ; F79F: D7 CE         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xce; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4300                   ; F7A1: B6 43 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4300); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $4320                   ; F7A4: F6 43 20      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4320); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORB   #$C7                    ; F7A7: CA C7         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = B | (UINT8)0xc7; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$CC                    ; F7A9: DD CC         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0xcc; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
  case 0xF7AB:
LF7AB:
                                                     #ifdef DEBUG
                                      mon("LF7AB    ASLB                          ; F7AB: 58            \n");
                                      #endif
    PC = 0xf7ab; 
    INSTRUCTION_START
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLA                          ; F7AC: 49            \n");
                                      #endif
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
    C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$CC                    ; F7AD: DD CC         \n");
                                      #endif
    clockticks = clockticks + 4; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = DP|0xcc; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         BCS   LF7B6                   ; F7AF: 25 05         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LF7B6;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   <$CE                    ; F7B1: D6 CE         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xce); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LE7C7                   ; F7B3: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xb6); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xf7); 
    clockticks = clockticks + 1; 
    goto LE7C7;
  case 0xF7B6:
LF7B6:
                                                     #ifdef DEBUG
                                      mon("LF7B6    INC   <$CE                    ; F7B6: 0C CE         \n");
                                      #endif
    PC = 0xf7b6; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xce); 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    wr_mem(DP|0xce, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$CC                    ; F7B8: DC CC         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0xcc); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0xcd); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LF7AB                   ; F7BA: 26 EF         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LF7AB;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   <$C8                    ; F7BC: DC C8         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0xc8); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0xc9); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$CA                    ; F7BE: DD CA         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0xca; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4300                   ; F7C0: B6 43 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4300); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$CF                    ; F7C3: 84 CF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0xcf; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $4320                   ; F7C5: F6 43 20      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4320); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$3A                    ; F7C8: C4 3A         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x3a; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$C8                    ; F7CA: DD C8         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0xc8; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         EORA  <$CA                    ; F7CC: 98 CA         \n");
                                      #endif
    clockticks = clockticks + 4; 
    res = A ^ rd_mem(DP|0xca); 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  <$CA                    ; F7CE: 94 CA         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)A; 
    res = val & rd_mem(DP|0xca); 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         EORB  <$CB                    ; F7D0: D8 CB         \n");
                                      #endif
    clockticks = clockticks + 4; 
    res = B ^ rd_mem(DP|0xcb); 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  <$CB                    ; F7D2: D4 CB         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)B; 
    res = val & rd_mem(DP|0xcb); 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$00                    ; F7D4: 10 83 00 00   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x0000; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LF7DF                   ; F7D8: 27 05         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LF7DF;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$3B                    ; F7DA: 86 3B         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x3b; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4400                   ; F7DC: B7 44 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4400, val); 
  case 0xF7DF:
LF7DF:
                                                     #ifdef DEBUG
                                      mon("LF7DF    LDD   #$1EA2                  ; F7DF: CC 1E A2      \n");
                                      #endif
    PC = 0xf7df; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x1e; 
    B = 0xa2; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F7E2: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$1F74                  ; F7E4: CC 1F 74      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x1f; 
    B = 0x74; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F7E7: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$10                    ; F7E9: 86 10         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x10; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Display_Vect_BCD        ; F7EB: BD E7 90      \n");
                                      #endif // Display BCD numbers
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xee); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xf7); 
    clockticks = clockticks + 1; 
    goto LE790;
  case 0xF7EE:
LF7EE:
                                                     #ifdef DEBUG
                                      mon("LF7EE    LDD   $301E                   ; F7EE: FC 30 1E      \n");
                                      #endif
    PC = 0xf7ee; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x301e); // Care needed with I/O space and word fetches
    B = rd_mem(0x301f); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F7F1: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   $3002                   ; F7F3: FC 30 02      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x3002); // Care needed with I/O space and word fetches
    B = rd_mem(0x3003); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F7F6: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4340                   ; F7F8: B6 43 40      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4340); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LF86C                   ; F7FB: BD F8 6C      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xfe); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xf7); 
    clockticks = clockticks + 1; 
    goto LF86C;
  case 0xF7FE:
LF7FE:
                                                     #ifdef DEBUG
                                      mon("LF7FE    LDD   #$1E70                  ; F7FE: CC 1E 70      \n");
                                      #endif
    PC = 0xf7fe; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x1e; 
    B = 0x70; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F801: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$1F5C                  ; F803: CC 1F 5C      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x1f; 
    B = 0x5c; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F806: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$10                    ; F808: 86 10         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x10; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Display_Vect_BCD        ; F80A: BD E7 90      \n");
                                      #endif // Display BCD numbers
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x0d); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xf8); 
    clockticks = clockticks + 1; 
    goto LE790;
  case 0xF80D:
LF80D:
                                                     #ifdef DEBUG
                                      mon("LF80D    LDD   $3020                   ; F80D: FC 30 20      \n");
                                      #endif
    PC = 0xf80d; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x3020); // Care needed with I/O space and word fetches
    B = rd_mem(0x3021); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F810: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   $3022                   ; F812: FC 30 22      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x3022); // Care needed with I/O space and word fetches
    B = rd_mem(0x3023); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F815: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   $3002                   ; F817: FC 30 02      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x3002); // Care needed with I/O space and word fetches
    B = rd_mem(0x3003); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F81A: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4360                   ; F81C: B6 43 60      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4360); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LF86C                   ; F81F: BD F8 6C      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x22); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xf8); 
    clockticks = clockticks + 1; 
    goto LF86C;
  case 0xF822:
LF822:
                                                     #ifdef DEBUG
                                      mon("LF822    LDB   #$AF                    ; F822: C6 AF         \n");
                                      #endif
    PC = 0xf822; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0xaf; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LE7C7                   ; F824: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x27); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xf8); 
    clockticks = clockticks + 1; 
    goto LE7C7;
  case 0xF827:
LF827:
                                                     #ifdef DEBUG
                                      mon("LF827    LDD   #$BFD5                  ; F827: CC BF D5      \n");
                                      #endif
    PC = 0xf827; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0xbf; 
    B = 0xd5; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F82A: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; F82C: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F82F: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0140                  ; F831: CC 01 40      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x01; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F834: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $4380                   ; F836: F6 43 80      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4380); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBB  #$80                    ; F839: C0 80         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x80; 
    res = val - (UINT8)arg; 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    B = (UINT8)(res); 
                                                     #ifdef DEBUG
                                      mon("         SEX                           ; F83B: 1D            \n");
                                      #endif
 // Z = B; 
 // N = B; 
    A = ((SINT8)B < 0 ? 0xff : 0); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         TFR   D,U                     ; F83C: 1F 03         \n");
                                      #endif
    U = ((A << 8) | B); 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         ASRA                          ; F83E: 47            \n");
                                      #endif
    val = (UINT8)A; 
    C = val & 1; 
    val = (UINT8)((SINT8)val >> 1); 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         RORB                          ; F83F: 56            \n");
                                      #endif
    res = ((UINT8)B) | ((C != 0) ? 0x100 : 0); 
    C = res & 1; 
    res = (UINT8)(res >> 1); 
 // Z = res; 
 // N = res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LEAU  D,U                     ; F840: 33 CB         \n");
                                      #endif
    clockticks = clockticks + 8; 
    U = (U + (((UINT8)A<<8)|(UINT8)B)); 
                                                     #ifdef DEBUG
                                      mon("         TFR   U,D                     ; F842: 1F 30         \n");
                                      #endif
    val = U; 
    A = (UINT8)(val >> 8); 
    B = (UINT8)val; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$1F                    ; F844: 84 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x1f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F846: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $46C1                   ; F848: B7 46 C1      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x46c1, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   $46C1                   ; F84B: B7 46 C1      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x46c1, val); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$14                    ; F84E: 8E 00 14      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x0014; 
 // Z = X; 
    N = (X) >> 8; 
    V = 0; 
  case 0xF851:
LF851:
                                                     #ifdef DEBUG
                                      mon("LF851    LEAX  -1,X                    ; F851: 30 1F         \n");
                                      #endif
    PC = 0xf851; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    X = (X + 0xffff); 
    Z = X; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LF851                   ; F853: 26 FC         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LF851;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   $4380                   ; F855: F6 43 80      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4380); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBB  #$80                    ; F858: C0 80         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x80; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    B = (UINT8)(res); 
                                                     #ifdef DEBUG
                                      mon("         SEX                           ; F85A: 1D            \n");
                                      #endif
 // Z = B; 
 // N = B; 
    A = ((SINT8)B < 0 ? 0xff : 0); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$1F                    ; F85B: 84 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x1f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORA   #$E0                    ; F85D: 8A E0         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A | (UINT8)0xe0; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F85F: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$8040                  ; F861: CC 80 40      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F864: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #off_F725               ; F866: CE F7 25      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0xf725; 
    Z = U; 
    N = (U) >> 8; 
    V = 0; 
    // End of function sub_F77F
                                                     #ifdef DEBUG
                                      mon("         JMP   LF70D                   ; F869: 7E F7 0D      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LF70D;
    
    // =============== S U B R O U T I N E =======================================
  case 0xF86C:
LF86C:
                                                     #ifdef DEBUG
                                      mon("LF86C    LDB   #$07                    ; F86C: C6 07         \n");
                                      #endif
    PC = 0xf86c; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x07; 
    B = val; 
 // N = val; 
 // Z = val; 
    V = 0; 
  case 0xF86E:
LF86E:
                                                     #ifdef DEBUG
                                      mon("LF86E    LSRA                          ; F86E: 44            \n");
                                      #endif
    PC = 0xf86e; 
    INSTRUCTION_START
    val = (UINT8)A; 
    C = val & 1; 
    val = val >> 1; 
    A = val; 
    N = 0; 
    Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BCC   LF876                   ; F86F: 24 05         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LF876;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   $3022                   ; F871: BE 30 22      \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x3022)<<8; 
    ea = ea | rd_mem(0x3023); 
    X = ea; 
    Z = X; 
    N = (X) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LF879                   ; F874: 20 03         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LF879;
    
    // ---------------------------------------------------------------------------
  case 0xF876:
LF876:
                                                     #ifdef DEBUG
                                      mon("LF876    LDX   $3032                   ; F876: BE 30 32      \n");
                                      #endif
    PC = 0xf876; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x3032)<<8; 
    ea = ea | rd_mem(0x3033); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xF879:
LF879:
                                                     #ifdef DEBUG
                                      mon("LF879    STX   ,Y++                    ; F879: AF A1         \n");
                                      #endif
    PC = 0xf879; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
    val = X; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         DECB                          ; F87B: 5A            \n");
                                      #endif
    val = (UINT8)B; 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LF86E                   ; F87C: 2A F0         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LF86E;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$8040                  ; F87E: CC 80 40      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F881: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
    // End of function sub_F86C
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; F883: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xF884:
LF884:
                                                     #ifdef DEBUG
                                      mon("LF884    LDD   #$BF20                  ; F884: CC BF 20      \n");
                                      #endif
    PC = 0xf884; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0xbf; 
    B = 0x20; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F887: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
    // End of function sub_F884
                                                     #ifdef DEBUG
                                      mon("         JMP   LF70D                   ; F889: 7E F7 0D      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LF70D;
    
    // =============== S U B R O U T I N E =======================================
  case 0xF88C:
LF88C:
                                                     #ifdef DEBUG
                                      mon("LF88C    LDD   #$BEFD                  ; F88C: CC BE FD      \n");
                                      #endif
    PC = 0xf88c; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0xbe; 
    B = 0xfd; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F88F: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
    // End of function sub_F88C
                                                     #ifdef DEBUG
                                      mon("         JMP   LF70D                   ; F891: 7E F7 0D      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LF70D;
    
    // =============== S U B R O U T I N E =======================================
  case 0xF894:
LF894:
                                                     #ifdef DEBUG
                                      mon("LF894    LDD   #$BEA7                  ; F894: CC BE A7      \n");
                                      #endif
    PC = 0xf894; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0xbe; 
    B = 0xa7; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F897: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$CE                    ; F899: C6 CE         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xce; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xF89B:
LF89B:
                                                     #ifdef DEBUG
                                      mon("LF89B    STB   <$CE                    ; F89B: D7 CE         \n");
                                      #endif
    PC = 0xf89b; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xce; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   LE7C7                   ; F89D: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xa0); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xf8); 
    clockticks = clockticks + 1; 
    goto LE7C7;
  case 0xF8A0:
LF8A0:
                                                     #ifdef DEBUG
                                      mon("LF8A0    LDB   <$CE                    ; F8A0: D6 CE         \n");
                                      #endif
    PC = 0xf8a0; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xce); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         INCB                          ; F8A2: 5C            \n");
                                      #endif
    val = (UINT8)B; 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$D3                    ; F8A3: C1 D3         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0xd3; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   LF89B                   ; F8A5: 25 F4         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LF89B;
    }
    // End of function sub_F894
                                                     #ifdef DEBUG
                                      mon("         JMP   LF70D                   ; F8A7: 7E F7 0D      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LF70D;
    
    // =============== S U B R O U T I N E =======================================
  case 0xF8AA:
LF8AA:
                                                     #ifdef DEBUG
                                      mon("LF8AA    LDD   #$BFAE                  ; F8AA: CC BF AE      \n");
                                      #endif
    PC = 0xf8aa; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0xbf; 
    B = 0xae; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F8AD: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$BFB3                  ; F8AF: CC BF B3      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xbf; 
    B = 0xb3; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F8B2: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F8B4: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F8B6: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F8B8: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$8040                  ; F8BA: CC 80 40      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F8BD: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$C9                    ; F8BF: C6 C9         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xc9; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LE7C7                   ; F8C1: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xc4); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xf8); 
    clockticks = clockticks + 1; 
    goto LE7C7;
  case 0xF8C4:
LF8C4:
                                                     #ifdef DEBUG
                                      mon("LF8C4    LDB   #$CA                    ; F8C4: C6 CA         \n");
                                      #endif
    PC = 0xf8c4; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0xca; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LE7C7                   ; F8C6: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xc9); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xf8); 
    clockticks = clockticks + 1; 
    goto LE7C7;
    // End of function sub_F8AA
  case 0xF8C9:
LF8C9:
                                                     #ifdef DEBUG
                                      mon("LF8C9    JMP   LF70D                   ; F8C9: 7E F7 0D      \n");
                                      #endif
    PC = 0xf8c9; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    goto LF70D;
    
    // =============== S U B R O U T I N E =======================================
  case 0xF8CC:
LF8CC:
                                                     #ifdef DEBUG
                                      mon("LF8CC    LDA   <$C6                    ; F8CC: 96 C6         \n");
                                      #endif
    PC = 0xf8cc; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xc6); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$01                    ; F8CE: 81 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x01; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BHI   LF8D9                   ; F8D0: 22 07         \n");
                                      #endif
    // temp hack to force a flush
    if (Z && (!C)) {
    clockticks = clockticks + 3; 
    goto LF8D9;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; F8D2: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$C2                    ; F8D5: DD C2         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0xc2; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STA   <$C4                    ; F8D7: 97 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xc4; 
    wr_mem(ea, val); 
  case 0xF8D9:
LF8D9:
                                                     #ifdef DEBUG
                                      mon("LF8D9    LDD   #$6000                  ; F8D9: CC 60 00      \n");
                                      #endif
    PC = 0xf8d9; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x60; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F8DC: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$BFAF                  ; F8DE: CC BF AF      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xbf; 
    B = 0xaf; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F8E1: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$8040                  ; F8E3: CC 80 40      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F8E6: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$C2                    ; F8E8: DC C2         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0xc2); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0xc3); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$01                    ; F8EA: C3 00 01      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0001; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         TST   <$C4                    ; F8ED: 0D C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xc4); 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LF900                   ; F8EF: 26 0F         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LF900;
    }
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$FC                    ; F8F1: C1 FC         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0xfc; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   LF8FC                   ; F8F3: 25 07         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LF8FC;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$01                    ; F8F5: 86 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x01; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$C4                    ; F8F7: 97 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xc4; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; F8F9: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0xF8FC:
LF8FC:
                                                     #ifdef DEBUG
                                      mon("LF8FC    STD   <$C2                    ; F8FC: DD C2         \n");
                                      #endif
    PC = 0xf8fc; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = DP|0xc2; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         BRA   LF917                   ; F8FE: 20 17         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LF917;
    
    // ---------------------------------------------------------------------------
  case 0xF900:
LF900:
                                                     #ifdef DEBUG
                                      mon("LF900    CMPB  #$B0                    ; F900: C1 B0         \n");
                                      #endif
    PC = 0xf900; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0xb0; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   LF906                   ; F902: 25 02         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LF906;
    }
                                                     #ifdef DEBUG
                                      mon("         CLRB                          ; F904: 5F            \n");
                                      #endif
    B = 0; // SEARCH_ME
 // V = 0; 
 // Z = 0; 
 // N = 0; 
 // C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         INCA                          ; F905: 4C            \n");
                                      #endif
    val = (UINT8)A; 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    A = res; 
    clockticks = clockticks + 2; 
  case 0xF906:
LF906:
                                                     #ifdef DEBUG
                                      mon("LF906    CMPA  #$08                    ; F906: 81 08         \n");
                                      #endif
    PC = 0xf906; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x08; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   LF90F                   ; F908: 25 05         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LF90F;
    }
                                                     #ifdef DEBUG
                                      mon("         CLR   <$C4                    ; F90A: 0F C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    wr_mem(DP|0xc4, 0); 
 // V = 0; 
 // Z = 0; 
 // N = 0; 
 // C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; F90C: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0xF90F:
LF90F:
                                                     #ifdef DEBUG
                                      mon("LF90F    STD   <$C2                    ; F90F: DD C2         \n");
                                      #endif
    PC = 0xf90f; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0xc2; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$7F                    ; F911: C1 7F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x7f; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   LF917                   ; F913: 25 02         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LF917;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   #$7F                    ; F915: C6 7F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x7f; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xF917:
LF917:
                                                     #ifdef DEBUG
                                      mon("LF917    ORA   #$70                    ; F917: 8A 70         \n");
                                      #endif
    PC = 0xf917; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    res = A | (UINT8)0x70; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F919: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$6280                  ; F91B: CC 62 80      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x62; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F91E: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$BFBC                  ; F920: CC BF BC      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xbf; 
    B = 0xbc; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F923: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$7200                  ; F925: CC 72 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x72; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F928: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   <$C4                    ; F92A: D6 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xc4); 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LF932                   ; F92C: 26 04         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LF932;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   #$CC                    ; F92E: C6 CC         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xcc; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LF934                   ; F930: 20 02         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LF934;
    
    // ---------------------------------------------------------------------------
  case 0xF932:
LF932:
                                                     #ifdef DEBUG
                                      mon("LF932    LDB   #$CD                    ; F932: C6 CD         \n");
                                      #endif
    PC = 0xf932; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0xcd; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xF934:
LF934:
                                                     #ifdef DEBUG
                                      mon("LF934    JSR   LE7C7                   ; F934: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    PC = 0xf934; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x37); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xf9); 
    clockticks = clockticks + 1; 
    goto LE7C7;
  case 0xF937:
LF937:
                                                     #ifdef DEBUG
                                      mon("LF937    LDB   #$CB                    ; F937: C6 CB         \n");
                                      #endif
    PC = 0xf937; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0xcb; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LE7C7                   ; F939: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x3c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xf9); 
    clockticks = clockticks + 1; 
    goto LE7C7;
    // End of function sub_F8CC
  case 0xF93C:
LF93C:
                                                     #ifdef DEBUG
                                      mon("LF93C    JMP   LF70D                   ; F93C: 7E F7 0D      \n");
                                      #endif
    PC = 0xf93c; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    goto LF70D;
    
    // =============== S U B R O U T I N E =======================================
  case 0xF93F:
LF93F:
                                                     #ifdef DEBUG
                                      mon("LF93F    LDD   #$BFC8                  ; F93F: CC BF C8      \n");
                                      #endif
    PC = 0xf93f; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0xbf; 
    B = 0xc8; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F942: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$38                    ; F944: 8E 00 38      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x0038; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$BFCC                  ; F947: CC BF CC      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xbf; 
    B = 0xcc; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0xF94A:
LF94A:
                                                     #ifdef DEBUG
                                      mon("LF94A    STD   ,Y++                    ; F94A: ED A1         \n");
                                      #endif
    PC = 0xf94a; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
 // Z = A | B; 
    N = A; 
    V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LEAX  -1,X                    ; F94C: 30 1F         \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + 0xffff); 
    Z = X; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LF94A                   ; F94E: 26 FA         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LF94A;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$8040                  ; F950: CC 80 40      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F953: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
    // End of function sub_F93F
                                                     #ifdef DEBUG
                                      mon("         JMP   LF70D                   ; F955: 7E F7 0D      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LF70D;
    
    // =============== S U B R O U T I N E =======================================
  case 0xF958:
LF958:
                                                     #ifdef DEBUG
                                      mon("LF958    LDD   #$BFAE                  ; F958: CC BF AE      \n");
                                      #endif
    PC = 0xf958; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0xbf; 
    B = 0xae; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F95B: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$8040                  ; F95D: CC 80 40      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F960: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$7200                  ; F962: CC 72 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x72; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F965: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDS   #$4FFF                  ; F967: 10 CE 4F FF   \n");
                                      #endif
    clockticks = clockticks + 4; 
    S = 0x4fff; 
 // Z = S; 
 // N = (S) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$C2                    ; F96B: C6 C2         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xc2; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LE7C7                   ; F96D: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x70); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xf9); 
    clockticks = clockticks + 1; 
    goto LE7C7;
  case 0xF970:
LF970:
                                                     #ifdef DEBUG
                                      mon("LF970    LDA   #$5D                    ; F970: 86 5D         \n");
                                      #endif
    PC = 0xf970; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x5d; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4700                   ; F972: B7 47 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4700, val); 
                                                     #ifdef DEBUG
                                      mon("         TST   $4320                   ; F975: 7D 43 20      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4320); 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LF97F                   ; F978: 2A 05         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LF97F;
    }
                                                     #ifdef DEBUG
                                      mon("         TST   $4320                   ; F97A: 7D 43 20      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4320); 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LF98A                   ; F97D: 2A 0B         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LF98A;
    }
  case 0xF97F:
LF97F:
                                                     #ifdef DEBUG
                                      mon("LF97F    LDB   #$C3                    ; F97F: C6 C3         \n");
                                      #endif
    PC = 0xf97f; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0xc3; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LE7C7                   ; F981: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x84); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xf9); 
    clockticks = clockticks + 1; 
    goto LE7C7;
  case 0xF984:
LF984:
                                                     #ifdef DEBUG
                                      mon("LF984    LDU   #off_F727               ; F984: CE F7 27      \n");
                                      #endif
    PC = 0xf984; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0xf727; 
    Z = U; 
    N = (U) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JMP   LF70D                   ; F987: 7E F7 0D      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LF70D;
    
    // ---------------------------------------------------------------------------
  case 0xF98A:
LF98A:
                                                     #ifdef DEBUG
                                      mon("LF98A    LDD   #$6280                  ; F98A: CC 62 80      \n");
                                      #endif
    PC = 0xf98a; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x62; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F98D: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         CLR   <$CC                    ; F98F: 0F CC         \n");
                                      #endif
    clockticks = clockticks + 4; 
    wr_mem(DP|0xcc, 0); 
 // V = 0; 
 // Z = 0; 
 // N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #word_FB4B              ; F991: 8E FB 4B      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0xfb4b; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xF994:
LF994:
                                                     #ifdef DEBUG
                                      mon("LF994    LDS   #LF99B                  ; F994: 10 CE F9 9B   \n");
                                      #endif
    PC = 0xf994; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    S = 0xf99b; 
    Z = S; 
    N = (S) >> 8; 
    V = 0; 
    // End of function sub_F958
                                                     #ifdef DEBUG
                                      mon("         JMP   LFB38                   ; F998: 7E FB 38      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LFB38;
    
    // =============== S U B R O U T I N E =======================================
  case 0xF99B:
LF99B:
                                                     #ifdef DEBUG
                                      mon("LF99B    BEQ   LFA19                   ; F99B: 27 7C         \n");
                                      #endif
    PC = 0xf99b; 
    INSTRUCTION_START
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LFA19;
    }
                                                     #ifdef DEBUG
                                      mon("         STD   <$D2                    ; F99D: DD D2         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0xd2; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         INC   <$CC                    ; F99F: 0C CC         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xcc); 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    wr_mem(DP|0xcc, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDS   #$4FFF                  ; F9A1: 10 CE 4F FF   \n");
                                      #endif
    clockticks = clockticks + 4; 
    S = 0x4fff; 
 // Z = S; 
 // N = (S) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   $06,X                   ; F9A5: EC 06         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + 0x0006); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F9A7: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$1E98                  ; F9A9: CC 1E 98      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x1e; 
    B = 0x98; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F9AC: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   $3032                   ; F9AE: FC 30 32      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x3032); // Care needed with I/O space and word fetches
    B = rd_mem(0x3033); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F9B1: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F9B3: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F9B5: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F9B7: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   $3002                   ; F9B9: FC 30 02      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x3002); // Care needed with I/O space and word fetches
    B = rd_mem(0x3003); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F9BC: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         TFR   X,D                     ; F9BE: 1F 10         \n");
                                      #endif
    val = X; 
    A = (UINT8)(val >> 8); 
    B = (UINT8)val; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #word_FB4B              ; F9C0: 83 FB 4B      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0xfb4b; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; F9C3: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$03                    ; F9C4: 86 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x03; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xF9C6:
LF9C6:
                                                     #ifdef DEBUG
                                      mon("LF9C6    ASLB                          ; F9C6: 58            \n");
                                      #endif
    PC = 0xf9c6; 
    INSTRUCTION_START
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
    Z = res; 
    N = res; 
    V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LF9CE                   ; F9C7: 25 05         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LF9CE;
    }
                                                     #ifdef DEBUG
                                      mon("         LDU   $3022                   ; F9C9: FE 30 22      \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x3022)<<8; 
    ea = ea | rd_mem(0x3023); 
    U = ea; 
    Z = U; 
    N = (U) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LF9D1                   ; F9CC: 20 03         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LF9D1;
    
    // ---------------------------------------------------------------------------
  case 0xF9CE:
LF9CE:
                                                     #ifdef DEBUG
                                      mon("LF9CE    LDU   $3032                   ; F9CE: FE 30 32      \n");
                                      #endif
    PC = 0xf9ce; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x3032)<<8; 
    ea = ea | rd_mem(0x3033); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0xF9D1:
LF9D1:
                                                     #ifdef DEBUG
                                      mon("LF9D1    STU   ,Y++                    ; F9D1: EF A1         \n");
                                      #endif
    PC = 0xf9d1; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         DECA                          ; F9D3: 4A            \n");
                                      #endif
    val = (UINT8)A; 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LF9C6                   ; F9D4: 2A F0         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LF9C6;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $3002                   ; F9D6: FC 30 02      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x3002); // Care needed with I/O space and word fetches
    B = rd_mem(0x3003); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F9D9: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F9DB: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   ,X                      ; F9DD: A6 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(X); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Display_Vect_BCD        ; F9DF: BD E7 90      \n");
                                      #endif // Display BCD numbers
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xe2); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xf9); 
    clockticks = clockticks + 1; 
    goto LE790;
  case 0xF9E2:
LF9E2:
                                                     #ifdef DEBUG
                                      mon("LF9E2    LDA   $01,X                   ; F9E2: A6 01         \n");
                                      #endif
    PC = 0xf9e2; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0001)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Display_Vect_BCD        ; F9E4: BD E7 90      \n");
                                      #endif // Display BCD numbers
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xe7); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xf9); 
    clockticks = clockticks + 1; 
    goto LE790;
  case 0xF9E7:
LF9E7:
                                                     #ifdef DEBUG
                                      mon("LF9E7    LDD   $3002                   ; F9E7: FC 30 02      \n");
                                      #endif
    PC = 0xf9e7; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x3002); // Care needed with I/O space and word fetches
    B = rd_mem(0x3003); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F9EA: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $02,X                   ; F9EC: A6 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0002)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Display_Vect_BCD        ; F9EE: BD E7 90      \n");
                                      #endif // Display BCD numbers
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf1); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xf9); 
    clockticks = clockticks + 1; 
    goto LE790;
  case 0xF9F1:
LF9F1:
                                                     #ifdef DEBUG
                                      mon("LF9F1    LDA   $03,X                   ; F9F1: A6 03         \n");
                                      #endif
    PC = 0xf9f1; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0003)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Display_Vect_BCD        ; F9F3: BD E7 90      \n");
                                      #endif // Display BCD numbers
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf6); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xf9); 
    clockticks = clockticks + 1; 
    goto LE790;
  case 0xF9F6:
LF9F6:
                                                     #ifdef DEBUG
                                      mon("LF9F6    LDD   $3002                   ; F9F6: FC 30 02      \n");
                                      #endif
    PC = 0xf9f6; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x3002); // Care needed with I/O space and word fetches
    B = rd_mem(0x3003); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; F9F9: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $04,X                   ; F9FB: A6 04         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0004)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Display_Vect_BCD        ; F9FD: BD E7 90      \n");
                                      #endif // Display BCD numbers
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x00); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xfa); 
    clockticks = clockticks + 1; 
    goto LE790;
  case 0xFA00:
LFA00:
                                                     #ifdef DEBUG
                                      mon("LFA00    LDA   $05,X                   ; FA00: A6 05         \n");
                                      #endif
    PC = 0xfa00; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0005)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Display_Vect_BCD        ; FA02: BD E7 90      \n");
                                      #endif // Display BCD numbers
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x05); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xfa); 
    clockticks = clockticks + 1; 
    goto LE790;
  case 0xFA05:
LFA05:
                                                     #ifdef DEBUG
                                      mon("LFA05    LDD   $3002                   ; FA05: FC 30 02      \n");
                                      #endif
    PC = 0xfa05; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x3002); // Care needed with I/O space and word fetches
    B = rd_mem(0x3003); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; FA08: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$D2                    ; FA0A: 96 D2         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xd2); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Display_Vect_BCD        ; FA0C: BD E7 90      \n");
                                      #endif // Display BCD numbers
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x0f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xfa); 
    clockticks = clockticks + 1; 
    goto LE790;
  case 0xFA0F:
LFA0F:
                                                     #ifdef DEBUG
                                      mon("LFA0F    LDA   <$D3                    ; FA0F: 96 D3         \n");
                                      #endif
    PC = 0xfa0f; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xd3); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Display_Vect_BCD        ; FA11: BD E7 90      \n");
                                      #endif // Display BCD numbers
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x14); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xfa); 
    clockticks = clockticks + 1; 
    goto LE790;
  case 0xFA14:
LFA14:
                                                     #ifdef DEBUG
                                      mon("LFA14    LDD   #$8040                  ; FA14: CC 80 40      \n");
                                      #endif
    PC = 0xfa14; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; FA17: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
  case 0xFA19:
LFA19:
                                                     #ifdef DEBUG
                                      mon("LFA19    LEAX  $08,X                   ; FA19: 30 08         \n");
                                      #endif
    PC = 0xfa19; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    X = (X + 0x0008); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #LFB73                  ; FA1B: 8C FB 73      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0xfb73; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         LBCS  LF994                   ; FA1E: 10 25 FF 72   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if (C) {
    clockticks = clockticks + 1; 
    goto LF994;
    }
                                                     #ifdef DEBUG
                                      mon("         LDS   #$4FFF                  ; FA22: 10 CE 4F FF   \n");
                                      #endif
    clockticks = clockticks + 4; 
    S = 0x4fff; 
 // Z = S; 
 // N = (S) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         TST   <$CC                    ; FA26: 0D CC         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xcc); 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LFA2E                   ; FA28: 26 04         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LFA2E;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   #$C5                    ; FA2A: C6 C5         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xc5; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LFA35                   ; FA2C: 20 07         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LFA35;
    
    // ---------------------------------------------------------------------------
  case 0xFA2E:
LFA2E:
                                                     #ifdef DEBUG
                                      mon("LFA2E    LDB   #$C4                    ; FA2E: C6 C4         \n");
                                      #endif
    PC = 0xfa2e; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0xc4; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   LE7C7                   ; FA30: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x33); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xfa); 
    clockticks = clockticks + 1; 
    goto LE7C7;
  case 0xFA33:
LFA33:
                                                     #ifdef DEBUG
                                      mon("LFA33    LDB   #$C6                    ; FA33: C6 C6         \n");
                                      #endif
    PC = 0xfa33; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0xc6; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xFA35:
LFA35:
                                                     #ifdef DEBUG
                                      mon("LFA35    JSR   LE7C7                   ; FA35: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    PC = 0xfa35; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x38); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xfa); 
    clockticks = clockticks + 1; 
    goto LE7C7;
  case 0xFA38:
LFA38:
                                                     #ifdef DEBUG
                                      mon("LFA38    LDX   #off_FAE1               ; FA38: 8E FA E1      \n");
                                      #endif
    PC = 0xfa38; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0xfae1; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CLR   <$CC                    ; FA3B: 0F CC         \n");
                                      #endif
    clockticks = clockticks + 4; 
    wr_mem(DP|0xcc, 0); 
 // V = 0; 
 // Z = 0; 
 // N = 0; 
 // C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$6480                  ; FA3D: CC 64 80      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x64; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; FA40: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
  case 0xFA42:
LFA42:
                                                     #ifdef DEBUG
                                      mon("LFA42    TFR   X,D                     ; FA42: 1F 10         \n");
                                      #endif
    PC = 0xfa42; 
    INSTRUCTION_START
    val = X; 
    A = (UINT8)(val >> 8); 
    B = (UINT8)val; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #off_FAE9               ; FA44: 83 FA E9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0xfae9; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         LSRB                          ; FA47: 54            \n");
                                      #endif
    val = (UINT8)B; 
    C = val & 1; 
    val = val >> 1; 
    B = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDS   #LFA4E                  ; FA48: 10 CE FA 4E   \n");
                                      #endif
    clockticks = clockticks + 4; 
    S = 0xfa4e; 
    Z = S; 
    N = (S) >> 8; 
    V = 0; 
    // End of function sub_F99B
                                                     #ifdef DEBUG
                                      mon("         JMP   [,X]                    ; FA4C: 6E 94         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 4; 
    clockticks = clockticks + 2; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    PC = ea; 
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xFA4E:
LFA4E:
                                                     #ifdef DEBUG
                                      mon("LFA4E    BEQ   LFAC1                   ; FA4E: 27 71         \n");
                                      #endif
    PC = 0xfa4e; 
    INSTRUCTION_START
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LFAC1;
    }
                                                     #ifdef DEBUG
                                      mon("         STD   <$D2                    ; FA50: DD D2         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0xd2; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         INC   <$CC                    ; FA52: 0C CC         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xcc); 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    wr_mem(DP|0xcc, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #off_FAF9               ; FA54: 8C FA F9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0xfaf9; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCC   LFA92                   ; FA57: 24 39         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LFA92;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $02,X                   ; FA59: EC 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + 0x0002); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; FA5B: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$1EA2                  ; FA5D: CC 1E A2      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x1e; 
    B = 0xa2; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; FA60: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   $3032                   ; FA62: FC 30 32      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x3032); // Care needed with I/O space and word fetches
    B = rd_mem(0x3033); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; FA65: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; FA67: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; FA69: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   $3022                   ; FA6B: FC 30 22      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x3022); // Care needed with I/O space and word fetches
    B = rd_mem(0x3023); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; FA6E: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   $3002                   ; FA70: FC 30 02      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x3002); // Care needed with I/O space and word fetches
    B = rd_mem(0x3003); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; FA73: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         TFR   X,D                     ; FA75: 1F 10         \n");
                                      #endif
    val = X; 
    A = (UINT8)(val >> 8); 
    B = (UINT8)val; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #off_FAE1               ; FA77: 83 FA E1      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0xfae1; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; FA7A: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; FA7B: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ADDB  #$50                    ; FA7C: CB 50         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x50; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$03                    ; FA7E: 86 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x03; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xFA80:
LFA80:
                                                     #ifdef DEBUG
                                      mon("LFA80    ASLB                          ; FA80: 58            \n");
                                      #endif
    PC = 0xfa80; 
    INSTRUCTION_START
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
    Z = res; 
    N = res; 
    V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LFA88                   ; FA81: 25 05         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LFA88;
    }
                                                     #ifdef DEBUG
                                      mon("         LDU   $3022                   ; FA83: FE 30 22      \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x3022)<<8; 
    ea = ea | rd_mem(0x3023); 
    U = ea; 
    Z = U; 
    N = (U) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LFA8B                   ; FA86: 20 03         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LFA8B;
    
    // ---------------------------------------------------------------------------
  case 0xFA88:
LFA88:
                                                     #ifdef DEBUG
                                      mon("LFA88    LDU   $3032                   ; FA88: FE 30 32      \n");
                                      #endif
    PC = 0xfa88; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x3032)<<8; 
    ea = ea | rd_mem(0x3033); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0xFA8B:
LFA8B:
                                                     #ifdef DEBUG
                                      mon("LFA8B    STU   ,Y++                    ; FA8B: EF A1         \n");
                                      #endif
    PC = 0xfa8b; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         DECA                          ; FA8D: 4A            \n");
                                      #endif
    val = (UINT8)A; 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LFA80                   ; FA8E: 2A F0         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LFA80;
    }
                                                     #ifdef DEBUG
                                      mon("         BRA   LFAA9                   ; FA90: 20 17         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LFAA9;
    
    // ---------------------------------------------------------------------------
  case 0xFA92:
LFA92:
                                                     #ifdef DEBUG
                                      mon("LFA92    LDD   $02,X                   ; FA92: EC 02         \n");
                                      #endif
    PC = 0xfa92; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + 0x0002); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; FA94: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$96                    ; FA96: CC 00 96      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x96; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; FA99: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         TFR   X,D                     ; FA9B: 1F 10         \n");
                                      #endif
    val = X; 
    A = (UINT8)(val >> 8); 
    B = (UINT8)val; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #off_FAF9               ; FA9D: 83 FA F9      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0xfaf9; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         LSRB                          ; FAA0: 54            \n");
                                      #endif
    val = (UINT8)B; 
 // C = val & 1; 
    val = val >> 1; 
    B = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDS   #$3018                  ; FAA1: 10 CE 30 18   \n");
                                      #endif
    clockticks = clockticks + 4; 
    S = 0x3018; 
 // Z = S; 
 // N = (S) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   B,S                     ; FAA5: EC E5         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(S + (SINT8)B); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; FAA7: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
  case 0xFAA9:
LFAA9:
                                                     #ifdef DEBUG
                                      mon("LFAA9    LDD   $3002                   ; FAA9: FC 30 02      \n");
                                      #endif
    PC = 0xfaa9; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x3002); // Care needed with I/O space and word fetches
    B = rd_mem(0x3003); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; FAAC: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDS   #$4FFF                  ; FAAE: 10 CE 4F FF   \n");
                                      #endif
    clockticks = clockticks + 4; 
    S = 0x4fff; 
 // Z = S; 
 // N = (S) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$D2                    ; FAB2: 96 D2         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xd2); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Display_Vect_BCD        ; FAB4: BD E7 90      \n");
                                      #endif // Display BCD numbers
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xb7); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xfa); 
    clockticks = clockticks + 1; 
    goto LE790;
  case 0xFAB7:
LFAB7:
                                                     #ifdef DEBUG
                                      mon("LFAB7    LDA   <$D3                    ; FAB7: 96 D3         \n");
                                      #endif
    PC = 0xfab7; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xd3); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Display_Vect_BCD        ; FAB9: BD E7 90      \n");
                                      #endif // Display BCD numbers
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xbc); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xfa); 
    clockticks = clockticks + 1; 
    goto LE790;
  case 0xFABC:
LFABC:
                                                     #ifdef DEBUG
                                      mon("LFABC    LDD   #$8040                  ; FABC: CC 80 40      \n");
                                      #endif
    PC = 0xfabc; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; FABF: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
  case 0xFAC1:
LFAC1:
                                                     #ifdef DEBUG
                                      mon("LFAC1    LEAX  $04,X                   ; FAC1: 30 04         \n");
                                      #endif
    PC = 0xfac1; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    X = (X + 0x0004); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #LFB09                  ; FAC3: 8C FB 09      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0xfb09; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         LBCS  LFA42                   ; FAC6: 10 25 FF 78   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if (C) {
    clockticks = clockticks + 1; 
    goto LFA42;
    }
                                                     #ifdef DEBUG
                                      mon("         LDS   #$4FFF                  ; FACA: 10 CE 4F FF   \n");
                                      #endif
    clockticks = clockticks + 4; 
    S = 0x4fff; 
 // Z = S; 
 // N = (S) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         TST   <$CC                    ; FACE: 0D CC         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xcc); 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LFAD6                   ; FAD0: 26 04         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LFAD6;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   #$C8                    ; FAD2: C6 C8         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xc8; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LFAD8                   ; FAD4: 20 02         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LFAD8;
    
    // ---------------------------------------------------------------------------
  case 0xFAD6:
LFAD6:
                                                     #ifdef DEBUG
                                      mon("LFAD6    LDB   #$C7                    ; FAD6: C6 C7         \n");
                                      #endif
    PC = 0xfad6; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0xc7; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xFAD8:
LFAD8:
                                                     #ifdef DEBUG
                                      mon("LFAD8    JSR   LE7C7                   ; FAD8: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    PC = 0xfad8; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xdb); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xfa); 
    clockticks = clockticks + 1; 
    goto LE7C7;
  case 0xFADB:
LFADB:
                                                     #ifdef DEBUG
                                      mon("LFADB    LDU   #off_F727               ; FADB: CE F7 27      \n");
                                      #endif
    PC = 0xfadb; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0xf727; 
    Z = U; 
    N = (U) >> 8; 
    V = 0; 
    // End of function sub_FA4E
    // ---------------------------------------------------------------------------
                                                     #ifdef DEBUG
                                      mon("         JMP   LF70D                   ; FADE: 7E F7 0D      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LF70D;
    
    // =============== S U B R O U T I N E =======================================
    // FUNCTION CHUNK AT ROM:FBF6 SIZE 00000026 BYTES
  case 0xFB09:
LFB09:
                                                     #ifdef DEBUG
                                      mon("LFB09    LDS   #LFB10                  ; FB09: 10 CE FB 10   \n");
                                      #endif
    PC = 0xfb09; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    S = 0xfb10; 
    Z = S; 
    N = (S) >> 8; 
    V = 0; 
    // End of function sub_FB09
                                                     #ifdef DEBUG
                                      mon("         JMP   LFBF6                   ; FB0D: 7E FB F6      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LFBF6;
    
    // =============== S U B R O U T I N E =======================================
  case 0xFB10:
LFB10:
                                                     #ifdef DEBUG
                                      mon("LFB10    CMPD  #$01                    ; FB10: 10 83 00 01   \n");
                                      #endif
    PC = 0xfb10; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x0001; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LFB19                   ; FB14: 27 03         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LFB19;
    }
                                                     #ifdef DEBUG
                                      mon("         JMP   LFA4E                   ; FB16: 7E FA 4E      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LFA4E;
    
    // ---------------------------------------------------------------------------
  case 0xFB19:
LFB19:
                                                     #ifdef DEBUG
                                      mon("LFB19    LDU   #$02                    ; FB19: CE 00 02      \n");
                                      #endif
    PC = 0xfb19; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0x0002; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0xFB1C:
LFB1C:
                                                     #ifdef DEBUG
                                      mon("LFB1C    LDS   #LFB23                  ; FB1C: 10 CE FB 23   \n");
                                      #endif
    PC = 0xfb1c; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    S = 0xfb23; 
    Z = S; 
    N = (S) >> 8; 
    V = 0; 
    // End of function sub_FB10
                                                     #ifdef DEBUG
                                      mon("         JMP   LFC0D                   ; FB20: 7E FC 0D      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LFC0D;
    
    // =============== S U B R O U T I N E =======================================
  case 0xFB23:
LFB23:
                                                     #ifdef DEBUG
                                      mon("LFB23    CMPD  -$0CB2,U                ; FB23: 10 A3 C9 F3 4E\n");
                                      #endif
    PC = 0xfb23; 
    INSTRUCTION_START
    clockticks = clockticks + 1; 
    clockticks = clockticks + 8; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0xf34e))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0xf34e))+1)); 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = ea; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
    clockticks = clockticks + 1; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LFB2D                   ; FB28: 27 03         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LFB2D;
    }
                                                     #ifdef DEBUG
                                      mon("         JMP   LFA4E                   ; FB2A: 7E FA 4E      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LFA4E;
    
    // ---------------------------------------------------------------------------
  case 0xFB2D:
LFB2D:
                                                     #ifdef DEBUG
                                      mon("LFB2D    LEAU  $02,U                   ; FB2D: 33 42         \n");
                                      #endif
    PC = 0xfb2d; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    U = (U + 0x0002); 
                                                     #ifdef DEBUG
                                      mon("         CMPU  #$20                    ; FB2F: 11 83 00 20   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
    arg = 0x0020; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LFB1C                   ; FB33: 25 E7         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LFB1C;
    }
    // End of function sub_FB23
                                                     #ifdef DEBUG
                                      mon("         JMP   LFA4E                   ; FB35: 7E FA 4E      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LFA4E;
    
    // ---------------------------------------------------------------------------
    // START OF FUNCTION CHUNK FOR sub_FE7C
  case 0xFB38:
LFB38:
                                                     #ifdef DEBUG
                                      mon("LFB38    LDD   ,X                      ; FB38: EC 84         \n");
                                      #endif
    PC = 0xfb38; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(X); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(X+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4706                   ; FB3A: FD 47 06      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4706, A); // Care needed with I/O space and word fetches
    wr_mem(0x4707, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $02,X                   ; FB3D: EC 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + 0x0002); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4704                   ; FB3F: FD 47 04      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4704, A); // Care needed with I/O space and word fetches
    wr_mem(0x4705, B); 
                                                     #ifdef DEBUG
                                      mon("         MUL                           ; FB42: 3D            \n");
                                      #endif
    res = (UINT16)(A * B); 
 // Z = res; 
 // C = res & 0x80; 
    A = res >> 8; 
    B = (UINT8)res; 
    clockticks = clockticks + 11; 
                                                     #ifdef DEBUG
                                      mon("         LDD   $4700                   ; FB43: FC 47 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x4700); // Care needed with I/O space and word fetches
    B = rd_mem(0x4701); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  $04,X                   ; FB46: 10 A3 04      \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(X + 0x0004))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(X + 0x0004))+1)); 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = ea; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
    clockticks = clockticks + 1; 
    // END OF FUNCTION CHUNK FOR sub_FE7C
    // ---------------------------------------------------------------------------
                                                     #ifdef DEBUG
                                      mon("         JMP   ,S                      ; FB49: 6E E4         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 4; 
    PC = S; 
    JUMP;
    
  case 0xFB73:
LFB73:
                                                     #ifdef DEBUG
                                      mon("LFB73    JMP   ,S                      ; FB73: 6E E4         \n");
                                      #endif
    PC = 0xfb73; 
    INSTRUCTION_START
    clockticks = clockticks + 1; 
    clockticks = clockticks + 4; 
    PC = S; 
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0xFB75:
LFB75:
                                                     #ifdef DEBUG
                                      mon("LFB75    LDD   #$5555                  ; FB75: CC 55 55      \n");
                                      #endif
    PC = 0xfb75; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x55; 
    B = 0x55; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $501E                   ; FB78: FD 50 1E      \n");
                                      #endif // Math zero constant
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x501e, A); // Care needed with I/O space and word fetches
    wr_mem(0x501f, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$57                    ; FB7B: 86 57         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x57; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4700                   ; FB7D: B7 47 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x4700, val); 
    // End of function sub_FB75
                                                     #ifdef DEBUG
                                      mon("         BRA   LFB73                   ; FB80: 20 F1         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LFB73;
    
    // =============== S U B R O U T I N E =======================================
  case 0xFB82:
LFB82:
                                                     #ifdef DEBUG
                                      mon("LFB82    LDD   #$AAAA                  ; FB82: CC AA AA      \n");
                                      #endif
    PC = 0xfb82; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0xaa; 
    B = 0xaa; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $501E                   ; FB85: FD 50 1E      \n");
                                      #endif // Math zero constant
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x501e, A); // Care needed with I/O space and word fetches
    wr_mem(0x501f, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$58                    ; FB88: 86 58         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x58; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4700                   ; FB8A: B7 47 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x4700, val); 
    // End of function sub_FB82
                                                     #ifdef DEBUG
                                      mon("         BRA   LFB73                   ; FB8D: 20 E4         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LFB73;
    
    // =============== S U B R O U T I N E =======================================
  case 0xFB8F:
LFB8F:
                                                     #ifdef DEBUG
                                      mon("LFB8F    LDD   #$5555                  ; FB8F: CC 55 55      \n");
                                      #endif
    PC = 0xfb8f; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x55; 
    B = 0x55; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $501E                   ; FB92: FD 50 1E      \n");
                                      #endif // Math zero constant
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x501e, A); // Care needed with I/O space and word fetches
    wr_mem(0x501f, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$59                    ; FB95: 86 59         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x59; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4700                   ; FB97: B7 47 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x4700, val); 
    // End of function sub_FB8F
                                                     #ifdef DEBUG
                                      mon("         BRA   LFB73                   ; FB9A: 20 D7         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LFB73;
    
    // =============== S U B R O U T I N E =======================================
  case 0xFB9C:
LFB9C:
                                                     #ifdef DEBUG
                                      mon("LFB9C    LDA   #$5A                    ; FB9C: 86 5A         \n");
                                      #endif
    PC = 0xfb9c; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x5a; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4700                   ; FB9E: B7 47 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x4700, val); 
    // End of function sub_FB9C
                                                     #ifdef DEBUG
                                      mon("         BRA   LFB73                   ; FBA1: 20 D0         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LFB73;
    
    // =============== S U B R O U T I N E =======================================
  case 0xFBA3:
LFBA3:
                                                     #ifdef DEBUG
                                      mon("LFBA3    LDA   #$5B                    ; FBA3: 86 5B         \n");
                                      #endif
    PC = 0xfba3; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x5b; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4700                   ; FBA5: B7 47 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x4700, val); 
    // End of function sub_FBA3
                                                     #ifdef DEBUG
                                      mon("         BRA   LFB73                   ; FBA8: 20 C9         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LFB73;
    
    // =============== S U B R O U T I N E =======================================
  case 0xFBAA:
LFBAA:
                                                     #ifdef DEBUG
                                      mon("LFBAA    LDD   #$5555                  ; FBAA: CC 55 55      \n");
                                      #endif
    PC = 0xfbaa; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x55; 
    B = 0x55; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5000                   ; FBAD: FD 50 00      \n");
                                      #endif // Math result X
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5000, A); // Care needed with I/O space and word fetches
    wr_mem(0x5001, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$5C                    ; FBB0: 86 5C         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x5c; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4700                   ; FBB2: B7 47 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4700, val); 
                                                     #ifdef DEBUG
                                      mon("         NOP                           ; FBB5: 12            \n");
                                      #endif
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   $5002                   ; FBB6: FC 50 02      \n");
                                      #endif // Math result Y
    clockticks = clockticks + 5; 
    A = rd_mem(0x5002); // Care needed with I/O space and word fetches
    B = rd_mem(0x5003); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$5555                  ; FBB9: 10 83 55 55   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x5555; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
    // End of function sub_FBAA
                                                     #ifdef DEBUG
                                      mon("         BRA   LFB73                   ; FBBD: 20 B4         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LFB73;
    
    // =============== S U B R O U T I N E =======================================
  case 0xFBBF:
LFBBF:
                                                     #ifdef DEBUG
                                      mon("LFBBF    LDD   #$AAAA                  ; FBBF: CC AA AA      \n");
                                      #endif
    PC = 0xfbbf; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0xaa; 
    B = 0xaa; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5000                   ; FBC2: FD 50 00      \n");
                                      #endif // Math result X
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5000, A); // Care needed with I/O space and word fetches
    wr_mem(0x5001, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$5C                    ; FBC5: 86 5C         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x5c; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4700                   ; FBC7: B7 47 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4700, val); 
                                                     #ifdef DEBUG
                                      mon("         NOP                           ; FBCA: 12            \n");
                                      #endif
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   $5002                   ; FBCB: FC 50 02      \n");
                                      #endif // Math result Y
    clockticks = clockticks + 5; 
    A = rd_mem(0x5002); // Care needed with I/O space and word fetches
    B = rd_mem(0x5003); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$AAAA                  ; FBCE: 10 83 AA AA   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0xaaaa; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
    // End of function sub_FBBF
                                                     #ifdef DEBUG
                                      mon("         BRA   LFB73                   ; FBD2: 20 9F         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LFB73;
    
    // =============== S U B R O U T I N E =======================================
  case 0xFBD4:
LFBD4:
                                                     #ifdef DEBUG
                                      mon("LFBD4    LDD   #$2696                  ; FBD4: CC 26 96      \n");
                                      #endif
    PC = 0xfbd4; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x26; 
    B = 0x96; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5018                   ; FBD7: FD 50 18      \n");
                                      #endif // XT
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5018, A); // Care needed with I/O space and word fetches
    wr_mem(0x5019, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$1B2C                  ; FBDA: CC 1B 2C      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x1b; 
    B = 0x2c; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $501A                   ; FBDD: FD 50 1A      \n");
                                      #endif // YT
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x501a, A); // Care needed with I/O space and word fetches
    wr_mem(0x501b, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$4000                  ; FBE0: CC 40 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x40; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $501C                   ; FBE3: FD 50 1C      \n");
                                      #endif // ZT
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x501c, A); // Care needed with I/O space and word fetches
    wr_mem(0x501d, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$5D                    ; FBE6: 86 5D         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x5d; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4700                   ; FBE8: B7 47 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4700, val); 
                                                     #ifdef DEBUG
                                      mon("         MUL                           ; FBEB: 3D            \n");
                                      #endif
    res = (UINT16)(A * B); 
 // Z = res; 
 // C = res & 0x80; 
    A = res >> 8; 
    B = (UINT8)res; 
    clockticks = clockticks + 11; 
                                                     #ifdef DEBUG
                                      mon("         LDD   $5000                   ; FBEC: FC 50 00      \n");
                                      #endif // Math result X
    clockticks = clockticks + 5; 
    A = rd_mem(0x5000); // Care needed with I/O space and word fetches
    B = rd_mem(0x5001); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$0B6A                  ; FBEF: 10 83 0B 6A   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x0b6a; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
    // End of function sub_FBD4
                                                     #ifdef DEBUG
                                      mon("         JMP   LFB73                   ; FBF3: 7E FB 73      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LFB73;
    
    // ---------------------------------------------------------------------------
    // START OF FUNCTION CHUNK FOR sub_FB09
  case 0xFBF6:
LFBF6:
                                                     #ifdef DEBUG
                                      mon("LFBF6    LDA   #$5A                    ; FBF6: 86 5A         \n");
                                      #endif
    PC = 0xfbf6; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x5a; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4700                   ; FBF8: B7 47 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4700, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; FBFB: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $501A                   ; FBFE: FD 50 1A      \n");
                                      #endif // YT
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x501a, A); // Care needed with I/O space and word fetches
    wr_mem(0x501b, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$4000                  ; FC01: CC 40 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x40; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $501C                   ; FC04: FD 50 1C      \n");
                                      #endif // ZT
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x501c, A); // Care needed with I/O space and word fetches
    wr_mem(0x501d, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$01                    ; FC07: CC 00 01      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x01; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5018                   ; FC0A: FD 50 18      \n");
                                      #endif // XT
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5018, A); // Care needed with I/O space and word fetches
    wr_mem(0x5019, B); 
  case 0xFC0D:
LFC0D:
                                                     #ifdef DEBUG
                                      mon("LFC0D    STD   $5018                   ; FC0D: FD 50 18      \n");
                                      #endif // XT
    PC = 0xfc0d; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5018, A); // Care needed with I/O space and word fetches
    wr_mem(0x5019, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$5E                    ; FC10: 86 5E         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x5e; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4700                   ; FC12: B7 47 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4700, val); 
                                                     #ifdef DEBUG
                                      mon("         MUL                           ; FC15: 3D            \n");
                                      #endif
    res = (UINT16)(A * B); 
 // Z = res; 
    C = res & 0x80; 
    A = res >> 8; 
    B = (UINT8)res; 
    clockticks = clockticks + 11; 
                                                     #ifdef DEBUG
                                      mon("         LDD   $5000                   ; FC16: FC 50 00      \n");
                                      #endif // Math result X
    clockticks = clockticks + 5; 
    A = rd_mem(0x5000); // Care needed with I/O space and word fetches
    B = rd_mem(0x5001); 
    Z = A|B; 
    N = A; 
    V = 0; 
    // END OF FUNCTION CHUNK FOR sub_FB09
                                                     #ifdef DEBUG
                                      mon("         JMP   LFB73                   ; FC19: 7E FB 73      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LFB73;
    
    // =============== S U B R O U T I N E =======================================
  case 0xFC1C:
LFC1C:
                                                     #ifdef DEBUG
                                      mon("LFC1C    LDU   #$5028                  ; FC1C: CE 50 28      \n");
                                      #endif
    PC = 0xfc1c; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0x5028; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$05                    ; FC1F: CC 00 05      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x05; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0xFC22:
LFC22:
                                                     #ifdef DEBUG
                                      mon("LFC22    STD   ,U                      ; FC22: ED C4         \n");
                                      #endif
    PC = 0xfc22; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$01                    ; FC24: C3 00 01      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0001; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         LEAU  $08,U                   ; FC27: 33 48         \n");
                                      #endif
    clockticks = clockticks + 5; 
    U = (U + 0x0008); 
                                                     #ifdef DEBUG
                                      mon("         CMPU  #$6000                  ; FC29: 11 83 60 00   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
    arg = 0x6000; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LFC22                   ; FC2D: 25 F3         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LFC22;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; FC2F: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $501E                   ; FC32: FD 50 1E      \n");
                                      #endif // Math zero constant
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x501e, A); // Care needed with I/O space and word fetches
    wr_mem(0x501f, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$4000                  ; FC35: CC 40 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x40; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5020                   ; FC38: FD 50 20      \n");
                                      #endif // Math 1.000 constant
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5020, A); // Care needed with I/O space and word fetches
    wr_mem(0x5021, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$04                    ; FC3B: CC 00 04      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x04; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4701                   ; FC3E: FD 47 01      \n");
                                      #endif // Point BIC to $5020 MReg10
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4701, A); // Care needed with I/O space and word fetches
    wr_mem(0x4702, B); 
                                                     #ifdef DEBUG
                                      mon("         LDU   #$08                    ; FC41: CE 00 08      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x0008; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0xFC44:
LFC44:
                                                     #ifdef DEBUG
                                      mon("LFC44    STA   $4640                   ; FC44: B7 46 40      \n");
                                      #endif
    PC = 0xfc44; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4640, val); 
                                                     #ifdef DEBUG
                                      mon("         TFR   U,D                     ; FC47: 1F 30         \n");
                                      #endif
    val = U; 
    A = (UINT8)(val >> 8); 
    B = (UINT8)val; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; FC49: 44            \n");
                                      #endif
    val = (UINT8)A; 
    C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         RORB                          ; FC4A: 56            \n");
                                      #endif
    res = ((UINT8)B) | ((C != 0) ? 0x100 : 0); 
    C = res & 1; 
    res = (UINT8)(res >> 1); 
 // Z = res; 
 // N = res; 
    B = res; 
    clockticks = clockticks + 2; 
  case 0xFC4B:
LFC4B:
                                                     #ifdef DEBUG
                                      mon("LFC4B    LDA   #$5B                    ; FC4B: 86 5B         \n");
                                      #endif
    PC = 0xfc4b; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x5b; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4700                   ; FC4D: B7 47 00      \n");
                                      #endif // Test routine $5B
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4700, val); 
                                                     #ifdef DEBUG
                                      mon("         DECB                          ; FC50: 5A            \n");
                                      #endif
    val = (UINT8)B; 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LFC4B                   ; FC51: 26 F8         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LFC4B;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$5F                    ; FC53: 86 5F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x5f; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4700                   ; FC55: B7 47 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4700, val); 
                                                     #ifdef DEBUG
                                      mon("         MUL                           ; FC58: 3D            \n");
                                      #endif
    res = (UINT16)(A * B); 
 // Z = res; 
 // C = res & 0x80; 
    A = res >> 8; 
    B = (UINT8)res; 
    clockticks = clockticks + 11; 
                                                     #ifdef DEBUG
                                      mon("         CMPU  $5000                   ; FC59: 11 B3 50 00   \n");
                                      #endif // Math result X
    clockticks = clockticks + 7; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5000)<<8; 
    ea = ea | rd_mem(0x5001); 
    val = U; 
    arg = ea; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LFC62                   ; FC5D: 27 03         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LFC62;
    }
                                                     #ifdef DEBUG
                                      mon("         JMP   LFB73                   ; FC5F: 7E FB 73      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LFB73;
    
    // ---------------------------------------------------------------------------
  case 0xFC62:
LFC62:
                                                     #ifdef DEBUG
                                      mon("LFC62    TFR   U,D                     ; FC62: 1F 30         \n");
                                      #endif
    PC = 0xfc62; 
    INSTRUCTION_START
    val = U; 
    A = (UINT8)(val >> 8); 
    B = (UINT8)val; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         LEAU  D,U                     ; FC64: 33 CB         \n");
                                      #endif
    clockticks = clockticks + 8; 
    U = (U + (((UINT8)A<<8)|(UINT8)B)); 
                                                     #ifdef DEBUG
                                      mon("         CMPU  #$0200                  ; FC66: 11 83 02 00   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
    arg = 0x0200; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LFC44                   ; FC6A: 25 D8         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LFC44;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; FC6C: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
    Z = A|B; 
    N = A; 
    V = 0; 
    // End of function sub_FC1C
                                                     #ifdef DEBUG
                                      mon("         JMP   LFB73                   ; FC6F: 7E FB 73      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LFB73;
    
    // =============== S U B R O U T I N E =======================================
  case 0xFC72:
LFC72:
                                                     #ifdef DEBUG
                                      mon("LFC72    LDD   #$1B2C                  ; FC72: CC 1B 2C      \n");
                                      #endif
    PC = 0xfc72; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x1b; 
    B = 0x2c; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5018                   ; FC75: FD 50 18      \n");
                                      #endif // XT
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5018, A); // Care needed with I/O space and word fetches
    wr_mem(0x5019, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; FC78: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $501A                   ; FC7B: FD 50 1A      \n");
                                      #endif // YT
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x501a, A); // Care needed with I/O space and word fetches
    wr_mem(0x501b, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$4000                  ; FC7E: CC 40 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x40; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $501C                   ; FC81: FD 50 1C      \n");
                                      #endif // ZT
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x501c, A); // Care needed with I/O space and word fetches
    wr_mem(0x501d, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$5D                    ; FC84: 86 5D         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x5d; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4700                   ; FC86: B7 47 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4700, val); 
                                                     #ifdef DEBUG
                                      mon("         MUL                           ; FC89: 3D            \n");
                                      #endif
    res = (UINT16)(A * B); 
 // Z = res; 
 // C = res & 0x80; 
    A = res >> 8; 
    B = (UINT8)res; 
    clockticks = clockticks + 11; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$196A                  ; FC8A: CC 19 6A      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x19; 
    B = 0x6a; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5018                   ; FC8D: FD 50 18      \n");
                                      #endif // XT
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5018, A); // Care needed with I/O space and word fetches
    wr_mem(0x5019, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; FC90: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $501A                   ; FC93: FD 50 1A      \n");
                                      #endif // YT
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x501a, A); // Care needed with I/O space and word fetches
    wr_mem(0x501b, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$4000                  ; FC96: CC 40 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x40; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $501C                   ; FC99: FD 50 1C      \n");
                                      #endif // ZT
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x501c, A); // Care needed with I/O space and word fetches
    wr_mem(0x501d, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$5E                    ; FC9C: 86 5E         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x5e; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4700                   ; FC9E: B7 47 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4700, val); 
                                                     #ifdef DEBUG
                                      mon("         MUL                           ; FCA1: 3D            \n");
                                      #endif
    res = (UINT16)(A * B); 
 // Z = res; 
 // C = res & 0x80; 
    A = res >> 8; 
    B = (UINT8)res; 
    clockticks = clockticks + 11; 
                                                     #ifdef DEBUG
                                      mon("         LDD   $5000                   ; FCA2: FC 50 00      \n");
                                      #endif // Math result X
    clockticks = clockticks + 5; 
    A = rd_mem(0x5000); // Care needed with I/O space and word fetches
    B = rd_mem(0x5001); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$3496                  ; FCA5: 10 83 34 96   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x3496; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
    // End of function sub_FC72
                                                     #ifdef DEBUG
                                      mon("         JMP   LFB73                   ; FCA9: 7E FB 73      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LFB73;
    
    // =============== S U B R O U T I N E =======================================
  case 0xFCAC:
LFCAC:
                                                     #ifdef DEBUG
                                      mon("LFCAC    ASLB                          ; FCAC: 58            \n");
                                      #endif
    PC = 0xfcac; 
    INSTRUCTION_START
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; FCAD: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #word_FCD1              ; FCAE: CE FC D1      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0xfcd1; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LEAU  B,U                     ; FCB1: 33 C5         \n");
                                      #endif
    clockticks = clockticks + 5; 
    U = (U + (SINT8)B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   ,U                      ; FCB3: EC C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(U); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(U+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5018                   ; FCB5: FD 50 18      \n");
                                      #endif // XT
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5018, A); // Care needed with I/O space and word fetches
    wr_mem(0x5019, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $02,U                   ; FCB8: EC 42         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0x0002); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $501A                   ; FCBA: FD 50 1A      \n");
                                      #endif // YT
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x501a, A); // Care needed with I/O space and word fetches
    wr_mem(0x501b, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $04,U                   ; FCBD: EC 44         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + 0x0004); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $501C                   ; FCBF: FD 50 1C      \n");
                                      #endif // ZT
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x501c, A); // Care needed with I/O space and word fetches
    wr_mem(0x501d, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$5D                    ; FCC2: 86 5D         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x5d; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4700                   ; FCC4: B7 47 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4700, val); 
                                                     #ifdef DEBUG
                                      mon("         MUL                           ; FCC7: 3D            \n");
                                      #endif
    res = (UINT16)(A * B); 
 // Z = res; 
 // C = res & 0x80; 
    A = res >> 8; 
    B = (UINT8)res; 
    clockticks = clockticks + 11; 
                                                     #ifdef DEBUG
                                      mon("         LDD   $5000                   ; FCC8: FC 50 00      \n");
                                      #endif // Math result X
    clockticks = clockticks + 5; 
    A = rd_mem(0x5000); // Care needed with I/O space and word fetches
    B = rd_mem(0x5001); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  $06,U                   ; FCCB: 10 A3 46      \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(U + 0x0006))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(U + 0x0006))+1)); 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = ea; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
    clockticks = clockticks + 1; 
    // End of function sub_FCAC
    // ---------------------------------------------------------------------------
                                                     #ifdef DEBUG
                                      mon("         JMP   LFB73                   ; FCCE: 7E FB 73      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LFB73;
    
    // ---------------------------------------------------------------------------
    // START OF FUNCTION CHUNK FOR sub_6532
  case 0xFD07:
LFD07:
Check_Test_Diag:
                                                     #ifdef DEBUG
                                      mon("Check_Test_Diag LDA   $4300                   ; FD07: B6 43 00      \n");
                                      #endif
    PC = 0xfd07; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4300); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$10                    ; FD0A: 84 10         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x10; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $4320                   ; FD0C: F6 43 20      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4320); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$04                    ; FD0F: C4 04         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x04; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$00                    ; FD11: 10 83 00 00   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x0000; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LFD1A                   ; FD15: 27 03         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LFD1A;
    }
                                                     #ifdef DEBUG
                                      mon("         JMP   LF720                   ; FD17: 7E F7 20      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LF720;
    
    // ---------------------------------------------------------------------------
  case 0xFD1A:
LFD1A:
                                                     #ifdef DEBUG
                                      mon("LFD1A    STA   $4640                   ; FD1A: B7 46 40      \n");
                                      #endif // Self test and Diag selected
    PC = 0xfd1a; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4640, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$FF                    ; FD1D: 86 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xff; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4686                   ; FD1F: B7 46 86      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4686, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   $4683                   ; FD22: B7 46 83      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4683, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   $4682                   ; FD25: B7 46 82      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4682, val); 
                                                     #ifdef DEBUG
                                      mon("         LDB   $4340                   ; FD28: F6 43 40      \n");
                                      #endif // Get diag test option
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4340); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         COMB                          ; FD2B: 53            \n");
                                      #endif
    val = (UINT8)B ^ 0xff; 
    B = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #Diag_Test_Tablefcb $E0, $10, $E1, $11, ; FD2C: CE FD 9A      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0xfd9a; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0xFD2F:
LFD2F:
                                                     #ifdef DEBUG
                                      mon("LFD2F    CMPB  ,U+                     ; FD2F: E1 C0         \n");
                                      #endif
    PC = 0xfd2f; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    val = (UINT8)B; 
    arg = rd_mem(U); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
    U = U + 1; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LFD5A                   ; FD31: 26 27         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LFD5A;
    }
                                                     #ifdef DEBUG
                                      mon("         STA   $4620                   ; FD33: B7 46 20      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4620, val); 
                                                     #ifdef DEBUG
                                      mon("         LDY   #$00                    ; FD36: 10 8E 00 00   \n");
                                      #endif // Point to Vector RAM start instruction
    clockticks = clockticks + 4; 
    Y = 0x0000; 
 // Z = Y; 
 // N = (Y) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$BFAE                  ; FD3A: CC BF AE      \n");
                                      #endif // Vector instruction JRSL 0x1FAE
    clockticks = clockticks + 3; 
    A = 0xbf; 
    B = 0xae; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; FD3D: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$8040                  ; FD3F: CC 80 40      \n");
                                      #endif // Vector instruction CNTR 0x40
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; FD42: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   ,U                      ; FD44: A6 C4         \n");
                                      #endif // Get BCD number of diag test from table
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(U); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDS   #$4FFF                  ; FD46: 10 CE 4F FF   \n");
                                      #endif // Reset stack pointer
    clockticks = clockticks + 4; 
    S = 0x4fff; 
 // Z = S; 
 // N = (S) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   Display_Vect_BCD        ; FD4A: BD E7 90      \n");
                                      #endif // Display 2 digit BCD number in A
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x4d); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0xfd); 
    clockticks = clockticks + 1; 
    goto LE790;
  case 0xFD4D:
LFD4D:
                                                     #ifdef DEBUG
                                      mon("LFD4D    LDD   #$2020                  ; FD4D: CC 20 20      \n");
                                      #endif // Vector HALT
    PC = 0xfd4d; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x20; 
    B = 0x20; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; FD50: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; FD52: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4600                   ; FD54: B7 46 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4600, val); 
                                                     #ifdef DEBUG
                                      mon("         LDU   #LFDBC                  ; FD57: CE FD BC      \n");
                                      #endif // Bounds check
    clockticks = clockticks + 3; 
    U = 0xfdbc; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0xFD5A:
LFD5A:
                                                     #ifdef DEBUG
                                      mon("LFD5A    LEAU  $01,U                   ; FD5A: 33 41         \n");
                                      #endif
    PC = 0xfd5a; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    U = (U + 0x0001); 
                                                     #ifdef DEBUG
                                      mon("         CMPU  #LFDBC                  ; FD5C: 11 83 FD BC   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
    arg = 0xfdbc; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LFD2F                   ; FD60: 25 CD         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LFD2F;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   $4340                   ; FD62: F6 43 40      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4340); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         COMB                          ; FD65: 53            \n");
                                      #endif
    val = (UINT8)B ^ 0xff; 
    B = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         TFR   B,A                     ; FD66: 1F 98         \n");
                                      #endif
    A = (UINT8)B; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$0F                    ; FD68: C4 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x0f; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$F8                    ; FD6A: 84 F8         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0xf8; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$C0                    ; FD6C: 81 C0         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xc0; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LFD72                   ; FD6E: 27 02         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LFD72;
    }
                                                     #ifdef DEBUG
                                      mon("         CLR   <$D1                    ; FD70: 0F D1         \n");
                                      #endif
    clockticks = clockticks + 4; 
    wr_mem(DP|0xd1, 0); 
 // V = 0; 
 // Z = 0; 
 // N = 0; 
 // C = 0; 
    clockticks = clockticks + 2; 
  case 0xFD72:
LFD72:
                                                     #ifdef DEBUG
                                      mon("LFD72    LDX   #JMPTBL_Diag            ; FD72: 8E FD 85      \n");
                                      #endif
    PC = 0xfd72; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0xfd85; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xFD75:
LFD75:
                                                     #ifdef DEBUG
                                      mon("LFD75    CMPA  ,X+                     ; FD75: A1 80         \n");
                                      #endif
    PC = 0xfd75; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    val = (UINT8)A; 
    arg = rd_mem(X); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
    X = X + 1; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LFD7B                   ; FD77: 26 02         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LFD7B;
    }
                                                     #ifdef DEBUG
                                      mon("         JMP   [,X]                    ; FD79: 6E 94         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 4; 
    clockticks = clockticks + 2; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    PC = ea; 
    JUMP;
    
    // ---------------------------------------------------------------------------
  case 0xFD7B:
LFD7B:
                                                     #ifdef DEBUG
                                      mon("LFD7B    LEAX  $02,X                   ; FD7B: 30 02         \n");
                                      #endif
    PC = 0xfd7b; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    X = (X + 0x0002); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #Diag_Test_Tablefcb $E0, $10, $E1, $11, ; FD7D: 8C FD 9A      \n");
                                      #endif // Bounds check
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0xfd9a; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LFD75                   ; FD80: 25 F3         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LFD75;
    }
    // END OF FUNCTION CHUNK FOR sub_6532
    // ---------------------------------------------------------------------------
                                                     #ifdef DEBUG
                                      mon("         JMP   LFF24                   ; FD82: 7E FF 24      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LFF24;
    
                   // FCB   $80                     ; FD88:  ' ' 80 FD          SUBA  #$FD ; 
                   // FCB   $F8                     ; FD97:  ' ' F8 FE A7       EORB  $FEA7 ; 
                   // FCB   $F2                     ; FDB4:  ' ' F2 23 F3       SBCB  $23F3 ; 
                   // FCB   $23                     ; FDB5:  '#' 23 F3          BLS   $FDAA ; 
                   // FCB   $F3                     ; FDB6:  ' ' F3 24 F4       ADDD  $24F4 ; 
                   // FCB   $24                     ; FDB7:  '$' 24 F4          BCC   $FDAD ; 
                   // FCB   $F4                     ; FDB8:  ' ' F4 25 F8       ANDB  $25F8 ; 
                   // FCB   $25                     ; FDB9:  '%' 25 F8          BCS   $FDB3 ; 
                   // FCB   $F8                     ; FDBA:  ' ' F8 26 5D       EORB  $265D ; 
                   // FCB   $26                     ; FDBB:  '&' 26 5D          BNE   $FE1A ; 
    // =============== S U B R O U T I N E =======================================
  case 0xFDBC:
LFDBC:
                                                     #ifdef DEBUG
                                      mon("LFDBC    TSTB                          ; FDBC: 5D            \n");
                                      #endif
    PC = 0xfdbc; 
    INSTRUCTION_START
    val = (UINT8)B; 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LFDC2                   ; FDBD: 27 03         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LFDC2;
    }
                                                     #ifdef DEBUG
                                      mon("         JMP   LFF24                   ; FDBF: 7E FF 24      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LFF24;
    
    // ---------------------------------------------------------------------------
  case 0xFDC2:
LFDC2:
                                                     #ifdef DEBUG
                                      mon("LFDC2    TFR   S,D                     ; FDC2: 1F 40         \n");
                                      #endif
    PC = 0xfdc2; 
    INSTRUCTION_START
    val = S; 
    A = (UINT8)(val >> 8); 
    B = (UINT8)val; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$40                    ; FDC4: 84 40         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x40; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$01                    ; FDC6: C4 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x01; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$00                    ; FDC8: 10 83 00 00   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x0000; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LFDD4                   ; FDCC: 26 06         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LFDD4;
    }
                                                     #ifdef DEBUG
                                      mon("         LDU   #$4686                  ; FDCE: CE 46 86      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x4686; 
    Z = U; 
    N = (U) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JMP   LFEFF                   ; FDD1: 7E FE FF      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LFEFF;
    
    // ---------------------------------------------------------------------------
    // End of function sub_FDBC
  case 0xFDD4:
LFDD4:
                                                     #ifdef DEBUG
                                      mon("LFDD4    JMP   Check_Test_Diag         ; FDD4: 7E FD 07      \n");
                                      #endif
    PC = 0xfdd4; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    goto LFD07;
    
    // =============== S U B R O U T I N E =======================================
  case 0xFDD7:
LFDD7:
                                                     #ifdef DEBUG
                                      mon("LFDD7    TSTB                          ; FDD7: 5D            \n");
                                      #endif
    PC = 0xfdd7; 
    INSTRUCTION_START
    val = (UINT8)B; 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LFDDD                   ; FDD8: 27 03         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LFDDD;
    }
                                                     #ifdef DEBUG
                                      mon("         JMP   LFF24                   ; FDDA: 7E FF 24      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LFF24;
    
    // ---------------------------------------------------------------------------
  case 0xFDDD:
LFDDD:
                                                     #ifdef DEBUG
                                      mon("LFDDD    TFR   S,D                     ; FDDD: 1F 40         \n");
                                      #endif
    PC = 0xfddd; 
    INSTRUCTION_START
    val = S; 
    A = (UINT8)(val >> 8); 
    B = (UINT8)val; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$81                    ; FDDF: 84 81         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x81; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$F8                    ; FDE1: C4 F8         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0xf8; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$00                    ; FDE3: 10 83 00 00   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x0000; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LFDEF                   ; FDE7: 26 06         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LFDEF;
    }
                                                     #ifdef DEBUG
                                      mon("         LDU   #$4683                  ; FDE9: CE 46 83      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x4683; 
    Z = U; 
    N = (U) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JMP   LFEFF                   ; FDEC: 7E FE FF      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LFEFF;
    
    // ---------------------------------------------------------------------------
    // End of function sub_FDD7
  case 0xFDEF:
LFDEF:
                                                     #ifdef DEBUG
                                      mon("LFDEF    JMP   Check_Test_Diag         ; FDEF: 7E FD 07      \n");
                                      #endif
    PC = 0xfdef; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    goto LFD07;
    
    // =============== S U B R O U T I N E =======================================
  case 0xFDF2:
LFDF2:
                                                     #ifdef DEBUG
                                      mon("LFDF2    CMPB  #$06                    ; FDF2: C1 06         \n");
                                      #endif
    PC = 0xfdf2; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x06; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   LFE0E                   ; FDF4: 26 18         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LFE0E;
    }
                                                     #ifdef DEBUG
                                      mon("         TST   <$D1                    ; FDF6: 0D D1         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xd1); 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LFE0C                   ; FDF8: 26 12         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LFE0C;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   #$0800                  ; FDFA: 8E 08 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x0800; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; FDFD: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xFDFF:
LFDFF:
                                                     #ifdef DEBUG
                                      mon("LFDFF    STA   ,X+                     ; FDFF: A7 80         \n");
                                      #endif
    PC = 0xfdff; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, val); 
    X = X + 1; 
                                                     #ifdef DEBUG
                                      mon("         ADDA  #$05                    ; FE01: 8B 05         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x05; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$1000                  ; FE03: 8C 10 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x1000; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LFDFF                   ; FE06: 25 F7         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LFDFF;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$FF                    ; FE08: 86 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xff; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$D1                    ; FE0A: 97 D1         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0xd1; 
    wr_mem(ea, val); 
  case 0xFE0C:
LFE0C:
                                                     #ifdef DEBUG
                                      mon("LFE0C    BRA   LFE34                   ; FE0C: 20 26         \n");
                                      #endif
    PC = 0xfe0c; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto LFE34;
    
    // ---------------------------------------------------------------------------
  case 0xFE0E:
LFE0E:
                                                     #ifdef DEBUG
                                      mon("LFE0E    CLR   <$D1                    ; FE0E: 0F D1         \n");
                                      #endif
    PC = 0xfe0e; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    wr_mem(DP|0xd1, 0); 
 // V = 0; 
 // Z = 0; 
 // N = 0; 
 // C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4620                   ; FE10: B7 46 20      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4620, val); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #Diag_Vect_Data         ; FE13: 8E FE 37      \n");
                                      #endif // Point to diag vector test instructions
    clockticks = clockticks + 3; 
    X = 0xfe37; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; FE16: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; FE17: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; FE18: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #LFE4F                  ; FE19: 8C FE 4F      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0xfe4f; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LFE21                   ; FE1C: 25 03         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LFE21;
    }
                                                     #ifdef DEBUG
                                      mon("         JMP   LFF24                   ; FE1E: 7E FF 24      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LFF24;
    
    // ---------------------------------------------------------------------------
  case 0xFE21:
LFE21:
                                                     #ifdef DEBUG
                                      mon("LFE21    LDD   ,X                      ; FE21: EC 84         \n");
                                      #endif
    PC = 0xfe21; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(X); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(X+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $00                     ; FE23: FD 00 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x0000, A); // Care needed with I/O space and word fetches
    wr_mem(0x0001, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $02,X                   ; FE26: EC 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + 0x0002); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $02                     ; FE28: FD 00 02      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x0002, A); // Care needed with I/O space and word fetches
    wr_mem(0x0003, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$2020                  ; FE2B: CC 20 20      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x20; 
    B = 0x20; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $04                     ; FE2E: FD 00 04      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x0004, A); // Care needed with I/O space and word fetches
    wr_mem(0x0005, B); 
                                                     #ifdef DEBUG
                                      mon("         STA   $4600                   ; FE31: B7 46 00      \n");
                                      #endif // Run diag vector test
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x4600, val); 
    // End of function sub_FDF2
    // ---------------------------------------------------------------------------
  case 0xFE34:
LFE34:
                                                     #ifdef DEBUG
                                      mon("LFE34    JMP   Check_Test_Diag         ; FE34: 7E FD 07      \n");
                                      #endif
    PC = 0xfe34; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    goto LFD07;
    
    // =============== S U B R O U T I N E =======================================
  case 0xFE4F:
LFE4F:
                                                     #ifdef DEBUG
                                      mon("LFE4F    LDX   #off_FCF1               ; FE4F: 8E FC F1      \n");
                                      #endif
    PC = 0xfe4f; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0xfcf1; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; FE52: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; FE53: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         LDY   #$00                    ; FE54: 10 8E 00 00   \n");
                                      #endif
    clockticks = clockticks + 4; 
    Y = 0x0000; 
 // Z = Y; 
 // N = (Y) >> 8; 
 // V = 0; 
  case 0xFE58:
LFE58:
                                                     #ifdef DEBUG
                                      mon("LFE58    CMPX  #Check_Test_Diag        ; FE58: 8C FD 07      \n");
                                      #endif
    PC = 0xfe58; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0xfd07; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LFE60                   ; FE5B: 25 03         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LFE60;
    }
                                                     #ifdef DEBUG
                                      mon("         JMP   LFF24                   ; FE5D: 7E FF 24      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LFF24;
    
    // ---------------------------------------------------------------------------
  case 0xFE60:
LFE60:
                                                     #ifdef DEBUG
                                      mon("LFE60    STA   $4640                   ; FE60: B7 46 40      \n");
                                      #endif
    PC = 0xfe60; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4640, val); 
                                                     #ifdef DEBUG
                                      mon("         LEAY  $01,Y                   ; FE63: 31 21         \n");
                                      #endif
    clockticks = clockticks + 5; 
    Y = (Y + 0x0001); 
 // Z = Y; 
                                                     #ifdef DEBUG
                                      mon("         CMPY  #$0200                  ; FE65: 10 8C 02 00   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = Y; 
    arg = 0x0200; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LFE71                   ; FE69: 25 06         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LFE71;
    }
                                                     #ifdef DEBUG
                                      mon("         LDS   #Check_Test_Diag        ; FE6B: 10 CE FD 07   \n");
                                      #endif
    clockticks = clockticks + 4; 
    S = 0xfd07; 
    Z = S; 
    N = (S) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LFE75                   ; FE6F: 20 04         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LFE75;
    
    // ---------------------------------------------------------------------------
  case 0xFE71:
LFE71:
                                                     #ifdef DEBUG
                                      mon("LFE71    LDS   #LFE58                  ; FE71: 10 CE FE 58   \n");
                                      #endif
    PC = 0xfe71; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    S = 0xfe58; 
 // Z = S; 
 // N = (S) >> 8; 
 // V = 0; 
  case 0xFE75:
LFE75:
                                                     #ifdef DEBUG
                                      mon("LFE75    TFR   X,D                     ; FE75: 1F 10         \n");
                                      #endif
    PC = 0xfe75; 
    INSTRUCTION_START
    val = X; 
    A = (UINT8)(val >> 8); 
    B = (UINT8)val; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #off_FCFF               ; FE77: 83 FC FF      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0xfcff; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
    // End of function sub_FE4F
                                                     #ifdef DEBUG
                                      mon("         JMP   [,X]                    ; FE7A: 6E 94         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 4; 
    clockticks = clockticks + 2; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    PC = ea; 
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // FUNCTION CHUNK AT ROM:FB38 SIZE 00000013 BYTES
  case 0xFE7C:
LFE7C:
                                                     #ifdef DEBUG
                                      mon("LFE7C    LDX   #word_FB4B              ; FE7C: 8E FB 4B      \n");
                                      #endif
    PC = 0xfe7c; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0xfb4b; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; FE7F: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; FE80: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; FE81: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; FE82: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         LDY   #$00                    ; FE83: 10 8E 00 00   \n");
                                      #endif
    clockticks = clockticks + 4; 
    Y = 0x0000; 
 // Z = Y; 
 // N = (Y) >> 8; 
 // V = 0; 
  case 0xFE87:
LFE87:
                                                     #ifdef DEBUG
                                      mon("LFE87    CMPX  #LFB73                  ; FE87: 8C FB 73      \n");
                                      #endif
    PC = 0xfe87; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0xfb73; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LFE8F                   ; FE8A: 25 03         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LFE8F;
    }
                                                     #ifdef DEBUG
                                      mon("         JMP   LFF24                   ; FE8C: 7E FF 24      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LFF24;
    
    // ---------------------------------------------------------------------------
  case 0xFE8F:
LFE8F:
                                                     #ifdef DEBUG
                                      mon("LFE8F    STA   $4640                   ; FE8F: B7 46 40      \n");
                                      #endif
    PC = 0xfe8f; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4640, val); 
                                                     #ifdef DEBUG
                                      mon("         LEAY  $01,Y                   ; FE92: 31 21         \n");
                                      #endif
    clockticks = clockticks + 5; 
    Y = (Y + 0x0001); 
 // Z = Y; 
                                                     #ifdef DEBUG
                                      mon("         CMPY  #$0200                  ; FE94: 10 8C 02 00   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = Y; 
    arg = 0x0200; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LFEA0                   ; FE98: 25 06         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LFEA0;
    }
  case 0xFE9A:
LFE9A:
                                                     #ifdef DEBUG
                                      mon("LFE9A    LDS   #Check_Test_Diag        ; FE9A: 10 CE FD 07   \n");
                                      #endif
    PC = 0xfe9a; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    S = 0xfd07; 
    Z = S; 
    N = (S) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   LFEA4                   ; FE9E: 20 04         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto LFEA4;
    
    // ---------------------------------------------------------------------------
  case 0xFEA0:
LFEA0:
                                                     #ifdef DEBUG
                                      mon("LFEA0    LDS   #LFE87                  ; FEA0: 10 CE FE 87   \n");
                                      #endif
    PC = 0xfea0; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    S = 0xfe87; 
    Z = S; 
    N = (S) >> 8; 
    V = 0; 
    // End of function sub_FE7C
  case 0xFEA4:
LFEA4:
                                                     #ifdef DEBUG
                                      mon("LFEA4    JMP   LFB38                   ; FEA4: 7E FB 38      \n");
                                      #endif
    PC = 0xfea4; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    goto LFB38;
    
    // =============== S U B R O U T I N E =======================================
  case 0xFEA7:
LFEA7:
                                                     #ifdef DEBUG
                                      mon("LFEA7    ANDB  #$07                    ; FEA7: C4 07         \n");
                                      #endif
    PC = 0xfea7; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x07; 
    B = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LFEAE                   ; FEA9: 27 03         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LFEAE;
    }
                                                     #ifdef DEBUG
                                      mon("         JMP   LFF24                   ; FEAB: 7E FF 24      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LFF24;
    
    // ---------------------------------------------------------------------------
  case 0xFEAE:
LFEAE:
                                                     #ifdef DEBUG
                                      mon("LFEAE    LDA   #$01                    ; FEAE: 86 01         \n");
                                      #endif
    PC = 0xfeae; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x01; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xFEB0:
LFEB0:
                                                     #ifdef DEBUG
                                      mon("LFEB0    STB   $46E0                   ; FEB0: F7 46 E0      \n");
                                      #endif
    PC = 0xfeb0; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x46e0, val); 
                                                     #ifdef DEBUG
                                      mon("         TFR   X,U                     ; FEB3: 1F 13         \n");
                                      #endif
    U = X; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $4400                   ; FEB5: F6 44 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4400); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $4401                   ; FEB8: F6 44 01      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4401); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$40                    ; FEBB: C4 40         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x40; 
    B = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   LFF03                   ; FEBD: 26 44         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LFF03;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   #$80                    ; FEBF: C6 80         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x80; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0xFEC1:
LFEC1:
                                                     #ifdef DEBUG
                                      mon("LFEC1    DECB                          ; FEC1: 5A            \n");
                                      #endif
    PC = 0xfec1; 
    INSTRUCTION_START
    val = (UINT8)B; 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BMI   LFF03                   ; FEC2: 2B 3F         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LFF03;
    }
                                                     #ifdef DEBUG
                                      mon("         STA   $4640                   ; FEC4: B7 46 40      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4640, val); 
                                                     #ifdef DEBUG
                                      mon("         TST   $4401                   ; FEC7: 7D 44 01      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4401); 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BMI   LFEC1                   ; FECA: 2B F5         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LFEC1;
    }
                                                     #ifdef DEBUG
                                      mon("         STA   $4400                   ; FECC: B7 44 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4400, val); 
                                                     #ifdef DEBUG
                                      mon("         LDB   $4401                   ; FECF: F6 44 01      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4401); 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BPL   LFF03                   ; FED2: 2A 2F         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto LFF03;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   #$0100                  ; FED4: 8E 01 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x0100; 
 // Z = X; 
    N = (X) >> 8; 
    V = 0; 
  case 0xFED7:
LFED7:
                                                     #ifdef DEBUG
                                      mon("LFED7    LEAX  -1,X                    ; FED7: 30 1F         \n");
                                      #endif
    PC = 0xfed7; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    X = (X + 0xffff); 
    Z = X; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LFF03                   ; FED9: 27 28         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LFF03;
    }
                                                     #ifdef DEBUG
                                      mon("         STA   $4640                   ; FEDB: B7 46 40      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4640, val); 
                                                     #ifdef DEBUG
                                      mon("         LDB   $4401                   ; FEDE: F6 44 01      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4401); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$40                    ; FEE1: C4 40         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x40; 
    B = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   LFED7                   ; FEE3: 27 F2         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto LFED7;
    }
                                                     #ifdef DEBUG
                                      mon("         TST   $4401                   ; FEE5: 7D 44 01      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4401); 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BMI   LFF03                   ; FEE8: 2B 19         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LFF03;
    }
                                                     #ifdef DEBUG
                                      mon("         CMPA  $4400                   ; FEEA: B1 44 00      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    arg = rd_mem(0x4400); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   LFF03                   ; FEED: 26 14         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto LFF03;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   $4401                   ; FEEF: F6 44 01      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4401); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$40                    ; FEF2: C4 40         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x40; 
    B = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BMI   LFF03                   ; FEF4: 2B 0D         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto LFF03;
    }
                                                     #ifdef DEBUG
                                      mon("         ASLA                          ; FEF6: 48            \n");
                                      #endif
    val = (UINT8)A; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
    Z = res; 
    N = res; 
    V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BCC   LFEB0                   ; FEF7: 24 B7         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto LFEB0;
    }
                                                     #ifdef DEBUG
                                      mon("         LDU   #$4682                  ; FEF9: CE 46 82      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x4682; 
    Z = U; 
    N = (U) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JMP   LFEFF                   ; FEFC: 7E FE FF      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LFEFF;
    
  case 0xFEFF:
LFEFF:
                                                     #ifdef DEBUG
                                      mon("LFEFF    LDA   #$00                    ; FEFF: 86 00         \n");
                                      #endif
    PC = 0xfeff; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   ,U                      ; FF01: A7 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, val); 
  case 0xFF03:
LFF03:
                                                     #ifdef DEBUG
                                      mon("LFF03    LDX   #$00                    ; FF03: 8E 00 00      \n");
                                      #endif
    PC = 0xff03; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x0000; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xFF06:
LFF06:
                                                     #ifdef DEBUG
                                      mon("LFF06    STA   $4640                   ; FF06: B7 46 40      \n");
                                      #endif
    PC = 0xff06; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4640, val); 
                                                     #ifdef DEBUG
                                      mon("         LEAX  $01,X                   ; FF09: 30 01         \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + 0x0001); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$AC55                  ; FF0B: 8C AC 55      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0xac55; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LFF06                   ; FF0E: 25 F6         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LFF06;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$FF                    ; FF10: 86 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xff; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   ,U                      ; FF12: A7 C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$00                    ; FF14: 8E 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x0000; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xFF17:
LFF17:
                                                     #ifdef DEBUG
                                      mon("LFF17    STA   $4640                   ; FF17: B7 46 40      \n");
                                      #endif
    PC = 0xff17; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4640, val); 
                                                     #ifdef DEBUG
                                      mon("         LEAX  $01,X                   ; FF1A: 30 01         \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + 0x0001); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$AC55                  ; FF1C: 8C AC 55      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0xac55; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LFF17                   ; FF1F: 25 F6         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LFF17;
    }
    // End of function sub_FEA7
                                                     #ifdef DEBUG
                                      mon("         JMP   Check_Test_Diag         ; FF21: 7E FD 07      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LFD07;
    
    // ---------------------------------------------------------------------------
    // START OF FUNCTION CHUNK FOR sub_6532
  case 0xFF24:
LFF24:
                                                     #ifdef DEBUG
                                      mon("LFF24    LDA   #$00                    ; FF24: 86 00         \n");
                                      #endif
    PC = 0xff24; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4686                   ; FF26: B7 46 86      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4686, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   $4683                   ; FF29: B7 46 83      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4683, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   $4682                   ; FF2C: B7 46 82      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4682, val); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$00                    ; FF2F: 8E 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x0000; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xFF32:
LFF32:
                                                     #ifdef DEBUG
                                      mon("LFF32    STA   $4640                   ; FF32: B7 46 40      \n");
                                      #endif
    PC = 0xff32; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4640, val); 
                                                     #ifdef DEBUG
                                      mon("         LEAX  $01,X                   ; FF35: 30 01         \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + 0x0001); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$5600                  ; FF37: 8C 56 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x5600; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LFF32                   ; FF3A: 25 F6         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LFF32;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$FF                    ; FF3C: 86 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xff; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4686                   ; FF3E: B7 46 86      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4686, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   $4683                   ; FF41: B7 46 83      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4683, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   $4682                   ; FF44: B7 46 82      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4682, val); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$00                    ; FF47: 8E 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x0000; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0xFF4A:
LFF4A:
                                                     #ifdef DEBUG
                                      mon("LFF4A    STA   $4640                   ; FF4A: B7 46 40      \n");
                                      #endif
    PC = 0xff4a; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4640, val); 
                                                     #ifdef DEBUG
                                      mon("         LEAX  $01,X                   ; FF4D: 30 01         \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + 0x0001); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$5600                  ; FF4F: 8C 56 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x5600; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   LFF4A                   ; FF52: 25 F6         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto LFF4A;
    }
    // END OF FUNCTION CHUNK FOR sub_6532
    // ---------------------------------------------------------------------------
                                                     #ifdef DEBUG
                                      mon("         JMP   Check_Test_Diag         ; FF54: 7E FD 07      \n");
                                      #endif
    clockticks = clockticks + 4; 
    goto LFD07;
    
    // end of ROM
