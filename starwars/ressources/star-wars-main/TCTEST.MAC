 	.TITLE TOMCAT TEST

DEVSYS	==0		;010101010101010101010101010101010101010101010101010101

	.INCLUDE WSCOMN	;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

	.PAGE
	.SBTTL	GLOBLS

	;INTERNAL ROUTINES
	.GLOBL	TEST
	;EXTERNAL
	.GLOBL	RESET,DOMESS,VWBYTE,VWNIBL
	;LOCATIONS
	.GLOBL	RAM,RAMZ,MBRAM,MBRAMZ,VGRAM,VGRAMZ,VGROM,VGROMZ,STACK
	.GLOBL	NVRAM,NVRAMZ,NVRRCL,PROG,EEBUF
	.GLOBL	IN0,IN1,R.BYT0,R.BYT1,R.BYT2,R.BYT3
	.GLOBL	W.BANK
	.GLOBL	W.LED1,W.LED2,W.LED3

	.GLOBL	VJBONDRY,VJBOX,VJPOTP,VJSQR
	.GLOBL	VJCHKR,VJHTCH,VJINTN,VJBIP,VJBIP2,VJRSTR,VJRST2
	.GLOBL	VGCOLR,VGCNTR,VGSCAL,VGMSGA,VGHALT
	.GLOBL	VGGO,VGSTOP
	.GLOBL	FAKEVG,VGPSROM,VGRROM
	.GLOBL	TESTSW,AUXSW,IN0,FIRESW,DIAGSW
	.GLOBL	WTCHDG
	.GLOBL	W.CHN0,W.CHN1,R.CHN
	.GLOBL	R.STAS,R.RCVS,W.XMTS,W.RSTS
 
	.GLOBL	M.DVD,M.DVN,M.QUO,M.XP,M.YP,M.ZP
	.GLOBL	M.XT,M.YT,M.ZT,M.ZRO,M.ONE,M.PCGO,M.BIC,M.BUSY
	
	.GLOBB	TESTBT,AUXBIT,FIREBT,THMBT,DIAGBT

	.GLOBB	IDAYEA,IDANAY
	.GLOBB	MS.RAM,MS.SWT,MS.POT,MS.INT,MS.MBT,MS.BIP,MS.DIV,MS.MTX,MS.XIT
	.GLOBB	MS.SCL,MS.MBN
	.GLOBB	VGCRED,VGCGRN,VGCBLU,VGCWHT,VGCPRP,VGCYLW,VGCTRQ

	.ASECT
	.DPAGE	4800/100	;SET DPAGE TO PROGRAM RAM
	.=4800+0C0		;VARIABLES IN TOP OF DPAGE
COLOR:	.BLKB 1			;COLOR FOR PATTERN TESTS
BRITE:	.BLKB 1			;BRIGHTNESS FLAG FOR RASTER TEST
SCALE:	.BLKB 2			;SCALE VALUE FOR SCALE TEST
SCLTYP:	.BLKB 1			;TYPE OF SCALE TEST BEING PERFORMED
DBNC:	.BLKB 1			;DEBOUNCE AND AUTO REPEAT FOR AUX SWITCH
DBNC2:	.BLKB 1			;DEBOUNCE AND AUTO REPEAT FOR FIRE SWITCHES
DBNC3:	.BLKB 1			;DEBOUNCE AND AUTO REPEAT FOR THUMB SWITCHES
SWNEW:	.BLKB 2			;EDGE CATCHER NEW
SWOLD:	.BLKB 2			;EDGE CATCHER OLD
TTEMP:	.BLKB 2			;TEST ROUTINE TEMPS
TTEMP2:	.BLKB 2
SOUND:	.BLKB 1			;WHAT SOUND TRYING TO MAKE
SIGFLG:	.BLKB 1			;SIGNATURE ANALYSIS TEST FLAG
ERRORS:	.BLKB 2			;ERRORS FROM TESTS
ERRPNT:	.BLKB 2
ERRCNT:	.BLKB 1
CHKSUM:	.BLKB 2*6		;2 BYTES * 6 ROMS ( 5 PROGRAM AND 1 VG ROM )
ZSUM:
				;---
	
	.CSECT	TEST

	.IF	EQ,DEVSYS-1	;ONLY RESET WHILE DEVELOPING
	JMP RESET
	.IFF			;DO EVERYTHING

	.PAGE
	.SBTTL	TEST ROUTINES
TRAMP:				;TABLE OF POINTERS FOR RAM TEST	(ERROR BIT PATTERN)
	.WORD RAM			;PROCESSOR RAM			0001
MRAM0:	.WORD MBRAM+0000		;MATH BOX RAM (EVEN ADDRESSES)	0002
MRAM1:	.WORD MBRAM+0001		;MATH BOX RAM ( ODD ADDRESSES)	0004
	.WORD VGRAM+0000		;VECTOR GENERATOR RAM		0008
	.WORD VGRAM+0800		;   "       "      "		0010
	.WORD VGRAM+1000		;   "       "      "		0020
	.WORD VGRAM+1800		;   "       "      "		0040
	.WORD VGRAM+2000		;   "       "      "		0080
	.WORD VGRAM+2800		;   "       "      "		0100
TRAMPZ:	.WORD NVRAM+0000		;NON-VOLATILE RAM		0200
TROMP:				;TABLE OF POINTERS FOR ROM TEST
	.WORD PROG+0000			;PROGRAM ROMS			0400
	.WORD PROG+2000			;   "     "			0800
	.WORD PROG+4000			;   "     "			1000
	.WORD PROG+6000			;   "     "			2000
	.WORD PROG+8000			;   "     "			4000
TROMPZ:	.WORD VGROM+0000		;VECTOR GENERATOR ROM		8000
					;===

BITS:	.WORD 1,2,4,8,10,20,40,80	;BIT PATTERNS
	.WORD 100,200,400,800,1000,2000,4000,8000

.MACRO	ERR
	.LIST BYT
	TFR S,D			;GET TEST FLAG
	ORA BITS-TRAMP-2(U)	;SET BIT CORRESPONDING TO RAM UNDER TEST
	ORB BITS-TRAMP-1(U)
	TFR D,S			;PUT IT BACK
	BRA 100$
	.NLIST BYT
	.ENDM
	.PAGE
	.SBTTL	TEST

.IFTF		;EQ,DEVSYS-1	;IN ANY CASE, DEFINE THE ENTRY POINT

TEST:

.IFT		;EQ,DEVSYS-1	;DEVELOPMENT SYSTEM IS TIGHT ON ROM
	JMP RESET
.IFF		;EQ,DEVSYS-1	;ELSE IS ROM VERSION

	LDA DIAGSW
	ANDA #DIAGBT		;DIAGNOSTIC SWITCH?
	IFEQ			;YES, ITS ON
	LDA R.BYT2		;CHECK FOR DIAGNOSTIC 1 OR 2
	COMA
	ANDA #7F		;DIAG 1 = 00; DIAG 2 = 80
	IFNE			;NOT DIAG 1 OR 2, THEN SKIP RAM/ROM TEST
	JMP DIAGLP		;GO EXECUTE DIAGNOSTICS, NOW WITHOUT DELAY
	ENDIF
	ENDIF

;ELSE PERFORM RAM/ROM TEST FOR SELF-TEST AND/OR DIAGNOSTICS 1&2

;PERFORM A RUNNING 1 AND 0 TEST ON ALL RAMS. THE MAJORITY OF RAMS ARE OF TYPE 4016 ( 2K*8 )
;EXCEPT FOR THE NON-VOLATILE RAM WHICH IS 100*4.
;THIS TEST ASSUMES THAT ALL RAM HAS BEEN CLEARED BEFORE GETTING HERE.

RAMTST:
	LDS #0			;USE S TO FLAG ERRORS
	LDU #TRAMP		;TABLE OF RAM POINTERS
	BEGIN
	LDX (U)++		;BLOCK POINTER
	LDY #800		;BLOCK SIZE ( 2K*8 )
	BEGIN
	LDA 0(X)		;START WITH NEXT BYTE
	IFNE			;ERROR---SHOULD BE ZERO
	ERR
	ENDIF
	LDA #080		;FLOATING ONE TEST
	LSLA			;SETUP CARRY TOO(1,000)
30$:				;---
	ROLA			;FORM NEXT TEST
	STA 0(X)
	TFR A,B
	EORB 0(X)
	IFNE			;ERROR---SHOULD HAVE MATCHED
	ERR
	ENDIF
	BCC 50$			;?END OF FLOATING ONE?(=1,000)
	TSTA
	BNE 30$			;B NOPE, WAS FLOATING ZERO
	ADDA #0FF		;YEP, PREPARE FOR FLOATING ZERO
	BRA 30$			;J (1,000),ADDA#0FF,(0,0FF),ROLA,(1,0FE)
50$:				;---
	TFR A,B
	INCB			;?END OF FLOATING ZERO?(=0,0FF)
	BNE 30$			;B NOT YET
				;---
	STA WTCHDG		;KEEP THE DOG QUIET
				;---
				;INCREMENT X TO NEXT BYTE
	CMPU #MRAM0+2		;MATH RAM??  ( SPECIAL CASE FOR MATH RAM )
	BEQ 80$
	CMPU #MRAM1+2
	IFEQ			;YES, MATH RAM
80$:	LEAX 2(X)		;THEN DO EVERY OTHER BYTE
	ELSE
	LEAX 1(X)		;DO EVERY BYTE
	ENDIF
				;---
	LEAY -1(Y)		;DECREMENT BLOCK LENGTH COUNT, DONE?
	EQEND
100$:	CMPU #TRAMPZ		;END OF TABLE?
	HSEND
				;===
FINCLR:				;PERFORM A FINAL CLEAR OF ALL RAMS
				;PREVIOUS TESTING LEFT ALL DATA AT 0FF
	LDU #TRAMP
	BEGIN
	LDX 0(U)++
	LDY #800		;BLOCK SIZE COUNTER
	BEGIN
	INC 0(X)		;SHOULD INC FROM 0FF TO 00
	IFNE			;WASN'T 0FF ---  ERROR
	ERR
	ENDIF
	LDA 0(X)		;INC SHOULD HAVE LEFT A 00
	IFNE			;WASN'T 00 ---  ERROR
	ERR
	ENDIF
				;---
	STA WTCHDG		;MUZZLE THE DOG
				;---
				;INCREMENT X TO NEXT BYTE
	CMPU #MRAM0+2		;MATH RAM??  ( SPECIAL CASE FOR MATH RAM )
	BEQ 80$
	CMPU #MRAM1+2
	IFEQ			;YES, MATH RAM
80$:	LEAX 2(X)		;THEN DO EVERY OTHER BYTE
	ELSE
	LEAX 1(X)		;DO EVERY BYTE
	ENDIF
				;---
	LEAY -1(Y)		;DECREMENT BLOCK LENGTH COUNT, DONE?
	EQEND
100$:	CMPU #TRAMPZ		;END OF TABLE?
	HSEND
				;===

				;NON-VOLATILE RAM  TEST
	TFR S,D			;IS PROGRAM RAM OK?
	ANDB #01
	IFEQ			;YES, USE IT FOR EEBUFF
	LDX #NVRAM
	LDU #EEBUF
	BEGIN
	LDD (X)++
	STD (U)++
	CMPX #NVRAMZ
	HSEND
 	ENDIF
				;---
	LDU #TRAMPZ+2		;POINTER FOR ERROR BITS
NVRTST:	LDX #NVRAM		;CLEAR IT FIRST
	LDD #0000
	BEGIN
	STD (X)++
	CMPX #NVRAMZ
	HSEND
				;---
	LDX #NVRAM
	BEGIN			;PERFORM RUNNING 1 AND 0 TESTS
	LDA 0(X)
	ANDA #0F		;LOW NIBBLE ONLY
	IFNE
	ERR
	ENDIF
	LDA #80
	LSLA			;SET PATTERN (1,00)
	LDY #4			;SET COUNT

30$:	ROLA
	STA 0(X)
	TFR A,B
	EORB 0(X)
	ANDB #0F
	IFNE			;SHOULD HAVE MATCHED
	ERR
	ENDIF
	LEAY -1(Y)		;DONE WITH THIS PASS?
	BNE 30$			;NO, CONTINUE
	TSTA			;YES, WHAT PHASE
	IFPL			;WAS RUNNING 1, MAKE IT RUNNING 0
	LDA #0FF		;C SHOULD BE CLEAR STILL
	LDY #5			;COUNT OF 5 WILL LEAVE NIBBLE AS F
	BRA 30$
	ENDIF			;ELSE DONE
				;---
	STA WTCHDG
				;---
	LEAX 1(X)		;NEXT BYTE
	CMPX #NVRAMZ		;DONE?
	HSEND
				;---
				; OK CHECK USING A FINAL CLEAR
	LDX #NVRAM
	BEGIN
	INC 0(X)		;WAS LEFT AS xF, NOW SHOULD BE x0
	LDA 0(X)+
	ANDA #0F		;LOW NIBBLE ONLY
	IFNE			;WRONG
	ERR
 	ENDIF
	CMPX #NVRAMZ		;DONE?
	HSEND
100$:				;---
	TFR S,D
	ANDB #01
	IFEQ			;PROGRAM RAM ( EEBUF ) OK
	LDX #EEBUF		;COPY DATA BACK TO NVRAM
	LDU #NVRAM
	BEGIN
	LDD (X)++
	STD (U)++
	CMPX #EEBUF+100
	HSEND
	ELSE			;NO EEBUF
	LDA #0FF		;PERFORM A RECALL OF THE NON-VOLATILE MEMORY
	STA NVRRCL
	LDX #0100		;WAIT FOR THE CAP TO DISCHARGE
	BEGIN
	STA WTCHDG
	LEAX -1(X)
	EQEND
	LDA #00			;TURN OFF RECALL LINE
	STA NVRRCL
	LDX #0A000		;NOW WAIT FOR THE CAP TO CHARGE BACK UP
	BEGIN
	STA WTCHDG
	LEAX -1(X)
	EQEND
	ENDIF
				;---
	STA WTCHDG		;KEEP THE DOG HAPPY
				;---
ROMTST:
				;SPECIAL DEAL FOR FIRST ROM, BANK SELECTED HALVES OF A 27128
	LDA #00			;SWITCH TO FIRST HALF
	STA W.BANK
	LDX TROMP		;GET POINTER FOR FIRST ROM
	LDY #2000		;EACH HALF OF THE 27128 IS 8K LONG
	TFR X,D			;USE ADDRESS AS SEED
	BEGIN
	ADCB 1(X)
	ADCA (X)++
	STA WTCHDG		;SHUT THE DOG UP
	LEAY -2(Y)
	EQEND			;END OF FIRST HALF
	TFR D,X			;SAVE CURRENT CHECKSUM
	LDA #0FF
	STA W.BANK		;SWITCH BANKS
	LDU #TROMP+2		;SETUP U CORRECTLY FOR ERROR AND LATER TESTS
	TFR X,D			;GET CHECKSUM BACK
	LDY #2000		;OTHER HALF IS 8K ALSO
	LDX TROMP		;STARTING ADDRESS
	BRA 30$			;CONTINUE WITH THE CHECKSUMMING
				;---
	LDU #TROMP+2		;TABLE OF ROM POINTERS, SECOND ROM
	BEGIN
	LDX (U)++		;GET POINTER
	LDY #2000		;2764s ARE 8K LONG
20$:	TFR X,D			;USE ADDRESS AS SEED
30$:	BEGIN
	ADCB 1(X)
	ADCA (X)++
	STA WTCHDG		;SHUT THE DOG UP
	LEAY -2(Y)
	EQEND
	STD CHKSUM-TROMP-2(U)
	IFNE			;ERROR
	TFR S,D
	ORA BITS-TRAMP-2(U)
	ORB BITS-TRAMP-1(U)
	TFR D,S
	ENDIF
	CMPU #TROMPZ
	HSEND
	CMPU #TROMPZ+2
	IFLO
	LDX (U)++
	LDY #1000
	BRA 20$
	ENDIF
				;===
	LDA #0FF		;TURN OFF THE LEDS
	STA W.LED1
	STA W.LED2
	STA W.LED3
				;---
	CLR SIGFLG
	LDA DIAGSW		;CHECK FOR DIAGNOSTIC SWITCH
	ANDA #DIAGBT
	IFEQ			;ITS ON, DO DIAGNOSTICS
	JMP DIAGLP
	ENDIF
	STA WTCHDG		;HIT THE DOG
				;---
	.PAGE
	.SBTTL	DISPLAY THE RESULTS
TSTOUT:
	STS ERRORS		;SAVE ERRORS FOR LATER
	TFR S,D
	ANDB #01		;PROGRAM RAM OK? ( VARIABLES AND STACK )
	IFEQ			;NO, SPECIAL FAILURE MODE
				;YES, THEN ATTEMP TO USE VG FOR ERROR DISPLAY
				;SETUP FOR DISPLAY
	LDY #VGRAM		;VG POINTER
	LDD #VGCOLR&0FF00	;COLOR OFF
	STD (Y)++
	LDD #VJBONDRY		;DRAW A BOX TO FOOL THE BEAM KILLER
	STD (Y)++
	LDD #VGCNTR
	STD (Y)++
	LDA #4800/100		;SET DPAGE REGISTER
	TFR A,DPR
	STS TTEMP		;SAVE ERRORS IN RAM
	LDS #STACK		;SET STACK
	LDB #MS.XIT		;"PRESS AUX SWITCH TO CONTINUE"
	JSR DOMESS
	LDB #MS.RAM		;"HARDWARE ERRORS"
	JSR DOMESS
	LDB #MS.RAM+2		;START WITH ERROR MESSAGES
	STB TTEMP2
	LDD TTEMP		;ERRORS?
	IFEQ			;NO ERRORS
	LDB #MS.RAM+1		;"NO ERRORS DETECTED"
	JSR DOMESS
	ELSE			;YES, THERE ARE ERRORS
	BEGIN
	LSRD			;SHIFT IT
	STD TTEMP		;STORE IT BACK
	IFCS			;HAD AN ERROR THERE
	LDB TTEMP2		;MESSAGE NUMBER FOR THIS ERROR
	JSR DOMESS		;SAY IT
	LDB TTEMP2
	SUBB #MS.RAM+12.	;ROM ERROR MESSAGES?
	IFHS			;YES, THEN OUTPUT THE CHECKSUM
	ASLB
	LDX #TSUMY		;POSITION TO THE RIGHT OF THE MESSAGE
	ABX
	LDU (X)
	STU (Y)++
	LDU #1FFF&288.
	STU (Y)++
	LDX #CHKSUM		;GET THE DATA
	ABX
	LDA (X)+
	COMA
	JSR VWBYTE
	LDA (X)
	COMA
	JSR VWBYTE
	LDD #VGCNTR
	STD (Y)++
	ENDIF
	ENDIF
	INC TTEMP2		;NEXT MESSAGE NUMBER
	LDD TTEMP		;DONE WHEN NO ERRORS LEFT TO DISPLAY
	EQEND
	ENDIF
	BRA 100$		;LEAVE
	ENDIF
				;---
				;NOTHING WORKS, TRY TO MAKE ERROR TONES
	BEGIN
	LDX #0008
	TFR S,D
	BEGIN
	LSRB
	IFCS			;ERROR ON
	LDA #IDANAY		;ERROR SOUND
	ELSE
	LDA #IDAYEA		;NON-ERROR SOUND
	ENDIF
	STA W.XMTS
	LDU #0000		;1/2 SECOND DELAY
	BEGIN
	STB WTCHDG
	LEAU 1 (U)
	CMPU #0A000
	HSEND
	LEAX -1(X)
	EQEND
				;NOW THE OTHER HALF OF THE ERRORS
	LDX #0008
	TFR S,D
	BEGIN
	LSRA
	IFCS			;ERROR ON
	LDB #IDANAY		;ERROR SOUND
	ELSE
	LDB #IDAYEA		;NON-ERROR SOUND
	ENDIF
	STB W.XMTS
	LDU #0000		;1/2 SECOND DELAY
	BEGIN
	STA WTCHDG
	LEAU 1(U)
	CMPU #0A000
	HSEND
	LEAX -1(X)
	EQEND
				;DELAY, THEN REPEAT
	LDU #0000
	BEGIN
	STA WTCHDG
	LEAU 1(U)
	CMPU #0FF00
	HSEND

	LOOP
100$:	LDD #2020		;HALT
	STD (Y)++
; FALL THROUGH TO MAIN TEST LOOP
	.PAGE
	.SBTTL	TEST MAINLINE
	LDU #TSTATE		;SET UP FIRST TEST STATE
	CLR COLOR		;START WITH THE FIRST COLOR IN TABLE
	LDA #03			;INIT SWITCH DEBOUNCERS
	STA DBNC
	STA DBNC2
	STA DBNC3
	STA ERRCNT		;START NOISES QUICKLY
	LDX #BITS		;SET UP FOR HARDWARE ERROR DISPLAY ( FIRST STATE )
	STX ERRPNT
TSTLP:
	BEGIN
	LDD #1
	LDX #0
	BEGIN			;DELAY
	STA WTCHDG		;5 CYCLES ----  SHUT THE DOG UP
	LEAX D(X)		;8 CYCLES
	CMPX #1800.		;4 CYCLES
	HSEND			;3 CYCLES = 20 CYCLES * 1800. /1.5MHz = 24ms
	STA VGSTOP		;STOP THE VECTOR GENERATOR, SHOULD HAVE PREVIOUSLY HALTED
				;---
	LDA DIAGSW		;CHECK FOR DIAGNOSTIC SWITCH
	ANDA #DIAGBT
	IFEQ			;IT IS ON
	JMP HANG		;GO DO THEM BUT RESET FIRST
	ENDIF
				;---
				;DEBOUNCE SWITCHES AND SET PARAMS
	LDA AUXSW		;CHECK AUX SWITCH
	ANDA #AUXBIT
	IFEQ			;SWITCH WAS THERE
	LDA DBNC
	IFNE
	DECA
	IFEQ
	LEAU 2(U)		;INC STATE
	CMPU #TSTATZ		;END OF STATE TABLE?
	IFHS
	LDU #TSTATE+2
	ENDIF
	LDD #0000
	STD SCALE		;ALWAYS START THE SCALE TEST WITH LARGEST SCALE
	STA SCLTYP		;ALWAYS START THE SCALE TEST WITH LINEAR TEST
	STA COLOR		;ALWAYS START AT FIRST COLOR IN TABLE ( RED )
	LDA #80			;AUTO REPEAT TIMER
	ENDIF
	ENDIF
	ELSE			;NO SWITCHES ON
	LDA #03			;WANT TO SEE IT THIS MANY TIMES FOR A DEBOUNCE
	ENDIF
	STA DBNC
				;---
	LDA IN0			;DEBOUNCE FIRE SWITCH FOR COLOR CHANGES
	COMA			;CHECK FOR EITHER FIRE SWITCH
	ANDA #FIREBT
	IFNE
	LDA DBNC2
	IFNE
	DECA
	IFEQ			;INC COLOR FROM TABLE
	LDB COLOR
	ADDB #2
	CMPB #TCOLRZ-TCOLR
	IFHS			;END OF TABLE, START OVER
	CLRB
	ENDIF
	STB COLOR
	CMPB #<TCOLRW-TCOLR>/2	;WHITE?
	IFEQ			;YES, ALWAYS MAKE A NEW WHITE BRIGHT
	CLR BRITE
	ENDIF
	LDA #80			;AUTO REPEAT TIMER
	ENDIF
	ENDIF
	ELSE			;NO SWITCHES ON
	LDA #03			;WANT TO SEE IT THIS MANY TIMES TO DEBOUNCE
	ENDIF
	STA DBNC2
				;---
	CMPU #TSTATZ-2		;RASTER TEST?
	IFEQ			;YES, THEN CHECK FOR BRIGHTNESS CHANGE
	LDA IN1			;USE THUMB BUTTONS FOR CHANGE
	COMA
	ANDA #THMBT
	IFNE			;SWITCH IS ON
	LDA DBNC3
	IFNE
	DECA
	IFEQ			;TIME TO CHANGE
	LDB BRITE
	EORB #01
	STB BRITE
	LDA #80			;AUTO REPEAT TIMER
	ENDIF
	ENDIF
	ELSE			;SWITCHES NOT ON
	LDA #03			;NORMAL DEBOUNCE COUNT
	ENDIF
	STA DBNC3
	ELSE			;NOPE, NOT THE RASTER TEST
	CLR BRITE		;THEN MAKE SURE FLAG NOT SET
	ENDIF
				;---
	LDY #VGRAM		;SETUP POINTER
	LDB COLOR		;OUTPUT COLOR COMMAND
	LDX #TCOLR
	LDD B(X)
	CMPD #VGCOLR+<VGCWHT*100>;WHITE?
	IFEQ
	TST BRITE
	IFNE			;WANTS THE DIMMER WHITE FOR COLOR TRACKING
	LDB #20			;INSTEAD OF THE NORMAL 80
	ENDIF
	ENDIF
	STD (Y)++
	JMP @(U)		;EXECUTE THAT STATE
GETBAK:	LDD #2020		;PUT A COUPLE OF HALTS AT END
	STD (Y)++
	STD (Y)++
GETBK2:	STA VGGO		;START THE VECTOR GENERATOR
	LDA TESTSW		;CHECK FOR TEST SWITCH
	ANDA #TESTBT
	NEEND			;FALL THROUGH IF NO TEST SWITCH
HANG:
	.IF	NE,DEVSYS
	JMP RESET		;NO WATCHDOG WHILE DEVELOPING
	.IFF
	JMP HANG		;WAIT FOR WATCHDOG
	.ENDC
				;===

TSTATE:	.WORD	SDISP		;DISPLAY RAM-ROM ERRORS
TSTAT3:	.WORD	SSWTCH		;SWITCH TEST
TSTAT1:	.WORD	SDIV		;MATHBOX TESTS -- DIVIDER AND MATRIX PROC.
	.WORD	SHATCH		;CROSSHATCH PATTERN
	.WORD	SCHKR		;CHECKER BOARD PATTERN
	.WORD	SINTEN		;COLOR INTENSITY PATTERN
	.WORD	SBIP		;BIP PATTERN
	.WORD	SSCAL		;SCALE PATTERN
	.WORD	SRASTR		;RASTER PATTERN
TSTATZ:
					;---
TCOLR:	.WORD VGCOLR+<VGCRED*100>	;COLORS FOR PATTERN TESTS
	.WORD VGCOLR+<VGCGRN*100>
	.WORD VGCOLR+<VGCBLU*100>
	.WORD VGCOLR+<VGCPRP*100>
TCOLRW:	.WORD VGCOLR+<VGCWHT*100>
	.WORD VGCOLR+<VGCYLW*100>
	.WORD VGCOLR+<VGCTRQ*100>
TCOLRZ:
				;---
TSUMY:
	.WORD	1FFF&-200.
	.WORD	1FFF&-250.
	.WORD	1FFF&-300.
	.WORD	1FFF&-350.
	.WORD	1FFF&-400.
	.WORD	1FFF&-150.
TSUMYZ:

	.PAGE
	.SBTTL	SWITCH AND POT TEST
SDISP:
	DEC ERRCNT		;TIME?
	IFMI			;YES, TIME TO SOUND OFF
	LDA #10			;RESET TIMER FOR THE NEXT BIT
	STA ERRCNT
	LDX ERRPNT		;INDEXES INTO BIT TABLE
	LDD ERRORS		;CHECK IT OUT
	ANDA 0(X)
	BNE 30$			;ERROR DETECTED, GO SAY NAY
	ANDB 1(X)		;A WAS CLEAN, HOW ABOUT B?
	IFEQ			;B CLEAN TOO, SAY YEA
	LDA #IDAYEA
	ELSE			;MAKE ERROR SOUND ( NAY )
30$:	LDA #IDANAY
	ENDIF
	STA W.XMTS		;SHOVE IT OUT TO THE SOUND BOARD
	LEAX 2(X)
	CMPX #BITS+20		;END OF BIT TABLE?
	IFHS			;YES
	LDA #20			;DELAY LONGER BEFORE STARTING OVER
	STA ERRCNT
	LDX #BITS
	ENDIF
	STX ERRPNT
	ENDIF
	JMP GETBK2		;DO NOTHING

SSWTCH:
	STA W.CHN0		;START POT 0 READING FOR LATER
	STA W.CHN0		;MAKES IT A GOOD START
				;---
	LDD #VJBONDRY		;DRAW THE BORDER
	STD (Y)++
	LDD #VGCNTR
	STD (Y)++
	LDS #STACK		;SET STACK
	LDB #MS.SWT		;"SWITCH TEST"
	JSR DOMESS
	LDB #MS.XIT		;"PRESS AUX COIN TO CONTINUE"
	JSR DOMESS
	LDB #MS.SWT+1		;MESSAGES FOR SWITCHES
	STB TTEMP2
	LDA R.BYT0		;GET SWITCH DATA
	LDB R.BYT1
	ORB #0C7		;DISALLOW NON-SWITCHES (IE MATHBOX READY,VG HALTED,ETC.)
	STD TTEMP
	BEGIN			;DISPLAY MESSAGES FOR ON SWITCHES
	ASLD			;SHIFT BIT TO CARRY
	STD TTEMP		;SAVE FOR NEXT SWITCH
	IFCC			;SWITCH WAS ON
	LDB TTEMP2		;DISLAY MESSAGE
	JSR DOMESS
	ENDIF
	INC TTEMP2		;NEXT POSSIBLE MESSAGE
	LDD TTEMP		;SWITCH DATA
	EQEND
				;---
				;FIND SWITCH EDGES AND MAKE SOUND
	LDD SWNEW		;PUT LAST TIMES NEW INTO THIS TIMES OLD
	STD SWOLD
	LDA R.BYT0		;READ IN SWITCHES IN QUESTION
	ANDA #0CF
	LDB R.BYT1
	ANDB #03A
	STD SWNEW		;SAVE AS NEW
	EORA SWOLD		;CATCH OFF TO ON EDGES
	ANDA SWOLD
	EORB SWOLD+1
	ANDB SWOLD+1
	CMPD #0000
	IFNE			;CAUGHT AN EDGE, MAKE A SOUND
	LDA #IDAYEA
	STA W.XMTS
	ENDIF
				;---
				;OPTION SWITCHES
	LDD #1FFF&-350.		;POSITION FOR OPTION SWITCH DISPLAY
	STD (Y)++
	LDD #1FFF&-140.
	STD (Y)++
	LDA #10			;SHOW OPTION SWITCH BANK LOCATION ( 10D )
	JSR VWBYTE
	LDD VGMSGA+28.
	STD (Y)++
	LDD VGMSGA
	STD (Y)++
	LDA R.BYT2		;1ST BANK OF OPTION SWITCHES
	JSR SWDISP		;SHOW 'EM
				;---
	LDD #1FFF&-400.
	STD (Y)++
	LDD #1FFF&-164.
	STD (Y)++
	LDA #10			;SHOW OPTION SWITCH BANK LOCATION ( 10EF )
	JSR VWBYTE 
	LDD VGMSGA+30.
	STD (Y)++
	LDD VGMSGA+32.
	STD (Y)++
	LDD VGMSGA
	STD (Y)++
	LDA R.BYT3		;2ND BANK OF OPTION SWITCHES
	JSR SWDISP		;SHOW 'EM
				;---
				;POT TEST
	LDB #MS.POT		;"POT TEST"
	JSR DOMESS
	LDD #VJPOTP		;SHOW PATTERN AROUND POT TEST LINE
	STD (Y)++
	LDD #0000.&1FFF		;POSITION TO THE RIGHT
	STD (Y)++
	LDD #0256.+64.&1FFF
	STD (Y)++
	LDB R.CHN		;READ Y POT
	SUBB #80		;MAKE READING RELATIVE TO CENTER
	SEX
	TFR D,U			;COMPENSATE FOR 1.5/1 ASPECT RATIO
	ASRD			;1/2
	LEAU D(U)		;GENERATED 1.5 FOR THE Y POT
	TFR U,D			;GET IT BACK
	ANDA #1F
	STD (Y)++
	STA W.CHN1		;START X POT
	STA W.CHN1		;MAKE SURE IT STARTS CORRECTLY
	LDX #20.
	BEGIN			;DELAY AT LEAST 100 us
	LEAX -1(X)
	EQEND
	LDB R.CHN
	SUBB #80
	SEX
	ANDA #1F
	ORA #0E0		;TURN THIS LINE ON
	STD (Y)++
	LDD #VGCNTR
	STD (Y)++
				;---
	LDU #TSTAT3		;DESTROYED U, SET BACK TO SWITCH TEST STATE
	JMP GETBAK		;GO BACK TO MAIN TEST LOOP
				;---

SWDISP:				;DISPLAY 8 SWITCHES IN  "0" OR "1" FORM
	LDB #07			;COUNT
	BEGIN
	LSRA			;SHIFT SWITCH INTO CARRY
	IFCS			;NOT ON
	LDX VGMSGA+32.		;"F" FOR OFF
	ELSE			;WAS ON
	LDX VGMSGA+48.		;"N" FOR ON
	ENDIF
	STX (Y)++
	DECB
	MIEND
	LDD #VGCNTR
	STD (Y)++
	RTS
				;===
	.PAGE
	.SBTTL	SCREEN TEST PATTERNS
SCHKR:
	LDD #VJCHKR		;CHECKER PATTERN
	STD (Y)++
	JMP GETBAK

SHATCH:
	LDD #VJHTCH		;CROSS HATCH PATTERN
	STD (Y)++
	JMP GETBAK

SINTEN:
	LDD #VJINTN		;COLOR BAR PATTERN
	STD (Y)++
	LDB #MS.INT		;OUTPUT THE INTENSITY TEST MESSAGES
	BEGIN
	STB TTEMP2
	JSR DOMESS
	LDB TTEMP2
	INCB
	CMPB #MS.INT+5
	HSEND
	JMP GETBAK

SBIP:	LDD #VJBIP		;BIP PATTERN
	STD (Y)++
	LDD #VJBIP2		;BOX WITHOUT CENTERS
	STD (Y)++
	STD (Y)++
	STD (Y)++
	STD (Y)++
	LDD #VGCNTR
	STD (Y)++
	LDB #MS.BIP		;"BIP TEST"
	JSR DOMESS
	LDB #MS.BIP+1		;"ALIGN THE BOXES"
	JSR DOMESS
	JMP GETBAK

SSCAL:	LDA DBNC2		;CHECK FOR TRIGGER SWITCH
	CMPA #01
	IFLS
	LDD #0000		;RESET TO LARGEST LINEAR SCALE TEST
	STD SCALE
	STA SCLTYP
	ENDIF
				;---
	LDD #VGCOLR&0F000	;NO COLOR FOR THE BOX
	STD (Y)++
	LDD #VJBOX		;DRAW A BOX
	STD (Y)++
	LDD #VGCNTR
	STD (Y)++
				;---
	LDD SCALE		;UPDATE SCALE
	ADDD #0001
	TST SCLTYP		;WHICH TEST ARE WE DOING?
	IFEQ			;LINEAR SCALE TEST
	CMPB #0FC		;DONE YET?
	IFHS			;YEP, ALL DONE
	LDA #01
	STA SCLTYP		;NON-ZERO MEANS GO TO COMBINED SCALE TEST
	LDD #0000		;START FROM 0000
	ENDIF
	STD SCALE
				;---
	ELSE			;COMBINATION SCALE TEST
	CMPB #0B0		;CAUSE A DELAY
	IFHS			;DELAY WHILE LINEAR IS 80 TO 0B0
	CLRB
	INCA
	ENDIF
	CMPA #08		;BINARY SCALE WRAP?
	IFHS			;YES
	CLR SCLTYP		;THEN START LINEAR SCALE TEST AGAIN
	LDD #0000
	ENDIF
	STD SCALE
	CMPB #7F		;IF LINEAR SCALE IS GREATER THAN 7F MAKE IT 7F
	IFHS			;THIS HOLDS THE SIZE OF THE SQUARE WHILE DELAYING
	LDB #7F
	ENDIF
	ENDIF
	ORA #VGSCAL&0F000/100	;MAKE THIS A SCALE INSTRUCTION
	STD (Y)++
	LDD #VGCOLR+<VGCGRN*100>;GIVE IT SOME COLOR
	STD (Y)++
	LDD #VJSQR		;USE SQAURE FOR SCALE TEST
	STD (Y)++
	LDD #VGSCAL
	STD (Y)++
	LDB SCLTYP
	IFEQ			;LINEAR SCALE TEST
	LDB #MS.SCL+1		;"LINEAR"
	ELSE
	LDB #MS.SCL+2		;"LINEAR AND BINARY"
	ENDIF
	JSR DOMESS
	LDB #MS.SCL		;"SCALE TEST"
	JSR DOMESS
	JMP GETBAK

SRASTR:	LDD #VJRSTR		;START OF PATTERN
	STD (Y)++
	LDX #38			;# OF LINES
	LDD #VJRST2		;EACH LINE
	BEGIN
	STD (Y)++
	LEAX -1(X)
	EQEND
	LDD #VGCNTR		;CENTER
	STD (Y)++
	JMP GETBAK

	.PAGE
	.SBTTL	MATHBOX TEST --- DIVIDER

SDIV:
	LDD #VJBONDRY		;PUT THE BOX OUT THERE
	STD (Y)++
	LDD #VGCNTR
	STD (Y)++
	LDD #VGSCAL
	STD (Y)++
	LDS #STACK		;SETUP THE STACK
	LDB #MS.MBT		;"MATHBOX TESTS"
	JSR DOMESS
				;---
	LDA #5D			;DO A QUICKIE TEST FOR THE MATHBOX READY LINE
	STA M.PCGO
	TST M.BUSY		;IF READY ALREADY, ITS AN ERROR
	BPL 10$			;ERROR
	TST M.BUSY		;IF READY NOW, GOOD.  ELSE ERROR
	BPL 20$
10$:
	LDB #MS.MBN		;"BAD MATHBOX READY LINE"   (MATH BOX NO)
	JSR DOMESS
	LDU #TSTAT1		;STAY IN THIS TEST
	JMP GETBAK		;GO BACK TO THE MAINLINE
20$:
				;---
			;CONTINUE WITH MATHBOX TESTS
	LDD #VGCOLR+<VGCGRN*100>;SHOW ERRORS IN GREEN
	STD (Y)++
	CLR TTEMP		;CLEAR ERROR FLAG
	LDX #TDIV		;BEGINNING OF TABLE
	BEGIN
	LDS #SDIVRT		;SET RETURN ADDRESS
	JMP DIVTST		;GO DO CURRENT DIVIDER TEST INDICATED BY X
SDIVRT:				;RETURN FROM DIVIDER TEST
				;COMPARE TO CORRECT ANSWER WAS LAST THING DONE
	IFNE			;ERROR--THEN DISPLAY ERROR
	STD ERRORS		;ANSWER FROM DIVIDER
	INC TTEMP		;FLAG AN ERROR  ( WON'T WRAP )
				;SHOW OPTION SWITCH SETTING FOR DIAGNOSTIC
	LDS #STACK		;SET STACK
	LDD 6(X)		;Y POSITION ON SCREEN
	STD (Y)++
	LDD #1FFF&-360.		;X POS
	STD (Y)++
	LDD VGMSGA+48.		;"NNNN" FOR ON INDICATES DIVIDER TEST
	STD (Y)++
	STD (Y)++
	STD (Y)++
	STD (Y)++
	LDD VGMSGA		;" "
	STD (Y)++
	TFR X,D			;WHICH TEST OF 16.
	SUBD #TDIV
	ASLB			;DISPLAY D6-D3
	LDA #03
	BEGIN
	ASLB
	IFCC
	LDU VGMSGA+32.		;"F" FOR OFF
	ELSE
	LDU VGMSGA+48.		;"N" FOR ON
	ENDIF
	STU (Y)++
	DECA
	MIEND
	LDD VGMSGA		;COUPLE OF SPACES
	STD (Y)++
	STD (Y)++
	LDA 0(X)		;NUMERATOR
	JSR VWBYTE
	LDA 1(X)
	JSR VWBYTE
	LDD VGMSGA
	STD (Y)++
	LDA 2(X)		;DENOMINATOR
	JSR VWBYTE
	LDA 3(X)
	JSR VWBYTE
	LDD VGMSGA
	STD (Y)++
	LDA 4(X)		;CORRECT ANSWER
	JSR VWBYTE
	LDA 5(X)
	JSR VWBYTE
	LDD VGMSGA
	STD (Y)++
	LDA ERRORS		;INCORRECT ANSWER
	JSR VWBYTE
	LDA ERRORS+1
	JSR VWBYTE
				;---
	LDD #VGCNTR
	STD (Y)++
	ENDIF
	LEAX 8(X)
	CMPX #TDIVZ
	HSEND
	LDS #STACK		;SET STACK FOR MESSAGES
	TST TTEMP		;ERRORS?
	IFEQ			;NO
	LDB #MS.DIV+1		;"NO DIVIDER ERRORS"
	ELSE
	LDB #MS.DIV		;"DIVIDER ERRORS"
	JSR DOMESS
	LDB #MS.DIV+2		; DIVIDER ERROR HEADING
	ENDIF
	JSR DOMESS
				;===
	.PAGE
	.SBTTL	MATHBOX TEST --- MATRIX
SMUL:
	LDX #TMULT
	CLR TTEMP		;CLEAR ERROR FLAG
	LDD #VGCOLR+<VGCRED*100>;SHOW MATRIX ERRORS IN RED
	STD (Y)++
	BEGIN
	TFR X,D			;GET TEST #
	SUBD #TMULT1		;MINUS TABLE OFFSET
	LSRB			;/2 ==> 0,2,4,6 FOR MTST12
	LDS #SMULRT
	JMP @0(X)
				;COMPARE TO CORRECT ANSWER WAS LAST THING DONE
SMULRT:
	IFNE			;ERROR--THEN DISPLAY ERROR
	STD ERRORS		;ANSWER FROM DIVIDER
	INC TTEMP		;FLAG AN ERROR
	CMPX #TMULT2		;SOME TESTS DON'T HAVE DIAGNOSTICS
	IFLO			;THESE DO
				;SHOW OPTION SWITCH SETTING FOR DIAGNOSTIC
	LDD 2(X)		;Y POSITION ON SCREEN
	STD (Y)++
	LDD #1FFF&-350.		;X POS
	STD (Y)++
	LDD VGMSGA+48.		;"NNNF" FOR ON INDICATES MULTIPLIER RATHER THAN DIVIDER TEST
	STD (Y)++
	STD (Y)++
	STD (Y)++
	LDD VGMSGA+32.		;"F"
	STD (Y)++
	LDD VGMSGA		;" "
	STD (Y)++
	TFR X,D			;WHICH TEST OF 6
	SUBD #TMULT
	ASLB			;DISPLAY D5-D2
	ASLB
	ADDB #50		;THESE TESTS START WITH DIAG 5
	LDA #03
	BEGIN
	ASLB
	IFCC
	LDU VGMSGA+32.		;"F" FOR OFF
	ELSE
	LDU VGMSGA+48.		;"N" FOR ON
	ENDIF
	STU (Y)++
	DECA
	MIEND
	ELSE			;NON DIAGNOSTIC TESTS GIVE CODE LETTERS
	LDD 2(X)
	STD (Y)++
	LDD #150.
	STD (Y)++
	TFR X,D
	SUBD #TMULT2
	LSRB
	LDS #VGMSGA+22.
	LDD B(S)
	STD (Y)++
	ENDIF
	LDD VGMSGA
	STD (Y)++
	LDS #STACK		;SET STACK
	LDA ERRORS		;DIPLAY ERRONEOUS DATA
	JSR VWBYTE
	LDA ERRORS+1
	JSR VWBYTE
	LDD #VGCNTR
	STD (Y)++
	ENDIF
	LEAX 4(X)
	CMPX #TMULTZ
	HSEND
	LDS #STACK		;SET THE STACK FOR THE MESSAGE ROUTINE
	TST TTEMP		;ERRORS?
	IFEQ			;NO
	LDB #MS.MTX+1		;"NO MATRIX ERRORS"
	ELSE
	LDB #MS.MTX		;"MATRIX ERRORS"
	ENDIF
	JSR DOMESS
	LDU #TSTAT1		;RESET U FOR MATHBOX TESTS
	JMP GETBAK
				;===
TMULT:
	.WORD	MTST6,1FFF&-150.
	.WORD	MTST7,1FFF&-200.
TMULT1:
	.WORD	MTST12,1FFF&-250.
	.WORD	MTST12,1FFF&-300.
	.WORD	MTST12,1FFF&-350.
	.WORD	MTST12,1FFF&-400.
TMULT2:	.WORD	MULT9,1FFF&-150.
	.WORD	MTST10,1FFF&-200.
	.WORD	MTST11,1FFF&-250.
	.WORD	MTST8,1FFF&-300.
TMULTZ:
				;===
MULT9:
	LDS #MT9RT1
	JMP MTST9		;CLEARS ACCUMULATOR AND STARTS ACCUMULATING
MT9RT1:
	CMPD #0001
	IFNE
	JMP SMULRT
	ENDIF
	LDU #0002
	BEGIN
	LDS #MT9RT2
	JMP MTST92		;ADD ACCUMULATOR TO ITSELF
MT9RT2:
	CMPD BITS(U)
	IFNE
	JMP SMULRT
	ENDIF
	LEAU 2(U)
	CMPU #0020
	HSEND
	JMP SMULRT
				;===

	.PAGE
	.SBTTL	DIVIDER TESTS
;
; PROGRAMMER: JED MARGOLIN MODIFIED BY NORM AVELLAR
;
; DATE 12/10/82		5/18/83
;	2/21/83
;	3/14/83
;	4/4/83
;
; HARDWARE: STAR WARS,REV A
;
; The STAR WARS Divider is an unsigned 15 bit fractional divider which assumes
; that the dividend (the numerator) is less than twice the Divisor (the
; denominator).
;
; The hardware consists of a Dividend Latch, a Dividend Shift Register, an 
; inverting Divisor Latch, an Adder, a Difference Latch, a Quotient Shift
; Register with tri-state Buffer, and a Control Unit which includes the
; Divide Cycle Counter.
;
; The Dividend Latch is written into by the 6809 and has two parts: Dividend
; Latch High Byte (DVDDH) and Dividend Latch Low Byte (DVDDL) The Dividend 
; Latch is not altered by the operation of the divider so it may be left at 
; its previous value if desired.
; 
; The Divisor Latch is also written into by the 6809 and has two parts:
; Divisor High Byte (DVSRH) and Divisor Low Byte (DVSRL). DVSRH loads 
; the Divisor High Byte, clears the Quotient Shift Register, and loads the 
; Dividend Shift Register from the Dividend Latch. DVSRL loads the Divisor Low 
; Byte and starts the Divider.
;
; Divider Operation: Subtract the Divisor from the Dividend in the Dividend 
; Shift Register and put the result in the Difference Latch. 

;	If the result of this subtraction is positive, the Carry (C16*) will 
;	be a '1'. Shift a '1' into the Quotient Shift Register and store the 
;	value from the Difference Latch into the Dividend Shift Register. 
;	(In a conventional divider algorithm the dividend shift register would
;	then be shifted	left, but here the output of the Adder is wired 
;	to the	Difference Latch already shifted over by one)
;
;	If the result of the subtraction is negative, the Carry (C16*) will
;	be a '0'. Shift a '0' into the Quotient Shift Register and shift the
;	Dividend Shift Register left once. The value in the Difference Latch
;	is otherwise ignored.
;
; Do it 15 times. With a 3 Mhz clock it will take 5.0 uS.
;
; The Quotient Shift Register is read by the 6809 as QUOH and QUOL.
;	  
; 
;
DIVTST:			;DIVIDER TESTS
	LDD 0(X)	;GET NUMERATOR
	STD M.DVN
	LDD 2(X)	;GET DENOMINATOR
	STD M.DVD	;STORE DENOMINATOR AND START DIVIDER
	MUL		;CONVENIENT WAY TO WAIT
	LDD M.QUO		;GET ANSWER
	CMPD 4(X)	;IS IT RIGHT?
	JMP 0(S)	;RETURN VIA PREVIOUSLY SET POINTER

TDIV:			;TABLE OF VALUES FOR DIVIDER TESTS
			;NUMERATOR,DENOMINATOR,QUOTIENT,Y POS ON SCREEN
	.WORD	4000,4000,4000,0200.
	.WORD	5555,4000,5555,0150.
	.WORD	2AAA,4000,2AAA,0100.
	.WORD	2AAA,2AAA,4000,0050.
	.WORD	5555,5555,4000,0000.
TDIVZ:

	.PAGE
	.SBTTL	MULTIPLIER TEST

MULRET:
	JMP 0(S)	;RETURN VIA PREVIOUSLY SET POINTER


;TEST 1 LOOP - LDA ZERO,HALT
MTST1:
	LDD #5555
	STD M.ZRO
	LDA #57
	STA M.PCGO
	BRA MULRET
;
;TEST 2 LOOP - LDB ZERO,HALT
MTST2:
	LDD #0AAAA
	STD M.ZRO
	LDA #58
	STA M.PCGO
	BRA MULRET
;
;TEST 3 LOOP - LDC ZERO,MAC,HALT
MTST3:
	LDD #5555
	STD M.ZRO
	LDA #59
	STA M.PCGO
	BRA MULRET
;
;TEST 4 LOOP - CLA,HALT
MTST4:
	LDA #5A
	STA M.PCGO
	BRA MULRET
;
;TEST 5 LOOP - IBC,HALT
MTST5:
	LDA #5B
	STA M.PCGO
	BRA MULRET
;
;TEST 6 LOOP - LAC XP
;	       SAC YP,HALT
MTST6:
	LDD #5555
	STD M.XP
	LDA #5C
	STA M.PCGO
	NOP
	LDD M.YP	;FOR ANALYZER TRIGGERING
	CMPD #5555
	BRA MULRET
;
;TEST 7 LOOP - LAC XP
;              SAC YP,HALT
MTST7:
	LDD #0AAAA
	STD M.XP
	LDA #5C
	STA M.PCGO
	NOP
	LDD M.YP	;FOR ANALYZER TRIGGERING
	CMPD #0AAAA
	BRA MULRET
;
;
;TEST 8 LOOP TESTS SUBTRACT
;		LDA XT,CLA
;		LDB YT
;		LDC ZT,MAC
;		SAC XP,HALT
;
MTST8:
	LDD #2696
	STD M.XT
	LDD #1B2C
	STD M.YT
	LDD #4000
	STD M.ZT
	LDA #5D
	STA M.PCGO
	MUL
	LDD M.XP
	CMPD #0B6A
	JMP MULRET
;
;TEST 9 TESTS ACCUMULATOR
;		LDA XT
;		LDB YT
;		LDC ZT,MAC
;		SAC XP,HALT
;
MTST9:
	LDA #5A		;FIRST CLEAR ACCUMULATOR
	STA M.PCGO
	LDD #0000
	STD M.YT
	LDD #4000
	STD M.ZT
	LDD #0001	;EVERY TIME THIS PART IS RUN 
	STD M.XT	;THE PRODUCT SHOULD ACCUMULATE
MTST92:
	STD M.XT	;ADD RESULT BACK TO ACCUMULATOR
	LDA #5E
	STA M.PCGO
	MUL
	LDD M.XP	;PUT RESULT IN D
	JMP MULRET
;
;TEST 10 - TEST BLOCK INDEX COUNTER
;		LDA X,IND,CLA
;		LDB ZERO
;		LDC ONE,MAC
;		SAC XP,HALT
;
MTST10:
	LDU #MBRAM+28	;SETUP THE MATH RAM
	LDD #0005	;START AT BIC #4
	BEGIN		;PUT THE BIC NUMBER IN THE FIRST WORD OF EACH BIC
	STD (U)
	ADDD #0001
	LEAU 8(U)
	CMPU #MBRAMZ
	HSEND
			;---
	LDD #0000
	STD M.ZRO
	LDD #4000
	STD M.ONE
	LDD #0004
	STD M.BIC
	LDU #0008	;START AT 8TH BIC
	BEGIN
			;---
	STA WTCHDG
			;---
	TFR U,D		;INCREMENT THE BIC
	LSRD		;ADD HALF THE CURRENT VALUE OF U
	BEGIN
	LDA #05B	;INC BIC
	STA M.PCGO
	DECB
	EQEND
			;---
	LDA #5F		;GO GET THE DATA
	STA M.PCGO
	MUL
	CMPU M.XP	;SHOULD BE THE SAME
	IFNE		;ERROR
	JMP MULRET
	ENDIF		;ELSE GO ON
	TFR U,D		;ADD U TO ITSELF
	LEAU D(U)
	CMPU #0200
	HSEND
	LDD #0000	;NO ERRORS
	JMP MULRET
;
;TEST 11 QUICK ACCUMULATOR TEST
;
MTST11:
	LDD #1B2C
	STD M.XT
	LDD #0000
	STD M.YT
	LDD #4000
	STD M.ZT
	LDA #5D		;CLEARS ACCUM. AND PUTS 1B2C IN ACCUM
	STA M.PCGO
	MUL
	LDD #196A
	STD M.XT
	LDD #0000
	STD M.YT
	LDD #4000
	STD M.ZT
	LDA #5E		;ADDS 196A TO ACCUM.
	STA M.PCGO
	MUL
	LDD M.XP
	CMPD #3496
	JMP MULRET
			;---
;
;
;TEST 12 LOOP -- TESTS SUBTRACT
;		LDA XT,CLA
;		LDB YT
;		LDC ZT,MAC
;		SAC XP,HALT
;
MTST12:
				;B MUST BE SET TO 0,2,4 OR 6 BEFORE GETTING HERE
	ASLB
	ASLB
	LDU #TMTRX		;TABLE OF VALUES FOR TEST 12
	LEAU B(U)
	LDD 0(U)
	STD M.XT
	LDD 2(U)
	STD M.YT
	LDD 4(U)
	STD M.ZT
	LDA #5D
	STA M.PCGO
	MUL			;DELAY
	LDD M.XP
	CMPD 6(U)
	JMP MULRET
TMTRX:
	.WORD	5555,0000,4000,5555
	.WORD	0000,5555,0C000,5555
	.WORD	2AAA,0000,4000,2AAA
	.WORD	0000,2AAA,0C000,2AAA
			;===

TMUL:			;TABLE OF MULTIPLIER TEST ROUTINES
	.WORD	MTST1
	.WORD	MTST2
	.WORD	MTST3
	.WORD	MTST4
	.WORD	MTST5
	.WORD	MTST6
	.WORD	MTST7
TMUL1:
	.WORD	MTST12
	.WORD	MTST12
	.WORD	MTST12
	.WORD	MTST12
TMULZ:
			;===

	.PAGE
	.SBTTL	DIAGNOSTICS

DLOOP:
DIAGLP:
	LDA TESTSW	;BOTH TEST AND DIAG SWITCHES ON?
	ANDA #TESTBT
	LDB DIAGSW
	ANDB #DIAGBT
	CMPD #0000	;SHOULD BE 0000 IF BOTH ON
	IFNE
	JMP HANG	;WAIT FOR WATCH DOG
	ENDIF		;ELSE DO DIAGNOSTICS
			;---
	STA WTCHDG	;KEEP THE DOG QUIET
			;---
	LDA #0FF	;TURN OFF ALL LEDS
	STA W.LED1
	STA W.LED2
	STA W.LED3
			;---
	LDB R.BYT2
	COMB
	LDU #TDNUM	;TABLE OF DIAG NUM TO BCD CONVERSIONS
	BEGIN		;SEE IF IT CAN BE FOUND
	CMPB (U)+	;IS THIS THE SWITCH CONFIGURATION?
	IFEQ		;YES, THEN SHOW THE TEST NUMBER
	STA VGSTOP	;MAKE SURE VG HAS STOPPED
	LDY #VGRAM	;SET UP POINTER
	LDD #VJBONDRY	;DRAW A BOX
	STD (Y)++
	LDD #VGCNTR
	STD (Y)++
	LDA (U)		;GET BCD FOR DIAG NUMBER
	LDS #STACK
	JSR VWBYTE
	LDD #2020	;PUT A HALT IN AT END OF LIST
	STD (Y)++
	STD (Y)++
	STA VGGO	;START THE VG
	LDU #TDNUMZ	;LEAVE THE LOOP
	ENDIF
	LEAU 1(U)	;NEXT ENTRY
	CMPU #TDNUMZ
	HSEND
			;---
	LDB R.BYT2	;READ OPTION SWITCH TO FIND DIAGNOSTIC TEST #
	COMB		;OFF-->0, ON-->1
	TFR B,A
	ANDB #0F	;TO BE USED BY CERTAIN TESTS INTERNALLY
	ANDA #0F8	;TOP 5 BITS INDICATE TEST TYPE
			;
	CMPA #0C0	;AVG INSTRUCTIONS?
	IFNE		;NO
	CLR SIGFLG	;MAKE SURE SIGNATURE ANALYSIS GETS INITIATED CORRECTLY
	ENDIF
			;
	LDX #TDIAG
	BEGIN		;FIND THE TEST TYPE
	CMPA (X)+
	IFEQ
	JMP @(X)
	ENDIF		;ELSE LOOK AT NEXT ENTRY
	LEAX 2(X)
	CMPX #TDIAGZ	;PAST END OF TABLE?
	HSEND		;IF NOT KEEP LOOKING
	JMP DIAGERR	;ELSE FLASH ALL 3 LEDS TO INDICATE ERROR
			;===

.MACRO	LOOKUP	...A,...B
	.BYTE	...A
	.WORD	...B
	.ENDM

TDIAG:
	LOOKUP	000,D.KERN	;KERNAL TEST
	LOOKUP	080,D.AVGR	;AVG RAM AND ROM TEST
	LOOKUP	0C0,D.AVGI	;AVG INSTRUCTIONS
	LOOKUP	0E0,D.MTRX	;MATRIX PROCESSOR INSTRUCTIONS
	LOOKUP	0E8,D.MTRX	;	   "
	LOOKUP	0F0,D.DVDR	;DIVIDER TESTS
	LOOKUP	0F8,D.SND	;SOUND BOARD COMMUNICATIONS
TDIAGZ:
				;---
TDNUM:				;SWITCH TO TEST NUMBER CONVERSION TABLE
	.BYTE	0E0,10
	.BYTE	0E1,11
	.BYTE	0E2,12
	.BYTE	0E3,13
	.BYTE	0E4,14
	.BYTE	0E5,15
	.BYTE	0E6,16
	.BYTE	0E7,17
	.BYTE	0E8,18
	.BYTE	0E9,19
	.BYTE	0EA,20
	.BYTE	0F0,21
	.BYTE	0F1,22
	.BYTE	0F2,23
	.BYTE	0F3,24
	.BYTE	0F4,25
	.BYTE	0F8,26
TDNUMZ:

				;===

	.PAGE
	.SBTTL	KERNAL TEST

D.KERN:
	TSTB		;SHOULD BE 00
	IFNE		;ERROR
	JMP DIAGERR
	ENDIF		;ELSE, GO ON
			;---
	TFR S,D		;GET TEST RESULTS
	ANDA #40	;ROM 4 OK?
	ANDB #01	;RAM OK?
	CMPD #0000
	IFEQ		;YES, ROM AND RAM OK
	LDU #W.LED1	;THEN FLASH LED 1
	JMP LEDFLSH	;AND RETURN TO DIAGLP
	ENDIF		;ELSE, NOT OK -- NO LED FLASH
	JMP DIAGLP
			;===

	.SBTTL	AVG ROM/RAM TEST

D.AVGR:
	TSTB		;SHOULD BE 00
	IFNE		;ERROR
	JMP DIAGERR
	ENDIF		;ELSE, GO ON
			;---
	TFR S,D
	ANDA #81
	ANDB #0F8
	CMPD #0000
	IFEQ		;AVG RAM AND ROM ARE OK
	LDU #W.LED2	;THEN FLASH LED 2
	JMP LEDFLSH	;AND RETURN TO DIAGLP
	ENDIF		;ELSE, NOT OK -- NO LED FLASH
	JMP DIAGLP
			;===

	.PAGE
	.SBTTL	AVG INSTRUCTION DIAGNOSTICS

D.AVGI:
	CMPB #06	;SIGNATURE ANALYSIS?
	IFEQ		;YEP
	TST SIGFLG	;BEEN THROUGH HERE ALREADY?
	IFEQ		;NOPE, THEN SET UP RAM, AND SET FLAG
	LDX #VGRAM+800	;VGRAM1
	LDA #00
	BEGIN
	STA (X)+
	ADDA #05
	CMPX #VGRAM+1000;FILLED VGRAM1 WITH APPROPRIATE DATA?
	HSEND
	LDA #0FF
	STA SIGFLG	;FLAG SO WON'T DO IT AGAIN
	ENDIF
			;---
	ELSE		;NORMAL AVG INSTRUCTIONS
	CLR SIGFLG
	STA VGSTOP
	LDX #TAVGI
	ASLB		;2-WORD ENTRIES
	ASLB
	ABX
	CMPX #TAVGIZ
	IFHS
	JMP DIAGERR	;FLASH LEDS
	ENDIF		;ELSE DO IT
	LDD 0(X)	;SET UP INSTRUCTIONS FROM THE TABLE
	STD VGRAM+0
	LDD 2(X)
	STD VGRAM+2
	LDD #2020	;MAKE SURE IT STOPS
	STD VGRAM+4
	STA VGGO	;START THE VG
	ENDIF
	JMP DIAGLP	;GO BACK TO THE DIAGNOSTIC MAIN LOOP
			;---
TAVGI:
	.WORD	2020,2020	;HALT;HALT
	.WORD	0100,0100	;VCTR 100,100
	.WORD	5010,2020	;SVCTR 20,20;HALT
	.WORD	8040,2020	;CNTR;HALT
	.WORD	7240,2020	;SCAL 2,40;HALT
	.WORD	6780,2020	;COLOR WHT,80;HALT
TAVGIZ:
			;===

	.PAGE
	.SBTTL	MATHBOX DIAGS

D.MTRX:			;MATRIX PROCESSOR DIAGS
	LDX #TMUL	;MATRIX MULTIPLIER TEST TABLE
	ASLB
	ABX
	LDY #0000	;SETUP REPEAT COUNT
30$:			;REPEATER RETURN POINT ( FOR FASTER TESTS )
			;
	CMPX #TMULZ	;PAST END OF TABLE?
	IFHS		;YES
	JMP DIAGERR	;THEN INDICATE AN ERROR
	ENDIF		;ELSE DO TEST
			;
	STA WTCHDG	;DOING MULTIPLE TESTS, SO KEEP THE DOG QUIET
	LEAY 1(Y)	;INC REPEAT COUNT
	CMPY #0200
	IFHS		;CHECK FOR NEW TEST, RESTART VG, ETC.
	LDS #DLOOP	;RETURN TO THE DIAGNOSTIC MAIN LOOP DELAY
	ELSE		;JUST KEEP DOING OLD TEST
	LDS #30$	;RETURN TO ABOVE
	ENDIF
	TFR X,D		;SETUP FOR MTST12
	SUBD #TMUL1	;GIVES 0,2,4 OR 6
	JMP @0(X)	;DO IT AND RETURN VIA S
			;===

D.DVDR:			;DIVIDER DIAGS
	LDX #TDIV	;DIVIDER TEST TABLE
	ASLB		;8 BYTES PER ENTRY
	ASLB
	ASLB
	ABX
			;
	LDY #0000	;SETUP REPEAT COUNT
30$:			;REPEATER RETURN POINT ( FOR FASTER TESTS )
	CMPX #TDIVZ	;PAST END OF TABLE?
	IFHS		;YES
	JMP DIAGERR	;THEN INDICATE AN ERROR
	ENDIF		;ELSE
			;
	STA WTCHDG	;DOING MULTIPLE TESTS, SO KEEP THE DOG QUIET
	LEAY 1(Y)	;INC REPEAT COUNT
	CMPY #0200
	IFHS		;CHECK FOR NEW TEST, RESTART VG, ETC.
	LDS #DLOOP	;RETURN TO THE DIAGNOSTIC MAIN LOOP DELAY
	ELSE		;JUST KEEP DOING OLD TEST
	LDS #30$	;RETURN TO ABOVE
	ENDIF
	JMP DIVTST	;GO DO IT AND RETURN VIA S
			;===

	.PAGE
	.SBTTL	SOUND BOARD COMMUNICATIONS

D.SND:
	ANDB #07
	IFNE
	JMP DIAGERR
	ENDIF		;ELSE GO ON
			;---
	LDA #01		;STARTING PATTERN
	BEGIN
			;
	STB W.RSTS	;RESET THE SOUND BOARD (INITIATE PORT TEST)
			;
	TFR X,U		;SHORT PAUSE
			;---
	LDB R.RCVS	;READ PORT FROM SOUND BOARD, SHOULD CLEAR RECIEVED FLAG
	LDB R.STAS	;CHECK RECEIVE STATUS, SHOULD BE LOW SINCE I JUST READ IT
	ANDB #40	
	BNE WAIT1	;WASN'T CORRECT POLARITY
			;---
			;CHECK TO SEE IF XMIT READY
	LDB #80		;ALLOW A DELAY
	BEGIN
	DECB
	BMI WAIT1	;DELAYED TOO LONG, WAIT A WHILE AND TRY AGAIN
	STA WTCHDG	;KEEP THE POOCH QUIET
	TST R.STAS	;CHECK XMIT STATUS
	PLEND		;XMIT IS NOW READY
			;
	STA W.XMTS	;GIVE THE SOUND BOARD THE DATA PATTERN
			;
	LDB R.STAS	;CHECK XMIT STATUS, SHOULD BE HI SINCE I JUST SENT DATA
	BPL WAIT1	;WRONG, DELAY AND TRY AGAIN LATER
			;---
			;WAIT FOR SOUND BOARD TO TALK TO US
	LDX #0100	;ALLOW A DELAY
	BEGIN
	LEAX -1(X)
	BEQ WAIT1	;DELAYED TOO LONG, TRY AGAIN LATER
	STA WTCHDG
	LDB R.STAS	;GET STATUS
	ANDB #40	;HI IF SOUND BOARD TALKED TO US
	NEEND		;IT SPOKE!
			;---
			;THE XMIT LINE SHOULD BE READY AGAIN SINCE IT READ BEFORE IT SPOKE
	TST R.STAS	;
	BMI WAIT1	;WRONG!  DELAY AND TRY AGAIN
			;---
	CMPA R.RCVS	;COMPARE DATA RCVD FROM SOUND BOARD TO DATA XMITD
	BNE WAIT1	;ERROR, GO AWAY AGAIN
			;---
			;CHECK RECEIVE STATUS AGAIN
	LDB R.STAS
	ANDB #40
	BMI WAIT1	;WRONGO
			;---
	ASLA		;NEW PATTERN
	CSEND		;WHEN BIT SHIFTS TO CARRY, ALL DONE
			;---
	LDU #W.LED3	;ELSE ALL OK, FLASH LED #3
	JMP LEDFLSH
			;===

	.PAGE
	.SBTTL	DIAGNOSTIC LED FLASHERS

LEDFLSH:		;FLASH LED POINTED AT BY U
	LDA #00		;TURN LED ON
	STA (U)
WAIT1:			;THIS ENTRY POINT WAITS 1 SECOND
	LDX #0000	;WAIT ABOUT HALF A SECOND
	BEGIN
	STA WTCHDG
	LEAX 1(X)
	CMPX #0AC55
	HSEND
			;---
	LDA #0FF	;TURN LED OFF
	STA (U)
	LDX #0000	;WAIT ANOTHER HALF A SECOND
	BEGIN
	STA WTCHDG
	LEAX 1(X)
	CMPX #0AC55
	HSEND
	JMP DIAGLP	;GO BACK TO BEGINNING OF DIAGNOSTICS
			;===

DIAGERR:		;DIAGNOSTIC ERROR INDICATOR--FLASH ALL LEDS
	LDA #00		;TURN ALL LEDS ON
	STA W.LED1
	STA W.LED2
	STA W.LED3
	LDX #0000	;WAIT ABOUT 1/4 SECOND
	BEGIN
	STA WTCHDG
	LEAX 1(X)
	CMPX #5600
	HSEND
			;---
	LDA #0FF	;TURN ALL LEDS OFF
	STA W.LED1
	STA W.LED2
	STA W.LED3
	LDX #0000	;WAITR ANOTHER 1/4 SECOND
	BEGIN
	STA WTCHDG
	LEAX 1(X)
	CMPX #5600
	HSEND
	JMP DIAGLP	;GO BACK TO DIAGNOSTIC LOOP
			;===	

	.ENDC		;END OF NON-DEVSYS

	HLL69F

	.END

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                