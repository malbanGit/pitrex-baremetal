	.TITLE	TCEROM

	.INCLUDE WSCOMN ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
;INTERNAL ROUTINES
	.GLOBL	EEACC,EEACCU,EEACCT,EECKSM,EEINIT,EEOPT,EEOPT1,EEOPT3,EEUTIM,CHKEE,EEINI0
	.GLOBL	EETEMP,EETMP2,EETMP3,SUMMIT,TEMPEE,TMPEE2,TMPEE3
;EXTERNAL ROUTINES
	.GLOBL	VWBYTE,VWNIBL,MESSON,DOMESS,DOMES2,SETINT,BINBCD,WAITFRAME
;EXTERNAL GLOBAL OFFSETS

				;RHEOSTAT
				;*** IRQ/MAINLINE INTERACTIONS !!!!
RH$LO	==0			;LO VALUE-MINIMUM
RH$LT	==1			;LO VALUE ON TRIAL
RH$SP	==2			;SPREAD MULTIPLIER
RH$ST	==3			;SPREAD CHANGE TIMER

RH$NML	==4			;NORMALZIED POT VALUE
RH$POS	==5			;SITE POSITION
RH$RAT	==7			;RATE OF TURN
RH$RSD	==8			;MAGIC  TIC RESIDUE
RH$IZ	==9			;SIZE OF BLOCK

;EXTERNAL LOCATIONS
	.GLOBL	EEROM,EEROMZ,EEBUF,NVRRCL,NSTORE
	.GLOBL	DUPOPT,EECK0
	.GLOBL	SAVSCR,SAVINT,EECK1
	.GLOBL	POTSAV,AMECH,LMECH,RMECH,GAMES,TIMEON,TTIME
	.GLOBL	HISTOG,ZHISTOG,ENDGAM,EECK2
	.GLOBL	OPTS0,EECK3,RESETS
	.GLOBL	BCD
	.GLOBL	GM.DWAV
	.GLOBL	INTINT,INTSCR
	.GLOBL	ITEMP
	.GLOBL	NVTSTR,NVADDR
	.GLOBL	RHEOP,RHEOY
	.GLOBL	SI.RSY
	.GLOBL	TIMER
	.GLOBL	VGCNTR,VGMSGA,VJCOLN,VGCOLR,VGCGRN,VGCRED
	.GLOBL	WTCHDG

	.GLOBB	BT.SUP,FRAME,R.OPT1,R.OPT2
	.GLOBB	MS.ACC,MS.XIT,MS.TST,MS.RES
	.GLOBB	MS.OPT,MS.VLC,MS.LMV,MS.RMV,MS.BAV,MS.SLV,MS.DIF,MS.RHS
	.GLOBB	MS.RAC,MS.ROP,MS.BSV,MS.MUV,MS.TER,MS.GNV,MS.BNV
	.GLOBL	NAREA,TEMP,TEMP2,TMPCNT,EEVAL,EEINDX,EECOIN,$CCTIM,GTIME
	.GLOBB	GN.SWE,LFIRBT,RFIRBT

	.CSECT	TCEROM
;	***************************************
DEVSYS	==0	;10101010101 IF DEVSYS IS 1, WILL GET BRKS AT STRATEGIC POINTS

RESONLY	==0	;IF RESONLY IS 1, ONLY ALLOW CHANGES TO RESET OPTIONS IN OPTION MODE
;	***************************************
	.PAGE
	.SBTTL	DISPLAY ACCOUNTING INFO
	.REPT 0
**********************************
*
*	EEACC
*
**********************************

DESCRIPTION:	DISPLAYS THE ACCOUNTING INFO FROM THE EEROM

IN:		

OUT:		

USE:	EEROM,TEMP(8),TEMP2(8)

	.ENDR

EEACC:
	LDA #MS.ACC
	BEGIN
	JSR MESSON
	INCA
	CMPA #MS.OPT
	HSEND
	LDA #MS.XIT		;EXIT MESSAGE
	JSR MESSON
				;---
	LDD #VGCOLR+<VGCRED*100>;SETUP COLOR FOR DATA MESSAGES
	STD (Y)++
	LDX #AMECH		;START WITH AUX COIN DATA
	LDU #T.ACCP		;TABLE OF POSITIONS
	BEGIN
	LDD (U)++		;SET POSITION
	STD (Y)++
	LDD #1FFF&048.
	STD (Y)++
	STU TEMP		;SAVE U--- VWNIBL ALTERS U
	LDB #5
	STB BT.SUP
	LDB #05			;VIEW 6 NIBBLES
	BEGIN
	LDA (X)+
	JSR VWNIBL
	DECB
	MIEND
	LDD #VGCNTR
	STD (Y)++
	LDU TEMP		;GET POINTER TO POS TABLE BACK
	CMPX #TTIME
	HSEND
				;---
				;DISPLAY HIGHEST LEVEL ATTAINED
	LDD T.ACCP+6.
	STD (Y)++
	LDD #1FFF&316.
	STD (Y)++
	LDA #01
	STA BT.SUP		;SUPRESS 1 DIGIT
	LDA ENDGAM		;BCD VALUE OF HIGHEST WAVE ATTAINED ( HI NIBL )
	JSR VWNIBL
	LDA ENDGAM+1		;LO NIBL
	JSR VWNIBL
	LDD #VGCNTR
	STD (Y)++
				;---
				;GET TOTAL COINS PAID
	LDX #RMECH		;GET RIGHT MECH DATA INTO TEMP
	JSR EETEMP
	LDU #TEMP2		;GET LEFT MECH DATA INTO TEMP2
	LDX #LMECH
	JSR EETMP2
	LDA TEMP+2		;3 BYTE ADD, RESULT IN TEMP
	ADDA TEMP2+2
	DAA
	STA TEMP+2
	LDA TEMP+1
	ADCA TEMP2+1
	DAA
	STA TEMP+1
	LDA TEMP		;NOW THE MSB
	ADCA TEMP2
	DAA
	STA TEMP
				;DISPLAY TOTAL COINS
	LDD T.ACCP+8		;POSITION
	STD (Y)++
	LDD #1FFF&048.
	STD (Y)++
	LDB #5
	STB BT.SUP
	LDA TEMP		;DATA
	JSR VWBYTE
	LDA TEMP+1
	JSR VWBYTE
	LDA TEMP+2
	JSR VWBYTE
	LDD #VGCNTR		;CENTER
	STD (Y)++
				;---
	LDX #TTIME		;DISPLAY TOTAL GAME TIME
	JSR EETEMP		;MOVE IT TO TEMP
	JSR TMPMUL		;GOT TO MULTIPLY BY 4 FOR SECONDS
	LDD T.ACCP+14.		;POSITION IT
	STD (Y)++
	LDD #1FFF&048.
	STD (Y)++
	LDB #7
	STB BT.SUP
	LDA TEMP
	JSR VWBYTE
	LDA TEMP+1
	JSR VWBYTE
	LDA TEMP+2
	JSR VWBYTE
	LDA TEMP+3
	JSR VWBYTE
	LDD #VGCNTR
	STD (Y)++
				;---
	LDX #TIMEON		;DISPLAY TOTAL TIME ON
	JSR EETEMP		;MOVE IT TO TEMP
	JSR TMPMUL		;GOT TO MULTIPLY BY 4 FOR SECONDS
	LDD T.ACCP+16.		;POSITION IT
	STD (Y)++
	LDD #1FFF&048.
	STD (Y)++
	LDB #7
	STB BT.SUP
	LDA TEMP
	JSR VWBYTE
	LDA TEMP+1
	JSR VWBYTE
	LDA TEMP+2
	JSR VWBYTE
	LDA TEMP+3
	JSR VWBYTE
	LDD #VGCNTR
	STD (Y)++
				;---
				;CALCULATE AND SHOW AVERAGE GAME TIME
	LDX #GAMES-2		;MOVE NUMBER OF GAMES PLAYED TO TEMP+1
	JSR EETEMP
	CLR TEMP		;LEADING 0
	LDA TEMP+1		;NUMBER OF GAMES = 00?
	ORA TEMP+2
	ORA TEMP+3
	IFNE			;NO, THEN I GUESS I WON'T DIVIDE BY 0
	LDX #TTIME		;GET TOTAL GAME TIME TO TEMP2
	LDU #TEMP2
	JSR EETMP2

	JSR DIVIDE		;TEMP2/TEMP RESULT IN TEMP ( GAME TIME/# OF GAMES)
				;ADJUST ANSWER FOR M:S FORMAT
	LDA TEMP
	ANDA #0F
	CMPA #0F		;E MEANS 56 SECONDS ( 14*4)  F IS 60 SECONDS
	LDA TEMP
	IFHS			;60 SECONDS GETS ADDED IN AS A MINUTE (HI NIBBLE)
	INC TEMP
	ENDIF
	LSRA			;HI NIBBLE REALLY 64 SECONDS NOT 60 SECONDS
	LSRA			;SO ADD 64 SECOND NIBBLE TO 4 SECOND NIBBLE
	LSRA
	LSRA
	ADDA TEMP
	STA TEMP		;ADJUSTED MINUTES+SECONDS/4 IE. M:S
	ANDA #0F
	CMPA #0F
	IFHS			;IF 60 SECONDS ADD 1 TO MINUTES
	INC TEMP		;0F+1=10
	ENDIF
	ENDIF

	LDD T.ACCP+10.		;SHOW IT
	STD (Y)++
	LDD #1FFF&048.
	STD (Y)++
	LDA TEMP
	JSR TIME
	LDD #VGCNTR
	STD (Y)++
				;---
				;CALCULATE AND SHOW PERCENTAGE OF PLAY/TIMEON
	LDX #TIMEON		;GET TOTAL TIME ON TO TEMP
	JSR EETEMP
	LDA TEMP		;NO PLAY TIME?
	ORA TEMP+1
	ORA TEMP+2
	ORA TEMP+3
	IFNE			;WON'T DIVIDE BY ZERO
	LDX #TTIME+2		;GET PLAY TIME ON TO TEMP2 ( 2 LSD IGNORED )
	LDU #TEMP2
	JSR EETMP2
	CLR TEMP2+3		; * 100.

	JSR DIVIDE
	ENDIF

	LDD T.ACCP+12.		;SHOW IT
	STD (Y)++
	LDD #1FFF&048.
	STD (Y)++
	CLRA			;CONVERT FROM HEX
	LDB TEMP
	LDX #10
	JSR BINBCD
	LDB #1
	STB BT.SUP
	LDA BCD+2
	JSR VWBYTE
	LDD #VGCNTR
	STD (Y)++	
				;---
				;DISPLAY HISTOGRAM OF GAME TIMES
	LDB #<ZHISTOG-HISTOG-2>/2	;START AT LARGEST TIME ( 6:00 )
	STB TEMP
	LDU #T.HISP
	STU TEMP+2
	BEGIN
	LDU TEMP+2
	LDD (U)++		;Y POSITION
	STD (Y)++
	CMPU #T.HISP+20.	;PAST HALF WAY POINT + 2 ( U++ ABOVE )
	IFHS			;YES, PUT DATA ON LEFT HALF OF SCREEN
	LDD #1FFF&-300.
	ELSE			;RIGHT SIDE OF SCREEN
	LDD #1FFF&100.
	ENDIF
	STD (Y)++
	STU TEMP+2
	LDX #T.HIST-1		;TIME SLOT TIME
	LDB TEMP
	LDA B(X)
	JSR TIME		;DISPLAY TIME IN M:S FORMAT
	LDD VGMSGA		;2 BLANKS
	STD (Y)++
	STD (Y)++
	LDB #0
	STB BT.SUP
	LDX #HISTOG		;HISTOGRAM DATA
	LDB TEMP
	ASLB
	LDA B(X)		;HIGH NIBBLE
	JSR VWNIBL		;SHOW IT
	INCB
	LDA B(X)
	JSR VWNIBL
	LDD #VGCNTR		;CENTER INSTRUCTION
	STD (Y)++

	DEC TEMP
	MIEND
	RTS
	.PAGE
	.SBTTL	DIVIDE
	.REPT 0
**********************************
*
*	DIVIDE
*
**********************************

DESCRIPTION:	DECIMAL DIVIDE TEMP2/TEMP.
		USES ITERATIVE ADD OF -TEMP UNTIL WRAP.

IN:		TEMP2 =NUMERATOR
		TEMP  =DENOMINATOR  ( NON-ZERO )

OUT:		TEMP  =ANSWER

USE:		TEMP(4),TEMP2(4)

	.ENDR

DIVIDE:
	LDX #TEMP+4		;PERFORM DECIMAL NEGATE OF DENOMINATOR
	LDA #01
	STA TMPCNT		;SETUP FOR NEGATE
	LDB #03			;4 BYTES WORTH
	BEGIN
	LDA #99
	SUBA -(X)
	ADDA TMPCNT
	DAA
	STA (X)
	IFCC			;PROPAGATE THE CARRY
	CLR TMPCNT
	ELSE
	LDA #01
	STA TMPCNT
	ENDIF
	DECB
	MIEND

	LDB #0FF
	BEGIN			;START DIVIDE
	INCB
	CMPB #0EF
	BEQ 40$			;OVERFLOW---LEAVE AT MAX
	LDA TEMP2+3		;START WITH LSB
	ADDA TEMP+3		;SUBTRACT DENOMINATOR ( ADD NEGATIVE IN DECIMAL)
	DAA
	STA TEMP2+3
	LDA TEMP2+2
	ADCA TEMP+2
	DAA
	STA TEMP2+2
	LDA TEMP2+1
	ADCA TEMP+1
	DAA
	STA TEMP2+1
	LDA TEMP2+0
	ADCA TEMP+0
	DAA
	STA TEMP2+0
	CCEND			;DONE WHEN STAYS NEGATIVE ( DECIMAL ) NO CARRY
40$:
	STB TEMP
	RTS
	.PAGE
	.SBTTL	TMPMUL
	.REPT 0
**********************************
*
*	TMPMUL
*
**********************************

DESCRIPTION:	PERFORM DECIMAL MULTIPLY  TEMP(4) * 4
		USE SUCCESIVE ADDS

IN:		TEMP(4) IS BCD NUMBER TO MULT

OUT:		TEMP(4) IS RESULT

USE:		TEMP(4)

	.ENDR

TMPMUL:
	BSR TMPML2			;DO IT TWICE
TMPML2:				;ADD TEMP TO TEMP IN DECIMAL
	CLC			;START WITH CARRY CLEAR
	LDB #03			;4 BYTES WORTH
	LDX #TEMP+3		;START WITH LSD
	BEGIN
	LDA (X)
	ADCA (X)
	DAA
	STA (X)
	LEAX -1(X)
	DECB
	MIEND
	RTS
	
	.PAGE
	.SBTTL	COIN ACOUNTING UPDATE
	.REPT 0
**********************************
*
*	EEACCU
*
**********************************

DESCRIPTION:	UPDATE COIN COUNTERS IN EEROM.
		( CALLED EVERY 16MS. )

IN:		NONE

OUT:		A,B,X,U  ALTERED

USE:		AMECH(6),RMECH(6),LMECH(6),TEMP(4),EECOIN

	.ENDR

EEACCU:
	LDA #2			;VERIFY AREA 2
	JSR SUMMIT		;CALCULATES CHECKSUM WITHOUT STORING
	IFEQ			;CHECKSUM OK, THEN CONTINUE-- ELSE BAD DATA
	CLRA			;START WITH 0
	LDB $CCTIM		;GET COIN COUNTER DATA-ALL 3
	ASLD			;GET COUNTER DATA INTO A
	LDB $CCTIM+1
	ASLD
	LDB $CCTIM+2
	ASLD
	TFR A,B			;NEW DATA IN B
	EORB EECOIN		;1=CHANGE IN STATE
	ANDB EECOIN		;1=COIN COUNTER JUST TURNED ON
	STA EECOIN		;NEW STATE
	LDX #RMECH
	BEGIN
	LSRB
	IFCS
	LDU #ITEMP
	JSR EETMP2		;MOVE EE TO TEMP
	LDA ITEMP+2		;LSB
	ADDA #01
	DAA
	STA ITEMP+2
	LDA ITEMP+1
	ADCA #00
	DAA
	STA ITEMP+1
	LDA ITEMP+0
	ADCA #00
	DAA
	STA ITEMP+0
	LDU #ITEMP
	JSR TMPEE2		;PUT BACK IN EE ROM
	LDA #2			;CALCULATE CHECKSUM FOR AREA 2
	STB ITEMP+3		;SAVE IT
	JSR EECKSM
	LDB ITEMP+3		;GET B BACK
	ENDIF
	LEAX -6(X)		;NEXT MECH
	CMPX #AMECH		;DONE?
	LOEND
	ENDIF
	RTS
	.PAGE
	.SBTTL	UPDATE TOTAL GAME TIME
	.REPT 0
**********************************
*
*	EEACCT
*
**********************************

DESCRIPTION:	ADD GAME TIME TO TOTAL TIME.
		CALLED ONCE AT END OF GAME.
		ALSO UPDATE TOTAL TIME ON.

IN:		TTIME=TOTAL ACCRUED TIME (EEROM)
		GTIME=TIME FOR LAST GAME
		TIME =RAM BASED TOTAL TIME ON

OUT:		A,B,X,U  ALTERED

USE:		TEMP(4),TTIME(8),HISTOG(36.)

	.ENDR

EEACCT:				;UPDATE TOTAL GAME TIME
	LDA #2
	JSR CHKEE		;MAKE SURE AREA 2 IS VALID
	LDX #TTIME		;TOTAL GAME TIMES
	JSR EETEMP		;GET TOTALS INTO TEMPS
	LDA TEMP+3		;ADD GAME TIME TO TOTAL
	ADDA GTIME+1
	DAA
	STA TEMP+3
	LDA TEMP+2
	ADCA GTIME+0
	DAA
	STA TEMP+2
	LDA TEMP+1
	ADCA #00
	DAA
	STA TEMP+1
	LDA TEMP+0
	ADCA #00
	DAA
	IFCC			;DO NOT OVERFLOW THE MSB
	STA TEMP+0
	ENDIF
	LDA #3			;DO FOUR BYTES
	STB TMPCNT
	LDU #TEMP
	JSR TMPEE3		;PUT DATA BACK TO EEROM
				;---
				;UPDATE NUMBER OF GAMES PLAYED
	LDX #GAMES		;NUMBER OF GAMES
	JSR EETEMP		;PUT IT IN TEMPS
	LDA TEMP+2
	ADDA #01
	DAA
	STA TEMP+2
	LDA TEMP+1
	ADCA #00
	DAA
	STA TEMP+1
	LDA TEMP+0
	ADCA #00
	DAA
	STA TEMP+0
	JSR TEMPEE		;PUT IT BACK IN EEROM
				;---
				;RECORD HIGHEST LEVEL EVER ATTAINED
	LDX #ENDGAM
	JSR EETEMP		;GET CURRENT HIGHEST TO TEMP
	LDA GM.DWAV		;END OF GAME LEVEL ( IN BCD OR DECIMAL )
	CMPA TEMP		;COMPARE TO RECORDED LEVEL
	IFHI			;THIS ONE IS HIGHER, USE IT INSTEAD
	STA TEMP
	CLR TEMP+1		;CLEAR UNUSED NIBBLES
	CLR TEMP+2
	JSR TEMPEE		;PUT IT BACK INTO EEROM
	ENDIF
				;---
				;UPDATE HISTOGRAM INFO
	LDX #ZHISTOG-2		;LAST ENTRY POINTER
	LDA GTIME		;MSB-IF NOT 0 THEN OVER 6:00, SO PUT IN LAST ENTRY
	IFEQ			;FIND OUT WHERE TO PUT DATA
	LDA GTIME+1
	LDX #HISTOG		;BEGINNING OF HISTOGRAM DATA
	LDB #9A			;GET NEGATIVE OF T.HIST ( THIS WON'T WORK FOR ALL)
	SUBB T.HIST
	STB TEMP
	BEGIN
	ADDA TEMP
	DAA
	BCC 20$			;FOUND ITS NICHE
	LEAX 2(X)
	CMPX #ZHISTOG-2
	HSEND			;IF NOT FOUND, PUT IN LAST ONE ANYWAY
	ENDIF
20$:	LDA 1(X)		;ADD 1
	ANDA #0F
	ADDA #01
	DAA
	STA 1(X)
	ANDA #0F0
	IFNE			;UPDATE HI NIBBLE
	LDA (X)
	ANDA #0F
	ADDA #01
	DAA
	STA (X)
	ANDA #0F0
	IFNE			;OVERFLOW-BAD NEWS DIVIDE ALL HISTOGRAM VALUES BY 2
	LDX #HISTOG
	BEGIN
	LDA (X)
	ASLA
	ASLA
	ASLA
	ASLA
	STA TEMP
	LDA 1(X)
	ANDA #0F
	ADDA TEMP
	BITA #10		;WILL DIVIDE BY 2 WORK?
	IFNE			;NO
	SUBA #06		;THIS CORRECTS IT
	ENDIF
	LSRA
	STA 1(X)
	LSRA
	LSRA
	LSRA
	LSRA
	STA (X)
	LEAX 2(X)
	CMPX #ZHISTOG
	HSEND
	LDA #5			;1/2 OF 100 IS 50
	STA (U)
	LDA #0
	STA 1(U)
	ENDIF
	ENDIF
				;---
				;SAVE POT VALUES
	LDA RHEOP+RH$LO
	STA TEMP
	LDA RHEOP+RH$SP
	STA TEMP+1
	LDA RHEOY+RH$LO
	STA TEMP+2
	LDA RHEOY+RH$SP
	STA TEMP+3
	LDX #POTSAV		;MOVE THEM FROM TEMP TO POTSAV IN EEROM
	LDU #TEMP
	LDA #3			;4 BYTES WORTH
	JSR TMPEE3
				;---
EEUTIM:				;UPDATE TOTAL TIME ON
	LDX #TIMEON		;MOVE TIMEON FROM EEROM
	JSR EETEMP
	SEI			;STOPS INTERRUPT INTERACTION
	LDU TIMER+2		;RAM BASED TIME
	LDD TIMER
	CLI
	CMPD TEMP		;NEW TIME SHOULD BE LARGER THAN OLD
	BHI 40$			;OK USE THIS AS NEW TIME
	BLO 50$			;LESS, DON'T USE IT AND SET IT TO OLD
	CMPU TEMP+2		;CHECK THE LOWER BYTES
	BLS 50$
40$:
	STD TEMP		;SAVE NEW TIME
	STU TEMP+2
	LDX #TIMEON
	LDU #TEMP
	LDA #03
	JSR TMPEE3		;PUT IT BACK INTO EEROM
	BRA 60$
50$:
	LDD TEMP		;RESTORE TIME FROM TIMEON
	STD TIMER
	LDD TEMP+2
	STD TIMER+2
60$:
				;---
	LDA #2			;SET NEW CHECKSUM
	JMP EECKSM		;AND RETURN
	.PAGE
	.SBTTL	SET EEROM AREA TO DEFAULT VALUES
	.REPT 0
**********************************
*
*	EECPY
*
**********************************

DESCRIPTION:	COPY DEFAULT VALUES TO EEROM AREA(A)

IN:		A=EEROM AREA NUMBER

OUT:		B,X,U  ALTERED

USE:		EEROM

	.ENDR

EECPY:
	CMPA #NAREA		;LEGAL?
	IFLO			;YES, GO AHEAD PLEASE
	CMPA #02		;AREAS 0 AND 1 GET DEFAULTS DIFFERENTLY
	IFHS			;GET DEFAULTS FROM T.DFLT
	LDX #T.AREA+1		;GET END OF AREA
	LDB A(X)		;POINTS TO SOMEWHERE IN EEROM PAGE
	SUBB #02		;LIMIT IS FIRST NIBBLE OF CHECKSUM
	STB TEMP+1
	LDB #EEROM/100		;WHAT PAGE IS NON-VOLATILE RAM
	STB TEMP		;(TEMP,TEMP+1) IS LIMIT
	LDX #T.AREA
	LDB A(X)		;GET START OF AREA
	LDX #T.DFLT-<EECK1-EEROM+2> ;DEFAULT TABLE STARTS WITH AREA 2
	ABX
	TFR X,U
	LDX #EEROM
	ABX
	BEGIN
	LDB (U)+
	STB (X)+
	CMPX TEMP
	HSEND
	ELSE			;ELSE GET DEFAULTS FROM ELSEWHERE
	TFR A,B			;SAVE IT
	TSTA
	IFEQ			;OPTION SWITCHES----USE PHYSICAL SWITCHES FOR DEFAULT
	LDA R.OPT1		;COINS
	STA TEMP
	LDA R.OPT2		;STARTING LIVES,DIFFICULTY,BONUS SHIELDS,ATTRACTIVE MUSIC
	STA TEMP+1
	LDA #00			;SET FOR MISC. OPTIONS
	STA TEMP+2
	LDX #DUPOPT		;START OF AREA 0
	JSR TEMPEE
	ELSE			;MUST BE HIGH SCORE INIT
	LDX #SAVSCR		;DO SCORES FIRST
	LDU #INTSCR		;INITIAL SCORE TABLE (SEE TCHSCR)
	LDA #11.
	JSR TMPEE3
	LDX #SAVINT		;NOW FOR THE INITIALS
	LDU #INTINT		;INITIAL INITIALS TABLE (SEE TCHSCR)
	LDA #08
	JSR TMPEE3
	ENDIF
	TFR B,A			;GET AREA NUMBER BACK INTO A
	ENDIF
	ENDIF
;FALL THROUGH TO CHECKSUM IT
	.PAGE
	.SBTTL	CHECKSUM EEROM AREA
	.REPT 0
**********************************
*
*	EECKSM
*
**********************************

DESCRIPTION:	CALCULATE CHECKSUM FOR EEROM AREA.
		CONDITION CODE HAS Z SET IF CHECKSUM WAS ALREADY CORRECT (TEST).

IN:		A=AREA NUMBER

OUT:		A=AREA NUMBER (NOT CHANGED)
		B=CHECKSUM
		CC=ZERO IF CHECKSUM WAS CORRECT
 		X ALTERED

USE:		EEROM
		3 BYTES OF STACK USED TO MAKE ROUTINE RE-ENTRANT
	.ENDR

CNT	=0
NEWSUM	=1
OLDSUM	=2
EECKSM:
	JSR SUMMIT		;GET CHECKSUM, Z=1 IF CHECKSUM SAME, SUM IN B
	IFNE			;STORE IT
	STB 1(X)		;LO NIBBLE
	LSRB
	LSRB
	LSRB
	LSRB
	STB (X)			;HI NIBBLE
	LDB #0FF		;CLEAR ZERO FLAG
	ENDIF
				;---
	RTS
				;===

SUMMIT:
	LEAS -3(S)		;ALLOCATE 3 BYTES
	LDX #T.AREA+1		;GET LENGHT OF AREA
	LDB A(X)
	LDX #T.AREA
	SUBB A(X)
	SUBB #02		;DON'T CHECKSUM THE CHECKSUM
	STB CNT(S)
	LDB A(X)		;GET START OF AREA
	LDX #EEROM
	ABX			;POINTS TO START OF AREA TO CHECKSUM
	LDB #00			;SEED
	STB NEWSUM(S)
	SEC			;PREVENT A ZERO CHECKSUM
	BEGIN
	LDB (X)+		;GET DATA
	ANDB #0F		;ONLY LOWER NIBBLE IS DATA
	ADCB NEWSUM(S)		;SUM
	STB NEWSUM(S)
	DEC CNT(S)
	EQEND
	ADCB #0			;GET ALL THE CARRIES IN
	STB NEWSUM(S)
				;COMPARE WITH OLD CHECKSUM
	LDB (X)			;HI NIBBLE
	ASLB
	ASLB
	ASLB
	ASLB
	STB OLDSUM(S)
	LDB 1(X)		;LO NIBBLE
	ANDB #0F
	ADDB OLDSUM(S)		;OLD CHECKSUM
	STB OLDSUM(S)
	LDB NEWSUM(S)
	CMPB OLDSUM(S)		;SET CONDITION CODE
	LEAS 3(S)		;RESTORE STACK POINTER
	RTS
				;===

	.PAGE
	.SBTTL	TEST/REINIT EEROM
	.REPT 0
**********************************
*
*	EEINIT
*
**********************************

DESCRIPTION:	CALL EEINIT AFTER RESET. (IE. POWERON,SELFTEST,WATCHDOG,ETC.)
		MAKE SURE EEROM IS VALID, USE FOLLOWING STEPS:
	1. IF THE EEROM RAM IS VALID THEN USE IT.
	2. IF AN AREA OF THE RAM IS BAD THEN USE THE DATA
	   FROM THE EEROM (RECALLED DATA) FOR THAT AREA.
	3. IF THE ABOVE FAILS THEN THE AREAS IN ERROR ARE REWRITTEN
	   WITH THE DEFAULT VALUES.

IN:		

OUT:		A,B,X,U ALTERED

USE:		EEROM

	.ENDR

EEINIT:
	LDX #EEROM		;COPY EEROM TO BUFFER
	LDU #EEBUF
	BEGIN
	LDD (X)++
	STD (U)++
	CMPX #EEROMZ
	HSEND
				;---
	LDA #0FF		;PERFORM A RECALL OF THE NON-VOLATILE MEMORY
	STA NVRRCL
	LDX #0100		;WAIT FOR THE CAP TO DISCHARGE
	BEGIN
	STA WTCHDG
	LEAX -1(X)
	EQEND
	LDA #00			;TURN OFF RECALL LINE
	STA NVRRCL
	LDX #0A000		;NOW WAIT FOR THE CAP TO CHARGE BACK UP
	BEGIN
	STA WTCHDG
	LEAX -1(X)
	EQEND
				;---
	LDX #EEROM		;SWAP EEROM AND BUFFER
	LDY #EEBUF
	BEGIN
	LDU (X)
	LDD (Y)
	STU (Y)++
	STD (X)++
	CMPX #EEROMZ
	HSEND			;EEBUF HAS RECALLED DATA AND EEROM HAS ITS ORIGINAL
	.IF	NE,RESONLY
				; THIS MAKES SURE THAT WE ALWAYS USE PHYSICAL SWITCHES
	LDA #00			;OPTION SWITCH BACKUP AREA NUMBER
	BRA EEINI0		;WILL RESET BOTH BACKUP AND PRIMARY OPTION AREAS
	.ENDC
				;---
				;START CHECKING VALIDITY
	LDA #NAREA		;OPTION SWITCH AREA IS SPECIAL, 2 AREAS
	JSR SUMMIT
	BEQ 20$			;PRIMARY OK, MAKE SURE BACKUP IS OK
	LDA #00			;PRIMARY WAS BAD, CHECK BACKUP AREA
	JSR SUMMIT
	BEQ 15$			;BACKUP OK, GO REWRITE MAIN AREA FROM BACKUP
				;BOTH RAM AREAS BAD, CHECK RECALLED DATA
	JSR EEINI2		;RESTORE PRIMARY AND BACKUP FROM EEBUFF COPY
	LDA #NAREA
	JSR EEINI2
	JSR SUMMIT		;CHECKSUM RECALLED PRIMARY
	BEQ 20$			;'TWAS OK, CHECK NEW BACKUP
	LDA #00			;NEW PRIMARY BAD, CHECK NEW BACKUP
	JSR SUMMIT
	BEQ 15$
	.IIF EQ,DEVSYS-1,SWI	;OH SHIT! NONE OF THEM WAS GOOD

EEINI0	=.		; SPECIAL ENTRY FOR ALWAYS SETTING UP OPTION SWITCH INFO **************

	JSR EECPY		;RESTORE FROM ROM TABLE
15$:				;PRIMARY BAD, BUT BACKUP OK
	LDX #T.AREA		;MOVE BACKUP TO PRIMARY
	LDB NAREA(X)
	LDX #EEROM
	ABX			;POINTER TO BAD AREA
	LDU #EEROM		;POINTER TO GOOD AREA (BACKUP)
	BRA 40$			;FIX IT FROM BACKUP
20$:				;PRIMARY GOOD
	LDA #00			;CHECK THE BACKUP AREA
	JSR SUMMIT
	BNE EEINI1		;FIX IT FROM PRIMARY
				;---
				;BOTH AREAS HAVE GOOD CHECKSUMS, MAKE AREAS THE SAME
	LDA EECK3		;PRIMARY OPTION SWITCH CHECKSUM
	ANDA #0F
	STA TEMP
	LDA EECK0		;BACKUP
	ANDA #0F
	CMPA TEMP
	IFEQ
	LDA EECK3+1
	ANDA #0F
	STA TEMP
	LDA EECK0+1
	ANDA #0F
	CMPA TEMP
	ENDIF
	BEQ 55$			;OPTION SWITCH CHECKSUM ARE THE SAME, CHECK OTHER AREAS
EEINI1	=.
	LDX #T.AREA		;REPLACE BACKUP AREA WITH PRIMARY
	LDB NAREA(X)
	LDX #EEROM
	ABX
	TFR X,U			;POINTS TO PRIMARY OPTION SWITCH AREA
	LDX #EEROM		;POINTS TO BACKUP OPTION SWITCH AREA
40$:
	LDB T.AREA+1		;LENGTH OF OPTION SWITCH AREAS
	STB TMPCNT
	BEGIN
	LDB (U)+		;TRANSFER GOOD TO BAD
	STB (X)+
	DEC TMPCNT
	EQEND
55$:
	LDA #NAREA-1		;NEXT AREA
	BEGIN
	JSR SUMMIT
	IFNE			;NO GOOD
	JSR EEINI2		;REPLACE FROM BUFFER
	JSR SUMMIT
	IFNE			;REALLY BAD, USE DEFAULTS
	.IIF EQ,DEVSYS-1,SWI
	JSR EECPY
	ENDIF
	ENDIF
	DECA
	EQEND
				;---
	LDX #TIMEON		;SETUP RAM BASED TIME ON
	JSR EETEMP
	LDD TEMP
	STD TIMER
	LDD TEMP+2
	STD TIMER+2
	RTS
EEINI2:				;MOVE AREA A FROM EEBUF TO EEROM
	LDX #T.AREA+1
	LDB A(X)
	LDX #EEROM
	ABX
	STX TEMP		;START OF NEXT AREA
	LDX #T.AREA
	LDB A(X)
	LDX #EEBUF
	ABX
	TFR X,U			;START OF AREA IN EEBUF
	LDX #EEROM
	ABX			;START OF AREA IN EEROM
	BEGIN
	LDB (U)+
	STB (X)+
	CMPX TEMP
	HSEND
	RTS
				;===

CHKEE:				;CHECK AND RESTORE IF NECESSARY THE VALIDITY OF AREA (A)
	JSR SUMMIT
	IFNE			;ERROR
	STA TEMP		;SAVE AREA NUMBER
	LDX #EEROM		;COPY EEROM TO BUFFER
	LDU #EEBUF
	BEGIN
	LDD (X)++
	STD (U)++
	CMPX #EEROMZ
	HSEND
	JSR NOVRCL		;PERFORM A RECALL OF THE NON-VOLATILE RAM
	LDX #EEROM		;SWAP EEROM AND BUFFER
	LDY #EEBUF
	BEGIN
	LDU (X)
	LDD (Y)
	STU (Y)++
	STD (X)++
	CMPX #EEROMZ
	HSEND			;EEBUF HAS RECALEED DATA AND EEROM HAS ITS ORIGINAL
	LDA TEMP		;RESTORE AREA NUMBER
	JSR EEINI2
	JSR SUMMIT
	IFNE
	.IIF EQ,DEVSYS-1,SWI
	JSR EECPY
	ENDIF
	ENDIF
	RTS
	.PAGE
	.SBTTL	DISPLAY OPTION SWITCHES
	.REPT 0
**********************************
*
*	EEOPT
*
**********************************

DESCRIPTION:	DISPLAY OPTION SWITCH INFORMATION

IN:		

OUT:		A,B,X,U  ALTERED

USE:		EEINDX

	.ENDR

EEOPT:
	LDA #MS.OPT		;OPTION SWITCH MESSAGES
	BEGIN
	JSR MESSON
	INCA
	CMPA #MS.VLC
	HSEND
	LDA #MS.TST		;"AUX FOR SELF TEST" MESSAGE
	JSR MESSON
	LDD #VGCOLR+<VGCGRN*100>;OPTION SWITCH VALUE COLOR
	STD (Y)++
	LDA #T.OPTZ-T.OPT-1	;DISPLAY ALL OPTION SWITCH VALUES
	STA TEMP2
	BEGIN
	LDA TEMP2
	JSR EEOPT3
	DEC TEMP2
	MIEND
				;---
	JSR EETSTR		;REPORT RESULTS OF EEROM ( NOVRAM ) TEST
				;---
	LDA RESETS		;CHECK FOR RESETS
	ANDA #0F
	IFNE			;SOMETHING NEEDS TO BE RESET
	LDB #MS.RES		;"USE RIGHT FIRE BUTTON TO PERFORM ANY RESET"
	JSR DOMESS
	LDA GN.SWE		;CHECK FOR FIRE BUTTON
	ANDA #RFIRBT		;RIGHT FIRE
	IFNE			;IT WAS PUSHED, RESET INDICATED AREAS
	LDA RESETS
	ANDA #08		;RESET HIGH SCORES?
	IFNE			;YES
	LDA #01
	JSR EECPY		;PERFORM DEFAULT COPY ON AREA 1
	JSR SETINT		;RESET OTHER INITIALS TOO
	ENDIF
				;---
	LDA RESETS
	ANDA #04		;RESET ACCOUNTING INFO?
	IFNE			;YES
	LDX #GAMES		;CLEAR AREA 2 STARTING AT GAMES ( LEAVE COINS ALONE )
	LDD #0000
	BEGIN
	STD (X)++		;WORD STORE FOR 2 NIBBLES
	CMPX #EECK2
	HSEND
	LDA #02			;CHECKSUM AREA 2
	JSR EECKSM
	ENDIF
				;---
	LDA RESETS
	ANDA #02		;RESET OPTIONS TO DEFAULT?
	IFNE			;YES
	LDA #00			;SET AREA 0 TO DEFAULT
	JSR EECPY
	LDX #T.AREA		;COPY BACKUP AREA TO PRIMARY AREA
	LDB NAREA(X)
	LDX #EEROM
	ABX
	LDU #EEROM
	LDB T.AREA+1
	STB TMPCNT
	BEGIN
	LDB (U)+
	STB (X)+
	DEC TMPCNT
	EQEND
	ENDIF
				;---
	LDA RESETS
	ANDA #01		;TEST NOVRAM?
	IFNE			;YES
	JSR EETST		;TEST STORE-ABILITY OF NOVRAM
	ENDIF
				;---
	LDD #00			;CLEAR RESET BYTE
	STD RESETS
	ENDIF
	ENDIF
	RTS
	.PAGE
	.SBTTL	SELECT NEW OPTIONS
	.REPT 0
**********************************
*
*	EEOPT1
*
**********************************

DESCRIPTION:	DISPLAY AND MAKE CHANGES TO OPTION SWITCH VALUES.

IN:		EEINDX=CURRENT OPTION BEING CHANGED

OUT:		A,B,X,U  ALTERED

USE:		EEINDX,EEVAL,EEROM,TEMP

	.ENDR

EEOPT1:
	LDB FRAME+1
	ANDB #0F		;NOT TOO QUICK
	IFEQ
				;---
	LDB SI.RSY		;UP/DOWN
	CMPB #0D0
	IFLO			;MAY BE NEGATIVE ENOUGH
	CMPB #30
	IFHI			;LARGE ENOUGH TO CHANGE
	TSTB
	IFPL			;BACK AN OPTION
	LDB EEINDX
	DECB
	.IF	NE,RESONLY
	CMPB #T.OPTZ-T.OPT-4	;LIMIT SELECTION TO RESETS ONLY
	IFLO
	LDB #T.OPTZ-T.OPT-1
	ENDIF
	.IFF			;NOT RESET ONLY
	IFMI			;WRAP WHEN BELOW 0
	LDB #T.OPTZ-T.OPT-1
	ENDIF
	.ENDC
	STB EEINDX
	ELSE			;FORWARD AN OPTION
	LDB EEINDX
	INCB
	CMPB #T.OPTZ-T.OPT-1
	IFHI			;WRAP
	.IF	NE,RESONLY
	LDB #T.OPTZ-T.OPT-1-3	;DISALLOW ANY FUNCTIONS BUT RESETS
	.IFF
	LDB #0
	.ENDC
	ENDIF
	STB EEINDX
	ENDIF
	ENDIF
	ENDIF
	ENDIF
	LDX #T.OPT		;GET OPTION DESCRIPTOR
	LDA EEINDX
	LDB A(X)
	STB TEMP+2
	LSRB
	LSRB
	LSRB
	ANDB #03		;FIELD SIZE
	LDX #EEMASK
	LDA B(X)		;MASK FOR THIS FIELD SIZE
	STA TEMP		;ALSO MAX VALUE FOR CURRENT OPTION
				;---
				;LEFT FIRE BUTTON CHANGES THE OPTION
	LDB GN.SWE		;LOOK FOR EDGE OF LEFT FIRE BUTTON
	ANDB #LFIRBT
	IFNE			;FOUND AN EDGE
	LDB EEVAL		;CURRENT VALUE
	INCB			;NEXT VALUE, MAYBE
	CMPB TEMP		;PAST MAX?
	IFHI			;YES, WRAP BACK TO LOWEST VALUE
	LDB #00
	ENDIF
	STA EEVAL
				;---
	LDA TEMP+2		;OPTION DESCRIPTOR
	ROLA			;GET BIT POSITION
	ROLA
	ROLA
	ROLA
	ANDA #07
	BEGIN			;MOVE DATA AND MASK INTO POSITION
	DECA
	BMI 20$
	ASLB			;SHIFT DATA
	ASL TEMP		;SHIFT MASK
	LOOP
20$:
	LDA TEMP+2		;OPTION DESCRIPTOR
	ANDA #07		;INDEX INTO OPTION SWITCH AREA
	ASLA			;NIBBLES, NIBBLES, NIBBLES. I'VE GOT TO REMEMBER NIBBLES
	LDX #OPTS0
	LEAX A(X)		;POINTER TO OPTION SWITCH DATA
	LDA (X)			;GET THE DATA INTO TEMP STORAGE
	ASLA			;HIGH NIBBLE
	ASLA
	ASLA
	ASLA
	STA TEMP+1
	LDA 1(X)		;LO NIBBLE
	ANDA #0F
	ADDA TEMP+1
	STA TEMP+1

	EORB TEMP+1		;PUT NEW DATA INTO TEMP
	ANDB TEMP
	EORB TEMP+1
	STB 1(X)		;PUT IT BACK INTO EEROM
	LSRB
	LSRB
	LSRB
	LSRB
	STB (X)
	LDA #NAREA		;SET CHECKSUM
	JSR EECKSM
	LDX #EEROM		;MOV EEROM TO EEBUF TO PREPARE FOR "EEINI1"
	LDU #EEBUF
	BEGIN
	LDD (X)++
	STD (U)++
	CMPX #EEROM+0FF
	HSEND
	JSR EEINI1		;SETUP BACKUP AND CHECK OTHER AREAS
	LDA EEINDX		;DISPLAY THE NEW VALUE
	JSR EEOPT3
	ENDIF
	RTS
	.PAGE
	.SBTTL	DISPLAY OPTION VALUE
	.REPT 0
**********************************
*
*	EEOPT3
*
**********************************

DESCRIPTION:	DISLAY THE OPTION SWITCH VALUE.

IN:		A=OPTION NUMBER

OUT:		A,B,X,U   ALTERED

USE:	

	.ENDR

EEOPT3:
	LDX #T.OPT
	LDB A(X)		;OPTION SWITCH DESCRIPTOR
	STB TEMP		;SAVE IT
	ANDB #07		;WHICH WORD?
	LDX #OPTS0
	ASLB			;NIBBLES REMEMBER
	ABX			;POINTER TO OPTION SWITCHES
	LDB TEMP		;SWITCH DESCRIPTOR
	LSRB
	LSRB
	LSRB
	STB TEMP		;SAVE IT
	ANDB #03		;WHAT IS THE FIELD SIZE?
	LDU #EEMASK
	LEAU B(U)		;ADD B TO U, POINTS TO FIELD MASK
	LDB TEMP
	LSRB
	LSRB
	STB TEMP		;BIT POSITION OF FIELD
	LDB (X)			;GET OPTION SWITCH DATA (BOTH NIBBLES)
	ASLB
	ASLB
	ASLB
	ASLB
	STB TEMP+1
	LDB 1(X)
	ANDB #0F
	ADDB TEMP+1
	BEGIN			;MOVE FIELD TO LSB
	DEC TEMP
	BMI 20$
	LSRB
	LOOP
20$:
	ANDB (U)		;MASK FOR FIELD
	STB EEVAL
	LDX #T.MOPV		;OPTION SWITCH VALUE MESSAGE TABLE
	LEAX A(X)		;INDEX INTO TABLE--BASE MESSAGE #
	ADDB (X)		;MESSAGE NUMBER OF THIS VALUE
	JMP DOMES2		;COLOR MUST BE ALREADY SET UP
	.PAGE
	.SBTTL	TEST EEROM STORE
	.REPT 	0
**********************************
*
*	EETST
*
**********************************

DESCRIPTION:	TESTS THE STORE-ABILITY OF THE EEROM ( NOVRAM ).
		DATA RETAINED UNLESS BAD EEROM.
		*************************************************
		*** NOTE: USES UP 2 OF THE 1000 STORES QUOTED ***
		***       BY THE MANUFACTURER. USE SPARINGLY! ***
		*************************************************

IN:		

OUT:		A,B,X,U,Y	ALTERED

USE:		

	.ENDR

EETST:				;TEST STORE-ABILITY OF EEROM (NOVRAM)
	LDX #EEROM		;COPY CURRENT DATA TO BUFFER
	LDU #EEBUF
	BEGIN
	LDD (X)++
	STD (U)++
	CMPX #EEROMZ
	HSEND
				;---
	LDX #EEROM		;COMPLIMENT THE DATA PRIOR TO STORE
	BEGIN
	LDA (X)
	COMA
	STA (X)+
	CMPX #EEROMZ
	HSEND
				;---
	STA NSTORE		;STORE IT OUT TO ROM PORTION OF EEROM
	JSR EEWAIT		;WAIT 10 MS FOR THE STORE
	JSR EECLR		;CLEAR IT OUT TO TEST THE RECALL
	JSR NOVRCL		;RECALL THE DATA
				;DATA IN RAM SHOULD BE COMPLIMENT OF BUFFER DATA
				;---
	LDX #EEROM		;COMPLIMENT IT AGAIN
	BEGIN
	LDA (X)
	COMA
	STA (X)+
	CMPX #EEROMZ
	HSEND
				;---
				;SHOULD BE THE ORIGINAL DATA AGAIN
	STA NSTORE		;STORE IT OUT AGAIN
	JSR EEWAIT		;WAIT 10 MS FOR STORE
	JSR EECMP		;COMPARE DATA TO BUFFER
	BNE RESTOR		;BAD DATA--SET FLAG AND RESTORE WITH BUFFER DATA
				;TWICE COMPLIMENTED DATA LOOKS OK, TRY RECALLING THE DATA AGAIN
	JSR EECLR		;CLEAR IT TO TEST RECALL
	JSR NOVRCL		;RECALL THE DATA AGAIN
	JSR EECMP		;ONE LAST COMPARE
	IFNE
	JMP RESTORE		;PUT THE RAM PORTION BACK IF POSSIBLE
	ENDIF
	RTS
				;---
EECMP:				;COMPARE EEROM DATA TO BUFFER DATA
	LDX #EEROM
	LDU #EEBUF
	BEGIN
	LDA (X)+
	EORA (U)+
	ANDA #0F		;LOW NIBBLE ONLY
	BNE 10$
	CMPX #EEROMZ
	HSEND
	LDA #01			;SET FLAG TO SAY NOVRAM OK
	STA NVTSTR
	CLRA			;SET CONDTION CODE FOR NO ERROR ( Z=1 )
10$:	RTS
				;---
RESTOR:				;ERROR IN NOVRAM, SET FLAGS AND REWRITE DATA WITH BUFFER
	LEAX -1(X)		;DID POST ADD ABOVE
	TFR X,D			;ADDRESS OF ERROR
	STD NVADDR		;FOR REPORTING ERROR
	LDA #0FF		;FLAG SAYING NOVRAM BAD
	STA NVTSTR		;TEST RESULTS
				;---
	LDX #EEROM		;COPY BUFFER TO EEROM RAM
	LDU #EEBUF
	BEGIN
	LDD (U)++
	STD (X)++
	CMPX #EEROMZ
	HSEND
	TST NVTSTR		;SET CONDITION CODES
	RTS
				;---
EECLR:				;CLEAR RAM PORTION OF EEROM ( NOVRAM )
	LDX #EEROM
	LDD #0000
	BEGIN
	STD (X)++
	CMPX #EEROMZ
	HSEND
	RTS
				;---
EEWAIT:				;WAIT AT LEAST 10 MS FOR NOVRAM STORE CYCLE
	LDX #2000.		;10. MS = 15000. CYCLES/8 CYCLES = 1875.
	BEGIN
	LEAX -1(X)		;DEX
	EQEND
	RTS
				;---

EETSTR:				;REPORT EETST RESULTS
	LDA NVTSTR		;RESULTS OF NOVRAM ( EEROM ) TEST
				;0 MEANS NO TEST PERFORMED
				;1 MEANS NO ERRORS DETECTED
				;ANYTHING ELSE MEANS ERRORS DETECTED
	IFNE			;TEST WAS PERFORMED - TELL RESULTS
	CMPA #01
	IFEQ			;NO ERRORS -- GOOD EEROM
	LDB #MS.GNV		;"NO ERRORS"   ( GOOD NOVRAM )
	ELSE			;THERE WERE ERRORS
	LDD #1FFF&-150.
	STD (Y)++
	LDD #1FFF&420.
	STD (Y)++
	LDA NVADDR+1		;LOW BYTE OF ADDRESS OF ERROR
	JSR VWBYTE
	LDD #VGCNTR
	STD (Y)++
	LDB #MS.BNV		;"ERROR AT"   ( BAD NOVRAM )
	ENDIF
	JSR DOMESS
	ENDIF
	RTS
				;---

NOVRCL:				;RECALL NON-VOLATILE MEMORY
	LDA #0FF		;D7 = 1 PUTS NOVRAM IN RECALL MODE
	STA NVRRCL
	JSR WAITFRAME		;WAIT A WHILE, THERE'S A LARGE CAP ON THE LINE
	LDA #00			;D7 = 0 BRINGS US OUT OF RECALL MODE
	STA NVRRCL
	LDU #0000
	BEGIN			;WAIT LONG TIME FOR CAP TO CHARGE UP
	JSR WAITFRAME
	LEAU 1(U)
	CMPU #0020
	HSEND			;NOW THE NOVRAM SHOULD BE USABLE
	RTS
				;===

	.PAGE
	.SBTTL	MOVE EEROM TO TEMP
	.REPT 0
**********************************
*
*	EETEMP,EETMP2,EETMP3
*
**********************************

DESCRIPTION:	ROUTINES FOR MOVING NIBBLES IN EEROM TO BYTES IN RAM.
		EETEMP-MOVES 8 NIBBLES FROM EEROM (X) TO 4 BYTES AT TEMP.
		EETMP2-MOVES 8 NIBBLES FROM EEROM (X) TO 4 BYTES AT (U).
		EETMP3-MOVES (A) NIBBLES FROM EEROM (X) TO (A)/2 BYTES AT (U).

IN:		X POINTS TO AREA IN EEROM TO MOVE
		EETMP2--U MUST POINT TO RECEIVING AREA
		EETMP3--A CONTAINS # OF BYTES TO MOVE

OUT:		X RESTORED WITH EETEMP

USE:		TEMP(8),TMPCNT

	.ENDR

	;MOVE 8 NIBBLES IN EEROM TO 4 BYTES OF RAM
EETEMP:
	LDU #TEMP
EETMP2:
	LDA #3
EETMP3:
	STA TMPCNT
	BEGIN
	LDA (X)+		;UPPER NIBBLE
	ASLA
	ASLA
	ASLA
	ASLA
	STA (U)
	LDA (X)+		;LOWER NIBBLE
	ANDA #0F
	ADDA (U)
	STA (U)+
	DEC TMPCNT
	MIEND	
	LEAX -8(X)		;RESTORE X
	RTS
	.PAGE
	.SBTTL	MOVE TEMP TO EEROM
	.REPT 0
**********************************
*
*	TEMPEE,TMPEE2,TMPEE3
*
**********************************

DESCRIPTION:	MOVE BYTES FROM RAM AREA (U) TO EEROM (X).
		TEMPEE-3 BYTES FROM TEMP TO 6 NIBBLES IN EEROM (X).
		TMPEE2-3 BYTES FROM (U) TO 6 NIBBLES IN EEROM (X).
		TMPEE3-(A) BYTES FROM (U) TO (A)*2 NIBBLES IN EEROM (X).

IN:		ALL----AREA IN RAM MUST HAVE DATA TO TRANSFER
		       X POINTS TO RECEIVING AREA IN EEROM.
		TEMPEE-NOTHING MORE
		TMPEE2-U POINTS TO AREA IN RAM TO MOVE
		TMPEE3-A HAS COUNT OF BYTES TO MOVE		

OUT:		A,U ALTERED    X RESTORED BY TEMPEE AND TMPEE2,BUT NOT TMPEE3

USE:		EEROM(X),TMPCNT

	.ENDR

TEMPEE:
	LDU #TEMP
TMPEE2:
	LDA #2
TMPEE3:
	STA TMPCNT		;NUMBER OF BYTES TO MOVE
	BEGIN
	LDA (U)+		;GET DATA
	STA 1(X)		;STORE LOWER NIBBLE FIRST
	LSRA			;GET UPPER NIBBLE TO LOWER
	LSRA
	LSRA
	LSRA
	STA (X)++		;STORE UPPER, UPDATE X
	DEC TMPCNT
	MIEND
	LEAX -6(X)
	RTS

	.PAGE
	.SBTTL	TIME
	.REPT 0
**********************************
*
*	TIME
*
**********************************

DESCRIPTION:	DISPLAY A TIME IN M:S FORMAT

IN:		A=TIME ( FORMAT IS MS WHERE M IS MINUTES
		       ( AND S IS 4 SECOND MULTIPLIER ( 0 TO E ))

OUT:		A,B,U   ALTERED

USE:		Y UPDATED

	.ENDR

TIME:
	LDB #0
	STB BT.SUP
	TFR A,B
	LSRA
	LSRA
	LSRA
	LSRA
	CMPA #0A
	IFHS			;MAX OF 9
	LDA #09
	ENDIF
	JSR VWNIBL		;MINUTES
	LDA #VJCOLN&0FF00/100	;CHANGE TO COLON IF WE MAKE ONE
	STA (Y)+
	LDA #VJCOLN&00FF
	STA (Y)+

	CLRA
	ANDB #0F		;SECONDS
	IFNE
	BEGIN			;MULTIPLY BY 4 IN DECIMAL
	ADDA #04
	DAA
	DECB
	EQEND
	ENDIF
	JMP VWBYTE		;AND RETURN

	.PAGE
	.SBTTL	TABLES
EEMASK:	.BYTE 01,03,07,0F

T.DFLT:
	.WORD 0800,0800,0800,0800	;POT SAVE
	.WORD 0,0,0		;AUX COINS
	.WORD 0,0,0		;LEFT MECH COINS
	.WORD 0,0,0		;RIGHT MECH COINS
	.WORD 0,0,0		;NUMBER OF GAMES PLAYED
	.WORD 0,0,0,0		;TOTAL ON TIME
	.WORD 0,0,0,0		;TOTAL GAME TIME
	.WORD 0,0,0		;HISTOGRAM OF GAME TIMES
	.WORD 0,0,0
	.WORD 0,0,0
	.WORD 0,0,0
	.WORD 0,0,0
	.WORD 0,0,0
	.WORD 0,0,0		;HIGHEST WAVE LEVEL ATTAINED
	.WORD 0			;CHECKSUM FOR AREA 2

.MACRO	SPEC WRD,LEN,POS
	.BYTE 20*POS+<8*<LEN-1>>+WRD
	.ENDM

T.OPT:				;OPTION DESCRIPTOR TABLE
	SPEC 0,2,0		;COIN VALUE
	SPEC 0,1,4		;LEFT MECH MULT
	SPEC 0,2,2		;RIGHT MECH MULT
	SPEC 0,3,5		;BONUS ADDER
	SPEC 1,2,0		;STARTING LIVES ( 6 TO 9 )
	SPEC 1,2,2		;PLAY DIFFICULTY
	SPEC 1,2,4		;BONUS ENERGY AT WAVE END
	SPEC 1,1,6		;MUSIC IN ATTRACT
;	SPEC 1,1,7		;FREEZE MODE,   NOT USABLE HERE
	SPEC 4,1,7		;RESET HIGH SCORES
	SPEC 4,1,6		;RESET ACCOUNTING TIMING INFO
	SPEC 4,1,5		;RESET COIN OPTIONS TO DEFAULT
	SPEC 4,1,4		;TEST NOVRAM
T.OPTZ:

	.BYTE 0			;HISTORY OF GAME TIMES DATA
T.HIST:
	.BYTE 05,0A,10
	.BYTE 15,1A,20
	.BYTE 25,2A,30
	.BYTE 35,3A,40
	.BYTE 45,4A,50
	.BYTE 55,5A,60

T.AREA:				;STARTING ADDRESS FOR EACH AREA
	.BYTE 0
	.BYTE EECK0-EEROM+2
	.BYTE EECK1-EEROM+2
	.BYTE EECK2-EEROM+2
	.BYTE EECK3-EEROM+2



.MACRO	.POS	...Y
	.WORD	...Y&1FFF	;KEEPS IT LEGAL FOR THE VECTOR GENERATOR
	.ENDM

T.ACCP:				;Y POSITIONS FOR ACCOUNTING INFO
	.POS 440.		;AUX COINS
	.POS 400.		;LEFT COINS
	.POS 360.		;RIGHT COINS
	.POS 280.		;TOTAL GAMES PLAYED -/- HIGHEST LEVEL ATTAINED
	.POS 320.		;TOTAL COINS PAID
	.POS 180.		;AVERAGE GAME TIME
	.POS 080.		;PERCENTAGE OF GAME PLAYED
	.POS 220.		;TOTAL GAME TIME
	.POS 120.		;TIME ON

T.HISP:				;Y POSITIONS FOR HISTOGRAM
	.POS -405.
	.POS -360.
	.POS -315.
	.POS -270.
	.POS -225.
	.POS -180.
	.POS -135.
	.POS -090.
	.POS -045.
	.POS -405.
	.POS -360.
	.POS -315.
	.POS -270.
	.POS -225.
	.POS -180.
	.POS -135.
	.POS -090.
	.POS -045.

T.MOPV:				;TABLE OF MESSAGE #'S FOR OPTION SWITCH VALUES
	.BYTE MS.VLC		;VALUE OF COIN (FREE,1C/2P,1C/1P,2C/1P)
	.BYTE MS.LMV		;LEFT MECH VALUE (1,2)
	.BYTE MS.RMV		;RIGHT MECH VALUE (1,4,5,6)
	.BYTE MS.BAV		;BONUS ADDER VALUE (0,2-1,4-1,4-2,5-1,3-1,0,0)
	.BYTE MS.SLV		;STARTING LIVES (6,7,8,9)
	.BYTE MS.DIF		;DIFFICULTY (EASY,MODERATE,HARD,HARDEST)
	.BYTE MS.BSV		;BONUS SHIELD VALUE ( 0,1,2,3 )
	.BYTE MS.MUV		;MUSIC IN ATTRACT ( N/Y )
	.BYTE MS.RHS		;RESET HIGH SCORES ( Y/N )
	.BYTE MS.RAC		;RESET ACCOUNTING INFO ( Y/N )
	.BYTE MS.ROP		;RESET OPTIONS TO DEFAULTS ( Y/N )
	.BYTE MS.TER		;TEST EEROM ( Y/N )

	HLL69F
	.END
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     