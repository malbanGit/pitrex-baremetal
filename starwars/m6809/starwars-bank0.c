
                   // ORG   $6000
    // ===========================================================================
    // Segment type: Pure code
    // =============== S U B R O U T I N E =======================================
  case 0x6005:
L6005:
                                                     #ifdef DEBUG
                                      mon("L6005    LDX   #$00                    ; 6005: 8E 00 00      \n");
                                      #endif
    PC = 0x6005; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x0000; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$F800                  ; 6008: CC F8 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xf8; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$48                    ; 600B: 86 48         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x48; 
    A = val; 
 // N = val; 
 // Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         TFR   A,DP                    ; 600D: 1F 8B         \n");
                                      #endif
    DP = (A) << 8; checkDP(); 
    // memory_DP = &memory[DP];
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         LSR   <$3D                    ; 600F: 04 3D         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x3d); 
    C = val & 1; 
    val = val >> 1; 
    wr_mem(DP|0x3d, val); 
    N = 0; 
    Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BCC   L6005                   ; 6011: 24 F2         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto L6005;
    }
                                                     #ifdef DEBUG
                                      mon("         CMPS  #$4FFF                  ; 6013: 11 8C 4F FF   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = S; 
    arg = 0x4fff; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L601A                   ; 6017: 27 01         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L601A;
    }
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 6019: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
  case 0x601A:
L601A:
                                                     #ifdef DEBUG
                                      mon("L601A    LDA   <$28                    ; 601A: 96 28         \n");
                                      #endif
    PC = 0x601a; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x28); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L602F                   ; 601C: 26 11         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L602F;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4824                   ; 601E: B6 48 24      \n");
                                      #endif // Opt0_Shadow
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4824); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$80                    ; 6021: 84 80         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x80; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L602F                   ; 6023: 26 0A         \n");
                                      #endif // Check DIP switch for freeze mode
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L602F;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   <$31                    ; 6025: 96 31         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x31); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BITA  #$80                    ; 6027: 85 80         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A & (SINT8)0x80; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L6005                   ; 6029: 27 DA         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L6005;
    }
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$7F                    ; 602B: 84 7F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x7f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$31                    ; 602D: 97 31         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x31; 
    wr_mem(ea, val); 
  case 0x602F:
L602F:
                                                     #ifdef DEBUG
                                      mon("L602F    JSR   L60BE                   ; 602F: BD 60 BE      \n");
                                      #endif
    PC = 0x602f; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x32); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x60); 
    clockticks = clockticks + 1; 
    goto L60BE;
  case 0x6032:
L6032:
                                                     #ifdef DEBUG
                                      mon("L6032    LDA   <$3F                    ; 6032: 96 3F         \n");
                                      #endif // Vector pointer state
    PC = 0x6032; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x3f); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BMI   L6032                   ; 6034: 2B FC         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto L6032;
    }
  case 0x6036:
L6036:
                                                     #ifdef DEBUG
                                      mon("L6036    LDA   <$41                    ; 6036: 96 41         \n");
                                      #endif // Game mode/screen state
    PC = 0x6036; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x41); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$3D                    ; 6038: 81 3D         \n");
                                      #endif // Check game state for out of bounds
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x3d; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
  case 0x603A:
L603A:
                                                     #ifdef DEBUG
                                      mon("L603A    BCC   L603A                   ; 603A: 24 FE         \n");
                                      #endif
    PC = 0x603a; 
    INSTRUCTION_START
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto L603A;
    }
                                                     #ifdef DEBUG
                                      mon("         ASLA                          ; 603C: 48            \n");
                                      #endif
    val = (UINT8)A; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$6044                  ; 603D: 8E 60 44      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x6044; 
    Z = X; 
    N = (X) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   [A,X]                   ; 6040: AD 96         \n");
                                      #endif
    clockticks = clockticks + 3; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 2; 
    ea = rd_mem((UINT16)(X + (SINT8)A))<<8; 
    ea = ea | rd_mem((UINT16)(X + (SINT8)A + 1)); 
    --S;
    wr_mem(S, 0x42); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x60); 
    clockticks = clockticks + 1; 
    PC = ea; 
    JUMP;
    // End of function sub_6005
    // ---------------------------------------------------------------------------
  case 0x6042:
L6042:
                                                     #ifdef DEBUG
                                      mon("L6042    BRA   L6005                   ; 6042: 20 C1         \n");
                                      #endif
    PC = 0x6042; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto L6005;
    
    // =============== S U B R O U T I N E =======================================
  case 0x60BE:
L60BE:
                                                     #ifdef DEBUG
                                      mon("L60BE    INC   <$43                    ; 60BE: 0C 43         \n");
                                      #endif // Game over/insert coins timer
    PC = 0x60be; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x43); 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    wr_mem(DP|0x43, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L60CA                   ; 60C0: 26 08         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L60CA;
    }
                                                     #ifdef DEBUG
                                      mon("         INC   <$42                    ; 60C2: 0C 42         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x42); 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    wr_mem(DP|0x42, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L60CA                   ; 60C4: 26 04         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L60CA;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$80                    ; 60C6: 86 80         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x80; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$42                    ; 60C8: 97 42         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x42; 
    wr_mem(ea, val); 
  case 0x60CA:
L60CA:
                                                     #ifdef DEBUG
                                      mon("L60CA    LDA   $4814                   ; 60CA: B6 48 14      \n");
                                      #endif // Credits
    PC = 0x60ca; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4814); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L60D4                   ; 60CD: 26 05         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L60D4;
    }
                                                     #ifdef DEBUG
                                      mon("         STA   $4B31                   ; 60CF: B7 4B 31      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x4b31, val); 
                                                     #ifdef DEBUG
                                      mon("         BRA   L60F4                   ; 60D2: 20 20         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L60F4;
    
    // ---------------------------------------------------------------------------
  case 0x60D4:
L60D4:
                                                     #ifdef DEBUG
                                      mon("L60D4    LDA   $4B31                   ; 60D4: B6 4B 31      \n");
                                      #endif
    PC = 0x60d4; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b31); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L60E4                   ; 60D7: 26 0B         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L60E4;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   $BD12                   ; 60D9: BD BD 12      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xdc); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x60); 
    clockticks = clockticks + 1; 
    PC = 0xbd12; 
    JUMP;
  case 0x60DC:
L60DC:
                                                     #ifdef DEBUG
                                      mon("L60DC    LDA   $4814                   ; 60DC: B6 48 14      \n");
                                      #endif // Credits
    PC = 0x60dc; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4814); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B31                   ; 60DF: B7 4B 31      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x4b31, val); 
                                                     #ifdef DEBUG
                                      mon("         BRA   L60F4                   ; 60E2: 20 10         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L60F4;
    
    // ---------------------------------------------------------------------------
  case 0x60E4:
L60E4:
                                                     #ifdef DEBUG
                                      mon("L60E4    LDA   $4B31                   ; 60E4: B6 4B 31      \n");
                                      #endif
    PC = 0x60e4; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b31); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  $4814                   ; 60E7: B1 48 14      \n");
                                      #endif // Credits
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    arg = rd_mem(0x4814); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCC   L60F4                   ; 60EA: 24 08         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto L60F4;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   $BD03                   ; 60EC: BD BD 03      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xef); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x60); 
    clockticks = clockticks + 1; 
    PC = 0xbd03; 
    JUMP;
    // ---------------------------------------------------------------------------
  case 0x60EF:
L60EF:
                                                     #ifdef DEBUG
                                      mon("L60EF    LDA   #$FF                    ; 60EF: 86 FF         \n");
                                      #endif
    PC = 0x60ef; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0xff; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B31                   ; 60F1: B7 4B 31      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b31, val); 
  case 0x60F4:
L60F4:
                                                     #ifdef DEBUG
                                      mon("L60F4    JSR   L70DB                   ; 60F4: BD 70 DB      \n");
                                      #endif
    PC = 0x60f4; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf7); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x60); 
    clockticks = clockticks + 1; 
    goto L70DB;
  case 0x60F7:
L60F7:
                                                     #ifdef DEBUG
                                      mon("L60F7    LDA   <$AB                    ; 60F7: 96 AB         \n");
                                      #endif
    PC = 0x60f7; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xab); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$AA                    ; 60F9: 97 AA         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xaa; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$21                    ; 60FB: 96 21         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x21); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$30                    ; 60FD: 84 30         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x30; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         PSHS  A                       ; 60FF: 34 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, A); 
    clockticks = clockticks + 1; 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$1E                    ; 6101: 96 1E         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x1e); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$CF                    ; 6103: 84 CF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0xcf; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORA   ,S+                     ; 6105: AA E0         \n");
                                      #endif
    clockticks = clockticks + 6; 
    res = A | (UINT8)rd_mem(S); 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
    S = S + 1; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$F4                    ; 6107: 84 F4         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0xf4; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$AB                    ; 6109: 97 AB         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xab; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         EORA  <$AA                    ; 610B: 98 AA         \n");
                                      #endif
    clockticks = clockticks + 4; 
    res = A ^ rd_mem(DP|0xaa); 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  <$AA                    ; 610D: 94 AA         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)A; 
    res = val & rd_mem(DP|0xaa); 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$AC                    ; 610F: 97 AC         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0xac; 
    wr_mem(ea, val); 
    // End of function sub_60BE
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 6111: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Insert vector data for four blue dots in screen corners
  case 0x6112:
L6112:
                                                     #ifdef DEBUG
                                      mon("L6112    LDA   <$3F                    ; 6112: 96 3F         \n");
                                      #endif // Vector pointer state
    PC = 0x6112; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x3f); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$70                    ; 6114: C6 70         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x70; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         TFR   D,Y                     ; 6116: 1F 02         \n");
                                      #endif // Set new vector pointer value
    Y = ((A << 8) | B); 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$B99E                  ; 6118: CC B9 9E      \n");
                                      #endif // Vector JRSL to draw four blue dots in screen corners
    clockticks = clockticks + 3; 
    A = 0xb9; 
    B = 0x9e; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 611B: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
    // End of function sub_6112
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 611D: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Copies Star Wars logo vector data to vector RAM
  case 0x611E:
L611E:
                                                     #ifdef DEBUG
                                      mon("L611E    LDX   #$CEDE                  ; 611E: 8E CE DE      \n");
                                      #endif // Copies vector data. Called at start of attract screen 2
    PC = 0x611e; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0xcede; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #$2800                  ; 6121: CE 28 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x2800; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0x6124:
L6124:
                                                     #ifdef DEBUG
                                      mon("L6124    LDD   ,X++                    ; 6124: EC 81         \n");
                                      #endif
    PC = 0x6124; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
    A = rd_mem(X); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(X+1)); 
    X = X + 2; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,U++                    ; 6126: ED C1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = U; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    U = U + 2; 
                                                     #ifdef DEBUG
                                      mon("         CMPU  #$3000                  ; 6128: 11 83 30 00   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
    arg = 0x3000; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   L6124                   ; 612C: 25 F6         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L6124;
    }
    // End of function sub_611E
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 612E: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Vector instructions end
  case 0x612F:
L612F:
                                                     #ifdef DEBUG
                                      mon("L612F    LDD   #$8040                  ; 612F: CC 80 40      \n");
                                      #endif
    PC = 0x612f; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 6132: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$2020                  ; 6134: CC 20 20      \n");
                                      #endif // Vector HALT
    clockticks = clockticks + 3; 
    A = 0x20; 
    B = 0x20; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 6137: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y+                     ; 6139: ED A0         \n");
                                      #endif
    clockticks = clockticks + 6; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 1; 
                                                     #ifdef DEBUG
                                      mon("         TFR   Y,D                     ; 613B: 1F 20         \n");
                                      #endif
    val = Y; 
    A = (UINT8)(val >> 8); 
    B = (UINT8)val; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         SUBA  <$3F                    ; 613D: 90 3F         \n");
                                      #endif // Vector pointer state
    clockticks = clockticks + 4; 
    val = (UINT8)A; 
    arg = rd_mem(DP|0x3f); 
    res = val - (UINT8)arg; 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)(res); 
                                                     #ifdef DEBUG
                                      mon("         SUBA  #$14                    ; 613F: 80 14         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x14; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)(res); 
                                                     #ifdef DEBUG
                                      mon("         BCS   L6155                   ; 6141: 25 12         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L6155;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   L611E                   ; 6143: BD 61 1E      \n");
                                      #endif // Copies Star Wars logo vector data to vector RAM
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x46); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x61); 
    clockticks = clockticks + 1; 
    goto L611E;
  case 0x6146:
L6146:
                                                     #ifdef DEBUG
                                      mon("L6146    LDD   #$2020                  ; 6146: CC 20 20      \n");
                                      #endif
    PC = 0x6146; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x20; 
    B = 0x20; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $13FE                   ; 6149: FD 13 FE      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x13fe, A); // Care needed with I/O space and word fetches
    wr_mem(0x13ff, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $13FC                   ; 614C: FD 13 FC      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x13fc, A); // Care needed with I/O space and word fetches
    wr_mem(0x13fd, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $27FE                   ; 614F: FD 27 FE      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x27fe, A); // Care needed with I/O space and word fetches
    wr_mem(0x27ff, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $27FC                   ; 6152: FD 27 FC      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x27fc, A); // Care needed with I/O space and word fetches
    wr_mem(0x27fd, B); 
  case 0x6155:
L6155:
                                                     #ifdef DEBUG
                                      mon("L6155    LDA   #$FF                    ; 6155: 86 FF         \n");
                                      #endif
    PC = 0x6155; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0xff; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$3F                    ; 6157: 97 3F         \n");
                                      #endif // Vector pointer state
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0x3f; 
    wr_mem(ea, val); 
    // End of function sub_612F
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 6159: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // More stars/ties init stuff
  case 0x615A:
L615A:
                                                     #ifdef DEBUG
                                      mon("L615A    JSR   L6161                   ; 615A: BD 61 61      \n");
                                      #endif // Initialise tie fighters and fireballs
    PC = 0x615a; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x5d); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x61); 
    clockticks = clockticks + 1; 
    goto L6161;
  case 0x615D:
L615D:
                                                     #ifdef DEBUG
                                      mon("L615D    JSR   L7A48                   ; 615D: BD 7A 48      \n");
                                      #endif
    PC = 0x615d; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x60); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x61); 
    clockticks = clockticks + 1; 
    goto L7A48;
    // End of function sub_615A
  case 0x6160:
L6160:
                                                     #ifdef DEBUG
                                      mon("L6160    RTS                           ; 6160: 39            \n");
                                      #endif
    PC = 0x6160; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Initialise tie fighters and fireballs
  case 0x6161:
L6161:
                                                     #ifdef DEBUG
                                      mon("L6161    LDA   $4703                   ; 6161: B6 47 03      \n");
                                      #endif
    PC = 0x6161; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBA  $4703                   ; 6164: B0 47 03      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    arg = rd_mem(0x4703); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)(res); 
                                                     #ifdef DEBUG
                                      mon("         BNE   L6171                   ; 6167: 26 08         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L6171;
    }
                                                     #ifdef DEBUG
                                      mon("         STA   $4685                   ; 6169: B7 46 85      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4685, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$80                    ; 616C: 86 80         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x80; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4685                   ; 616E: B7 46 85      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4685, val); 
  case 0x6171:
L6171:
                                                     #ifdef DEBUG
                                      mon("L6171    LDA   #$80                    ; 6171: 86 80         \n");
                                      #endif
    PC = 0x6171; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x80; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$83                    ; 6173: 97 83         \n");
                                      #endif // Star intensity
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x83; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4900                  ; 6175: 8E 49 00      \n");
                                      #endif // 3x Tie fighter data structure ($19 bytes per Tie)
    clockticks = clockticks + 3; 
    X = 0x4900; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #$50F0                  ; 6178: CE 50 F0      \n");
                                      #endif // 3x Tie fighter math data structure ($20 bytes per Tie)
    clockticks = clockticks + 3; 
    U = 0x50f0; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$1C                    ; 617B: C6 1C         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x1c; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0x617D:
L617D:
                                                     #ifdef DEBUG
                                      mon("L617D    STU   ,X                      ; 617D: EF 84         \n");
                                      #endif
    PC = 0x617d; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = X; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         STB   $02,X                   ; 617F: E7 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0002); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LEAU  $20,U                   ; 6181: 33 C8 20      \n");
                                      #endif
    clockticks = clockticks + 5; 
    U = (U + (SINT8)0x20); 
                                                     #ifdef DEBUG
                                      mon("         ADDB  #$04                    ; 6184: CB 04         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x04; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         LEAX  $19,X                   ; 6186: 30 88 19      \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + (SINT8)0x19); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$494B                  ; 6189: 8C 49 4B      \n");
                                      #endif // 3x Tie fighter data structure ($19 bytes per Tie)
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x494b; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   L617D                   ; 618C: 25 EF         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L617D;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   #$494B                  ; 618E: 8E 49 4B      \n");
                                      #endif // 6x Fireball data structure 2 ($6 bytes per fireball)
    clockticks = clockticks + 3; 
    X = 0x494b; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #$5160                  ; 6191: CE 51 60      \n");
                                      #endif // 6x Fireball math data structure 2 ($8 bytes per Tie)
    clockticks = clockticks + 3; 
    U = 0x5160; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$2C                    ; 6194: C6 2C         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x2c; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0x6196:
L6196:
                                                     #ifdef DEBUG
                                      mon("L6196    STU   ,X                      ; 6196: EF 84         \n");
                                      #endif
    PC = 0x6196; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = X; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         STB   $02,X                   ; 6198: E7 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0002); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         CLR   $03,X                   ; 619A: 6F 03         \n");
                                      #endif
    clockticks = clockticks + 5; 
    wr_mem((UINT16)(X + 0x0003), 0); 
 // V = 0; 
 // Z = 0; 
 // N = 0; 
 // C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LEAU  $08,U                   ; 619C: 33 48         \n");
                                      #endif
    clockticks = clockticks + 5; 
    U = (U + 0x0008); 
                                                     #ifdef DEBUG
                                      mon("         ADDB  #$01                    ; 619E: CB 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x01; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         LEAX  $06,X                   ; 61A0: 30 06         \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + 0x0006); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$496F                  ; 61A2: 8C 49 6F      \n");
                                      #endif // 6x Fireball data structure 2 ($6 bytes per fireball)
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x496f; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   L6196                   ; 61A5: 25 EF         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L6196;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   $8ED6                   ; 61A7: BD 8E D6      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xaa); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x61); 
    clockticks = clockticks + 1; 
    PC = 0x8ed6; 
    JUMP;
  case 0x61AA:
L61AA:
                                                     #ifdef DEBUG
                                      mon("L61AA    LDB   #$04                    ; 61AA: C6 04         \n");
                                      #endif
    PC = 0x61aa; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x04; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $CCCC                   ; 61AC: BD CC CC      \n");
                                      #endif // Copy XYZ data to math RAM
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xaf); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x61); 
    clockticks = clockticks + 1; 
    PC = 0xcccc; 
    JUMP;
  case 0x61AF:
L61AF:
                                                     #ifdef DEBUG
                                      mon("L61AF    LDB   #$07                    ; 61AF: C6 07         \n");
                                      #endif
    PC = 0x61af; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x07; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $CCCC                   ; 61B1: BD CC CC      \n");
                                      #endif // Copy XYZ data to math RAM
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xb4); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x61); 
    clockticks = clockticks + 1; 
    PC = 0xcccc; 
    JUMP;
    // End of function sub_6161
  case 0x61B4:
L61B4:
                                                     #ifdef DEBUG
                                      mon("L61B4    RTS                           ; 61B4: 39            \n");
                                      #endif
    PC = 0x61b4; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Set up math constants
  case 0x61B5:
L61B5:
                                                     #ifdef DEBUG
                                      mon("L61B5    LDD   #$00                    ; 61B5: CC 00 00      \n");
                                      #endif
    PC = 0x61b5; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $501E                   ; 61B8: FD 50 1E      \n");
                                      #endif // Math zero constant
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x501e, A); // Care needed with I/O space and word fetches
    wr_mem(0x501f, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$4000                  ; 61BB: CC 40 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x40; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5020                   ; 61BE: FD 50 20      \n");
                                      #endif // Math 1.000 constant
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5020, A); // Care needed with I/O space and word fetches
    wr_mem(0x5021, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$E000                  ; 61C1: CC E0 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xe0; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5026                   ; 61C4: FD 50 26      \n");
                                      #endif // Constant -0.5 ?
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5026, A); // Care needed with I/O space and word fetches
    wr_mem(0x5027, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$80                    ; 61C7: CC 00 80      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $506A                   ; 61CA: FD 50 6A      \n");
                                      #endif // Math Constant $0080
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x506a, A); // Care needed with I/O space and word fetches
    wr_mem(0x506b, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$40                    ; 61CD: CC 00 40      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5068                   ; 61D0: FD 50 68      \n");
                                      #endif // Math Constant $0040
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5068, A); // Care needed with I/O space and word fetches
    wr_mem(0x5069, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$021F                  ; 61D3: CC 02 1F      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x02; 
    B = 0x1f; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5022                   ; 61D6: FD 50 22      \n");
                                      #endif // Sine for rotation
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5022, A); // Care needed with I/O space and word fetches
    wr_mem(0x5023, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$3FF7                  ; 61D9: CC 3F F7      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x3f; 
    B = 0xf7; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5024                   ; 61DC: FD 50 24      \n");
                                      #endif // Cosine for rotation
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5024, A); // Care needed with I/O space and word fetches
    wr_mem(0x5025, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$4000                  ; 61DF: CC 40 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x40; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $506C                   ; 61E2: FD 50 6C      \n");
                                      #endif // Math 1.000 constant
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x506c, A); // Care needed with I/O space and word fetches
    wr_mem(0x506d, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0200                  ; 61E5: CC 02 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x02; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4706                   ; 61E8: FD 47 06      \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x4706, A); // Care needed with I/O space and word fetches
    wr_mem(0x4707, B); 
    // End of function sub_61B5
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 61EB: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Init stars math data
  case 0x61EC:
L61EC:
                                                     #ifdef DEBUG
                                      mon("L61EC    LDA   #$80                    ; 61EC: 86 80         \n");
                                      #endif
    PC = 0x61ec; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x80; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$83                    ; 61EE: 97 83         \n");
                                      #endif // Star intensity
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x83; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$5C60                  ; 61F0: 8E 5C 60      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x5c60; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0x61F3:
L61F3:
                                                     #ifdef DEBUG
                                      mon("L61F3    LDA   $4703                   ; 61F3: B6 47 03      \n");
                                      #endif
    PC = 0x61f3; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $4703                   ; 61F6: F6 47 03      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,X                      ; 61F9: ED 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         MUL                           ; 61FB: 3D            \n");
                                      #endif
    res = (UINT16)(A * B); 
 // Z = res; 
 // C = res & 0x80; 
    A = res >> 8; 
    B = (UINT8)res; 
    clockticks = clockticks + 11; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4703                   ; 61FC: B6 47 03      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $02,X                   ; 61FF: ED 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x0002); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         MUL                           ; 6201: 3D            \n");
                                      #endif
    res = (UINT16)(A * B); 
 // Z = res; 
 // C = res & 0x80; 
    A = res >> 8; 
    B = (UINT8)res; 
    clockticks = clockticks + 11; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4703                   ; 6202: B6 47 03      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $04,X                   ; 6205: ED 04         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x0004); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LEAX  $08,X                   ; 6207: 30 08         \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + 0x0008); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$5DF0                  ; 6209: 8C 5D F0      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x5df0; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   L61F3                   ; 620C: 25 E5         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L61F3;
    }
    // End of function sub_61EC
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 620E: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Init towers surface dots
  case 0x620F:
L620F:
                                                     #ifdef DEBUG
                                      mon("L620F    LDX   #$5C60                  ; 620F: 8E 5C 60      \n");
                                      #endif
    PC = 0x620f; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x5c60; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0x6212:
L6212:
                                                     #ifdef DEBUG
                                      mon("L6212    LDA   $4703                   ; 6212: B6 47 03      \n");
                                      #endif
    PC = 0x6212; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $4703                   ; 6215: F6 47 03      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,X                      ; 6218: ED 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = X; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         MUL                           ; 621A: 3D            \n");
                                      #endif
    res = (UINT16)(A * B); 
 // Z = res; 
 // C = res & 0x80; 
    A = res >> 8; 
    B = (UINT8)res; 
    clockticks = clockticks + 11; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4703                   ; 621B: B6 47 03      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $02,X                   ; 621E: ED 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x0002); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; 6220: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $04,X                   ; 6223: ED 04         \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + 0x0004); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LEAX  $08,X                   ; 6225: 30 08         \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + 0x0008); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$5DF0                  ; 6227: 8C 5D F0      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x5df0; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   L6212                   ; 622A: 25 E6         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L6212;
    }
    // End of function sub_620F
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 622C: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Check joystick X to show high scores if moved
  case 0x622D:
L622D:
                                                     #ifdef DEBUG
                                      mon("L622D    LDB   <$7D                    ; 622D: D6 7D         \n");
                                      #endif // Joystick X
    PC = 0x622d; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x7d); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$A0                    ; 622F: C1 A0         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0xa0; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BGT   L623E                   ; 6231: 2E 0B         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto L623E;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$08                    ; 6233: 86 08         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x08; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  <$41                    ; 6235: 91 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = (UINT8)A; 
    arg = rd_mem(DP|0x41); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L623C                   ; 6237: 27 03         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L623C;
    }
                                                     #ifdef DEBUG
                                      mon("         DECA                          ; 6239: 4A            \n");
                                      #endif
    val = (UINT8)A; 
    res = (UINT8)(val - 1); 
 // N = res; 
 // Z = res; 
 // V = val & ~res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$41                    ; 623A: 97 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0x41; 
    wr_mem(ea, val); 
  case 0x623C:
L623C:
                                                     #ifdef DEBUG
                                      mon("L623C    BRA   L624B                   ; 623C: 20 0D         \n");
                                      #endif
    PC = 0x623c; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto L624B;
    
    // ---------------------------------------------------------------------------
  case 0x623E:
L623E:
                                                     #ifdef DEBUG
                                      mon("L623E    CMPB  #$60                    ; 623E: C1 60         \n");
                                      #endif
    PC = 0x623e; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x60; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BLT   L624B                   ; 6240: 2D 09         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 3; 
    goto L624B;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$0C                    ; 6242: 86 0C         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x0c; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  <$41                    ; 6244: 91 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = (UINT8)A; 
    arg = rd_mem(DP|0x41); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L624B                   ; 6246: 27 03         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L624B;
    }
                                                     #ifdef DEBUG
                                      mon("         DECA                          ; 6248: 4A            \n");
                                      #endif
    val = (UINT8)A; 
    res = (UINT8)(val - 1); 
 // N = res; 
 // Z = res; 
 // V = val & ~res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$41                    ; 6249: 97 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x41; 
    wr_mem(ea, val); 
  case 0x624B:
L624B:
                                                     #ifdef DEBUG
                                      mon("L624B    LDA   $4591                   ; 624B: B6 45 91      \n");
                                      #endif
    PC = 0x624b; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4591); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$03                    ; 624E: 84 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x03; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L6257                   ; 6250: 26 05         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L6257;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$01                    ; 6252: 86 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x01; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4814                   ; 6254: B7 48 14      \n");
                                      #endif // Credits
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4814, val); 
  case 0x6257:
L6257:
                                                     #ifdef DEBUG
                                      mon("L6257    LDA   $4814                   ; 6257: B6 48 14      \n");
                                      #endif // Credits
    PC = 0x6257; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4814); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L6269                   ; 625A: 27 0D         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L6269;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   <$AC                    ; 625C: 96 AC         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xac); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$F0                    ; 625E: 84 F0         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0xf0; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L6269                   ; 6260: 27 07         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L6269;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$19                    ; 6262: 86 19         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x19; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$41                    ; 6264: 97 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x41; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         DEC   $4814                   ; 6266: 7A 48 14      \n");
                                      #endif // Credits
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4814); 
    res = (UINT8)(val - 1); 
 // N = res; 
 // Z = res; 
 // V = val & ~res; 
    wr_mem(0x4814, res); 
    clockticks = clockticks + 2; 
  case 0x6269:
L6269:
                                                     #ifdef DEBUG
                                      mon("L6269    LDA   $481E                   ; 6269: B6 48 1E      \n");
                                      #endif
    PC = 0x6269; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x481e); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$10                    ; 626C: 84 10         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x10; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   locret_6274             ; 626E: 26 04         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L6274;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$01                    ; 6270: 86 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x01; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$41                    ; 6272: 97 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0x41; 
    wr_mem(ea, val); 
    // End of function sub_622D
  case 0x6274:
L6274:
locret_6274:
                                                     #ifdef DEBUG
                                      mon("locret_6274 RTS                           ; 6274: 39            \n");
                                      #endif
    PC = 0x6274; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Game initialisation
  case 0x6275:
L6275:
                                                     #ifdef DEBUG
                                      mon("L6275    ORCC  #$10                    ; 6275: 1A 10         \n");
                                      #endif // Disable interrupts
    PC = 0x6275; 
    INSTRUCTION_START
    I = 1; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4534                  ; 6277: 8E 45 34      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x4534; 
    Z = X; 
    N = (X) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $C6D4                   ; 627A: BD C6 D4      \n");
                                      #endif // Read NOVRAM
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x7d); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x62); 
    clockticks = clockticks + 1; 
    PC = 0xc6d4; 
    JUMP;
  case 0x627D:
L627D:
                                                     #ifdef DEBUG
                                      mon("L627D    LDX   #$4AFA                  ; 627D: 8E 4A FA      \n");
                                      #endif
    PC = 0x627d; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x4afa; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   L62D5                   ; 6280: BD 62 D5      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x83); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x62); 
    clockticks = clockticks + 1; 
    goto L62D5;
  case 0x6283:
L6283:
                                                     #ifdef DEBUG
                                      mon("L6283    STA   $4866                   ; 6283: B7 48 66      \n");
                                      #endif // Joystick pitch data structure
    PC = 0x6283; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4866, val); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4AFB                  ; 6286: 8E 4A FB      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x4afb; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   L62D5                   ; 6289: BD 62 D5      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x8c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x62); 
    clockticks = clockticks + 1; 
    goto L62D5;
  case 0x628C:
L628C:
                                                     #ifdef DEBUG
                                      mon("L628C    STA   $4868                   ; 628C: B7 48 68      \n");
                                      #endif
    PC = 0x628c; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4868, val); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4AFC                  ; 628F: 8E 4A FC      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x4afc; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   L62D5                   ; 6292: BD 62 D5      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x95); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x62); 
    clockticks = clockticks + 1; 
    goto L62D5;
  case 0x6295:
L6295:
                                                     #ifdef DEBUG
                                      mon("L6295    STA   $486F                   ; 6295: B7 48 6F      \n");
                                      #endif // Joystick roll data structure
    PC = 0x6295; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x486f, val); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4AFD                  ; 6298: 8E 4A FD      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x4afd; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   L62D5                   ; 629B: BD 62 D5      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x9e); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x62); 
    clockticks = clockticks + 1; 
    goto L62D5;
  case 0x629E:
L629E:
                                                     #ifdef DEBUG
                                      mon("L629E    STA   $4871                   ; 629E: B7 48 71      \n");
                                      #endif
    PC = 0x629e; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4871, val); 
                                                     #ifdef DEBUG
                                      mon("         ANDCC #$EF                    ; 62A1: 1C EF         \n");
                                      #endif // n      ; Enable interrupts
    I = 0; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$0B                    ; 62A3: 86 0B         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x0b; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$41                    ; 62A5: 97 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x41; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$FF                    ; 62A7: 86 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xff; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B34                   ; 62A9: B7 4B 34      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x4b34, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   L61B5                   ; 62AC: BD 61 B5      \n");
                                      #endif // Set up math constants
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xaf); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x62); 
    clockticks = clockticks + 1; 
    goto L61B5;
  case 0x62AF:
L62AF:
                                                     #ifdef DEBUG
                                      mon("L62AF    JSR   L615A                   ; 62AF: BD 61 5A      \n");
                                      #endif // More stars/ties init stuff
    PC = 0x62af; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xb2); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x62); 
    clockticks = clockticks + 1; 
    goto L615A;
  case 0x62B2:
L62B2:
                                                     #ifdef DEBUG
                                      mon("L62B2    JSR   L611E                   ; 62B2: BD 61 1E      \n");
                                      #endif // Copies Star Wars logo vector data to vector RAM
    PC = 0x62b2; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xb5); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x62); 
    clockticks = clockticks + 1; 
    goto L611E;
  case 0x62B5:
L62B5:
                                                     #ifdef DEBUG
                                      mon("L62B5    JSR   L61EC                   ; 62B5: BD 61 EC      \n");
                                      #endif // Init stars math data
    PC = 0x62b5; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xb8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x62); 
    clockticks = clockticks + 1; 
    goto L61EC;
  case 0x62B8:
L62B8:
                                                     #ifdef DEBUG
                                      mon("L62B8    JSR   $D91A                   ; 62B8: BD D9 1A      \n");
                                      #endif
    PC = 0x62b8; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xbb); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x62); 
    clockticks = clockticks + 1; 
    PC = 0xd91a; 
    JUMP;
  case 0x62BB:
L62BB:
                                                     #ifdef DEBUG
                                      mon("L62BB    LDA   #$00                    ; 62BB: 86 00         \n");
                                      #endif
    PC = 0x62bb; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$5C                    ; 62BD: 97 5C         \n");
                                      #endif // Score millions
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x5c; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   <$5D                    ; 62BF: 97 5D         \n");
                                      #endif // Score hundred thousands
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x5d; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   <$5E                    ; 62C1: 97 5E         \n");
                                      #endif // Score thousands
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x5e; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   <$5F                    ; 62C3: 97 5F         \n");
                                      #endif // Score
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x5f; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   <$8B                    ; 62C5: 97 8B         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x8b; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   <$8C                    ; 62C7: 97 8C         \n");
                                      #endif // Sheild being depleted
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0x8c; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   $CC18                   ; 62C9: BD CC 18      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xcc); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x62); 
    clockticks = clockticks + 1; 
    PC = 0xcc18; 
    JUMP;
  case 0x62CC:
L62CC:
                                                     #ifdef DEBUG
                                      mon("L62CC    LDA   #$FF                    ; 62CC: 86 FF         \n");
                                      #endif
    PC = 0x62cc; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0xff; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4AEC                   ; 62CE: B7 4A EC      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4aec, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   $4818                   ; 62D1: B7 48 18      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x4818, val); 
    // End of function sub_6275
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 62D4: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x62D5:
L62D5:
                                                     #ifdef DEBUG
                                      mon("L62D5    LDA   #$40                    ; 62D5: 86 40         \n");
                                      #endif
    PC = 0x62d5; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x40; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  ,X                      ; 62D7: A1 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)A; 
    arg = rd_mem(X); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BLS   locret_62E3             ; 62D9: 23 08         \n");
                                      #endif
    // temp hack to force a flush
    if ((!Z) || C) {
    clockticks = clockticks + 3; 
    goto L62E3;
    }
                                                     #ifdef DEBUG
                                      mon("         SUBA  ,X                      ; 62DB: A0 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)A; 
    arg = rd_mem(X); 
    res = val - (UINT8)arg; 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)(res); 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; 62DD: 44            \n");
                                      #endif
    val = (UINT8)A; 
 // C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; 62DE: 44            \n");
                                      #endif
    val = (UINT8)A; 
 // C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; 62DF: 44            \n");
                                      #endif
    val = (UINT8)A; 
 // C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         INCA                          ; 62E0: 4C            \n");
                                      #endif
    val = (UINT8)A; 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ADDA  ,X                      ; 62E1: AB 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)A; 
    arg = rd_mem(X); 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
    V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
    // End of function sub_62D5
  case 0x62E3:
L62E3:
locret_62E3:
                                                     #ifdef DEBUG
                                      mon("locret_62E3 RTS                           ; 62E3: 39            \n");
                                      #endif
    PC = 0x62e3; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Called once before attract screen 3
  case 0x62E4:
L62E4:
if (reduceLinesDisplayTo != 0) {displayedLineCount = 0;}
                                                     #ifdef DEBUG
                                      mon("L62E4    LDD   #$00                    ; 62E4: CC 00 00      \n");
                                      #endif
    PC = 0x62e4; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B0C                   ; 62E7: FD 4B 0C      \n");
                                      #endif // Attract text position for scrolling
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4b0c, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b0d, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0200                  ; 62EA: CC 02 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x02; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B0E                   ; 62ED: FD 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4b0e, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b0f, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$0F                    ; 62F0: 86 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x0f; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4ADB                   ; 62F2: B7 4A DB      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4adb, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$1F                    ; 62F5: 86 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x1f; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4ADC                   ; 62F7: B7 4A DC      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4adc, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$6480                  ; 62FA: CC 64 80      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x64; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B10                   ; 62FD: FD 4B 10      \n");
                                      #endif // Attract text colour/intensity for fading
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x4b10, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b11, B); 
                                                     #ifdef DEBUG
                                      mon("         JSR   $D91A                   ; 6300: BD D9 1A      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x03); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x63); 
    clockticks = clockticks + 1; 
    PC = 0xd91a; 
    JUMP;
  case 0x6303:
L6303:
                                                     #ifdef DEBUG
                                      mon("L6303    INC   <$41                    ; 6303: 0C 41         \n");
                                      #endif // Game mode/screen state
    PC = 0x6303; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x41); 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    wr_mem(DP|0x41, res); 
    clockticks = clockticks + 2; 
    // End of function sub_62E4
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 6305: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Attract screen 3
  case 0x6306:
L6306:
                                                     #ifdef DEBUG
                                      mon("L6306    JSR   L6112                   ; 6306: BD 61 12      \n");
                                      #endif // Insert vector data for four blue dots in screen corners
    PC = 0x6306; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x09); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x63); 
    clockticks = clockticks + 1; 
    goto L6112;
  case 0x6309:
L6309:
                                                     #ifdef DEBUG
                                      mon("L6309    JSR   L761D                   ; 6309: BD 76 1D      \n");
                                      #endif // Display score
    PC = 0x6309; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x0c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x63); 
    clockticks = clockticks + 1; 
    goto L761D;
  case 0x630C:
L630C:
                                                     #ifdef DEBUG
                                      mon("L630C    JSR   L63D5                   ; 630C: BD 63 D5      \n");
                                      #endif // Check credits status
    PC = 0x630c; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x0f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x63); 
    clockticks = clockticks + 1; 
    goto L63D5;
  case 0x630F:
L630F:
if (reduceLinesDisplayTo != 0) inAttract3 = 1;
                                                     #ifdef DEBUG
                                      mon("L630F    JSR   L6368                   ; 630F: BD 63 68      \n");
                                      #endif
    PC = 0x630f; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x12); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x63); 
    clockticks = clockticks + 1; 
    goto L6368;
  case 0x6312:
L6312:
if (reduceLinesDisplayTo != 0) inAttract3 = 0;
                                                     #ifdef DEBUG
                                      mon("L6312    JSR   $CD80                   ; 6312: BD CD 80      \n");
                                      #endif // Starfield
    PC = 0x6312; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x15); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x63); 
    clockticks = clockticks + 1; 
    PC = 0xcd80; 
    JUMP;
  case 0x6315:
L6315:
                                                     #ifdef DEBUG
                                      mon("L6315    JSR   L612F                   ; 6315: BD 61 2F      \n");
                                      #endif // Vector instructions end
    PC = 0x6315; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x18); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x63); 
    clockticks = clockticks + 1; 
    goto L612F;
  case 0x6318:
L6318:
                                                     #ifdef DEBUG
                                      mon("L6318    JSR   L6DB6                   ; 6318: BD 6D B6      \n");
                                      #endif // Attract screen 3 stars YT move
    PC = 0x6318; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x1b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x63); 
    clockticks = clockticks + 1; 
    goto L6DB6;
  case 0x631B:
L631B:
                                                     #ifdef DEBUG
                                      mon("L631B    LDD   $4B0E                   ; 631B: FC 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    PC = 0x631b; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x4b0e); // Care needed with I/O space and word fetches
    B = rd_mem(0x4b0f); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BPL   L6322                   ; 631E: 2A 02         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto L6322;
    }
                                                     #ifdef DEBUG
                                      mon("         INC   <$41                    ; 6320: 0C 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x41); 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    wr_mem(DP|0x41, res); 
    clockticks = clockticks + 2; 
  case 0x6322:
L6322:
                                                     #ifdef DEBUG
                                      mon("L6322    JSR   L622D                   ; 6322: BD 62 2D      \n");
                                      #endif // Check joystick X to show high scores if moved
    PC = 0x6322; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x25); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x63); 
    clockticks = clockticks + 1; 
    goto L622D;
    // End of function sub_6306
  case 0x6325:
L6325:
                                                     #ifdef DEBUG
                                      mon("L6325    RTS                           ; 6325: 39            \n");
                                      #endif
    PC = 0x6325; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x6326:
L6326:
if (reduceLinesDisplayTo != 0) {displayedLineCount = 0;}
                                                     #ifdef DEBUG
                                      mon("L6326    LDD   #$03C0                  ; 6326: CC 03 C0      \n");
                                      #endif // Called once before attract screen 4
    PC = 0x6326; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x03; 
    B = 0xc0; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B0C                   ; 6329: FD 4B 0C      \n");
                                      #endif // Attract text position for scrolling
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4b0c, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b0d, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0200                  ; 632C: CC 02 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x02; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B0E                   ; 632F: FD 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4b0e, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b0f, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$23                    ; 6332: 86 23         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x23; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4ADB                   ; 6334: B7 4A DB      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4adb, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$2C                    ; 6337: 86 2C         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x2c; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4ADC                   ; 6339: B7 4A DC      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4adc, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$6580                  ; 633C: CC 65 80      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x65; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B10                   ; 633F: FD 4B 10      \n");
                                      #endif // Attract text colour/intensity for fading
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x4b10, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b11, B); 
                                                     #ifdef DEBUG
                                      mon("         JSR   $D91A                   ; 6342: BD D9 1A      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x45); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x63); 
    clockticks = clockticks + 1; 
    PC = 0xd91a; 
    JUMP;
  case 0x6345:
L6345:
                                                     #ifdef DEBUG
                                      mon("L6345    INC   <$41                    ; 6345: 0C 41         \n");
                                      #endif // Game mode/screen state
    PC = 0x6345; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x41); 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    wr_mem(DP|0x41, res); 
    clockticks = clockticks + 2; 
    // End of function sub_6326
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 6347: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Attract screen 4
  case 0x6348:
L6348:
                                                     #ifdef DEBUG
                                      mon("L6348    JSR   L6112                   ; 6348: BD 61 12      \n");
                                      #endif // Insert vector data for four blue dots in screen corners
    PC = 0x6348; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x4b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x63); 
    clockticks = clockticks + 1; 
    goto L6112;
  case 0x634B:
L634B:
                                                     #ifdef DEBUG
                                      mon("L634B    JSR   L761D                   ; 634B: BD 76 1D      \n");
                                      #endif // Display score
    PC = 0x634b; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x4e); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x63); 
    clockticks = clockticks + 1; 
    goto L761D;
  case 0x634E:
L634E:
                                                     #ifdef DEBUG
                                      mon("L634E    JSR   L63D5                   ; 634E: BD 63 D5      \n");
                                      #endif // Check credits status
    PC = 0x634e; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x51); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x63); 
    clockticks = clockticks + 1; 
    goto L63D5;
  case 0x6351:
L6351:
if (reduceLinesDisplayTo != 0) inAttract4 = 1;
                                                     #ifdef DEBUG
                                      mon("L6351    JSR   L6368                   ; 6351: BD 63 68      \n");
                                      #endif
    PC = 0x6351; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x54); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x63); 
    clockticks = clockticks + 1; 
    goto L6368;
    
  case 0x6354:
L6354:
if (reduceLinesDisplayTo != 0) inAttract4 = 0;
                                                     #ifdef DEBUG
                                      mon("L6354    JSR   $CD80                   ; 6354: BD CD 80      \n");
                                      #endif // Starfield
    PC = 0x6354; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x57); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x63); 
    clockticks = clockticks + 1; 
    PC = 0xcd80; 
    JUMP;
  case 0x6357:
L6357:
                                                     #ifdef DEBUG
                                      mon("L6357    JSR   L612F                   ; 6357: BD 61 2F      \n");
                                      #endif // Vector instructions end
    PC = 0x6357; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x5a); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x63); 
    clockticks = clockticks + 1; 
    goto L612F;
  case 0x635A:
L635A:
                                                     #ifdef DEBUG
                                      mon("L635A    JSR   L6DC0                   ; 635A: BD 6D C0      \n");
                                      #endif // Attract screen 4 stars ZT move
    PC = 0x635a; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x5d); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x63); 
    clockticks = clockticks + 1; 
    goto L6DC0;
  case 0x635D:
L635D:
                                                     #ifdef DEBUG
                                      mon("L635D    LDD   $4B0E                   ; 635D: FC 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    PC = 0x635d; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x4b0e); // Care needed with I/O space and word fetches
    B = rd_mem(0x4b0f); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BPL   L6364                   ; 6360: 2A 02         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto L6364;
    }
                                                     #ifdef DEBUG
                                      mon("         INC   <$41                    ; 6362: 0C 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x41); 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    wr_mem(DP|0x41, res); 
    clockticks = clockticks + 2; 
  case 0x6364:
L6364:
                                                     #ifdef DEBUG
                                      mon("L6364    JSR   L622D                   ; 6364: BD 62 2D      \n");
                                      #endif // Check joystick X to show high scores if moved
    PC = 0x6364; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x67); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x63); 
    clockticks = clockticks + 1; 
    goto L622D;
    // End of function sub_6348
  case 0x6367:
L6367:
                                                     #ifdef DEBUG
                                      mon("L6367    RTS                           ; 6367: 39            \n");
                                      #endif
    PC = 0x6367; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x6368:
L6368:
                                                     #ifdef DEBUG
                                      mon("L6368    LDD   $4B0E                   ; 6368: FC 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    PC = 0x6368; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x4b0e); // Care needed with I/O space and word fetches
    B = rd_mem(0x4b0f); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$01                    ; 636B: 83 00 01      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0001; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B0E                   ; 636E: FD 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4b0e, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b0f, B); 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$07                    ; 6371: C4 07         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x07; 
    B = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L639D                   ; 6373: 26 28         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L639D;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4ADB                   ; 6375: B6 4A DB      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4adb); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BMI   L637D                   ; 6378: 2B 03         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto L637D;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   $D8DF                   ; 637A: BD D8 DF      \n");
                                      #endif // Called from select screen, attract screen 1 + 3 when writing text
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x7d); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x63); 
    clockticks = clockticks + 1; 
    PC = 0xd8df; 
    JUMP;
  case 0x637D:
L637D:
                                                     #ifdef DEBUG
                                      mon("L637D    LDA   $4ADB                   ; 637D: B6 4A DB      \n");
                                      #endif
    PC = 0x637d; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4adb); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$12                    ; 6380: 81 12         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x12; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   L638E                   ; 6382: 26 0A         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L638E;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4593                   ; 6384: B6 45 93      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4593); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$03                    ; 6387: 84 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x03; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDA  #$1F                    ; 6389: 8B 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x1f; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
    V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $D8DF                   ; 638B: BD D8 DF      \n");
                                      #endif // Called from select screen, attract screen 1 + 3 when writing text
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x8e); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x63); 
    clockticks = clockticks + 1; 
    PC = 0xd8df; 
    JUMP;
  case 0x638E:
L638E:
                                                     #ifdef DEBUG
                                      mon("L638E    LDA   $4ADB                   ; 638E: B6 4A DB      \n");
                                      #endif
    PC = 0x638e; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4adb); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDA  #$01                    ; 6391: 8B 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x01; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  $4ADC                   ; 6393: B1 4A DC      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    arg = rd_mem(0x4adc); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   L639A                   ; 6396: 25 02         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L639A;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$80                    ; 6398: 86 80         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x80; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0x639A:
L639A:
                                                     #ifdef DEBUG
                                      mon("L639A    STA   $4ADB                   ; 639A: B7 4A DB      \n");
                                      #endif
    PC = 0x639a; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4adb, val); 
  case 0x639D:
L639D:
                                                     #ifdef DEBUG
                                      mon("L639D    LDD   $4B0C                   ; 639D: FC 4B 0C      \n");
                                      #endif // Attract text position for scrolling
    PC = 0x639d; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x4b0c); // Care needed with I/O space and word fetches
    B = rd_mem(0x4b0d); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$08                    ; 63A0: 83 00 08      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0008; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BPL   L63A8                   ; 63A3: 2A 03         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto L63A8;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; 63A5: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0x63A8:
L63A8:
                                                     #ifdef DEBUG
                                      mon("L63A8    STD   $4B0C                   ; 63A8: FD 4B 0C      \n");
                                      #endif // Attract text position for scrolling
    PC = 0x63a8; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4b0c, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b0d, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $4B0E                   ; 63AB: FC 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    clockticks = clockticks + 5; 
    A = rd_mem(0x4b0e); // Care needed with I/O space and word fetches
    B = rd_mem(0x4b0f); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$C0                    ; 63AE: 10 83 00 C0   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x00c0; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCC   L63C6                   ; 63B2: 24 12         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto L63C6;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   $4B11                   ; 63B4: F6 4B 11      \n");
                                      #endif // Attract text intensity
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b11); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBB  #$01                    ; 63B7: C0 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x01; 
    res = val - (UINT8)arg; 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    B = (UINT8)(res); 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$10                    ; 63B9: C1 10         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x10; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCC   L63C3                   ; 63BB: 24 06         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto L63C3;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; 63BD: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B0E                   ; 63C0: FD 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4b0e, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b0f, B); 
  case 0x63C3:
L63C3:
                                                     #ifdef DEBUG
                                      mon("L63C3    STB   $4B11                   ; 63C3: F7 4B 11      \n");
                                      #endif // Attract text intensity
    PC = 0x63c3; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b11, val); 
  case 0x63C6:
L63C6:
                                                     #ifdef DEBUG
                                      mon("L63C6    LDD   $4B0C                   ; 63C6: FC 4B 0C      \n");
                                      #endif // Attract text position for scrolling
    PC = 0x63c6; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x4b0c); // Care needed with I/O space and word fetches
    B = rd_mem(0x4b0d); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $48AF                   ; 63C9: FD 48 AF      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x48af, A); // Care needed with I/O space and word fetches
    wr_mem(0x48b0, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $4B10                   ; 63CC: FC 4B 10      \n");
                                      #endif // Attract text colour/intensity for fading
    clockticks = clockticks + 5; 
    A = rd_mem(0x4b10); // Care needed with I/O space and word fetches
    B = rd_mem(0x4b11); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 63CF: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $D942                   ; 63D1: BD D9 42      \n");
                                      #endif // Called from Attract screen 3 + 4
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xd4); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x63); 
    clockticks = clockticks + 1; 
    PC = 0xd942; 
    JUMP;
    // End of function sub_6368
  case 0x63D4:
L63D4:
                                                     #ifdef DEBUG
                                      mon("L63D4    RTS                           ; 63D4: 39            \n");
                                      #endif
    PC = 0x63d4; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Check credits status
  case 0x63D5:
L63D5:
                                                     #ifdef DEBUG
                                      mon("L63D5    LDA   $4814                   ; 63D5: B6 48 14      \n");
                                      #endif // Credits
    PC = 0x63d5; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4814); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L63EB                   ; 63D8: 26 11         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L63EB;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   <$43                    ; 63DA: 96 43         \n");
                                      #endif // Game over/insert coins timer
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x43); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$10                    ; 63DC: 84 10         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x10; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L63E4                   ; 63DE: 26 04         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L63E4;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   #$06                    ; 63E0: C6 06         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x06; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   L63E6                   ; 63E2: 20 02         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L63E6;
    
    // ---------------------------------------------------------------------------
  case 0x63E4:
L63E4:
                                                     #ifdef DEBUG
                                      mon("L63E4    LDB   #$05                    ; 63E4: C6 05         \n");
                                      #endif
    PC = 0x63e4; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x05; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
  case 0x63E6:
L63E6:

                                                     #ifdef DEBUG
                                      mon("L63E6    JSR   $E7C7                   ; 63E6: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    PC = 0x63e6; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xe9); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x63); 
    clockticks = clockticks + 1; 
    PC = 0xe7c7; 
    JUMP;
    
    
  case 0x63E9:
L63E9:
                                                     #ifdef DEBUG
                                      mon("L63E9    BRA   L63F0                   ; 63E9: 20 05         \n");
                                      #endif
    PC = 0x63e9; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto L63F0;
    
    // ---------------------------------------------------------------------------
  case 0x63EB:
L63EB:
                                                     #ifdef DEBUG
                                      mon("L63EB    LDB   #$0B                    ; 63EB: C6 0B         \n");
                                      #endif
    PC = 0x63eb; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x0b; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $E7C7                   ; 63ED: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf0); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x63); 
    clockticks = clockticks + 1; 
    PC = 0xe7c7; 
    JUMP;
  case 0x63F0:
L63F0:
if (noCoinInfo) goto locret_6458;
                                                     #ifdef DEBUG
                                      mon("L63F0    LDA   $4814                   ; 63F0: B6 48 14      \n");
                                      #endif // Credits
    PC = 0x63f0; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4814); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L6410                   ; 63F3: 26 1B         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L6410;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4812                   ; 63F5: B6 48 12      \n");
                                      #endif // Half credit
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4812); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L6404                   ; 63F8: 27 0A         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L6404;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   <$43                    ; 63FA: 96 43         \n");
                                      #endif // Game over/insert coins timer
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x43); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$10                    ; 63FC: 84 10         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x10; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L6404                   ; 63FE: 27 04         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L6404;
    }
                                                     #ifdef DEBUG
                                      mon("         BRA   L6410                   ; 6400: 20 0E         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L6410;
    
    // ---------------------------------------------------------------------------
                                                     #ifdef DEBUG
                                      mon("         BRA   L640E                   ; 6402: 20 0A         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L640E;
    
    // ---------------------------------------------------------------------------
  case 0x6404:
L6404:
                                                     #ifdef DEBUG
                                      mon("L6404    LDB   $4591                   ; 6404: F6 45 91      \n");
                                      #endif
    PC = 0x6404; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4591); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$03                    ; 6407: C4 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x03; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDB  #$07                    ; 6409: CB 07         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x07; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
    V = (UINT8)(val ^ arg ^ res ^ C); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $E7C7                   ; 640B: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x0e); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x64); 
    clockticks = clockticks + 1; 
    PC = 0xe7c7; 
    JUMP;
  case 0x640E:
L640E:
                                                     #ifdef DEBUG
                                      mon("L640E    BRA   locret_6458             ; 640E: 20 48         \n");
                                      #endif
    PC = 0x640e; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto L6458;
    
    // ---------------------------------------------------------------------------
  case 0x6410:
L6410:
                                                     #ifdef DEBUG
                                      mon("L6410    LDA   $4814                   ; 6410: B6 48 14      \n");
                                      #endif // Credits
    PC = 0x6410; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4814); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDA  $4812                   ; 6413: BB 48 12      \n");
                                      #endif // Half credit
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    arg = rd_mem(0x4812); 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$01                    ; 6416: 81 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x01; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   L641E                   ; 6418: 26 04         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L641E;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   #$0D                    ; 641A: C6 0D         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x0d; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   L6420                   ; 641C: 20 02         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L6420;
    
    // ---------------------------------------------------------------------------
  case 0x641E:
L641E:
                                                     #ifdef DEBUG
                                      mon("L641E    LDB   #$0C                    ; 641E: C6 0C         \n");
                                      #endif
    PC = 0x641e; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x0c; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
  case 0x6420:
L6420:
                                                     #ifdef DEBUG
                                      mon("L6420    JSR   $E7C7                   ; 6420: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    PC = 0x6420; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x23); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x64); 
    clockticks = clockticks + 1; 
    PC = 0xe7c7; 
    JUMP;
  case 0x6423:
L6423:
                                                     #ifdef DEBUG
                                      mon("L6423    LDD   #$01B0                  ; 6423: CC 01 B0      \n");
                                      #endif
    PC = 0x6423; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x01; 
    B = 0xb0; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$1F                    ; 6426: 84 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x1f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 6428: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$FF80                  ; 642A: CC FF 80      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xff; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         TST   $4812                   ; 642D: 7D 48 12      \n");
                                      #endif // Half credit
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4812); 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L6435                   ; 6430: 27 03         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L6435;
    }
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$18                    ; 6432: 83 00 18      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0018; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
  case 0x6435:
L6435:
                                                     #ifdef DEBUG
                                      mon("L6435    ANDA  #$1F                    ; 6435: 84 1F         \n");
                                      #endif
    PC = 0x6435; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x1f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 6437: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4814                   ; 6439: B6 48 14      \n");
                                      #endif // Credits
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4814); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$0A                    ; 643C: 81 0A         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x0a; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   L6442                   ; 643E: 25 02         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L6442;
    }
                                                     #ifdef DEBUG
                                      mon("         ADDA  #$06                    ; 6440: 8B 06         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x06; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
  case 0x6442:
L6442:
                                                     #ifdef DEBUG
                                      mon("L6442    LDB   #$02                    ; 6442: C6 02         \n");
                                      #endif
    PC = 0x6442; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x02; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STB   <$AD                    ; 6444: D7 AD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = B; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0xad; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   $E790                   ; 6446: BD E7 90      \n");
                                      #endif // Display BCD numbers
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x49); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x64); 
    clockticks = clockticks + 1; 
    PC = 0xe790; 
    JUMP;
  case 0x6449:
L6449:
                                                     #ifdef DEBUG
                                      mon("L6449    LDA   $4812                   ; 6449: B6 48 12      \n");
                                      #endif // Half credit
    PC = 0x6449; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4812); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L6453                   ; 644C: 27 05         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L6453;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$B8F3                  ; 644E: CC B8 F3      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xb8; 
    B = 0xf3; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 6451: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
  case 0x6453:
L6453:
                                                     #ifdef DEBUG
                                      mon("L6453    LDD   #$8040                  ; 6453: CC 80 40      \n");
                                      #endif
    PC = 0x6453; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 6456: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
    // End of function sub_63D5
  case 0x6458:
L6458:
locret_6458:
                                                     #ifdef DEBUG
                                      mon("locret_6458 RTS                           ; 6458: 39            \n");
                                      #endif
    PC = 0x6458; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x6459:
L6459:
                                                     #ifdef DEBUG
                                      mon("L6459    LDD   #$00                    ; 6459: CC 00 00      \n");
                                      #endif // Called once before attract screen 1
    PC = 0x6459; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B0C                   ; 645C: FD 4B 0C      \n");
                                      #endif // Attract text position for scrolling
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4b0c, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b0d, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $48AF                   ; 645F: FD 48 AF      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x48af, A); // Care needed with I/O space and word fetches
    wr_mem(0x48b0, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0100                  ; 6462: CC 01 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x01; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B0E                   ; 6465: FD 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4b0e, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b0f, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$6180                  ; 6468: CC 61 80      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x61; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B10                   ; 646B: FD 4B 10      \n");
                                      #endif // Attract text colour/intensity for fading
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x4b10, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b11, B); 
                                                     #ifdef DEBUG
                                      mon("         JSR   $D91A                   ; 646E: BD D9 1A      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x71); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x64); 
    clockticks = clockticks + 1; 
    PC = 0xd91a; 
    JUMP;
  case 0x6471:
L6471:
                                                     #ifdef DEBUG
                                      mon("L6471    JSR   L61B5                   ; 6471: BD 61 B5      \n");
                                      #endif // Set up math constants
    PC = 0x6471; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x64); 
    clockticks = clockticks + 1; 
    goto L61B5;
  case 0x6474:
L6474:
                                                     #ifdef DEBUG
                                      mon("L6474    JSR   L615A                   ; 6474: BD 61 5A      \n");
                                      #endif // More stars/ties init stuff
    PC = 0x6474; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x77); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x64); 
    clockticks = clockticks + 1; 
    goto L615A;
  case 0x6477:
L6477:
                                                     #ifdef DEBUG
                                      mon("L6477    LDU   #$5038                  ; 6477: CE 50 38      \n");
                                      #endif // Matrix 2
    PC = 0x6477; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0x5038; 
    Z = U; 
    N = (U) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $CDC3                   ; 647A: BD CD C3      \n");
                                      #endif // Initialise math registers matrix
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x7d); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x64); 
    clockticks = clockticks + 1; 
    PC = 0xcdc3; 
    JUMP;
  case 0x647D:
L647D:
                                                     #ifdef DEBUG
                                      mon("L647D    JSR   $CC38                   ; 647D: BD CC 38      \n");
                                      #endif
    PC = 0x647d; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x80); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x64); 
    clockticks = clockticks + 1; 
    PC = 0xcc38; 
    JUMP;
  case 0x6480:
L6480:
                                                     #ifdef DEBUG
                                      mon("L6480    INC   <$41                    ; 6480: 0C 41         \n");
                                      #endif // Game mode/screen state
    PC = 0x6480; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x41); 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    wr_mem(DP|0x41, res); 
    clockticks = clockticks + 2; 
    // End of function sub_6459
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 6482: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Attract screen 1
  case 0x6483:
L6483:
                                                     #ifdef DEBUG
                                      mon("L6483    JSR   L6112                   ; 6483: BD 61 12      \n");
                                      #endif // Insert vector data for four blue dots in screen corners
    PC = 0x6483; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x86); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x64); 
    clockticks = clockticks + 1; 
    goto L6112;
  case 0x6486:
L6486:
if (!noCopyright)
{
  

                                                     #ifdef DEBUG
                                      mon("L6486    JSR   L64CD                   ; 6486: BD 64 CD      \n");
                                      #endif // Print Star Wars and copyright text
    PC = 0x6486; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x89); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x64); 
    clockticks = clockticks + 1; 
    goto L64CD;
}
  case 0x6489:
L6489:
                                                     #ifdef DEBUG
                                      mon("L6489    JSR   $CD80                   ; 6489: BD CD 80      \n");
                                      #endif // Starfield
    PC = 0x6489; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x8c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x64); 
    clockticks = clockticks + 1; 
    PC = 0xcd80; 
    JUMP;
  case 0x648C:
L648C:
                                                     #ifdef DEBUG
                                      mon("L648C    JSR   L761D                   ; 648C: BD 76 1D      \n");
                                      #endif // Display score
    PC = 0x648c; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x8f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x64); 
    clockticks = clockticks + 1; 
    goto L761D;
  case 0x648F:
L648F:

                                                     #ifdef DEBUG
                                      mon("L648F    JSR   L63D5                   ; 648F: BD 63 D5      \n");
                                      #endif // Check credits status
    PC = 0x648f; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x92); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x64); 
    clockticks = clockticks + 1; 
    goto L63D5;
    
  case 0x6492:
L6492:
                                                     #ifdef DEBUG
                                      mon("L6492    LDD   $4B0E                   ; 6492: FC 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    PC = 0x6492; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x4b0e); // Care needed with I/O space and word fetches
    B = rd_mem(0x4b0f); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$50                    ; 6495: 10 83 00 50   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x0050; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCC   L64A9                   ; 6499: 24 0E         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto L64A9;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   $4B11                   ; 649B: F6 4B 11      \n");
                                      #endif // Attract text intensity
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b11); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBB  #$01                    ; 649E: C0 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x01; 
    res = val - (UINT8)arg; 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    B = (UINT8)(res); 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$F0                    ; 64A0: C1 F0         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0xf0; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   L64A6                   ; 64A2: 25 02         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L64A6;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   #$00                    ; 64A4: C6 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0x64A6:
L64A6:
                                                     #ifdef DEBUG
                                      mon("L64A6    STB   $4B11                   ; 64A6: F7 4B 11      \n");
                                      #endif // Attract text intensity
    PC = 0x64a6; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b11, val); 
  case 0x64A9:
L64A9:
                                                     #ifdef DEBUG
                                      mon("L64A9    LDD   $4B10                   ; 64A9: FC 4B 10      \n");
                                      #endif // Attract text colour/intensity for fading
    PC = 0x64a9; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x4b10); // Care needed with I/O space and word fetches
    B = rd_mem(0x4b11); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 64AC: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $C7FD                   ; 64AE: BD C7 FD      \n");
                                      #endif // Display high scores
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xb1); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x64); 
    clockticks = clockticks + 1; 
    PC = 0xc7fd; 
    JUMP;
  case 0x64B1:
L64B1:
                                                     #ifdef DEBUG
                                      mon("L64B1    JSR   $D923                   ; 64B1: BD D9 23      \n");
                                      #endif // Called from attract screen 1
    PC = 0x64b1; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xb4); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x64); 
    clockticks = clockticks + 1; 
    PC = 0xd923; 
    JUMP;
  case 0x64B4:
L64B4:
                                                     #ifdef DEBUG
                                      mon("L64B4    JSR   L612F                   ; 64B4: BD 61 2F      \n");
                                      #endif // Vector instructions end
    PC = 0x64b4; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xb7); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x64); 
    clockticks = clockticks + 1; 
    goto L612F;
  case 0x64B7:
L64B7:
                                                     #ifdef DEBUG
                                      mon("L64B7    JSR   L6DCA                   ; 64B7: BD 6D CA      \n");
                                      #endif // Move stars XT translate position
    PC = 0x64b7; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xba); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x64); 
    clockticks = clockticks + 1; 
    goto L6DCA;
  case 0x64BA:
L64BA:
                                                     #ifdef DEBUG
                                      mon("L64BA    LDD   $4B0E                   ; 64BA: FC 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    PC = 0x64ba; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x4b0e); // Care needed with I/O space and word fetches
    B = rd_mem(0x4b0f); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$01                    ; 64BD: 83 00 01      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0001; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B0E                   ; 64C0: FD 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x4b0e, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b0f, B); 
                                                     #ifdef DEBUG
                                      mon("         BPL   L64C9                   ; 64C3: 2A 04         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto L64C9;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$05                    ; 64C5: 86 05         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x05; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$41                    ; 64C7: 97 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0x41; 
    wr_mem(ea, val); 
  case 0x64C9:
L64C9:
                                                     #ifdef DEBUG
                                      mon("L64C9    JSR   L622D                   ; 64C9: BD 62 2D      \n");
                                      #endif // Check joystick X to show high scores if moved
    PC = 0x64c9; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xcc); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x64); 
    clockticks = clockticks + 1; 
    goto L622D;
    // End of function sub_6483
  case 0x64CC:
L64CC:
                                                     #ifdef DEBUG
                                      mon("L64CC    RTS                           ; 64CC: 39            \n");
                                      #endif
    PC = 0x64cc; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Print Star Wars and copyright text
  case 0x64CD:
L64CD:
                                                     #ifdef DEBUG
                                      mon("L64CD    LDB   #$00                    ; 64CD: C6 00         \n");
                                      #endif
    PC = 0x64cd; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $E7C7                   ; 64CF: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xd2); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x64); 
    clockticks = clockticks + 1; 
    PC = 0xe7c7; 
    JUMP;
  case 0x64D2:
L64D2:
                                                     #ifdef DEBUG
                                      mon("L64D2    LDB   #$01                    ; 64D2: C6 01         \n");
                                      #endif
    PC = 0x64d2; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x01; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $E7C7                   ; 64D4: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xd7); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x64); 
    clockticks = clockticks + 1; 
    PC = 0xe7c7; 
    JUMP;
  case 0x64D7:
L64D7:
                                                     #ifdef DEBUG
                                      mon("L64D7    LDB   #$02                    ; 64D7: C6 02         \n");
                                      #endif
    PC = 0x64d7; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x02; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $E7C7                   ; 64D9: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xdc); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x64); 
    clockticks = clockticks + 1; 
    PC = 0xe7c7; 
    JUMP;
  case 0x64DC:
L64DC:
                                                     #ifdef DEBUG
                                      mon("L64DC    LDB   #$03                    ; 64DC: C6 03         \n");
                                      #endif
    PC = 0x64dc; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x03; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $E7C7                   ; 64DE: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xe1); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x64); 
    clockticks = clockticks + 1; 
    PC = 0xe7c7; 
    JUMP;
    // End of function sub_64CD
  case 0x64E1:
L64E1:
                                                     #ifdef DEBUG
                                      mon("L64E1    RTS                           ; 64E1: 39            \n");
                                      #endif
    PC = 0x64e1; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x64E2:
L64E2:
                                                     #ifdef DEBUG
                                      mon("L64E2    JSR   $D91A                   ; 64E2: BD D9 1A      \n");
                                      #endif
    PC = 0x64e2; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xe5); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x64); 
    clockticks = clockticks + 1; 
    PC = 0xd91a; 
    JUMP;
  case 0x64E5:
L64E5:
                                                     #ifdef DEBUG
                                      mon("L64E5    LDD   #$00                    ; 64E5: CC 00 00      \n");
                                      #endif
    PC = 0x64e5; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B0C                   ; 64E8: FD 4B 0C      \n");
                                      #endif // Attract text position for scrolling
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4b0c, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b0d, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $48AF                   ; 64EB: FD 48 AF      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x48af, A); // Care needed with I/O space and word fetches
    wr_mem(0x48b0, B); 
                                                     #ifdef DEBUG
                                      mon("         INC   <$41                    ; 64EE: 0C 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x41); 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    wr_mem(DP|0x41, res); 
    clockticks = clockticks + 2; 
    // End of function sub_64E2
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 64F0: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x64F1:
L64F1:
                                                     #ifdef DEBUG
                                      mon("L64F1    JSR   L6112                   ; 64F1: BD 61 12      \n");
                                      #endif // Accounting time stats
    PC = 0x64f1; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf4); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x64); 
    clockticks = clockticks + 1; 
    goto L6112;
  case 0x64F4:
L64F4:
                                                     #ifdef DEBUG
                                      mon("L64F4    JSR   $BE20                   ; 64F4: BD BE 20      \n");
                                      #endif // Display accounting screen
    PC = 0x64f4; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf7); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x64); 
    clockticks = clockticks + 1; 
    PC = 0xbe20; 
    JUMP;
  case 0x64F7:
L64F7:
                                                     #ifdef DEBUG
                                      mon("L64F7    JSR   $D923                   ; 64F7: BD D9 23      \n");
                                      #endif // Called from attract screen 1
    PC = 0x64f7; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xfa); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x64); 
    clockticks = clockticks + 1; 
    PC = 0xd923; 
    JUMP;
  case 0x64FA:
L64FA:
                                                     #ifdef DEBUG
                                      mon("L64FA    JSR   L612F                   ; 64FA: BD 61 2F      \n");
                                      #endif // Vector instructions end
    PC = 0x64fa; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xfd); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x64); 
    clockticks = clockticks + 1; 
    goto L612F;
  case 0x64FD:
L64FD:
                                                     #ifdef DEBUG
                                      mon("L64FD    LDA   <$AC                    ; 64FD: 96 AC         \n");
                                      #endif
    PC = 0x64fd; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xac); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$04                    ; 64FF: 84 04         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x04; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L6507                   ; 6501: 27 04         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L6507;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$03                    ; 6503: 86 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x03; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$41                    ; 6505: 97 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x41; 
    wr_mem(ea, val); 
  case 0x6507:
L6507:
                                                     #ifdef DEBUG
                                      mon("L6507    LDA   $481E                   ; 6507: B6 48 1E      \n");
                                      #endif
    PC = 0x6507; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x481e); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$10                    ; 650A: 84 10         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x10; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   locret_6512             ; 650C: 27 04         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L6512;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$05                    ; 650E: 86 05         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x05; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$41                    ; 6510: 97 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0x41; 
    wr_mem(ea, val); 
    // End of function sub_64F1
  case 0x6512:
L6512:
locret_6512:
                                                     #ifdef DEBUG
                                      mon("locret_6512 RTS                           ; 6512: 39            \n");
                                      #endif
    PC = 0x6512; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x6513:
L6513:
                                                     #ifdef DEBUG
                                      mon("L6513    JSR   $D91A                   ; 6513: BD D9 1A      \n");
                                      #endif
    PC = 0x6513; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x16); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x65); 
    clockticks = clockticks + 1; 
    PC = 0xd91a; 
    JUMP;
  case 0x6516:
L6516:
                                                     #ifdef DEBUG
                                      mon("L6516    LDA   #$0A                    ; 6516: 86 0A         \n");
                                      #endif
    PC = 0x6516; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x0a; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4AF6                   ; 6518: B7 4A F6      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4af6, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; 651B: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4598                   ; 651D: B7 45 98      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4598, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   $4AF7                   ; 6520: B7 4A F7      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4af7, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$03                    ; 6523: 86 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x03; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $C2C3                   ; 6525: BD C2 C3      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x28); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x65); 
    clockticks = clockticks + 1; 
    PC = 0xc2c3; 
    JUMP;
  case 0x6528:
L6528:
                                                     #ifdef DEBUG
                                      mon("L6528    BEQ   L652F                   ; 6528: 27 05         \n");
                                      #endif
    PC = 0x6528; 
    INSTRUCTION_START
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L652F;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$03                    ; 652A: 86 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x03; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $C369                   ; 652C: BD C3 69      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x2f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x65); 
    clockticks = clockticks + 1; 
    PC = 0xc369; 
    JUMP;
  case 0x652F:
L652F:
                                                     #ifdef DEBUG
                                      mon("L652F    INC   <$41                    ; 652F: 0C 41         \n");
                                      #endif // Game mode/screen state
    PC = 0x652f; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x41); 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    wr_mem(DP|0x41, res); 
    clockticks = clockticks + 2; 
    // End of function sub_6513
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 6531: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // FUNCTION CHUNK AT ROM:F261 SIZE 000000CD BYTES
    // FUNCTION CHUNK AT ROM:F36E SIZE 000001AF BYTES
    // FUNCTION CHUNK AT ROM:F520 SIZE 000001ED BYTES
    // FUNCTION CHUNK AT ROM:F720 SIZE 00000003 BYTES
    // FUNCTION CHUNK AT ROM:FD07 SIZE 0000007E BYTES
    // FUNCTION CHUNK AT ROM:FF24 SIZE 00000033 BYTES
  case 0x6532:
L6532:
                                                     #ifdef DEBUG
                                      mon("L6532    JSR   L6112                   ; 6532: BD 61 12      \n");
                                      #endif // Game options
    PC = 0x6532; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x35); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x65); 
    clockticks = clockticks + 1; 
    goto L6112;
  case 0x6535:
L6535:
                                                     #ifdef DEBUG
                                      mon("L6535    JSR   $C450                   ; 6535: BD C4 50      \n");
                                      #endif
    PC = 0x6535; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x38); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x65); 
    clockticks = clockticks + 1; 
    PC = 0xc450; 
    JUMP;
  case 0x6538:
L6538:
                                                     #ifdef DEBUG
                                      mon("L6538    LDD   #L6780                  ; 6538: CC 67 80      \n");
                                      #endif
    PC = 0x6538; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x67; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 653B: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$66                    ; 653D: C6 66         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x66; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDB  $4AF6                   ; 653F: FB 4A F6      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)B; 
    arg = rd_mem(0x4af6); 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
    V = (UINT8)(val ^ arg ^ res ^ C); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $E7D3                   ; 6542: BD E7 D3      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x45); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x65); 
    clockticks = clockticks + 1; 
    PC = 0xe7d3; 
    JUMP;
  case 0x6545:
L6545:
                                                     #ifdef DEBUG
                                      mon("L6545    LDA   $4AF6                   ; 6545: B6 4A F6      \n");
                                      #endif
    PC = 0x6545; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4af6); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $C5A4                   ; 6548: BD C5 A4      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x4b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x65); 
    clockticks = clockticks + 1; 
    PC = 0xc5a4; 
    JUMP;
  case 0x654B:
L654B:
                                                     #ifdef DEBUG
                                      mon("L654B    JSR   $C4EB                   ; 654B: BD C4 EB      \n");
                                      #endif
    PC = 0x654b; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x4e); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x65); 
    clockticks = clockticks + 1; 
    PC = 0xc4eb; 
    JUMP;
  case 0x654E:
L654E:
                                                     #ifdef DEBUG
                                      mon("L654E    JSR   $D923                   ; 654E: BD D9 23      \n");
                                      #endif // Called from attract screen 1
    PC = 0x654e; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x51); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x65); 
    clockticks = clockticks + 1; 
    PC = 0xd923; 
    JUMP;
  case 0x6551:
L6551:
                                                     #ifdef DEBUG
                                      mon("L6551    JSR   L612F                   ; 6551: BD 61 2F      \n");
                                      #endif // Vector instructions end
    PC = 0x6551; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x54); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x65); 
    clockticks = clockticks + 1; 
    goto L612F;
  case 0x6554:
L6554:
                                                     #ifdef DEBUG
                                      mon("L6554    LDA   <$AC                    ; 6554: 96 AC         \n");
                                      #endif
    PC = 0x6554; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xac); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$04                    ; 6556: 84 04         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x04; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L655D                   ; 6558: 27 03         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L655D;
    }
                                                     #ifdef DEBUG
                                      mon("         JMP   $F261                   ; 655A: 7E F2 61      \n");
                                      #endif
    clockticks = clockticks + 4; 
    PC = 0xf261; 
    JUMP;
    
    // ---------------------------------------------------------------------------
  case 0x655D:
L655D:
                                                     #ifdef DEBUG
                                      mon("L655D    LDA   $481E                   ; 655D: B6 48 1E      \n");
                                      #endif
    PC = 0x655d; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x481e); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$10                    ; 6560: 84 10         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x10; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   locret_656B             ; 6562: 27 07         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L656B;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   $D91A                   ; 6564: BD D9 1A      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x67); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x65); 
    clockticks = clockticks + 1; 
    PC = 0xd91a; 
    JUMP;
  case 0x6567:
L6567:
                                                     #ifdef DEBUG
                                      mon("L6567    LDA   #$05                    ; 6567: 86 05         \n");
                                      #endif
    PC = 0x6567; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x05; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$41                    ; 6569: 97 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0x41; 
    wr_mem(ea, val); 
    // End of function sub_6532
  case 0x656B:
L656B:
locret_656B:
                                                     #ifdef DEBUG
                                      mon("locret_656B RTS                           ; 656B: 39            \n");
                                      #endif
    PC = 0x656b; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Start select screen
  case 0x656C:
L656C:
                                                     #ifdef DEBUG
                                      mon("L656C    LDD   #$0100                  ; 656C: CC 01 00      \n");
                                      #endif
    PC = 0x656c; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x01; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B0E                   ; 656F: FD 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4b0e, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b0f, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; 6572: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B0C                   ; 6575: FD 4B 0C      \n");
                                      #endif // Attract text position for scrolling
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4b0c, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b0d, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $48AF                   ; 6578: FD 48 AF      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x48af, A); // Care needed with I/O space and word fetches
    wr_mem(0x48b0, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$6480                  ; 657B: CC 64 80      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x64; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B10                   ; 657E: FD 4B 10      \n");
                                      #endif // Attract text colour/intensity for fading
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x4b10, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b11, B); 
                                                     #ifdef DEBUG
                                      mon("         JSR   $D91A                   ; 6581: BD D9 1A      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x84); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x65); 
    clockticks = clockticks + 1; 
    PC = 0xd91a; 
    JUMP;
  case 0x6584:
L6584:
                                                     #ifdef DEBUG
                                      mon("L6584    LDB   #$2C                    ; 6584: C6 2C         \n");
                                      #endif
    PC = 0x6584; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x2c; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
  case 0x6586:
L6586:
                                                     #ifdef DEBUG
                                      mon("L6586    TFR   B,A                     ; 6586: 1F 98         \n");
                                      #endif
    PC = 0x6586; 
    INSTRUCTION_START
    A = (UINT8)B; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $D8DF                   ; 6588: BD D8 DF      \n");
                                      #endif // Called from select screen, attract screen 1 + 3 when writing text
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x8b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x65); 
    clockticks = clockticks + 1; 
    PC = 0xd8df; 
    JUMP;
  case 0x658B:
L658B:
                                                     #ifdef DEBUG
                                      mon("L658B    INCB                          ; 658B: 5C            \n");
                                      #endif
    PC = 0x658b; 
    INSTRUCTION_START
    val = (UINT8)B; 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$3A                    ; 658C: C1 3A         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x3a; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   L6586                   ; 658E: 25 F6         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L6586;
    }
                                                     #ifdef DEBUG
                                      mon("         INC   <$41                    ; 6590: 0C 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x41); 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    wr_mem(DP|0x41, res); 
    clockticks = clockticks + 2; 
    // End of function sub_656C
    // ---------------------------------------------------------------------------
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 6592: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x659F:
L659F:
                                                     #ifdef DEBUG
                                      mon("L659F    LDD   $4B0E                   ; 659F: FC 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    PC = 0x659f; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x4b0e); // Care needed with I/O space and word fetches
    B = rd_mem(0x4b0f); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$01                    ; 65A2: 83 00 01      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0001; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B0E                   ; 65A5: FD 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x4b0e, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b0f, B); 
                                                     #ifdef DEBUG
                                      mon("         BPL   L65BD                   ; 65A8: 2A 13         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto L65BD;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; 65AA: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B15                   ; 65AC: B7 4B 15      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b15, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$1B                    ; 65AF: 86 1B         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x1b; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$41                    ; 65B1: 97 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x41; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         CLR   $481B                   ; 65B3: 7F 48 1B      \n");
                                      #endif
    clockticks = clockticks + 5; 
    wr_mem(0x481b, 0); 
 // V = 0; 
 // Z = 0; 
 // N = 0; 
 // C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         CLR   $481A                   ; 65B6: 7F 48 1A      \n");
                                      #endif
    clockticks = clockticks + 5; 
    wr_mem(0x481a, 0); 
 // V = 0; 
 // Z = 0; 
 // N = 0; 
 // C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         CLR   $4819                   ; 65B9: 7F 48 19      \n");
                                      #endif
    clockticks = clockticks + 5; 
    wr_mem(0x4819, 0); 
    V = 0; 
    Z = 0; 
    N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 65BC: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
  case 0x65BD:
L65BD:
                                                     #ifdef DEBUG
                                      mon("L65BD    JSR   L6112                   ; 65BD: BD 61 12      \n");
                                      #endif // Insert vector data for four blue dots in screen corners
    PC = 0x65bd; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xc0); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x65); 
    clockticks = clockticks + 1; 
    goto L6112;
  case 0x65C0:
L65C0:
                                                     #ifdef DEBUG
                                      mon("L65C0    LDX   #word_6593              ; 65C0: 8E 65 93      \n");
                                      #endif
    PC = 0x65c0; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x6593; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0x65C3:
L65C3:
                                                     #ifdef DEBUG
                                      mon("L65C3    LDD   ,X++                    ; 65C3: EC 81         \n");
                                      #endif
    PC = 0x65c3; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
    A = rd_mem(X); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(X+1)); 
    X = X + 2; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$1F                    ; 65C5: 84 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x1f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 65C7: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   ,X++                    ; 65C9: EC 81         \n");
                                      #endif
    clockticks = clockticks + 7; 
    A = rd_mem(X); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(X+1)); 
    X = X + 2; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$1F                    ; 65CB: 84 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x1f; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 65CD: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$7200                  ; 65CF: CC 72 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x72; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 65D2: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$BE50                  ; 65D4: CC BE 50      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xbe; 
    B = 0x50; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 65D7: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #L659F                  ; 65D9: 8C 65 9F      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x659f; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   L65C3                   ; 65DC: 25 E5         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L65C3;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   <$DD                    ; 65DE: 96 DD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xdd); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BPL   L65E7                   ; 65E0: 2A 05         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto L65E7;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$6380                  ; 65E2: CC 63 80      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x63; 
    B = 0x80; 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   L65EA                   ; 65E5: 20 03         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L65EA;
    
    // ---------------------------------------------------------------------------
  case 0x65E7:
L65E7:
                                                     #ifdef DEBUG
                                      mon("L65E7    LDD   #$6680                  ; 65E7: CC 66 80      \n");
                                      #endif
    PC = 0x65e7; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x66; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0x65EA:
L65EA:
                                                     #ifdef DEBUG
                                      mon("L65EA    STD   ,Y++                    ; 65EA: ED A1         \n");
                                      #endif
    PC = 0x65ea; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $B6C0                   ; 65EC: BD B6 C0      \n");
                                      #endif // Insert vector instructions at joystick position for laser explosion 3
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xef); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x65); 
    clockticks = clockticks + 1; 
    PC = 0xb6c0; 
    JUMP;
  case 0x65EF:
L65EF:
                                                     #ifdef DEBUG
                                      mon("L65EF    JSR   $D923                   ; 65EF: BD D9 23      \n");
                                      #endif // Called from attract screen 1
    PC = 0x65ef; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf2); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x65); 
    clockticks = clockticks + 1; 
    PC = 0xd923; 
    JUMP;
  case 0x65F2:
L65F2:
                                                     #ifdef DEBUG
                                      mon("L65F2    LDD   #$C8                    ; 65F2: CC 00 C8      \n");
                                      #endif
    PC = 0x65f2; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0xc8; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 65F5: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$1FF0                  ; 65F7: CC 1F F0      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x1f; 
    B = 0xf0; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 65FA: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   $4B0E                   ; 65FC: FC 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    clockticks = clockticks + 5; 
    A = rd_mem(0x4b0e); // Care needed with I/O space and word fetches
    B = rd_mem(0x4b0f); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; 65FF: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLA                          ; 6600: 49            \n");
                                      #endif
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; 6601: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLA                          ; 6602: 49            \n");
                                      #endif
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; 6603: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLA                          ; 6604: 49            \n");
                                      #endif
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$0A                    ; 6605: 81 0A         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x0a; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   L660B                   ; 6607: 25 02         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L660B;
    }
                                                     #ifdef DEBUG
                                      mon("         ADDA  #$06                    ; 6609: 8B 06         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x06; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
    V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
  case 0x660B:
L660B:
                                                     #ifdef DEBUG
                                      mon("L660B    JSR   $E790                   ; 660B: BD E7 90      \n");
                                      #endif // Display BCD numbers
    PC = 0x660b; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x0e); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x66); 
    clockticks = clockticks + 1; 
    PC = 0xe790; 
    JUMP;
  case 0x660E:
L660E:
                                                     #ifdef DEBUG
                                      mon("L660E    JSR   L612F                   ; 660E: BD 61 2F      \n");
                                      #endif // Vector instructions end
    PC = 0x660e; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x11); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x66); 
    clockticks = clockticks + 1; 
    goto L612F;
  case 0x6611:
L6611:
                                                     #ifdef DEBUG
                                      mon("L6611    LDA   #$FF                    ; 6611: 86 FF         \n");
                                      #endif
    PC = 0x6611; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0xff; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$DD                    ; 6613: 97 DD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xdd; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #word_6593              ; 6615: 8E 65 93      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x6593; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0x6618:
L6618:
                                                     #ifdef DEBUG
                                      mon("L6618    LDD   <$7B                    ; 6618: DC 7B         \n");
                                      #endif
    PC = 0x6618; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x7b); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x7c); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$FF98                  ; 661A: C3 FF 98      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0xff98; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  ,X                      ; 661D: A3 84         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(X)<<8; 
    ea = ea | rd_mem((UINT16)((X)+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         TSTA                          ; 661F: 4D            \n");
                                      #endif
    val = (UINT8)A; 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BPL   L6626                   ; 6620: 2A 04         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto L6626;
    }
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; 6622: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; 6623: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SBCA  #$FF                    ; 6624: 82 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xff; 
    res = val - (UINT8)arg - (C != 0 ? 1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)res; 
  case 0x6626:
L6626:
                                                     #ifdef DEBUG
                                      mon("L6626    STD   $4AFA                   ; 6626: FD 4A FA      \n");
                                      #endif
    PC = 0x6626; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4afa, A); // Care needed with I/O space and word fetches
    wr_mem(0x4afb, B); 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$48                    ; 6629: 10 83 00 48   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x0048; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCC   L6668                   ; 662D: 24 39         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto L6668;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   <$79                    ; 662F: DC 79         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x79); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x7a); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $02,X                   ; 6631: A3 02         \n");
                                      #endif
    clockticks = clockticks + 1; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem((UINT16)(X + 0x0002))<<8; 
    ea = ea | rd_mem((UINT16)(((UINT16)(X + 0x0002))+1)); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         TSTA                          ; 6633: 4D            \n");
                                      #endif
    val = (UINT8)A; 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BPL   L663A                   ; 6634: 2A 04         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto L663A;
    }
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; 6636: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; 6637: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SBCA  #$FF                    ; 6638: 82 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xff; 
    res = val - (UINT8)arg - (C != 0 ? 1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)res; 
  case 0x663A:
L663A:
                                                     #ifdef DEBUG
                                      mon("L663A    CMPD  #$34                    ; 663A: 10 83 00 34   \n");
                                      #endif
    PC = 0x663a; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x0034; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCC   L6668                   ; 663E: 24 28         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto L6668;
    }
                                                     #ifdef DEBUG
                                      mon("         ADDD  $4AFA                   ; 6640: F3 4A FA      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4afa)<<8; 
    ea = ea | rd_mem(0x4afb); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$50                    ; 6643: 10 83 00 50   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x0050; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCC   L6668                   ; 6647: 24 1F         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto L6668;
    }
                                                     #ifdef DEBUG
                                      mon("         TFR   X,D                     ; 6649: 1F 10         \n");
                                      #endif
    val = X; 
    A = (UINT8)(val >> 8); 
    B = (UINT8)val; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #word_6593              ; 664B: 83 65 93      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x6593; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         LSRB                          ; 664E: 54            \n");
                                      #endif
    val = (UINT8)B; 
    C = val & 1; 
    val = val >> 1; 
    B = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STB   <$DD                    ; 664F: D7 DD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xdd; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STB   $4B15                   ; 6651: F7 4B 15      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b15, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$AC                    ; 6654: 96 AC         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xac); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$F0                    ; 6656: 84 F0         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0xf0; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   locret_6667             ; 6658: 27 0D         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L6667;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$1B                    ; 665A: 86 1B         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x1b; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$41                    ; 665C: 97 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x41; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         CLR   $481B                   ; 665E: 7F 48 1B      \n");
                                      #endif
    clockticks = clockticks + 5; 
    wr_mem(0x481b, 0); 
 // V = 0; 
 // Z = 0; 
 // N = 0; 
 // C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         CLR   $481A                   ; 6661: 7F 48 1A      \n");
                                      #endif
    clockticks = clockticks + 5; 
    wr_mem(0x481a, 0); 
 // V = 0; 
 // Z = 0; 
 // N = 0; 
 // C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         CLR   $4819                   ; 6664: 7F 48 19      \n");
                                      #endif
    clockticks = clockticks + 5; 
    wr_mem(0x4819, 0); 
    V = 0; 
    Z = 0; 
    N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
  case 0x6667:
L6667:
locret_6667:
                                                     #ifdef DEBUG
                                      mon("locret_6667 RTS                           ; 6667: 39            \n");
                                      #endif
    PC = 0x6667; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
  case 0x6668:
L6668:
                                                     #ifdef DEBUG
                                      mon("L6668    LEAX  $04,X                   ; 6668: 30 04         \n");
                                      #endif
    PC = 0x6668; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    X = (X + 0x0004); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #L659F                  ; 666A: 8C 65 9F      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x659f; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   L6618                   ; 666D: 25 A9         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L6618;
    }
    // End of function sub_659F
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 666F: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x6670:
L6670:
                                                     #ifdef DEBUG
                                      mon("L6670    LDD   #$00                    ; 6670: CC 00 00      \n");
                                      #endif
    PC = 0x6670; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B0E                   ; 6673: FD 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4b0e, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b0f, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B0C                   ; 6676: FD 4B 0C      \n");
                                      #endif // Attract text position for scrolling
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4b0c, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b0d, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $48AF                   ; 6679: FD 48 AF      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x48af, A); // Care needed with I/O space and word fetches
    wr_mem(0x48b0, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$6180                  ; 667C: CC 61 80      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x61; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B10                   ; 667F: FD 4B 10      \n");
                                      #endif // Attract text colour/intensity for fading
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x4b10, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b11, B); 
                                                     #ifdef DEBUG
                                      mon("         JSR   $D91A                   ; 6682: BD D9 1A      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x85); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x66); 
    clockticks = clockticks + 1; 
    PC = 0xd91a; 
    JUMP;
  case 0x6685:
L6685:
                                                     #ifdef DEBUG
                                      mon("L6685    LDA   #$3A                    ; 6685: 86 3A         \n");
                                      #endif
    PC = 0x6685; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x3a; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $D8DF                   ; 6687: BD D8 DF      \n");
                                      #endif // Called from select screen, attract screen 1 + 3 when writing text
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x8a); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x66); 
    clockticks = clockticks + 1; 
    PC = 0xd8df; 
    JUMP;
  case 0x668A:
L668A:
                                                     #ifdef DEBUG
                                      mon("L668A    LDA   #$3B                    ; 668A: 86 3B         \n");
                                      #endif
    PC = 0x668a; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x3b; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $D8DF                   ; 668C: BD D8 DF      \n");
                                      #endif // Called from select screen, attract screen 1 + 3 when writing text
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x8f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x66); 
    clockticks = clockticks + 1; 
    PC = 0xd8df; 
    JUMP;
  case 0x668F:
L668F:
                                                     #ifdef DEBUG
                                      mon("L668F    LDA   #$3C                    ; 668F: 86 3C         \n");
                                      #endif
    PC = 0x668f; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x3c; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $D8DF                   ; 6691: BD D8 DF      \n");
                                      #endif // Called from select screen, attract screen 1 + 3 when writing text
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x94); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x66); 
    clockticks = clockticks + 1; 
    PC = 0xd8df; 
    JUMP;
  case 0x6694:
L6694:
                                                     #ifdef DEBUG
                                      mon("L6694    LDA   #$3D                    ; 6694: 86 3D         \n");
                                      #endif
    PC = 0x6694; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x3d; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $D8DF                   ; 6696: BD D8 DF      \n");
                                      #endif // Called from select screen, attract screen 1 + 3 when writing text
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x99); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x66); 
    clockticks = clockticks + 1; 
    PC = 0xd8df; 
    JUMP;
  case 0x6699:
L6699:
                                                     #ifdef DEBUG
                                      mon("L6699    LDA   #$3E                    ; 6699: 86 3E         \n");
                                      #endif
    PC = 0x6699; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x3e; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $D8DF                   ; 669B: BD D8 DF      \n");
                                      #endif // Called from select screen, attract screen 1 + 3 when writing text
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x9e); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x66); 
    clockticks = clockticks + 1; 
    PC = 0xd8df; 
    JUMP;
  case 0x669E:
L669E:
                                                     #ifdef DEBUG
                                      mon("L669E    LDA   #$3D                    ; 669E: 86 3D         \n");
                                      #endif
    PC = 0x669e; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x3d; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $D8DF                   ; 66A0: BD D8 DF      \n");
                                      #endif // Called from select screen, attract screen 1 + 3 when writing text
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xa3); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x66); 
    clockticks = clockticks + 1; 
    PC = 0xd8df; 
    JUMP;
  case 0x66A3:
L66A3:
                                                     #ifdef DEBUG
                                      mon("L66A3    JSR   $BD80                   ; 66A3: BD BD 80      \n");
                                      #endif
    PC = 0x66a3; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xa6); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x66); 
    clockticks = clockticks + 1; 
    PC = 0xbd80; 
    JUMP;
  case 0x66A6:
L66A6:
                                                     #ifdef DEBUG
                                      mon("L66A6    JSR   $CC38                   ; 66A6: BD CC 38      \n");
                                      #endif
    PC = 0x66a6; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xa9); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x66); 
    clockticks = clockticks + 1; 
    PC = 0xcc38; 
    JUMP;
  case 0x66A9:
L66A9:
                                                     #ifdef DEBUG
                                      mon("L66A9    INC   <$41                    ; 66A9: 0C 41         \n");
                                      #endif // Game mode/screen state
    PC = 0x66a9; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x41); 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    wr_mem(DP|0x41, res); 
    clockticks = clockticks + 2; 
    // End of function sub_6670
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 66AB: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x66AC:
L66AC:
                                                     #ifdef DEBUG
                                      mon("L66AC    JSR   L6112                   ; 66AC: BD 61 12      \n");
                                      #endif // Insert vector data for four blue dots in screen corners
    PC = 0x66ac; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xaf); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x66); 
    clockticks = clockticks + 1; 
    goto L6112;
  case 0x66AF:
L66AF:
                                                     #ifdef DEBUG
                                      mon("L66AF    JSR   L761D                   ; 66AF: BD 76 1D      \n");
                                      #endif // Display score
    PC = 0x66af; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xb2); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x66); 
    clockticks = clockticks + 1; 
    goto L761D;
  case 0x66B2:
L66B2:
                                                     #ifdef DEBUG
                                      mon("L66B2    JSR   L63D5                   ; 66B2: BD 63 D5      \n");
                                      #endif // Check credits status
    PC = 0x66b2; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xb5); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x66); 
    clockticks = clockticks + 1; 
    goto L63D5;
  case 0x66B5:
L66B5:
                                                     #ifdef DEBUG
                                      mon("L66B5    JSR   $C7FD                   ; 66B5: BD C7 FD      \n");
                                      #endif // Display high scores
    PC = 0x66b5; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xb8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x66); 
    clockticks = clockticks + 1; 
    PC = 0xc7fd; 
    JUMP;
  case 0x66B8:
L66B8:
                                                     #ifdef DEBUG
                                      mon("L66B8    JSR   $D923                   ; 66B8: BD D9 23      \n");
                                      #endif // Called from attract screen 1
    PC = 0x66b8; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xbb); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x66); 
    clockticks = clockticks + 1; 
    PC = 0xd923; 
    JUMP;
  case 0x66BB:
L66BB:
                                                     #ifdef DEBUG
                                      mon("L66BB    JSR   L612F                   ; 66BB: BD 61 2F      \n");
                                      #endif // Vector instructions end
    PC = 0x66bb; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xbe); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x66); 
    clockticks = clockticks + 1; 
    goto L612F;
  case 0x66BE:
L66BE:
                                                     #ifdef DEBUG
                                      mon("L66BE    JSR   $CAF3                   ; 66BE: BD CA F3      \n");
                                      #endif
    PC = 0x66be; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xc1); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x66); 
    clockticks = clockticks + 1; 
    PC = 0xcaf3; 
    JUMP;
  case 0x66C1:
L66C1:
                                                     #ifdef DEBUG
                                      mon("L66C1    LDA   $481E                   ; 66C1: B6 48 1E      \n");
                                      #endif
    PC = 0x66c1; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x481e); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$10                    ; 66C4: 84 10         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x10; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L66CE                   ; 66C6: 26 06         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L66CE;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0300                  ; 66C8: CC 03 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x03; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B0E                   ; 66CB: FD 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4b0e, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b0f, B); 
  case 0x66CE:
L66CE:
                                                     #ifdef DEBUG
                                      mon("L66CE    LDD   $4B0E                   ; 66CE: FC 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    PC = 0x66ce; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x4b0e); // Care needed with I/O space and word fetches
    B = rd_mem(0x4b0f); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$01                    ; 66D1: C3 00 01      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0001; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B0E                   ; 66D4: FD 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4b0e, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b0f, B); 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$0280                  ; 66D7: 10 83 02 80   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x0280; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   L66E3                   ; 66DB: 25 06         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L66E3;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$FFFF                  ; 66DD: CC FF FF      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xff; 
    B = 0xff; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4AEC                   ; 66E0: FD 4A EC      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4aec, A); // Care needed with I/O space and word fetches
    wr_mem(0x4aed, B); 
  case 0x66E3:
L66E3:
                                                     #ifdef DEBUG
                                      mon("L66E3    LDD   $4AEC                   ; 66E3: FC 4A EC      \n");
                                      #endif
    PC = 0x66e3; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x4aec); // Care needed with I/O space and word fetches
    B = rd_mem(0x4aed); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BPL   locret_6707             ; 66E6: 2A 1F         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto L6707;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$0B                    ; 66E8: 86 0B         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x0b; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$41                    ; 66EA: 97 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x41; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDU   #$4AB6                  ; 66EC: CE 4A B6      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x4ab6; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4520                  ; 66EF: 8E 45 20      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x4520; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$08                    ; 66F2: 86 08         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x08; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $C6F9                   ; 66F4: BD C6 F9      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf7); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x66); 
    clockticks = clockticks + 1; 
    PC = 0xc6f9; 
    JUMP;
  case 0x66F7:
L66F7:
                                                     #ifdef DEBUG
                                      mon("L66F7    LDU   #$4A8E                  ; 66F7: CE 4A 8E      \n");
                                      #endif // High scores RAM
    PC = 0x66f7; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0x4a8e; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4508                  ; 66FA: 8E 45 08      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x4508; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$0B                    ; 66FD: 86 0B         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x0b; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $C6F9                   ; 66FF: BD C6 F9      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x02); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x67); 
    clockticks = clockticks + 1; 
    PC = 0xc6f9; 
    JUMP;
  case 0x6702:
L6702:
                                                     #ifdef DEBUG
                                      mon("L6702    LDA   #$01                    ; 6702: 86 01         \n");
                                      #endif
    PC = 0x6702; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x01; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $C2B3                   ; 6704: BD C2 B3      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x07); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x67); 
    clockticks = clockticks + 1; 
    PC = 0xc2b3; 
    JUMP;
    // End of function sub_66AC
  case 0x6707:
L6707:
locret_6707:
                                                     #ifdef DEBUG
                                      mon("locret_6707 RTS                           ; 6707: 39            \n");
                                      #endif
    PC = 0x6707; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Called once before attract screen 2
  case 0x6708:
L6708:
                                                     #ifdef DEBUG
                                      mon("L6708    INC   <$41                    ; 6708: 0C 41         \n");
                                      #endif // Game mode/screen state
    PC = 0x6708; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x41); 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    wr_mem(DP|0x41, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         JSR   L611E                   ; 670A: BD 61 1E      \n");
                                      #endif // Copies Star Wars logo vector data to vector RAM
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x0d); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x67); 
    clockticks = clockticks + 1; 
    goto L611E;
  case 0x670D:
L670D:
                                                     #ifdef DEBUG
                                      mon("L670D    JSR   $D91A                   ; 670D: BD D9 1A      \n");
                                      #endif
    PC = 0x670d; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x10); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x67); 
    clockticks = clockticks + 1; 
    PC = 0xd91a; 
    JUMP;
  case 0x6710:
L6710:
                                                     #ifdef DEBUG
                                      mon("L6710    LDD   #$00                    ; 6710: CC 00 00      \n");
                                      #endif
    PC = 0x6710; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B0C                   ; 6713: FD 4B 0C      \n");
                                      #endif // Attract text position for scrolling
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4b0c, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b0d, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $48AF                   ; 6716: FD 48 AF      \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x48af, A); // Care needed with I/O space and word fetches
    wr_mem(0x48b0, B); 
                                                     #ifdef DEBUG
                                      mon("         JSR   $D9DC                   ; 6719: BD D9 DC      \n");
                                      #endif // Initialise before game start
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x1c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x67); 
    clockticks = clockticks + 1; 
    PC = 0xd9dc; 
    JUMP;
  case 0x671C:
L671C:
                                                     #ifdef DEBUG
                                      mon("L671C    JSR   L61B5                   ; 671C: BD 61 B5      \n");
                                      #endif // Set up math constants
    PC = 0x671c; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x1f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x67); 
    clockticks = clockticks + 1; 
    goto L61B5;
  case 0x671F:
L671F:
                                                     #ifdef DEBUG
                                      mon("L671F    JSR   L615A                   ; 671F: BD 61 5A      \n");
                                      #endif // More stars/ties init stuff
    PC = 0x671f; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x22); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x67); 
    clockticks = clockticks + 1; 
    goto L615A;
  case 0x6722:
L6722:
                                                     #ifdef DEBUG
                                      mon("L6722    LDU   #$5038                  ; 6722: CE 50 38      \n");
                                      #endif // Matrix 2
    PC = 0x6722; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0x5038; 
    Z = U; 
    N = (U) >> 8; 
    V = 0; 
  case 0x6725:
L6725:
                                                     #ifdef DEBUG
                                      mon("L6725    JSR   $CDC3                   ; 6725: BD CD C3      \n");
                                      #endif // Initialise math registers matrix
    PC = 0x6725; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x28); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x67); 
    clockticks = clockticks + 1; 
    PC = 0xcdc3; 
    JUMP;
  case 0x6728:
L6728:
                                                     #ifdef DEBUG
                                      mon("L6728    LDA   $4B34                   ; 6728: B6 4B 34      \n");
                                      #endif
    PC = 0x6728; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b34); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$FF                    ; 672B: 81 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xff; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   L6737                   ; 672D: 26 08         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L6737;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B06                   ; 672F: B6 4B 06      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b06); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B34                   ; 6732: B7 4B 34      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x4b34, val); 
                                                     #ifdef DEBUG
                                      mon("         BRA   locret_6758             ; 6735: 20 21         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L6758;
    
    // ---------------------------------------------------------------------------
  case 0x6737:
L6737:
                                                     #ifdef DEBUG
                                      mon("L6737    LDA   $4B06                   ; 6737: B6 4B 06      \n");
                                      #endif // Called once before attract screen 2
    PC = 0x6737; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b06); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  $4B34                   ; 673A: B1 4B 34      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    arg = rd_mem(0x4b34); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BEQ   locret_6758             ; 673D: 27 19         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L6758;
    }
                                                     #ifdef DEBUG
                                      mon("         STA   $4B34                   ; 673F: B7 4B 34      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x4b34, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   $C20C                   ; 6742: BD C2 0C      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x45); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x67); 
    clockticks = clockticks + 1; 
    PC = 0xc20c; 
    JUMP;
  case 0x6745:
L6745:
                                                     #ifdef DEBUG
                                      mon("L6745    LDA   $4592                   ; 6745: B6 45 92      \n");
                                      #endif
    PC = 0x6745; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4592); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$04                    ; 6748: 84 04         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x04; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   locret_6758             ; 674A: 26 0C         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L6758;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   #off_6759               ; 674C: 8E 67 59      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x6759; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4703                   ; 674F: B6 47 03      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$09                    ; 6752: C6 09         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x09; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         MUL                           ; 6754: 3D            \n");
                                      #endif
    res = (UINT16)(A * B); 
 // Z = res; 
 // C = res & 0x80; 
    A = res >> 8; 
    B = (UINT8)res; 
    clockticks = clockticks + 11; 
                                                     #ifdef DEBUG
                                      mon("         ASLA                          ; 6755: 48            \n");
                                      #endif
    val = (UINT8)A; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
    Z = res; 
    N = res; 
    V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         JSR   [A,X]                   ; 6756: AD 96         \n");
                                      #endif // Play random attract sound
    clockticks = clockticks + 3; 
    clockticks = clockticks + 5; 
    clockticks = clockticks + 2; 
    ea = rd_mem((UINT16)(X + (SINT8)A))<<8; 
    ea = ea | rd_mem((UINT16)(X + (SINT8)A + 1)); 
    --S;
    wr_mem(S, 0x58); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x67); 
    clockticks = clockticks + 1; 
    PC = ea; 
    JUMP;
    // End of function sub_6708
    // ---------------------------------------------------------------------------
  case 0x6758:
L6758:
locret_6758:
                                                     #ifdef DEBUG
                                      mon("locret_6758 RTS                           ; 6758: 39            \n");
                                      #endif
    PC = 0x6758; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x676B:
L676B:
                                                     #ifdef DEBUG
                                      mon("L676B    JSR   L6112                   ; 676B: BD 61 12      \n");
                                      #endif // Attract screen 2
    PC = 0x676b; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x6e); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x67); 
    clockticks = clockticks + 1; 
    goto L6112;
  case 0x676E:
L676E:
                                                     #ifdef DEBUG
                                      mon("L676E    JSR   $CD80                   ; 676E: BD CD 80      \n");
                                      #endif // Starfield
    PC = 0x676e; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x71); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x67); 
    clockticks = clockticks + 1; 
    PC = 0xcd80; 
    JUMP;
  case 0x6771:
L6771:
                                                     #ifdef DEBUG
                                      mon("L6771    JSR   $D9FA                   ; 6771: BD D9 FA      \n");
                                      #endif // Attract screen 2 large Star Wars logo handling
    PC = 0x6771; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x67); 
    clockticks = clockticks + 1; 
    PC = 0xd9fa; 
    JUMP;
  case 0x6774:
L6774:
                                                     #ifdef DEBUG
                                      mon("L6774    JSR   $D985                   ; 6774: BD D9 85      \n");
                                      #endif
    PC = 0x6774; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x77); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x67); 
    clockticks = clockticks + 1; 
    PC = 0xd985; 
    JUMP;
  case 0x6777:
L6777:
                                                     #ifdef DEBUG
                                      mon("L6777    JSR   L63D5                   ; 6777: BD 63 D5      \n");
                                      #endif // Check credits status
    PC = 0x6777; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x7a); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x67); 
    clockticks = clockticks + 1; 
    goto L63D5;
  case 0x677A:
L677A:
                                                     #ifdef DEBUG
                                      mon("L677A    JSR   L761D                   ; 677A: BD 76 1D      \n");
                                      #endif // Display score
    PC = 0x677a; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x7d); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x67); 
    clockticks = clockticks + 1; 
    goto L761D;
  case 0x677D:
L677D:
                                                     #ifdef DEBUG
                                      mon("L677D    JSR   L612F                   ; 677D: BD 61 2F      \n");
                                      #endif // Vector instructions end
    PC = 0x677d; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x80); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x67); 
    clockticks = clockticks + 1; 
    goto L612F;
  case 0x6780:
L6780:
                                                     #ifdef DEBUG
                                      mon("L6780    JSR   L6DA5                   ; 6780: BD 6D A5      \n");
                                      #endif // Attract screen 2 stars forward and down translate
    PC = 0x6780; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x83); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x67); 
    clockticks = clockticks + 1; 
    goto L6DA5;
  case 0x6783:
L6783:
                                                     #ifdef DEBUG
                                      mon("L6783    JSR   L622D                   ; 6783: BD 62 2D      \n");
                                      #endif // Check joystick X to show high scores if moved
    PC = 0x6783; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x86); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x67); 
    clockticks = clockticks + 1; 
    goto L622D;
    // End of function sub_676B
  case 0x6786:
L6786:
                                                     #ifdef DEBUG
                                      mon("L6786    RTS                           ; 6786: 39            \n");
                                      #endif
    PC = 0x6786; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Called once before difficulty select screen
  case 0x6787:
L6787:
                                                     #ifdef DEBUG
                                      mon("L6787    LDA   #$05                    ; 6787: 86 05         \n");
                                      #endif
    PC = 0x6787; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x05; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B0E                   ; 6789: B7 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b0e, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$FF                    ; 678C: 86 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xff; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B34                   ; 678E: B7 4B 34      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x4b34, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   $D91A                   ; 6791: BD D9 1A      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x94); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x67); 
    clockticks = clockticks + 1; 
    PC = 0xd91a; 
    JUMP;
  case 0x6794:
L6794:
                                                     #ifdef DEBUG
                                      mon("L6794    JSR   $BD44                   ; 6794: BD BD 44      \n");
                                      #endif
    PC = 0x6794; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x97); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x67); 
    clockticks = clockticks + 1; 
    PC = 0xbd44; 
    JUMP;
  case 0x6797:
L6797:
                                                     #ifdef DEBUG
                                      mon("L6797    INC   <$41                    ; 6797: 0C 41         \n");
                                      #endif // Game mode/screen state
    PC = 0x6797; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x41); 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    wr_mem(DP|0x41, res); 
    clockticks = clockticks + 2; 
    // End of function sub_6787
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 6799: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Called once before difficulty select screen
  case 0x679A:
L679A:
if (countOfStarsIngame!=0) gameRunning=1;
                                                     #ifdef DEBUG
                                      mon("L679A    LDA   #$0D                    ; 679A: 86 0D         \n");
                                      #endif
    PC = 0x679a; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x0d; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$41                    ; 679C: 97 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x41; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; 679E: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$42                    ; 67A1: DD 42         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x42; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STA   <$DD                    ; 67A3: 97 DD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xdd; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4593                   ; 67A5: B6 45 93      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4593); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$03                    ; 67A8: 84 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x03; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
  case 0x67AA:
L67AA:
                                                     #ifdef DEBUG
                                      mon("L67AA    ADDA  #$06                    ; 67AA: 8B 06         \n");
                                      #endif
    PC = 0x67aa; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x06; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$60                    ; 67AC: 97 60         \n");
                                      #endif // Shield count
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x60; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   <$8E                    ; 67AE: 97 8E         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x8e; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4593                   ; 67B0: B6 45 93      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4593); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; 67B3: 44            \n");
                                      #endif
    val = (UINT8)A; 
 // C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; 67B4: 44            \n");
                                      #endif
    val = (UINT8)A; 
    C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$03                    ; 67B5: 84 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x03; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B18                   ; 67B7: B7 4B 18      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b18, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; 67BA: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B17                   ; 67BC: B7 4B 17      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b17, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   <$8B                    ; 67BF: 97 8B         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x8b; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   <$8C                    ; 67C1: 97 8C         \n");
                                      #endif // Sheild being depleted
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x8c; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   <$5C                    ; 67C3: 97 5C         \n");
                                      #endif // Score millions
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x5c; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   <$5D                    ; 67C5: 97 5D         \n");
                                      #endif // Score hundred thousands
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x5d; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   <$5E                    ; 67C7: 97 5E         \n");
                                      #endif // Score thousands
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x5e; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   <$5F                    ; 67C9: 97 5F         \n");
                                      #endif // Score
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x5f; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B2D                   ; 67CB: B7 4B 2D      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b2d, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B37                   ; 67CE: B7 4B 37      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b37, val); 
  case 0x67D1:
L67D1:
                                                     #ifdef DEBUG
                                      mon("L67D1    STA   $4B35                   ; 67D1: B7 4B 35      \n");
                                      #endif
    PC = 0x67d1; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b35, val); 
  case 0x67D4:
L67D4:
                                                     #ifdef DEBUG
                                      mon("L67D4    ORCC  #$10                    ; 67D4: 1A 10         \n");
                                      #endif
    PC = 0x67d4; 
    INSTRUCTION_START
    I = 1; 
    clockticks = clockticks + 3; 
  case 0x67D6:
L67D6:
                                                     #ifdef DEBUG
                                      mon("L67D6    INC   $486F                   ; 67D6: 7C 48 6F      \n");
                                      #endif // Joystick roll data structure
    PC = 0x67d6; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x486f); 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    wr_mem(0x486f, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         INC   $4866                   ; 67D9: 7C 48 66      \n");
                                      #endif // Joystick pitch data structure
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4866); 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    wr_mem(0x4866, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         INC   $4871                   ; 67DC: 7C 48 71      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4871); 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    wr_mem(0x4871, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         INC   $4868                   ; 67DF: 7C 48 68      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4868); 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    wr_mem(0x4868, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ANDCC #$EF                    ; 67E2: 1C EF         \n");
                                      #endif
    I = 0; 
    clockticks = clockticks + 3; 
    // End of function sub_679A
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 67E4: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x67E5:
L67E5:
                                                     #ifdef DEBUG
                                      mon("L67E5    JSR   L61B5                   ; 67E5: BD 61 B5      \n");
                                      #endif // Set up math constants
    PC = 0x67e5; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xe8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x67); 
    clockticks = clockticks + 1; 
    goto L61B5;
  case 0x67E8:
L67E8:
                                                     #ifdef DEBUG
                                      mon("L67E8    JSR   L615A                   ; 67E8: BD 61 5A      \n");
                                      #endif // More stars/ties init stuff
    PC = 0x67e8; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xeb); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x67); 
    clockticks = clockticks + 1; 
    goto L615A;
  case 0x67EB:
L67EB:
                                                     #ifdef DEBUG
                                      mon("L67EB    JSR   L61EC                   ; 67EB: BD 61 EC      \n");
                                      #endif // Init stars math data
    PC = 0x67eb; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xee); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x67); 
    clockticks = clockticks + 1; 
    goto L61EC;
  case 0x67EE:
L67EE:
                                                     #ifdef DEBUG
                                      mon("L67EE    LDA   #$C0                    ; 67EE: 86 C0         \n");
                                      #endif
    PC = 0x67ee; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0xc0; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $5080                   ; 67F0: B7 50 80      \n");
                                      #endif // Matrix 4
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x5080, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   $508A                   ; 67F3: B7 50 8A      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x508a, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; 67F6: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4813                   ; 67F8: B7 48 13      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4813, val); 
                                                     #ifdef DEBUG
                                      mon("         INC   <$41                    ; 67FB: 0C 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x41); 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    wr_mem(DP|0x41, res); 
    clockticks = clockticks + 2; 
  case 0x67FD:
L67FD:
                                                     #ifdef DEBUG
                                      mon("L67FD    LDA   #$1D                    ; 67FD: 86 1D         \n");
                                      #endif
    PC = 0x67fd; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x1d; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$41                    ; 67FF: 97 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0x41; 
    wr_mem(ea, val); 
    // End of function sub_67E5
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 6801: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Next space wave after Death Star explosion
  case 0x6802:
L6802:
                                                     #ifdef DEBUG
                                      mon("L6802    JSR   L7A5A                   ; 6802: BD 7A 5A      \n");
                                      #endif
    PC = 0x6802; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x05); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x68); 
    clockticks = clockticks + 1; 
    goto L7A5A;
  case 0x6805:
L6805:
                                                     #ifdef DEBUG
                                      mon("L6805    LDX   #$08                    ; 6805: 8E 00 08      \n");
                                      #endif
    PC = 0x6805; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x0008; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B15                   ; 6808: B6 4B 15      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b15); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         INCA                          ; 680B: 4C            \n");
                                      #endif
    val = (UINT8)A; 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         JSR   L7720                   ; 680C: BD 77 20      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x0f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x68); 
    clockticks = clockticks + 1; 
    goto L7720;
  case 0x680F:
L680F:
                                                     #ifdef DEBUG
                                      mon("L680F    LDA   $4AD6                   ; 680F: B6 4A D6      \n");
                                      #endif
    PC = 0x680f; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4ad6); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B16                   ; 6812: B7 4B 16      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b16, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B15                   ; 6815: B6 4B 15      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b15); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0x6818:
L6818:
                                                     #ifdef DEBUG
                                      mon("L6818    CMPA  #$1F                    ; 6818: 81 1F         \n");
                                      #endif
    PC = 0x6818; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x1f; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BLS   L681E                   ; 681A: 23 02         \n");
                                      #endif
    // temp hack to force a flush
    if ((!Z) || C) {
    clockticks = clockticks + 3; 
    goto L681E;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$1F                    ; 681C: 86 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x1f; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0x681E:
L681E:
                                                     #ifdef DEBUG
                                      mon("L681E    STA   $4B14                   ; 681E: B7 4B 14      \n");
                                      #endif
    PC = 0x681e; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b14, val); 
                                                     #ifdef DEBUG
                                      mon("         ADDA  $4B18                   ; 6821: BB 4B 18      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    arg = rd_mem(0x4b18); 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$0F                    ; 6824: 81 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x0f; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BLS   L682A                   ; 6826: 23 02         \n");
                                      #endif
    // temp hack to force a flush
    if ((!Z) || C) {
    clockticks = clockticks + 3; 
    goto L682A;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$0F                    ; 6828: 86 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x0f; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0x682A:
L682A:
                                                     #ifdef DEBUG
                                      mon("L682A    STA   $4B19                   ; 682A: B7 4B 19      \n");
                                      #endif
    PC = 0x682a; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b19, val); 
                                                     #ifdef DEBUG
                                      mon("         INC   <$41                    ; 682D: 0C 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x41); 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    wr_mem(DP|0x41, res); 
    clockticks = clockticks + 2; 
  case 0x682F:
L682F:
                                                     #ifdef DEBUG
                                      mon("L682F    LDA   #$1F                    ; 682F: 86 1F         \n");
                                      #endif
    PC = 0x682f; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x1f; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$41                    ; 6831: 97 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x41; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; 6833: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$DD                    ; 6835: 97 DD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0xdd; 
    wr_mem(ea, val); 
    // End of function sub_6802
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 6837: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Next space wave after Death Star explosion
    // FUNCTION CHUNK AT ROM:6C76 SIZE 0000000E BYTES
  case 0x6838:
L6838:
                                                     #ifdef DEBUG
                                      mon("L6838    JSR   L6161                   ; 6838: BD 61 61      \n");
                                      #endif // Initialise tie fighters and fireballs
    PC = 0x6838; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x3b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x68); 
    clockticks = clockticks + 1; 
    goto L6161;
  case 0x683B:
L683B:
                                                     #ifdef DEBUG
                                      mon("L683B    JSR   $B939                   ; 683B: BD B9 39      \n");
                                      #endif
    PC = 0x683b; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x3e); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x68); 
    clockticks = clockticks + 1; 
    PC = 0xb939; 
    JUMP;
  case 0x683E:
L683E:
                                                     #ifdef DEBUG
                                      mon("L683E    LDD   #$00                    ; 683E: CC 00 00      \n");
                                      #endif
    PC = 0x683e; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B0E                   ; 6841: FD 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4b0e, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b0f, B); 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B3B                   ; 6844: B7 4B 3B      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b3b, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$09                    ; 6847: 86 09         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x09; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B3C                   ; 6849: B7 4B 3C      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b3c, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B2D                   ; 684C: B6 4B 2D      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b2d); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L6857                   ; 684F: 26 06         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L6857;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$27                    ; 6851: CC 00 27      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x27; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B0E                   ; 6854: FD 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4b0e, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b0f, B); 
  case 0x6857:
L6857:
                                                     #ifdef DEBUG
                                      mon("L6857    INC   <$41                    ; 6857: 0C 41         \n");
                                      #endif // Game mode/screen state
    PC = 0x6857; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x41); 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    wr_mem(DP|0x41, res); 
    clockticks = clockticks + 2; 
  case 0x6859:
L6859:
                                                     #ifdef DEBUG
                                      mon("L6859    JSR   L72C7                   ; 6859: BD 72 C7      \n");
                                      #endif // Space wave
    PC = 0x6859; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x5c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x68); 
    clockticks = clockticks + 1; 
    goto L72C7;
  case 0x685C:
L685C:
                                                     #ifdef DEBUG
                                      mon("L685C    LDA   <$60                    ; 685C: 96 60         \n");
                                      #endif // Shield count
    PC = 0x685c; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x60); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LBMI  L6C76                   ; 685E: 10 2B 04 14   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if ((SINT8)N <  0) {
    clockticks = clockticks + 1; 
    goto L6C76;
    }
  case 0x6862:
L6862:
                                                     #ifdef DEBUG
                                      mon("L6862    JSR   $A849                   ; 6862: BD A8 49      \n");
                                      #endif // Fireball movement
    PC = 0x6862; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x65); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x68); 
    clockticks = clockticks + 1; 
    PC = 0xa849; 
    JUMP;
  case 0x6865:
L6865:
                                                     #ifdef DEBUG
                                      mon("L6865    JSR   $9898                   ; 6865: BD 98 98      \n");
                                      #endif
    PC = 0x6865; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x68); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x68); 
    clockticks = clockticks + 1; 
    PC = 0x9898; 
    JUMP;
  case 0x6868:
L6868:
                                                     #ifdef DEBUG
                                      mon("L6868    JSR   $B98B                   ; 6868: BD B9 8B      \n");
                                      #endif // Check if tie/bunker/tower been hit
    PC = 0x6868; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x6b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x68); 
    clockticks = clockticks + 1; 
    PC = 0xb98b; 
    JUMP;
  case 0x686B:
L686B:
                                                     #ifdef DEBUG
                                      mon("L686B    JSR   $9890                   ; 686B: BD 98 90      \n");
                                      #endif // Fireball timer 3
    PC = 0x686b; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x6e); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x68); 
    clockticks = clockticks + 1; 
    PC = 0x9890; 
    JUMP;
  case 0x686E:
L686E:
                                                     #ifdef DEBUG
                                      mon("L686E    JSR   $9558                   ; 686E: BD 95 58      \n");
                                      #endif // Process shields
    PC = 0x686e; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x71); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x68); 
    clockticks = clockticks + 1; 
    PC = 0x9558; 
    JUMP;
  case 0x6871:
L6871:
                                                     #ifdef DEBUG
                                      mon("L6871    JSR   $8B6D                   ; 6871: BD 8B 6D      \n");
                                      #endif
    PC = 0x6871; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x68); 
    clockticks = clockticks + 1; 
    PC = 0x8b6d; 
    JUMP;
  case 0x6874:
L6874:
                                                     #ifdef DEBUG
                                      mon("L6874    JSR   L70DB                   ; 6874: BD 70 DB      \n");
                                      #endif
    PC = 0x6874; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x77); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x68); 
    clockticks = clockticks + 1; 
    goto L70DB;
  case 0x6877:
L6877:
                                                     #ifdef DEBUG
                                      mon("L6877    JSR   L6DD2                   ; 6877: BD 6D D2      \n");
                                      #endif
    PC = 0x6877; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x7a); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x68); 
    clockticks = clockticks + 1; 
    goto L6DD2;
  case 0x687A:
L687A:
                                                     #ifdef DEBUG
                                      mon("L687A    LDA   #$10                    ; 687A: 86 10         \n");
                                      #endif // BIC points to Matrix 4
    PC = 0x687a; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x10; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $CE0C                   ; 687C: BD CE 0C      \n");
                                      #endif // Copy transform data from [BIC] to matrix 2
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x7f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x68); 
    clockticks = clockticks + 1; 
    PC = 0xce0c; 
    JUMP;
  case 0x687F:
L687F:
                                                     #ifdef DEBUG
                                      mon("L687F    JSR   L6F5F                   ; 687F: BD 6F 5F      \n");
                                      #endif
    PC = 0x687f; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x82); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x68); 
    clockticks = clockticks + 1; 
    goto L6F5F;
  case 0x6882:
L6882:
                                                     #ifdef DEBUG
                                      mon("L6882    LDD   $4B0E                   ; 6882: FC 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    PC = 0x6882; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x4b0e); // Care needed with I/O space and word fetches
    B = rd_mem(0x4b0f); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$01                    ; 6885: C3 00 01      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0001; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B0E                   ; 6888: FD 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4b0e, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b0f, B); 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$28                    ; 688B: 10 83 00 28   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x0028; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L68A6                   ; 688F: 26 15         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L68A6;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B15                   ; 6891: B6 4B 15      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b15); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$03                    ; 6894: 81 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x03; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BLT   L68A1                   ; 6896: 2D 09         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 3; 
    goto L68A1;
    }
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$01                    ; 6898: 84 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x01; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L68A1                   ; 689A: 27 05         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L68A1;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   $BD85                   ; 689C: BD BD 85      \n");
                                      #endif // Imperial March
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x9f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x68); 
    clockticks = clockticks + 1; 
    PC = 0xbd85; 
    JUMP;
  case 0x689F:
L689F:
                                                     #ifdef DEBUG
                                      mon("L689F    BRA   L68A4                   ; 689F: 20 03         \n");
                                      #endif
    PC = 0x689f; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto L68A4;
    
    // ---------------------------------------------------------------------------
  case 0x68A1:
L68A1:
                                                     #ifdef DEBUG
                                      mon("L68A1    JSR   $BDA8                   ; 68A1: BD BD A8      \n");
                                      #endif // Space wave 1 music
    PC = 0x68a1; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xa4); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x68); 
    clockticks = clockticks + 1; 
    PC = 0xbda8; 
    JUMP;
  case 0x68A4:
L68A4:
                                                     #ifdef DEBUG
                                      mon("L68A4    BRA   L68C6                   ; 68A4: 20 20         \n");
                                      #endif
    PC = 0x68a4; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto L68C6;
    
    // ---------------------------------------------------------------------------
  case 0x68A6:
L68A6:
                                                     #ifdef DEBUG
                                      mon("L68A6    CMPD  #$C8                    ; 68A6: 10 83 00 C8   \n");
                                      #endif
    PC = 0x68a6; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x00c8; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L68B1                   ; 68AA: 26 05         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L68B1;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   $BDAD                   ; 68AC: BD BD AD      \n");
                                      #endif // Space Wave 2 music
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xaf); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x68); 
    clockticks = clockticks + 1; 
    PC = 0xbdad; 
    JUMP;
  case 0x68AF:
L68AF:
                                                     #ifdef DEBUG
                                      mon("L68AF    BRA   L68C6                   ; 68AF: 20 15         \n");
                                      #endif
    PC = 0x68af; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto L68C6;
    
    // ---------------------------------------------------------------------------
  case 0x68B1:
L68B1:
                                                     #ifdef DEBUG
                                      mon("L68B1    CMPD  #$0190                  ; 68B1: 10 83 01 90   \n");
                                      #endif
    PC = 0x68b1; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x0190; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L68BC                   ; 68B5: 26 05         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L68BC;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   $BD8A                   ; 68B7: BD BD 8A      \n");
                                      #endif // Enter Death Star
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xba); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x68); 
    clockticks = clockticks + 1; 
    PC = 0xbd8a; 
    JUMP;
  case 0x68BA:
L68BA:
                                                     #ifdef DEBUG
                                      mon("L68BA    BRA   L68C6                   ; 68BA: 20 0A         \n");
                                      #endif
    PC = 0x68ba; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto L68C6;
    
    // ---------------------------------------------------------------------------
  case 0x68BC:
L68BC:
                                                     #ifdef DEBUG
                                      mon("L68BC    CMPD  #$01A4                  ; 68BC: 10 83 01 A4   \n");
                                      #endif
    PC = 0x68bc; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x01a4; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   L68C6                   ; 68C0: 25 04         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L68C6;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$21                    ; 68C2: 86 21         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x21; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$41                    ; 68C4: 97 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x41; 
    wr_mem(ea, val); 
  case 0x68C6:
L68C6:
                                                     #ifdef DEBUG
                                      mon("L68C6    LDA   <$E6                    ; 68C6: 96 E6         \n");
                                      #endif
    PC = 0x68c6; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xe6); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$03                    ; 68C8: 81 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x03; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCC   locret_68CF             ; 68CA: 24 03         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto L68CF;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   $8F7B                   ; 68CC: BD 8F 7B      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xcf); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x68); 
    clockticks = clockticks + 1; 
    PC = 0x8f7b; 
    JUMP;
    // End of function sub_6838
  case 0x68CF:
L68CF:
locret_68CF:
                                                     #ifdef DEBUG
                                      mon("locret_68CF RTS                           ; 68CF: 39            \n");
                                      #endif
    PC = 0x68cf; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x68D0:
L68D0:
if (savetyNet) savetyNetCount = 0;
                                                     #ifdef DEBUG
                                      mon("L68D0    INC   $4B3B                   ; 68D0: 7C 4B 3B      \n");
                                      #endif
    PC = 0x68d0; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b3b); 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    wr_mem(0x4b3b, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         INC   <$41                    ; 68D3: 0C 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x41); 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    wr_mem(DP|0x41, res); 
    clockticks = clockticks + 2; 
  case 0x68D5:
L68D5:
                                                     #ifdef DEBUG
                                      mon("L68D5    JSR   L72C7                   ; 68D5: BD 72 C7      \n");
                                      #endif // Entering Death Star
    PC = 0x68d5; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xd8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x68); 
    clockticks = clockticks + 1; 
    goto L72C7;
  case 0x68D8:
L68D8:
                                                     #ifdef DEBUG
                                      mon("L68D8    LDA   <$60                    ; 68D8: 96 60         \n");
                                      #endif // Shield count
    PC = 0x68d8; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x60); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LBMI  L6C76                   ; 68DA: 10 2B 03 98   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if ((SINT8)N <  0) {
    clockticks = clockticks + 1; 
    goto L6C76;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   $A849                   ; 68DE: BD A8 49      \n");
                                      #endif // Fireball movement
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xe1); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x68); 
    clockticks = clockticks + 1; 
    PC = 0xa849; 
    JUMP;
  case 0x68E1:
L68E1:
                                                     #ifdef DEBUG
                                      mon("L68E1    JSR   $9898                   ; 68E1: BD 98 98      \n");
                                      #endif
    PC = 0x68e1; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xe4); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x68); 
    clockticks = clockticks + 1; 
    PC = 0x9898; 
    JUMP;
  case 0x68E4:
L68E4:
                                                     #ifdef DEBUG
                                      mon("L68E4    JSR   $B98B                   ; 68E4: BD B9 8B      \n");
                                      #endif // Check if tie/bunker/tower been hit
    PC = 0x68e4; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xe7); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x68); 
    clockticks = clockticks + 1; 
    PC = 0xb98b; 
    JUMP;
  case 0x68E7:
L68E7:
                                                     #ifdef DEBUG
                                      mon("L68E7    JSR   $9890                   ; 68E7: BD 98 90      \n");
                                      #endif // Fireball timer 3
    PC = 0x68e7; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xea); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x68); 
    clockticks = clockticks + 1; 
    PC = 0x9890; 
    JUMP;
  case 0x68EA:
L68EA:
                                                     #ifdef DEBUG
                                      mon("L68EA    JSR   $9558                   ; 68EA: BD 95 58      \n");
                                      #endif // Process shields
    PC = 0x68ea; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xed); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x68); 
    clockticks = clockticks + 1; 
    PC = 0x9558; 
    JUMP;
  case 0x68ED:
L68ED:
                                                     #ifdef DEBUG
                                      mon("L68ED    JSR   $8B86                   ; 68ED: BD 8B 86      \n");
                                      #endif
    PC = 0x68ed; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf0); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x68); 
    clockticks = clockticks + 1; 
    PC = 0x8b86; 
    JUMP;
  case 0x68F0:
L68F0:
                                                     #ifdef DEBUG
                                      mon("L68F0    JSR   L70DB                   ; 68F0: BD 70 DB      \n");
                                      #endif
    PC = 0x68f0; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf3); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x68); 
    clockticks = clockticks + 1; 
    goto L70DB;
  case 0x68F3:
L68F3:
                                                     #ifdef DEBUG
                                      mon("L68F3    JSR   L6DFA                   ; 68F3: BD 6D FA      \n");
                                      #endif
    PC = 0x68f3; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf6); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x68); 
    clockticks = clockticks + 1; 
    goto L6DFA;
  case 0x68F6:
L68F6:
                                                     #ifdef DEBUG
                                      mon("L68F6    LDA   #$10                    ; 68F6: 86 10         \n");
                                      #endif // BIC points to Matrix 4
    PC = 0x68f6; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x10; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $CE0C                   ; 68F8: BD CE 0C      \n");
                                      #endif // Copy transform data from [BIC] to matrix 2
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xfb); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x68); 
    clockticks = clockticks + 1; 
    PC = 0xce0c; 
    JUMP;
  case 0x68FB:
L68FB:
                                                     #ifdef DEBUG
                                      mon("L68FB    JSR   L6F5F                   ; 68FB: BD 6F 5F      \n");
                                      #endif
    PC = 0x68fb; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xfe); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x68); 
    clockticks = clockticks + 1; 
    goto L6F5F;
  case 0x68FE:
L68FE:
                                                     #ifdef DEBUG
                                      mon("L68FE    LDX   #$4900                  ; 68FE: 8E 49 00      \n");
                                      #endif // 3x Tie fighter data structure ($19 bytes per Tie)
    PC = 0x68fe; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x4900; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0x6901:
L6901:

if (savetyNet) 
{
  if (savetyNetCount>100)
  {
    printf("Savetynet taken!\n");
    wr_mem((UINT16)(X + 0x0003), 0); 
    
  }
}  



                                                     #ifdef DEBUG
                                      mon("L6901    LDA   $03,X                   ; 6901: A6 03         \n");
                                      #endif
    PC = 0x6901; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0003)); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   locret_6911             ; 6903: 26 0C         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L6911;
    }
                                                     #ifdef DEBUG
                                      mon("         LEAX  $19,X                   ; 6905: 30 88 19      \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + (SINT8)0x19); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$494B                  ; 6908: 8C 49 4B      \n");
                                      #endif // 3x Tie fighter data structure ($19 bytes per Tie)
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x494b; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   L6901                   ; 690B: 25 F4         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L6901;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$23                    ; 690D: 86 23         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x23; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
extern int starWarsZoom;
starWarsZoom = 1;
    
                                                     #ifdef DEBUG
                                      mon("         STA   <$41                    ; 690F: 97 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0x41; 
    wr_mem(ea, val); 
    // End of function sub_68D0
  case 0x6911:
L6911:
locret_6911:

if (savetyNet) savetyNetCount++;

                                                     #ifdef DEBUG
                                      mon("locret_6911 RTS                           ; 6911: 39            \n");
                                      #endif
    PC = 0x6911; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x6912:
L6912:
                                                     #ifdef DEBUG
                                      mon("L6912    LDD   #$7780                  ; 6912: CC 77 80      \n");
                                      #endif
    PC = 0x6912; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x77; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$56                    ; 6915: DD 56         \n");
                                      #endif // Zoom value
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x56; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0100                  ; 6917: CC 01 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x01; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$58                    ; 691A: DD 58         \n");
                                      #endif // Death Star zoom value
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x58; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B2D                   ; 691C: B6 4B 2D      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b2d); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L692A                   ; 691F: 26 09         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L692A;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B14                   ; 6921: B6 4B 14      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b14); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$04                    ; 6924: 81 04         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x04; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   L692A                   ; 6926: 26 02         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L692A;
    }
                                                     #ifdef DEBUG
                                      mon("         BRA   L6930                   ; 6928: 20 06         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L6930;
    
    // ---------------------------------------------------------------------------
  case 0x692A:
L692A:
                                                     #ifdef DEBUG
                                      mon("L692A    JSR   $BD67                   ; 692A: BD BD 67      \n");
                                      #endif // Red 5 Im going in
    PC = 0x692a; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x2d); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x69); 
    clockticks = clockticks + 1; 
    PC = 0xbd67; 
    JUMP;
  case 0x692D:
L692D:
                                                     #ifdef DEBUG
                                      mon("L692D    JSR   $BDEE                   ; 692D: BD BD EE      \n");
                                      #endif // R2 beeps entering Death Star
    PC = 0x692d; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x30); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x69); 
    clockticks = clockticks + 1; 
    PC = 0xbdee; 
    JUMP;
  case 0x6930:
L6930:
                                                     #ifdef DEBUG
                                      mon("L6930    INC   <$41                    ; 6930: 0C 41         \n");
                                      #endif // Game mode/screen state
    PC = 0x6930; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x41); 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    wr_mem(DP|0x41, res); 
    clockticks = clockticks + 2; 
    // End of function sub_6912
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 6932: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Entering Death Star 2nd part
  case 0x6933:
L6933:
                                                     #ifdef DEBUG
                                      mon("L6933    JSR   L733C                   ; 6933: BD 73 3C      \n");
                                      #endif // End of space wave? Also Trench catwalks
    PC = 0x6933; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x36); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x69); 
    clockticks = clockticks + 1; 
    goto L733C;
  case 0x6936:
L6936:
                                                     #ifdef DEBUG
                                      mon("L6936    JSR   $B98B                   ; 6936: BD B9 8B      \n");
                                      #endif // Check if tie/bunker/tower been hit
    PC = 0x6936; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x39); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x69); 
    clockticks = clockticks + 1; 
    PC = 0xb98b; 
    JUMP;
  case 0x6939:
L6939:
                                                     #ifdef DEBUG
                                      mon("L6939    JSR   $9890                   ; 6939: BD 98 90      \n");
                                      #endif // Fireball timer 3
    PC = 0x6939; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x3c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x69); 
    clockticks = clockticks + 1; 
    PC = 0x9890; 
    JUMP;
  case 0x693C:
L693C:
                                                     #ifdef DEBUG
                                      mon("L693C    JSR   $9558                   ; 693C: BD 95 58      \n");
                                      #endif // Process shields
    PC = 0x693c; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x3f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x69); 
    clockticks = clockticks + 1; 
    PC = 0x9558; 
    JUMP;
  case 0x693F:
L693F:
                                                     #ifdef DEBUG
                                      mon("L693F    JSR   L6DD2                   ; 693F: BD 6D D2      \n");
                                      #endif
    PC = 0x693f; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x42); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x69); 
    clockticks = clockticks + 1; 
    goto L6DD2;
  case 0x6942:
L6942:
                                                     #ifdef DEBUG
                                      mon("L6942    JSR   L6F67                   ; 6942: BD 6F 67      \n");
                                      #endif
    PC = 0x6942; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x45); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x69); 
    clockticks = clockticks + 1; 
    goto L6F67;
  case 0x6945:
L6945:
                                                     #ifdef DEBUG
                                      mon("L6945    LDD   $5080                   ; 6945: FC 50 80      \n");
                                      #endif // Matrix 4
    PC = 0x6945; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x5080); // Care needed with I/O space and word fetches
    B = rd_mem(0x5081); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$3F00                  ; 6948: 10 83 3F 00   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x3f00; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BLT   locret_6952             ; 694C: 2D 04         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 3; 
    goto L6952;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$25                    ; 694E: 86 25         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x25; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$41                    ; 6950: 97 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0x41; 
    wr_mem(ea, val); 
    // End of function sub_6933
  case 0x6952:
L6952:
locret_6952:
                                                     #ifdef DEBUG
                                      mon("locret_6952 RTS                           ; 6952: 39            \n");
                                      #endif
    PC = 0x6952; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x6953:
L6953:
                                                     #ifdef DEBUG
                                      mon("L6953    LDA   $4B2D                   ; 6953: B6 4B 2D      \n");
                                      #endif
    PC = 0x6953; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b2d); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L6962                   ; 6956: 26 0A         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L6962;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B14                   ; 6958: B6 4B 14      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b14); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$04                    ; 695B: 81 04         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x04; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   L6962                   ; 695D: 26 03         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L6962;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   $BD53                   ; 695F: BD BD 53      \n");
                                      #endif // Look at the size of that thing
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x62); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x69); 
    clockticks = clockticks + 1; 
    PC = 0xbd53; 
    JUMP;
  case 0x6962:
L6962:
                                                     #ifdef DEBUG
                                      mon("L6962    JSR   $BE0C                   ; 6962: BD BE 0C      \n");
                                      #endif
    PC = 0x6962; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x65); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x69); 
    clockticks = clockticks + 1; 
    PC = 0xbe0c; 
    JUMP;
  case 0x6965:
L6965:
                                                     #ifdef DEBUG
                                      mon("L6965    INC   <$41                    ; 6965: 0C 41         \n");
                                      #endif // Game mode/screen state
    PC = 0x6965; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x41); 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    wr_mem(DP|0x41, res); 
    clockticks = clockticks + 2; 
    // End of function sub_6953
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 6967: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Entering Death Star zoom in
  case 0x6968:
L6968:
                                                     #ifdef DEBUG
                                      mon("L6968    JSR   L736F                   ; 6968: BD 73 6F      \n");
                                      #endif
    PC = 0x6968; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x6b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x69); 
    clockticks = clockticks + 1; 
    goto L736F;
  case 0x696B:
L696B:
                                                     #ifdef DEBUG
                                      mon("L696B    JSR   $9898                   ; 696B: BD 98 98      \n");
                                      #endif
    PC = 0x696b; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x6e); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x69); 
    clockticks = clockticks + 1; 
    PC = 0x9898; 
    JUMP;
  case 0x696E:
L696E:
                                                     #ifdef DEBUG
                                      mon("L696E    JSR   $9890                   ; 696E: BD 98 90      \n");
                                      #endif // Fireball timer 3
    PC = 0x696e; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x71); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x69); 
    clockticks = clockticks + 1; 
    PC = 0x9890; 
    JUMP;
  case 0x6971:
L6971:
                                                     #ifdef DEBUG
                                      mon("L6971    JSR   $9558                   ; 6971: BD 95 58      \n");
                                      #endif // Process shields
    PC = 0x6971; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x69); 
    clockticks = clockticks + 1; 
    PC = 0x9558; 
    JUMP;
  case 0x6974:
L6974:
                                                     #ifdef DEBUG
                                      mon("L6974    JSR   L6DD2                   ; 6974: BD 6D D2      \n");
                                      #endif
    PC = 0x6974; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x77); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x69); 
    clockticks = clockticks + 1; 
    goto L6DD2;
  case 0x6977:
L6977:
                                                     #ifdef DEBUG
                                      mon("L6977    JSR   L6F67                   ; 6977: BD 6F 67      \n");
                                      #endif
    PC = 0x6977; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x7a); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x69); 
    clockticks = clockticks + 1; 
    goto L6F67;
  case 0x697A:
L697A:
                                                     #ifdef DEBUG
                                      mon("L697A    LDB   <$58                    ; 697A: D6 58         \n");
                                      #endif // Death Star zoom value
    PC = 0x697a; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x58); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; 697C: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
 // C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SEX                           ; 697D: 1D            \n");
                                      #endif
 // Z = B; 
 // N = B; 
    A = ((SINT8)B < 0 ? 0xff : 0); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  <$56                    ; 697E: D3 56         \n");
                                      #endif // Zoom value
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x56)<<8; 
    ea = ea | rd_mem(DP|0x57); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$7F                    ; 6980: C4 7F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x7f; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$56                    ; 6982: DD 56         \n");
                                      #endif // Zoom value
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x56; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$7310                  ; 6984: 10 83 73 10   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x7310; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BHI   L6997                   ; 6988: 22 0D         \n");
                                      #endif
    // temp hack to force a flush
    if (Z && (!C)) {
    clockticks = clockticks + 3; 
    goto L6997;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B14                   ; 698A: B6 4B 14      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b14); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L6993                   ; 698D: 26 04         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L6993;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$27                    ; 698F: 86 27         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x27; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   L6995                   ; 6991: 20 02         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L6995;
    
    // ---------------------------------------------------------------------------
  case 0x6993:
L6993:
                                                     #ifdef DEBUG
                                      mon("L6993    LDA   #$29                    ; 6993: 86 29         \n");
                                      #endif
    PC = 0x6993; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x29; 
    A = val; 
    
    
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0x6995:
L6995:
                                                     #ifdef DEBUG
                                      mon("L6995    STA   <$41                    ; 6995: 97 41         \n");
                                      #endif // Game mode/screen state
    PC = 0x6995; 
starWarsZoom = 0;
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x41; 
    wr_mem(ea, val); 
  case 0x6997:
L6997:
                                                     #ifdef DEBUG
                                      mon("L6997    LDD   <$58                    ; 6997: DC 58         \n");
                                      #endif // Death Star zoom value
    PC = 0x6997; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x58); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x59); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$60                    ; 6999: C3 00 60      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0060; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$58                    ; 699C: DD 58         \n");
                                      #endif // Death Star zoom value
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x58; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$83                    ; 699E: 96 83         \n");
                                      #endif // Star intensity
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x83); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBA  #$02                    ; 69A0: 80 02         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x02; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)(res); 
                                                     #ifdef DEBUG
                                      mon("         BHI   L69A6                   ; 69A2: 22 02         \n");
                                      #endif
    // temp hack to force a flush
    if (Z && (!C)) {
    clockticks = clockticks + 3; 
    goto L69A6;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; 69A4: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0x69A6:
L69A6:
                                                     #ifdef DEBUG
                                      mon("L69A6    STA   <$83                    ; 69A6: 97 83         \n");
                                      #endif // Star intensity
    PC = 0x69a6; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0x83; 
    wr_mem(ea, val); 
    // End of function sub_6968
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 69A8: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Towers/Bunkers init
  case 0x69A9:
L69A9:
                                                     #ifdef DEBUG
                                      mon("L69A9    LDA   $4B15                   ; 69A9: B6 4B 15      \n");
                                      #endif
    PC = 0x69a9; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b15); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         DECA                          ; 69AC: 4A            \n");
                                      #endif
    val = (UINT8)A; 
    res = (UINT8)(val - 1); 
 // N = res; 
 // Z = res; 
 // V = val & ~res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$1F                    ; 69AD: 81 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x1f; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   L69B3                   ; 69AF: 25 02         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L69B3;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$1F                    ; 69B1: 86 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x1f; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0x69B3:
L69B3:
                                                     #ifdef DEBUG
                                      mon("L69B3    STA   $4B13                   ; 69B3: B7 4B 13      \n");
                                      #endif
    PC = 0x69b3; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b13, val); 
                                                     #ifdef DEBUG
                                      mon("         ADDA  $4B18                   ; 69B6: BB 4B 18      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    arg = rd_mem(0x4b18); 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$0F                    ; 69B9: 81 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x0f; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BLS   L69BF                   ; 69BB: 23 02         \n");
                                      #endif
    // temp hack to force a flush
    if ((!Z) || C) {
    clockticks = clockticks + 3; 
    goto L69BF;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$0F                    ; 69BD: 86 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x0f; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0x69BF:
L69BF:
                                                     #ifdef DEBUG
                                      mon("L69BF    STA   $4B19                   ; 69BF: B7 4B 19      \n");
                                      #endif
    PC = 0x69bf; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x4b19, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   L615A                   ; 69C2: BD 61 5A      \n");
                                      #endif // More stars/ties init stuff
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xc5); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x69); 
    clockticks = clockticks + 1; 
    goto L615A;
  case 0x69C5:
L69C5:
                                                     #ifdef DEBUG
                                      mon("L69C5    JSR   L620F                   ; 69C5: BD 62 0F      \n");
                                      #endif // Init towers surface dots
    PC = 0x69c5; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xc8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x69); 
    clockticks = clockticks + 1; 
    goto L620F;
  case 0x69C8:
L69C8:
                                                     #ifdef DEBUG
                                      mon("L69C8    JSR   $A1CE                   ; 69C8: BD A1 CE      \n");
                                      #endif
    PC = 0x69c8; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xcb); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x69); 
    clockticks = clockticks + 1; 
    PC = 0xa1ce; 
    JUMP;
  case 0x69CB:
L69CB:
                                                     #ifdef DEBUG
                                      mon("L69CB    JSR   $B939                   ; 69CB: BD B9 39      \n");
                                      #endif
    PC = 0x69cb; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xce); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x69); 
    clockticks = clockticks + 1; 
    PC = 0xb939; 
    JUMP;
  case 0x69CE:
L69CE:
                                                     #ifdef DEBUG
                                      mon("L69CE    LDD   #$0100                  ; 69CE: CC 01 00      \n");
                                      #endif
    PC = 0x69ce; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x01; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5086                   ; 69D1: FD 50 86      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5086, A); // Care needed with I/O space and word fetches
    wr_mem(0x5087, B); 
                                                     #ifdef DEBUG
                                      mon("         ASRA                          ; 69D4: 47            \n");
                                      #endif
    val = (UINT8)A; 
    C = val & 1; 
    val = (UINT8)((SINT8)val >> 1); 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         RORB                          ; 69D5: 56            \n");
                                      #endif
    res = ((UINT8)B) | ((C != 0) ? 0x100 : 0); 
    C = res & 1; 
    res = (UINT8)(res >> 1); 
 // Z = res; 
 // N = res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5098                   ; 69D6: FD 50 98      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5098, A); // Care needed with I/O space and word fetches
    wr_mem(0x5099, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$2000                  ; 69D9: CC 20 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x20; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $509C                   ; 69DC: FD 50 9C      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x509c, A); // Care needed with I/O space and word fetches
    wr_mem(0x509d, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; 69DF: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$A7                    ; 69E1: 97 A7         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xa7; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B35                   ; 69E3: B7 4B 35      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b35, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B3D                   ; 69E6: B7 4B 3D      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b3d, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; 69E9: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B0E                   ; 69EB: B7 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x4b0e, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   $BD94                   ; 69EE: BD BD 94      \n");
                                      #endif // Towers 1 music
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf1); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x69); 
    clockticks = clockticks + 1; 
    PC = 0xbd94; 
    JUMP;
  case 0x69F1:
L69F1:
                                                     #ifdef DEBUG
                                      mon("L69F1    INC   <$41                    ; 69F1: 0C 41         \n");
                                      #endif // Game mode/screen state
    PC = 0x69f1; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x41); 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    wr_mem(DP|0x41, res); 
    clockticks = clockticks + 2; 
    // End of function sub_69A9
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 69F3: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Towers/Bunkers wave
    // FUNCTION CHUNK AT ROM:6CB6 SIZE 0000000E BYTES
  case 0x69F4:
L69F4:
                                                     #ifdef DEBUG
                                      mon("L69F4    JSR   L7390                   ; 69F4: BD 73 90      \n");
                                      #endif // Towers/Bunkers wave
    PC = 0x69f4; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf7); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x69); 
    clockticks = clockticks + 1; 
    goto L7390;
  case 0x69F7:
L69F7:
                                                     #ifdef DEBUG
                                      mon("L69F7    LDA   <$60                    ; 69F7: 96 60         \n");
                                      #endif // Shield count
    PC = 0x69f7; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x60); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LBMI  L6CB6                   ; 69F9: 10 2B 02 B9   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if ((SINT8)N <  0) {
    clockticks = clockticks + 1; 
    goto L6CB6;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   $A849                   ; 69FD: BD A8 49      \n");
                                      #endif // Fireball movement
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x00); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6a); 
    clockticks = clockticks + 1; 
    PC = 0xa849; 
    JUMP;
  case 0x6A00:
L6A00:
                                                     #ifdef DEBUG
                                      mon("L6A00    JSR   $9890                   ; 6A00: BD 98 90      \n");
                                      #endif // Fireball timer 3
    PC = 0x6a00; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x03); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6a); 
    clockticks = clockticks + 1; 
    PC = 0x9890; 
    JUMP;
  case 0x6A03:
L6A03:
                                                     #ifdef DEBUG
                                      mon("L6A03    JSR   $9558                   ; 6A03: BD 95 58      \n");
                                      #endif // Process shields
    PC = 0x6a03; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x06); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6a); 
    clockticks = clockticks + 1; 
    PC = 0x9558; 
    JUMP;
  case 0x6A06:
L6A06:
                                                     #ifdef DEBUG
                                      mon("L6A06    JSR   $B98B                   ; 6A06: BD B9 8B      \n");
                                      #endif // Check if tie/bunker/tower been hit
    PC = 0x6a06; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x09); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6a); 
    clockticks = clockticks + 1; 
    PC = 0xb98b; 
    JUMP;
    // End of function sub_69F4
  case 0x6A09:
L6A09:
                                                     #ifdef DEBUG
                                      mon("L6A09    JSR   L70DB                   ; 6A09: BD 70 DB      \n");
                                      #endif
    PC = 0x6a09; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x0c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6a); 
    clockticks = clockticks + 1; 
    goto L70DB;
    // =============== S U B R O U T I N E =======================================
  case 0x6A0C:
L6A0C:
                                                     #ifdef DEBUG
                                      mon("L6A0C    JSR   L6E22                   ; 6A0C: BD 6E 22      \n");
                                      #endif
    PC = 0x6a0c; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x0f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6a); 
    clockticks = clockticks + 1; 
    goto L6E22;
  case 0x6A0F:
L6A0F:
                                                     #ifdef DEBUG
                                      mon("L6A0F    LDA   #$10                    ; 6A0F: 86 10         \n");
                                      #endif // BIC points to Matrix 4
    PC = 0x6a0f; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x10; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $CE0C                   ; 6A11: BD CE 0C      \n");
                                      #endif // Copy transform data from [BIC] to matrix 2
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x14); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6a); 
    clockticks = clockticks + 1; 
    PC = 0xce0c; 
    JUMP;
  case 0x6A14:
L6A14:
                                                     #ifdef DEBUG
                                      mon("L6A14    JSR   L6F6F                   ; 6A14: BD 6F 6F      \n");
                                      #endif
    PC = 0x6a14; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x17); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6a); 
    clockticks = clockticks + 1; 
    goto L6F6F;
  case 0x6A17:
L6A17:
                                                     #ifdef DEBUG
                                      mon("L6A17    LDD   $5086                   ; 6A17: FC 50 86      \n");
                                      #endif
    PC = 0x6a17; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x5086); // Care needed with I/O space and word fetches
    B = rd_mem(0x5087); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$01                    ; 6A1A: C3 00 01      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0001; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$0400                  ; 6A1D: 10 83 04 00   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x0400; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BHI   L6A26                   ; 6A21: 22 03         \n");
                                      #endif
    // temp hack to force a flush
    if (Z && (!C)) {
    clockticks = clockticks + 3; 
    goto L6A26;
    }
                                                     #ifdef DEBUG
                                      mon("         STD   $5086                   ; 6A23: FD 50 86      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5086, A); // Care needed with I/O space and word fetches
    wr_mem(0x5087, B); 
  case 0x6A26:
L6A26:
                                                     #ifdef DEBUG
                                      mon("L6A26    LDA   <$43                    ; 6A26: 96 43         \n");
                                      #endif // Game over/insert coins timer
    PC = 0x6a26; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x43); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$0F                    ; 6A28: 84 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x0f; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L6A39                   ; 6A2A: 26 0D         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L6A39;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B0E                   ; 6A2C: B6 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b0e); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$0E                    ; 6A2F: 81 0E         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x0e; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   L6A36                   ; 6A31: 26 03         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L6A36;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   $BD99                   ; 6A33: BD BD 99      \n");
                                      #endif // Towers 2 music
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x36); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6a); 
    clockticks = clockticks + 1; 
    PC = 0xbd99; 
    JUMP;
  case 0x6A36:
L6A36:
                                                     #ifdef DEBUG
                                      mon("L6A36    INC   $4B0E                   ; 6A36: 7C 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    PC = 0x6a36; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b0e); 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    wr_mem(0x4b0e, res); 
    clockticks = clockticks + 2; 
  case 0x6A39:
L6A39:
                                                     #ifdef DEBUG
                                      mon("L6A39    LDA   <$A7                    ; 6A39: 96 A7         \n");
                                      #endif
    PC = 0x6a39; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xa7); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$05                    ; 6A3B: 81 05         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x05; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   locret_6A4F             ; 6A3D: 25 10         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L6A4F;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$01                    ; 6A3F: 86 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x01; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B3D                   ; 6A41: B7 4B 3D      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b3d, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $5098                   ; 6A44: B6 50 98      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x5098); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$80                    ; 6A47: 81 80         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x80; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCC   locret_6A4F             ; 6A49: 24 04         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto L6A4F;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$2B                    ; 6A4B: 86 2B         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x2b; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$41                    ; 6A4D: 97 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0x41; 
    wr_mem(ea, val); 
    // End of function sub_6A0C
  case 0x6A4F:
L6A4F:
locret_6A4F:
                                                     #ifdef DEBUG
                                      mon("locret_6A4F RTS                           ; 6A4F: 39            \n");
                                      #endif
    PC = 0x6a4f; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Entering Death Star zoomed fully in
  case 0x6A50:
L6A50:
                                                     #ifdef DEBUG
                                      mon("L6A50    LDA   #$00                    ; 6A50: 86 00         \n");
                                      #endif
    PC = 0x6a50; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$98                    ; 6A52: 97 98         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x98; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B36                   ; 6A54: B7 4B 36      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b36, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B15                   ; 6A57: B6 4B 15      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b15); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$1F                    ; 6A5A: 81 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x1f; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BLS   L6A60                   ; 6A5C: 23 02         \n");
                                      #endif
    // temp hack to force a flush
    if ((!Z) || C) {
    clockticks = clockticks + 3; 
    goto L6A60;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$1F                    ; 6A5E: 86 1F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x1f; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0x6A60:
L6A60:
                                                     #ifdef DEBUG
                                      mon("L6A60    STA   $4B12                   ; 6A60: B7 4B 12      \n");
                                      #endif
    PC = 0x6a60; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b12, val); 
                                                     #ifdef DEBUG
                                      mon("         ADDA  $4B18                   ; 6A63: BB 4B 18      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    arg = rd_mem(0x4b18); 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$0F                    ; 6A66: 81 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x0f; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BLS   L6A6C                   ; 6A68: 23 02         \n");
                                      #endif
    // temp hack to force a flush
    if ((!Z) || C) {
    clockticks = clockticks + 3; 
    goto L6A6C;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$0F                    ; 6A6A: 86 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x0f; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0x6A6C:
L6A6C:
                                                     #ifdef DEBUG
                                      mon("L6A6C    STA   $4B19                   ; 6A6C: B7 4B 19      \n");
                                      #endif
    PC = 0x6a6c; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x4b19, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   $83A4                   ; 6A6F: BD 83 A4      \n");
                                      #endif // Called when starting trench
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x72); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6a); 
    clockticks = clockticks + 1; 
    PC = 0x83a4; 
    JUMP;
  case 0x6A72:
L6A72:
                                                     #ifdef DEBUG
                                      mon("L6A72    JSR   $BD71                   ; 6A72: BD BD 71      \n");
                                      #endif
    PC = 0x6a72; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x75); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6a); 
    clockticks = clockticks + 1; 
    PC = 0xbd71; 
    JUMP;
  case 0x6A75:
L6A75:
                                                     #ifdef DEBUG
                                      mon("L6A75    LDD   #$00                    ; 6A75: CC 00 00      \n");
                                      #endif
    PC = 0x6a75; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B0E                   ; 6A78: FD 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4b0e, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b0f, B); 
                                                     #ifdef DEBUG
                                      mon("         INC   <$41                    ; 6A7B: 0C 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x41); 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    wr_mem(DP|0x41, res); 
    clockticks = clockticks + 2; 
    // End of function sub_6A50
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 6A7D: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x6A7E:
L6A7E:
                                                     #ifdef DEBUG
                                      mon("L6A7E    JSR   L615A                   ; 6A7E: BD 61 5A      \n");
                                      #endif // More stars/ties init stuff
    PC = 0x6a7e; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x81); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6a); 
    clockticks = clockticks + 1; 
    goto L615A;
  case 0x6A81:
L6A81:
                                                     #ifdef DEBUG
                                      mon("L6A81    JSR   $8341                   ; 6A81: BD 83 41      \n");
                                      #endif // Entering trench
    PC = 0x6a81; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x84); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6a); 
    clockticks = clockticks + 1; 
    PC = 0x8341; 
    JUMP;
  case 0x6A84:
L6A84:
                                                     #ifdef DEBUG
                                      mon("L6A84    LDA   #$2F                    ; 6A84: 86 2F         \n");
                                      #endif
    PC = 0x6a84; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x2f; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$41                    ; 6A86: 97 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0x41; 
    wr_mem(ea, val); 
    // End of function sub_6A7E
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 6A88: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x6A89:
L6A89:
                                                     #ifdef DEBUG
                                      mon("L6A89    JSR   L73EA                   ; 6A89: BD 73 EA      \n");
                                      #endif // Towers
    PC = 0x6a89; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x8c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6a); 
    clockticks = clockticks + 1; 
    goto L73EA;
  case 0x6A8C:
L6A8C:
                                                     #ifdef DEBUG
                                      mon("L6A8C    JSR   $9890                   ; 6A8C: BD 98 90      \n");
                                      #endif // Fireball timer 3
    PC = 0x6a8c; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x8f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6a); 
    clockticks = clockticks + 1; 
    PC = 0x9890; 
    JUMP;
  case 0x6A8F:
L6A8F:
                                                     #ifdef DEBUG
                                      mon("L6A8F    JSR   $9558                   ; 6A8F: BD 95 58      \n");
                                      #endif // Process shields
    PC = 0x6a8f; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x92); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6a); 
    clockticks = clockticks + 1; 
    PC = 0x9558; 
    JUMP;
  case 0x6A92:
L6A92:
                                                     #ifdef DEBUG
                                      mon("L6A92    JSR   $B98B                   ; 6A92: BD B9 8B      \n");
                                      #endif // Check if tie/bunker/tower been hit
    PC = 0x6a92; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x95); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6a); 
    clockticks = clockticks + 1; 
    PC = 0xb98b; 
    JUMP;
  case 0x6A95:
L6A95:
                                                     #ifdef DEBUG
                                      mon("L6A95    JSR   L6FE0                   ; 6A95: BD 6F E0      \n");
                                      #endif
    PC = 0x6a95; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x98); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6a); 
    clockticks = clockticks + 1; 
    goto L6FE0;
  case 0x6A98:
L6A98:
                                                     #ifdef DEBUG
                                      mon("L6A98    LDD   $4B0E                   ; 6A98: FC 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    PC = 0x6a98; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x4b0e); // Care needed with I/O space and word fetches
    B = rd_mem(0x4b0f); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$01                    ; 6A9B: C3 00 01      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0001; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
  case 0x6A9E:
L6A9E:
                                                     #ifdef DEBUG
                                      mon("L6A9E    STD   $4B0E                   ; 6A9E: FD 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    PC = 0x6a9e; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4b0e, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b0f, B); 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$11                    ; 6AA1: 83 00 11      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0011; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BCS   locret_6AAA             ; 6AA4: 25 04         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L6AAA;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$2D                    ; 6AA6: 86 2D         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x2d; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$41                    ; 6AA8: 97 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0x41; 
    wr_mem(ea, val); 
    // End of function sub_6A89
  case 0x6AAA:
L6AAA:
locret_6AAA:
                                                     #ifdef DEBUG
                                      mon("locret_6AAA RTS                           ; 6AAA: 39            \n");
                                      #endif
    PC = 0x6aaa; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x6AAB:
L6AAB:
                                                     #ifdef DEBUG
                                      mon("L6AAB    LDD   #$00                    ; 6AAB: CC 00 00      \n");
                                      #endif
    PC = 0x6aab; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5098                   ; 6AAE: FD 50 98      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5098, A); // Care needed with I/O space and word fetches
    wr_mem(0x5099, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $509A                   ; 6AB1: FD 50 9A      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x509a, A); // Care needed with I/O space and word fetches
    wr_mem(0x509b, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B0E                   ; 6AB4: FD 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x4b0e, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b0f, B); 
                                                     #ifdef DEBUG
                                      mon("         JSR   L6FF1                   ; 6AB7: BD 6F F1      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xba); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6a); 
    clockticks = clockticks + 1; 
    goto L6FF1;
  case 0x6ABA:
L6ABA:
                                                     #ifdef DEBUG
                                      mon("L6ABA    JSR   $8341                   ; 6ABA: BD 83 41      \n");
                                      #endif // Entering trench
    PC = 0x6aba; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xbd); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6a); 
    clockticks = clockticks + 1; 
    PC = 0x8341; 
    JUMP;
  case 0x6ABD:
L6ABD:
                                                     #ifdef DEBUG
                                      mon("L6ABD    INC   <$41                    ; 6ABD: 0C 41         \n");
                                      #endif // Game mode/screen state
    PC = 0x6abd; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x41); 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    wr_mem(DP|0x41, res); 
    clockticks = clockticks + 2; 
  case 0x6ABF:
L6ABF:
                                                     #ifdef DEBUG
                                      mon("L6ABF    JSR   L7413                   ; 6ABF: BD 74 13      \n");
                                      #endif
    PC = 0x6abf; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xc2); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6a); 
    clockticks = clockticks + 1; 
    goto L7413;
  case 0x6AC2:
L6AC2:
                                                     #ifdef DEBUG
                                      mon("L6AC2    JSR   $9890                   ; 6AC2: BD 98 90      \n");
                                      #endif // Fireball timer 3
    PC = 0x6ac2; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xc5); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6a); 
    clockticks = clockticks + 1; 
    PC = 0x9890; 
    JUMP;
  case 0x6AC5:
L6AC5:
                                                     #ifdef DEBUG
                                      mon("L6AC5    JSR   $9558                   ; 6AC5: BD 95 58      \n");
                                      #endif // Process shields
    PC = 0x6ac5; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xc8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6a); 
    clockticks = clockticks + 1; 
    PC = 0x9558; 
    JUMP;
  case 0x6AC8:
L6AC8:
                                                     #ifdef DEBUG
                                      mon("L6AC8    JSR   $B98B                   ; 6AC8: BD B9 8B      \n");
                                      #endif // Check if tie/bunker/tower been hit
    PC = 0x6ac8; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xcb); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6a); 
    clockticks = clockticks + 1; 
    PC = 0xb98b; 
    JUMP;
  case 0x6ACB:
L6ACB:
                                                     #ifdef DEBUG
                                      mon("L6ACB    JSR   L6FF1                   ; 6ACB: BD 6F F1      \n");
                                      #endif
    PC = 0x6acb; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xce); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6a); 
    clockticks = clockticks + 1; 
    goto L6FF1;
  case 0x6ACE:
L6ACE:
                                                     #ifdef DEBUG
                                      mon("L6ACE    LDD   $4B0E                   ; 6ACE: FC 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    PC = 0x6ace; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x4b0e); // Care needed with I/O space and word fetches
    B = rd_mem(0x4b0f); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$01                    ; 6AD1: C3 00 01      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0001; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B0E                   ; 6AD4: FD 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4b0e, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b0f, B); 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$11                    ; 6AD7: 83 00 11      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0011; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BCS   locret_6AFE             ; 6ADA: 25 22         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L6AFE;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   $5098                   ; 6ADC: BE 50 98      \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5098)<<8; 
    ea = ea | rd_mem(0x5099); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   $509A                   ; 6ADF: FE 50 9A      \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x509a)<<8; 
    ea = ea | rd_mem(0x509b); 
    U = ea; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   $509C                   ; 6AE2: FC 50 9C      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x509c); // Care needed with I/O space and word fetches
    B = rd_mem(0x509d); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         PSHS  U,X,B,A                 ; 6AE5: 34 56         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 2; 
    --S;
    wr_mem(S, U); 
    --S;
    wr_mem(S, U >> 8); 
    clockticks = clockticks + 1; 
    clockticks = clockticks + 2; 
    --S;
    wr_mem(S, X); 
    --S;
    wr_mem(S, X >> 8); 
    clockticks = clockticks + 1; 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, B); 
    clockticks = clockticks + 1; 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, A); 
    clockticks = clockticks + 1; 
                                                     #ifdef DEBUG
                                      mon("         JSR   L615A                   ; 6AE7: BD 61 5A      \n");
                                      #endif // More stars/ties init stuff
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xea); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6a); 
    clockticks = clockticks + 1; 
    goto L615A;
  case 0x6AEA:
L6AEA:
                                                     #ifdef DEBUG
                                      mon("L6AEA    PULS  A,B,X,U                 ; 6AEA: 35 56         \n");
                                      #endif
    PC = 0x6aea; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    clockticks = clockticks + 1; 
    A = rd_mem(S); 
    S++;
    clockticks = clockticks + 1; 
    clockticks = clockticks + 1; 
    B = rd_mem(S); 
    S++;
    clockticks = clockticks + 2; 
    clockticks = clockticks + 1; 
    X = rd_mem(S)<<8; 
    S++;
    X = X | rd_mem(S); 
    S++;
    clockticks = clockticks + 2; 
    clockticks = clockticks + 1; 
    U = rd_mem(S)<<8; 
    S++;
    U = U | rd_mem(S); 
    S++;
                                                     #ifdef DEBUG
                                      mon("         STX   $5098                   ; 6AEC: BF 50 98      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = X; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    wr_mem(0x5098, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem(0x5099, (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         STU   $509A                   ; 6AEF: FF 50 9A      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    wr_mem(0x509a, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem(0x509b, (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         STD   $509C                   ; 6AF2: FD 50 9C      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x509c, A); // Care needed with I/O space and word fetches
    wr_mem(0x509d, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; 6AF5: 86 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B36                   ; 6AF7: B7 4B 36      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b36, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$2F                    ; 6AFA: 86 2F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x2f; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$41                    ; 6AFC: 97 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0x41; 
    wr_mem(ea, val); 
    // End of function sub_6AAB
  case 0x6AFE:
L6AFE:
locret_6AFE:
                                                     #ifdef DEBUG
                                      mon("locret_6AFE RTS                           ; 6AFE: 39            \n");
                                      #endif
    PC = 0x6afe; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x6AFF:
L6AFF:
                                                     #ifdef DEBUG
                                      mon("L6AFF    LDA   #$01                    ; 6AFF: 86 01         \n");
                                      #endif
    PC = 0x6aff; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x01; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$98                    ; 6B01: 97 98         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0x98; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   L615A                   ; 6B03: BD 61 5A      \n");
                                      #endif // More stars/ties init stuff
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x06); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6b); 
    clockticks = clockticks + 1; 
    goto L615A;
  case 0x6B06:
L6B06:
                                                     #ifdef DEBUG
                                      mon("L6B06    JSR   $8341                   ; 6B06: BD 83 41      \n");
                                      #endif // Entering trench
    PC = 0x6b06; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x09); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6b); 
    clockticks = clockticks + 1; 
    PC = 0x8341; 
    JUMP;
  case 0x6B09:
L6B09:
                                                     #ifdef DEBUG
                                      mon("L6B09    LDA   #$FF                    ; 6B09: 86 FF         \n");
                                      #endif
    PC = 0x6b09; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0xff; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B36                   ; 6B0B: B7 4B 36      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b36, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B19                   ; 6B0E: B6 4B 19      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b19); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDA  $4B17                   ; 6B11: BB 4B 17      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    arg = rd_mem(0x4b17); 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$0F                    ; 6B14: 81 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x0f; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BLS   L6B1A                   ; 6B16: 23 02         \n");
                                      #endif
    // temp hack to force a flush
    if ((!Z) || C) {
    clockticks = clockticks + 3; 
    goto L6B1A;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$0F                    ; 6B18: 86 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x0f; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0x6B1A:
L6B1A:
                                                     #ifdef DEBUG
                                      mon("L6B1A    STA   $4B19                   ; 6B1A: B7 4B 19      \n");
                                      #endif
    PC = 0x6b1a; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b19, val); 
  case 0x6B1D:
L6B1D:
                                                     #ifdef DEBUG
                                      mon("L6B1D    LDA   #$2F                    ; 6B1D: 86 2F         \n");
                                      #endif
    PC = 0x6b1d; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x2f; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$41                    ; 6B1F: 97 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0x41; 
    wr_mem(ea, val); 
    // End of function sub_6AFF
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 6B21: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // FUNCTION CHUNK AT ROM:6CE1 SIZE 0000000E BYTES
  case 0x6B22:
L6B22:
                                                     #ifdef DEBUG
                                      mon("L6B22    LDA   #$00                    ; 6B22: 86 00         \n");
                                      #endif
    PC = 0x6b22; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B3E                   ; 6B24: B7 4B 3E      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b3e, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B0E                   ; 6B27: B7 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b0e, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0300                  ; 6B2A: CC 03 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x03; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5086                   ; 6B2D: FD 50 86      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5086, A); // Care needed with I/O space and word fetches
    wr_mem(0x5087, B); 
                                                     #ifdef DEBUG
                                      mon("         INC   <$41                    ; 6B30: 0C 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x41); 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    wr_mem(DP|0x41, res); 
    clockticks = clockticks + 2; 
  case 0x6B32:
L6B32:
                                                     #ifdef DEBUG
                                      mon("L6B32    JSR   L743C                   ; 6B32: BD 74 3C      \n");
                                      #endif // Trench
    PC = 0x6b32; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x35); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6b); 
    clockticks = clockticks + 1; 
    goto L743C;
  case 0x6B35:
L6B35:
                                                     #ifdef DEBUG
                                      mon("L6B35    LDA   <$60                    ; 6B35: 96 60         \n");
                                      #endif // Shield count
    PC = 0x6b35; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x60); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LBMI  L6CE1                   ; 6B37: 10 2B 01 A6   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if ((SINT8)N <  0) {
    clockticks = clockticks + 1; 
    goto L6CE1;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   $A849                   ; 6B3B: BD A8 49      \n");
                                      #endif // Fireball movement
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x3e); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6b); 
    clockticks = clockticks + 1; 
    PC = 0xa849; 
    JUMP;
  case 0x6B3E:
L6B3E:
                                                     #ifdef DEBUG
                                      mon("L6B3E    JSR   $AD6C                   ; 6B3E: BD AD 6C      \n");
                                      #endif
    PC = 0x6b3e; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x41); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6b); 
    clockticks = clockticks + 1; 
    PC = 0xad6c; 
    JUMP;
  case 0x6B41:
L6B41:
                                                     #ifdef DEBUG
                                      mon("L6B41    JSR   $8495                   ; 6B41: BD 84 95      \n");
                                      #endif
    PC = 0x6b41; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x44); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6b); 
    clockticks = clockticks + 1; 
    PC = 0x8495; 
    JUMP;
  case 0x6B44:
L6B44:
                                                     #ifdef DEBUG
                                      mon("L6B44    JSR   $9886                   ; 6B44: BD 98 86      \n");
                                      #endif // Fireball timer 2
    PC = 0x6b44; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x47); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6b); 
    clockticks = clockticks + 1; 
    PC = 0x9886; 
    JUMP;
  case 0x6B47:
L6B47:
                                                     #ifdef DEBUG
                                      mon("L6B47    JSR   $9558                   ; 6B47: BD 95 58      \n");
                                      #endif // Process shields
    PC = 0x6b47; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x4a); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6b); 
    clockticks = clockticks + 1; 
    PC = 0x9558; 
    JUMP;
  case 0x6B4A:
L6B4A:
                                                     #ifdef DEBUG
                                      mon("L6B4A    JSR   L70DB                   ; 6B4A: BD 70 DB      \n");
                                      #endif
    PC = 0x6b4a; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x4d); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6b); 
    clockticks = clockticks + 1; 
    goto L70DB;
  case 0x6B4D:
L6B4D:
                                                     #ifdef DEBUG
                                      mon("L6B4D    JSR   nullL1                  ; 6B4D: BD 6E A1      \n");
                                      #endif
    PC = 0x6b4d; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x50); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6b); 
    clockticks = clockticks + 1; 
    goto L6EA1;
  case 0x6B50:
L6B50:
                                                     #ifdef DEBUG
                                      mon("L6B50    LDA   #$10                    ; 6B50: 86 10         \n");
                                      #endif // BIC points to Matrix 4
    PC = 0x6b50; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x10; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $CE0C                   ; 6B52: BD CE 0C      \n");
                                      #endif // Copy transform data from [BIC] to matrix 2
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x55); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6b); 
    clockticks = clockticks + 1; 
    PC = 0xce0c; 
    JUMP;
  case 0x6B55:
L6B55:
                                                     #ifdef DEBUG
                                      mon("L6B55    JSR   L703B                   ; 6B55: BD 70 3B      \n");
                                      #endif // Trench viewpoint calc
    PC = 0x6b55; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x58); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6b); 
    clockticks = clockticks + 1; 
    goto L703B;
  case 0x6B58:
L6B58:
                                                     #ifdef DEBUG
                                      mon("L6B58    LDA   <$43                    ; 6B58: 96 43         \n");
                                      #endif // Game over/insert coins timer
    PC = 0x6b58; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x43); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$0F                    ; 6B5A: 84 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x0f; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L6B99                   ; 6B5C: 26 3B         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L6B99;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B0E                   ; 6B5E: B6 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b0e); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$02                    ; 6B61: 81 02         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x02; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   L6B68                   ; 6B63: 26 03         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L6B68;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   $BD9E                   ; 6B65: BD BD 9E      \n");
                                      #endif // Trench music
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x68); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6b); 
    clockticks = clockticks + 1; 
    PC = 0xbd9e; 
    JUMP;
  case 0x6B68:
L6B68:
                                                     #ifdef DEBUG
                                      mon("L6B68    LDA   $4B12                   ; 6B68: B6 4B 12      \n");
                                      #endif
    PC = 0x6b68; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b12); 
    A = val; 
 // N = val; 
 // Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; 6B6B: 44            \n");
                                      #endif
    val = (UINT8)A; 
    C = val & 1; 
    val = val >> 1; 
    A = val; 
    N = 0; 
    Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BCS   L6B83                   ; 6B6C: 25 15         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L6B83;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B0E                   ; 6B6E: B6 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b0e); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$10                    ; 6B71: 81 10         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x10; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   L6B7A                   ; 6B73: 26 05         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L6B7A;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   $BD6C                   ; 6B75: BD BD 6C      \n");
                                      #endif // Luke trust me
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x78); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6b); 
    clockticks = clockticks + 1; 
    PC = 0xbd6c; 
    JUMP;
  case 0x6B78:
L6B78:
                                                     #ifdef DEBUG
                                      mon("L6B78    BRA   L6B81                   ; 6B78: 20 07         \n");
                                      #endif
    PC = 0x6b78; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto L6B81;
    
    // ---------------------------------------------------------------------------
  case 0x6B7A:
L6B7A:
                                                     #ifdef DEBUG
                                      mon("L6B7A    CMPA  #$18                    ; 6B7A: 81 18         \n");
                                      #endif
    PC = 0x6b7a; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x18; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   L6B81                   ; 6B7C: 26 03         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L6B81;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   $BD76                   ; 6B7E: BD BD 76      \n");
                                      #endif // Yahoo youre all clear kid
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x81); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6b); 
    clockticks = clockticks + 1; 
    PC = 0xbd76; 
    JUMP;
  case 0x6B81:
L6B81:
                                                     #ifdef DEBUG
                                      mon("L6B81    BRA   L6B96                   ; 6B81: 20 13         \n");
                                      #endif
    PC = 0x6b81; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto L6B96;
    
    // ---------------------------------------------------------------------------
  case 0x6B83:
L6B83:
                                                     #ifdef DEBUG
                                      mon("L6B83    LDA   $4B0E                   ; 6B83: B6 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    PC = 0x6b83; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b0e); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$10                    ; 6B86: 81 10         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x10; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   L6B8F                   ; 6B88: 26 05         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L6B8F;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   $BD30                   ; 6B8A: BD BD 30      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x8d); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6b); 
    clockticks = clockticks + 1; 
    PC = 0xbd30; 
    JUMP;
  case 0x6B8D:
L6B8D:
                                                     #ifdef DEBUG
                                      mon("L6B8D    BRA   L6B96                   ; 6B8D: 20 07         \n");
                                      #endif
    PC = 0x6b8d; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto L6B96;
    
    // ---------------------------------------------------------------------------
  case 0x6B8F:
L6B8F:
                                                     #ifdef DEBUG
                                      mon("L6B8F    CMPA  #$16                    ; 6B8F: 81 16         \n");
                                      #endif
    PC = 0x6b8f; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x16; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   L6B96                   ; 6B91: 26 03         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L6B96;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   $BD62                   ; 6B93: BD BD 62      \n");
                                      #endif // Force is strong in this one
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x96); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6b); 
    clockticks = clockticks + 1; 
    PC = 0xbd62; 
    JUMP;
  case 0x6B96:
L6B96:
                                                     #ifdef DEBUG
                                      mon("L6B96    INC   $4B0E                   ; 6B96: 7C 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    PC = 0x6b96; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b0e); 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    wr_mem(0x4b0e, res); 
    clockticks = clockticks + 2; 
  case 0x6B99:
L6B99:
                                                     #ifdef DEBUG
                                      mon("L6B99    LDA   <$92                    ; 6B99: 96 92         \n");
                                      #endif
    PC = 0x6b99; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x92); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   locret_6BDA             ; 6B9B: 27 3D         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L6BDA;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   <$93                    ; 6B9D: DC 93         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x93); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x94); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5098                   ; 6B9F: B3 50 98      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5098)<<8; 
    ea = ea | rd_mem(0x5099); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$0800                  ; 6BA2: 83 08 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0800; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BHI   locret_6BDA             ; 6BA5: 22 33         \n");
                                      #endif
    // temp hack to force a flush
    if (Z && (!C)) {
    clockticks = clockticks + 3; 
    goto L6BDA;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4845                   ; 6BA7: B6 48 45      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4845); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L6BC6                   ; 6BAA: 26 1A         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L6BC6;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$01                    ; 6BAC: 86 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x01; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B3E                   ; 6BAE: B7 4B 3E      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x4b3e, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   $BDB2                   ; 6BB1: BD BD B2      \n");
                                      #endif // Explosion
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xb4); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6b); 
    clockticks = clockticks + 1; 
    PC = 0xbdb2; 
    JUMP;
  case 0x6BB4:
L6BB4:
                                                     #ifdef DEBUG
                                      mon("L6BB4    JSR   $9874                   ; 6BB4: BD 98 74      \n");
                                      #endif
    PC = 0x6bb4; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xb7); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6b); 
    clockticks = clockticks + 1; 
    PC = 0x9874; 
    JUMP;
  case 0x6BB7:
L6BB7:
                                                     #ifdef DEBUG
                                      mon("L6BB7    LDA   <$60                    ; 6BB7: 96 60         \n");
                                      #endif // Shield count
    PC = 0x6bb7; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x60); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LBLE  L6CE1                   ; 6BB9: 10 2F 01 24   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 1; 
    goto L6CE1;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$31                    ; 6BBD: 86 31         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x31; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$41                    ; 6BBF: 97 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0x41; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   $BD3A                   ; 6BC1: BD BD 3A      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xc4); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6b); 
    clockticks = clockticks + 1; 
    PC = 0xbd3a; 
    JUMP;
  case 0x6BC4:
L6BC4:
                                                     #ifdef DEBUG
                                      mon("L6BC4    BRA   locret_6BDA             ; 6BC4: 20 14         \n");
                                      #endif
    PC = 0x6bc4; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto L6BDA;
    
    // ---------------------------------------------------------------------------
  case 0x6BC6:
L6BC6:
                                                     #ifdef DEBUG
                                      mon("L6BC6    LDA   #$11                    ; 6BC6: 86 11         \n");
                                      #endif
    PC = 0x6bc6; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x11; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$41                    ; 6BC8: 97 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x41; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B15                   ; 6BCA: B6 4B 15      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b15); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$03                    ; 6BCD: 81 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x03; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BLT   locret_6BDA             ; 6BCF: 2D 09         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 3; 
    goto L6BDA;
    }
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$01                    ; 6BD1: 84 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x01; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   locret_6BDA             ; 6BD3: 27 05         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L6BDA;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   $BD17                   ; 6BD5: BD BD 17      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xd8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6b); 
    clockticks = clockticks + 1; 
    PC = 0xbd17; 
    JUMP;
  case 0x6BD8:
L6BD8:
                                                     #ifdef DEBUG
                                      mon("L6BD8    BRA   locret_6BDA             ; 6BD8: 20 00         \n");
                                      #endif
    PC = 0x6bd8; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto L6BDA;
    
    // End of function sub_6B22
  case 0x6BDA:
L6BDA:
locret_6BDA:
                                                     #ifdef DEBUG
                                      mon("locret_6BDA RTS                           ; 6BDA: 39            \n");
                                      #endif
    PC = 0x6bda; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x6BDB:
L6BDB:
                                                     #ifdef DEBUG
                                      mon("L6BDB    JSR   L61B5                   ; 6BDB: BD 61 B5      \n");
                                      #endif // Set up math constants
    PC = 0x6bdb; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xde); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6b); 
    clockticks = clockticks + 1; 
    goto L61B5;
  case 0x6BDE:
L6BDE:
                                                     #ifdef DEBUG
                                      mon("L6BDE    JSR   L615A                   ; 6BDE: BD 61 5A      \n");
                                      #endif // More stars/ties init stuff
    PC = 0x6bde; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xe1); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6b); 
    clockticks = clockticks + 1; 
    goto L615A;
  case 0x6BE1:
L6BE1:
                                                     #ifdef DEBUG
                                      mon("L6BE1    LDA   #$C0                    ; 6BE1: 86 C0         \n");
                                      #endif
    PC = 0x6be1; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0xc0; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $5080                   ; 6BE3: B7 50 80      \n");
                                      #endif // Matrix 4
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x5080, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   $508A                   ; 6BE6: B7 50 8A      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x508a, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$04                    ; 6BE9: 86 04         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x04; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B0E                   ; 6BEB: B7 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b0e, val); 
                                                     #ifdef DEBUG
                                      mon("         INC   <$41                    ; 6BEE: 0C 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x41); 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    wr_mem(DP|0x41, res); 
    clockticks = clockticks + 2; 
    // End of function sub_6BDB
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 6BF0: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Death Star explosion complete
  case 0x6BF1:
L6BF1:
                                                     #ifdef DEBUG
                                      mon("L6BF1    LDA   <$43                    ; 6BF1: 96 43         \n");
                                      #endif // Game over/insert coins timer
    PC = 0x6bf1; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x43); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$0F                    ; 6BF3: 84 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x0f; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L6C2C                   ; 6BF5: 26 35         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L6C2C;
    }
                                                     #ifdef DEBUG
                                      mon("         DEC   $4B0E                   ; 6BF7: 7A 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b0e); 
    res = (UINT8)(val - 1); 
 // N = res; 
 // Z = res; 
 // V = val & ~res; 
    wr_mem(0x4b0e, res); 
    clockticks = clockticks + 2; 
  case 0x6BFA:
L6BFA:
                                                     #ifdef DEBUG
                                      mon("L6BFA    LDA   $4B0E                   ; 6BFA: B6 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    PC = 0x6bfa; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b0e); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$03                    ; 6BFD: 81 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x03; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   L6C09                   ; 6BFF: 26 08         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L6C09;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4845                   ; 6C01: B6 48 45      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4845); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L6C09                   ; 6C04: 27 03         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L6C09;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   $9806                   ; 6C06: BD 98 06      \n");
                                      #endif // Exhaust port score
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x09); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6c); 
    clockticks = clockticks + 1; 
    PC = 0x9806; 
    JUMP;
  case 0x6C09:
L6C09:
                                                     #ifdef DEBUG
                                      mon("L6C09    LDA   $4B0E                   ; 6C09: B6 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    PC = 0x6c09; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b0e); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$02                    ; 6C0C: 81 02         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x02; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   L6C13                   ; 6C0E: 26 03         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L6C13;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   $9775                   ; 6C10: BD 97 75      \n");
                                      #endif // Shield bonus score
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x13); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6c); 
    clockticks = clockticks + 1; 
    PC = 0x9775; 
    JUMP;
  case 0x6C13:
L6C13:
                                                     #ifdef DEBUG
                                      mon("L6C13    LDA   $4B0E                   ; 6C13: B6 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    PC = 0x6c13; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b0e); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$01                    ; 6C16: 81 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x01; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   L6C22                   ; 6C18: 26 08         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L6C22;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4845                   ; 6C1A: B6 48 45      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4845); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L6C22                   ; 6C1D: 27 03         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L6C22;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   L953B                   ; 6C1F: BD 95 3B      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x22); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6c); 
    clockticks = clockticks + 1; 
    PC = 0x953b; 
    JUMP;
  case 0x6C22:
L6C22:
                                                     #ifdef DEBUG
                                      mon("L6C22    LDA   $4B0E                   ; 6C22: B6 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    PC = 0x6c22; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b0e); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$00                    ; 6C25: 81 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x00; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   L6C2C                   ; 6C27: 26 03         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L6C2C;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   $9722                   ; 6C29: BD 97 22      \n");
                                      #endif // Death Star starting wave bonus score
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x2c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6c); 
    clockticks = clockticks + 1; 
    PC = 0x9722; 
    JUMP;
  case 0x6C2C:
L6C2C:
                                                     #ifdef DEBUG
                                      mon("L6C2C    JSR   L7519                   ; 6C2C: BD 75 19      \n");
                                      #endif
    PC = 0x6c2c; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x2f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6c); 
    clockticks = clockticks + 1; 
    goto L7519;
  case 0x6C2F:
L6C2F:
                                                     #ifdef DEBUG
                                      mon("L6C2F    JSR   $9558                   ; 6C2F: BD 95 58      \n");
                                      #endif // Process shields
    PC = 0x6c2f; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x32); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6c); 
    clockticks = clockticks + 1; 
    PC = 0x9558; 
    JUMP;
  case 0x6C32:
L6C32:
                                                     #ifdef DEBUG
                                      mon("L6C32    JSR   L6F5F                   ; 6C32: BD 6F 5F      \n");
                                      #endif
    PC = 0x6c32; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x35); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6c); 
    clockticks = clockticks + 1; 
    goto L6F5F;
  case 0x6C35:
L6C35:
                                                     #ifdef DEBUG
                                      mon("L6C35    LDA   $4B0E                   ; 6C35: B6 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    PC = 0x6c35; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b0e); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$FE                    ; 6C38: 81 FE         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xfe; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   locret_6C75             ; 6C3A: 26 39         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L6C75;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B15                   ; 6C3C: B6 4B 15      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b15); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         INCA                          ; 6C3F: 4C            \n");
                                      #endif
    val = (UINT8)A; 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$62                    ; 6C40: 81 62         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x62; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BLS   L6C46                   ; 6C42: 23 02         \n");
                                      #endif
    // temp hack to force a flush
    if ((!Z) || C) {
    clockticks = clockticks + 3; 
    goto L6C46;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$62                    ; 6C44: 86 62         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x62; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0x6C46:
L6C46:
                                                     #ifdef DEBUG
                                      mon("L6C46    STA   $4B15                   ; 6C46: B7 4B 15      \n");
                                      #endif
    PC = 0x6c46; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b15, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B15                   ; 6C49: B6 4B 15      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b15); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$05                    ; 6C4C: 81 05         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x05; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCC   L6C5D                   ; 6C4E: 24 0D         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto L6C5D;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B17                   ; 6C50: B6 4B 17      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b17); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         INCA                          ; 6C53: 4C            \n");
                                      #endif
    val = (UINT8)A; 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$04                    ; 6C54: 81 04         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x04; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BLS   L6C5A                   ; 6C56: 23 02         \n");
                                      #endif
    // temp hack to force a flush
    if ((!Z) || C) {
    clockticks = clockticks + 3; 
    goto L6C5A;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$04                    ; 6C58: 86 04         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x04; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0x6C5A:
L6C5A:
                                                     #ifdef DEBUG
                                      mon("L6C5A    STA   $4B17                   ; 6C5A: B7 4B 17      \n");
                                      #endif
    PC = 0x6c5a; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b17, val); 
  case 0x6C5D:
L6C5D:
                                                     #ifdef DEBUG
                                      mon("L6C5D    LDA   $4B18                   ; 6C5D: B6 4B 18      \n");
                                      #endif
    PC = 0x6c5d; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b18); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDA  $4B17                   ; 6C60: BB 4B 17      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    arg = rd_mem(0x4b17); 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$0F                    ; 6C63: 81 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x0f; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BLS   L6C69                   ; 6C65: 23 02         \n");
                                      #endif
    // temp hack to force a flush
    if ((!Z) || C) {
    clockticks = clockticks + 3; 
    goto L6C69;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$0F                    ; 6C67: 86 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x0f; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0x6C69:
L6C69:
                                                     #ifdef DEBUG
                                      mon("L6C69    STA   $4B18                   ; 6C69: B7 4B 18      \n");
                                      #endif
    PC = 0x6c69; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b18, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$FF                    ; 6C6C: 86 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xff; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B2D                   ; 6C6E: B7 4B 2D      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b2d, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$1D                    ; 6C71: 86 1D         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x1d; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$41                    ; 6C73: 97 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0x41; 
    wr_mem(ea, val); 
    // End of function sub_6BF1
  case 0x6C75:
L6C75:
locret_6C75:
                                                     #ifdef DEBUG
                                      mon("locret_6C75 RTS                           ; 6C75: 39            \n");
                                      #endif
    PC = 0x6c75; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
    // START OF FUNCTION CHUNK FOR sub_6838
  case 0x6C76:
L6C76:
                                                     #ifdef DEBUG
                                      mon("L6C76    JSR   $BD58                   ; 6C76: BD BD 58      \n");
                                      #endif // Stay in attack formation
    PC = 0x6c76; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x79); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6c); 
    clockticks = clockticks + 1; 
    PC = 0xbd58; 
    JUMP;
  case 0x6C79:
L6C79:
                                                     #ifdef DEBUG
                                      mon("L6C79    LDA   #$36                    ; 6C79: 86 36         \n");
                                      #endif
    PC = 0x6c79; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x36; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$41                    ; 6C7B: 97 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x41; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; 6C7D: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B0E                   ; 6C80: FD 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x4b0e, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b0f, B); 
    // END OF FUNCTION CHUNK FOR sub_6838
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 6C83: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Towers
  case 0x6C84:
L6C84:
                                                     #ifdef DEBUG
                                      mon("L6C84    JSR   L7315                   ; 6C84: BD 73 15      \n");
                                      #endif
    PC = 0x6c84; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x87); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6c); 
    clockticks = clockticks + 1; 
    goto L7315;
  case 0x6C87:
L6C87:
                                                     #ifdef DEBUG
                                      mon("L6C87    JSR   $A849                   ; 6C87: BD A8 49      \n");
                                      #endif // Fireball movement
    PC = 0x6c87; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x8a); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6c); 
    clockticks = clockticks + 1; 
    PC = 0xa849; 
    JUMP;
  case 0x6C8A:
L6C8A:
                                                     #ifdef DEBUG
                                      mon("L6C8A    JSR   $987F                   ; 6C8A: BD 98 7F      \n");
                                      #endif // Fireball timer
    PC = 0x6c8a; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x8d); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6c); 
    clockticks = clockticks + 1; 
    PC = 0x987f; 
    JUMP;
  case 0x6C8D:
L6C8D:
                                                     #ifdef DEBUG
                                      mon("L6C8D    JSR   $9898                   ; 6C8D: BD 98 98      \n");
                                      #endif
    PC = 0x6c8d; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x90); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6c); 
    clockticks = clockticks + 1; 
    PC = 0x9898; 
    JUMP;
  case 0x6C90:
L6C90:
                                                     #ifdef DEBUG
                                      mon("L6C90    JSR   $B98B                   ; 6C90: BD B9 8B      \n");
                                      #endif // Check if tie/bunker/tower been hit
    PC = 0x6c90; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x93); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6c); 
    clockticks = clockticks + 1; 
    PC = 0xb98b; 
    JUMP;
  case 0x6C93:
L6C93:
                                                     #ifdef DEBUG
                                      mon("L6C93    LDD   #$FB01                  ; 6C93: CC FB 01      \n");
                                      #endif
    PC = 0x6c93; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0xfb; 
    B = 0x01; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5022                   ; 6C96: FD 50 22      \n");
                                      #endif // Sine for rotation
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5022, A); // Care needed with I/O space and word fetches
    wr_mem(0x5023, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$3FCE                  ; 6C99: CC 3F CE      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x3f; 
    B = 0xce; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5024                   ; 6C9C: FD 50 24      \n");
                                      #endif // Cosine for rotation
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x5024, A); // Care needed with I/O space and word fetches
    wr_mem(0x5025, B); 
                                                     #ifdef DEBUG
                                      mon("         JSR   $CE24                   ; 6C9F: BD CE 24      \n");
                                      #endif // Run math program $00 Roll on Matrix 4
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xa2); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6c); 
    clockticks = clockticks + 1; 
    PC = 0xce24; 
    JUMP;
  case 0x6CA2:
L6CA2:
                                                     #ifdef DEBUG
                                      mon("L6CA2    LDD   $4B0E                   ; 6CA2: FC 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    PC = 0x6ca2; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x4b0e); // Care needed with I/O space and word fetches
    B = rd_mem(0x4b0f); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$01                    ; 6CA5: C3 00 01      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0001; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B0E                   ; 6CA8: FD 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4b0e, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b0f, B); 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$28                    ; 6CAB: 10 83 00 28   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x0028; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   locret_6CB5             ; 6CAF: 25 04         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L6CB5;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$3B                    ; 6CB1: 86 3B         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x3b; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$41                    ; 6CB3: 97 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0x41; 
    wr_mem(ea, val); 
    // End of function sub_6C84
  case 0x6CB5:
L6CB5:
locret_6CB5:
                                                     #ifdef DEBUG
                                      mon("locret_6CB5 RTS                           ; 6CB5: 39            \n");
                                      #endif
    PC = 0x6cb5; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
    // START OF FUNCTION CHUNK FOR sub_69F4
  case 0x6CB6:
L6CB6:
                                                     #ifdef DEBUG
                                      mon("L6CB6    JSR   $BD58                   ; 6CB6: BD BD 58      \n");
                                      #endif // Stay in attack formation
    PC = 0x6cb6; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xb9); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6c); 
    clockticks = clockticks + 1; 
    PC = 0xbd58; 
    JUMP;
  case 0x6CB9:
L6CB9:
                                                     #ifdef DEBUG
                                      mon("L6CB9    LDA   #$38                    ; 6CB9: 86 38         \n");
                                      #endif
    PC = 0x6cb9; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x38; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$41                    ; 6CBB: 97 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x41; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; 6CBD: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B0E                   ; 6CC0: FD 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x4b0e, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b0f, B); 
    // END OF FUNCTION CHUNK FOR sub_69F4
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 6CC3: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x6CC4:
L6CC4:
                                                     #ifdef DEBUG
                                      mon("L6CC4    JSR   L73C3                   ; 6CC4: BD 73 C3      \n");
                                      #endif // Towers
    PC = 0x6cc4; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xc7); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6c); 
    clockticks = clockticks + 1; 
    goto L73C3;
  case 0x6CC7:
L6CC7:
                                                     #ifdef DEBUG
                                      mon("L6CC7    JSR   $A849                   ; 6CC7: BD A8 49      \n");
                                      #endif // Fireball movement
    PC = 0x6cc7; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xca); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6c); 
    clockticks = clockticks + 1; 
    PC = 0xa849; 
    JUMP;
  case 0x6CCA:
L6CCA:
                                                     #ifdef DEBUG
                                      mon("L6CCA    JSR   $987F                   ; 6CCA: BD 98 7F      \n");
                                      #endif // Fireball timer
    PC = 0x6cca; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xcd); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6c); 
    clockticks = clockticks + 1; 
    PC = 0x987f; 
    JUMP;
  case 0x6CCD:
L6CCD:
                                                     #ifdef DEBUG
                                      mon("L6CCD    LDD   $4B0E                   ; 6CCD: FC 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    PC = 0x6ccd; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x4b0e); // Care needed with I/O space and word fetches
    B = rd_mem(0x4b0f); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$01                    ; 6CD0: C3 00 01      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0001; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B0E                   ; 6CD3: FD 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4b0e, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b0f, B); 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$28                    ; 6CD6: 10 83 00 28   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x0028; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   locret_6CE0             ; 6CDA: 25 04         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L6CE0;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$3B                    ; 6CDC: 86 3B         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x3b; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$41                    ; 6CDE: 97 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0x41; 
    wr_mem(ea, val); 
    // End of function sub_6CC4
  case 0x6CE0:
L6CE0:
locret_6CE0:
                                                     #ifdef DEBUG
                                      mon("locret_6CE0 RTS                           ; 6CE0: 39            \n");
                                      #endif
    PC = 0x6ce0; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
    // START OF FUNCTION CHUNK FOR sub_6B22
  case 0x6CE1:
L6CE1:
                                                     #ifdef DEBUG
                                      mon("L6CE1    JSR   $BD58                   ; 6CE1: BD BD 58      \n");
                                      #endif // Stay in attack formation
    PC = 0x6ce1; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xe4); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6c); 
    clockticks = clockticks + 1; 
    PC = 0xbd58; 
    JUMP;
  case 0x6CE4:
L6CE4:
                                                     #ifdef DEBUG
                                      mon("L6CE4    LDA   #$3A                    ; 6CE4: 86 3A         \n");
                                      #endif
    PC = 0x6ce4; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x3a; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$41                    ; 6CE6: 97 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x41; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; 6CE8: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B0E                   ; 6CEB: FD 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x4b0e, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b0f, B); 
    // END OF FUNCTION CHUNK FOR sub_6B22
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 6CEE: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Game over
  case 0x6CEF:
L6CEF:
                                                     #ifdef DEBUG
                                      mon("L6CEF    JSR   L74D5                   ; 6CEF: BD 74 D5      \n");
                                      #endif // Game over
    PC = 0x6cef; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf2); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6c); 
    clockticks = clockticks + 1; 
    goto L74D5;
  case 0x6CF2:
L6CF2:
                                                     #ifdef DEBUG
                                      mon("L6CF2    JSR   $A849                   ; 6CF2: BD A8 49      \n");
                                      #endif // Fireball movement
    PC = 0x6cf2; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf5); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6c); 
    clockticks = clockticks + 1; 
    PC = 0xa849; 
    JUMP;
  case 0x6CF5:
L6CF5:
                                                     #ifdef DEBUG
                                      mon("L6CF5    JSR   $987F                   ; 6CF5: BD 98 7F      \n");
                                      #endif // Fireball timer
    PC = 0x6cf5; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6c); 
    clockticks = clockticks + 1; 
    PC = 0x987f; 
    JUMP;
  case 0x6CF8:
L6CF8:
                                                     #ifdef DEBUG
                                      mon("L6CF8    LDD   $4B0E                   ; 6CF8: FC 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    PC = 0x6cf8; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x4b0e); // Care needed with I/O space and word fetches
    B = rd_mem(0x4b0f); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$01                    ; 6CFB: C3 00 01      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0001; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B0E                   ; 6CFE: FD 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4b0e, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b0f, B); 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$28                    ; 6D01: 10 83 00 28   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x0028; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   locret_6D0B             ; 6D05: 25 04         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L6D0B;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$3B                    ; 6D07: 86 3B         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x3b; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$41                    ; 6D09: 97 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0x41; 
    wr_mem(ea, val); 
    // End of function sub_6CEF
  case 0x6D0B:
L6D0B:
locret_6D0B:
                                                     #ifdef DEBUG
                                      mon("locret_6D0B RTS                           ; 6D0B: 39            \n");
                                      #endif
    PC = 0x6d0b; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Game over init
  case 0x6D0C:
L6D0C:
if (countOfStarsIngame!=0) gameRunning=0;
                                                     #ifdef DEBUG
                                      mon("L6D0C    JSR   $BD49                   ; 6D0C: BD BD 49      \n");
                                      #endif // Remember
    PC = 0x6d0c; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x0f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6d); 
    clockticks = clockticks + 1; 
    PC = 0xbd49; 
    JUMP;
  case 0x6D0F:
L6D0F:
                                                     #ifdef DEBUG
                                      mon("L6D0F    JSR   $BD0D                   ; 6D0F: BD BD 0D      \n");
                                      #endif
    PC = 0x6d0f; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x12); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6d); 
    clockticks = clockticks + 1; 
    PC = 0xbd0d; 
    JUMP;
  case 0x6D12:
L6D12:
                                                     #ifdef DEBUG
                                      mon("L6D12    INC   <$41                    ; 6D12: 0C 41         \n");
                                      #endif // Game mode/screen state
    PC = 0x6d12; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x41); 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    wr_mem(DP|0x41, res); 
    clockticks = clockticks + 2; 
    // End of function sub_6D0C
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 6D14: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Game over
  case 0x6D15:
L6D15:
                                                     #ifdef DEBUG
                                      mon("L6D15    JSR   L61B5                   ; 6D15: BD 61 B5      \n");
                                      #endif // Set up math constants
    PC = 0x6d15; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x18); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6d); 
    clockticks = clockticks + 1; 
    goto L61B5;
  case 0x6D18:
L6D18:
                                                     #ifdef DEBUG
                                      mon("L6D18    JSR   L615A                   ; 6D18: BD 61 5A      \n");
                                      #endif // More stars/ties init stuff
    PC = 0x6d18; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x1b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6d); 
    clockticks = clockticks + 1; 
    goto L615A;
  case 0x6D1B:
L6D1B:
                                                     #ifdef DEBUG
                                      mon("L6D1B    JSR   L61EC                   ; 6D1B: BD 61 EC      \n");
                                      #endif // Init stars math data
    PC = 0x6d1b; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x1e); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6d); 
    clockticks = clockticks + 1; 
    goto L61EC;
  case 0x6D1E:
L6D1E:
                                                     #ifdef DEBUG
                                      mon("L6D1E    LDU   #$5038                  ; 6D1E: CE 50 38      \n");
                                      #endif // Matrix 2
    PC = 0x6d1e; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0x5038; 
    Z = U; 
    N = (U) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $CDC3                   ; 6D21: BD CD C3      \n");
                                      #endif // Initialise math registers matrix
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x24); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6d); 
    clockticks = clockticks + 1; 
    PC = 0xcdc3; 
    JUMP;
  case 0x6D24:
L6D24:
                                                     #ifdef DEBUG
                                      mon("L6D24    JSR   $C0FF                   ; 6D24: BD C0 FF      \n");
                                      #endif // NVRAM something
    PC = 0x6d24; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x27); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6d); 
    clockticks = clockticks + 1; 
    PC = 0xc0ff; 
    JUMP;
  case 0x6D27:
L6D27:
                                                     #ifdef DEBUG
                                      mon("L6D27    JSR   $CA8C                   ; 6D27: BD CA 8C      \n");
                                      #endif // Score
    PC = 0x6d27; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x2a); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6d); 
    clockticks = clockticks + 1; 
    PC = 0xca8c; 
    JUMP;
  case 0x6D2A:
L6D2A:
                                                     #ifdef DEBUG
                                      mon("L6D2A    LDA   $4AEC                   ; 6D2A: B6 4A EC      \n");
                                      #endif
    PC = 0x6d2a; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4aec); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BMI   L6D33                   ; 6D2D: 2B 04         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto L6D33;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$0F                    ; 6D2F: 86 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x0f; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   L6D38                   ; 6D31: 20 05         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L6D38;
    
    // ---------------------------------------------------------------------------
  case 0x6D33:
L6D33:
                                                     #ifdef DEBUG
                                      mon("L6D33    JSR   $BD7B                   ; 6D33: BD BD 7B      \n");
                                      #endif // High score
    PC = 0x6d33; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x36); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6d); 
    clockticks = clockticks + 1; 
    PC = 0xbd7b; 
    JUMP;
  case 0x6D36:
L6D36:
                                                     #ifdef DEBUG
                                      mon("L6D36    LDA   #$05                    ; 6D36: 86 05         \n");
                                      #endif
    PC = 0x6d36; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x05; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0x6D38:
L6D38:
                                                     #ifdef DEBUG
                                      mon("L6D38    STA   <$41                    ; 6D38: 97 41         \n");
                                      #endif // Game mode/screen state
    PC = 0x6d38; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0x41; 
    wr_mem(ea, val); 
    // End of function sub_6D15
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 6D3A: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x6D3B:
L6D3B:
                                                     #ifdef DEBUG
                                      mon("L6D3B    LDD   #$7304                  ; 6D3B: CC 73 04      \n");
                                      #endif // Exhaust port hit init
    PC = 0x6d3b; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x73; 
    B = 0x04; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$56                    ; 6D3E: DD 56         \n");
                                      #endif // Zoom value
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x56; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0AFF                  ; 6D40: CC 0A FF      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x0a; 
    B = 0xff; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$58                    ; 6D43: DD 58         \n");
                                      #endif // Death Star zoom value
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x58; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         JSR   L61EC                   ; 6D45: BD 61 EC      \n");
                                      #endif // Init stars math data
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x48); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6d); 
    clockticks = clockticks + 1; 
    goto L61EC;
  case 0x6D48:
L6D48:
                                                     #ifdef DEBUG
                                      mon("L6D48    LDU   #$5038                  ; 6D48: CE 50 38      \n");
                                      #endif // Matrix 2
    PC = 0x6d48; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0x5038; 
    Z = U; 
    N = (U) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $CDC3                   ; 6D4B: BD CD C3      \n");
                                      #endif // Initialise math registers matrix
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x4e); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6d); 
    clockticks = clockticks + 1; 
    PC = 0xcdc3; 
    JUMP;
  case 0x6D4E:
L6D4E:
                                                     #ifdef DEBUG
                                      mon("L6D4E    INC   <$41                    ; 6D4E: 0C 41         \n");
                                      #endif // Game mode/screen state
    PC = 0x6d4e; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x41); 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    wr_mem(DP|0x41, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $BD8F                   ; 6D50: BD BD 8F      \n");
                                      #endif // Death Star destroyed
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x53); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6d); 
    clockticks = clockticks + 1; 
    PC = 0xbd8f; 
    JUMP;
    // End of function sub_6D3B
  case 0x6D53:
L6D53:
                                                     #ifdef DEBUG
                                      mon("L6D53    RTS                           ; 6D53: 39            \n");
                                      #endif
    PC = 0x6d53; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x6D54:
L6D54:
                                                     #ifdef DEBUG
                                      mon("L6D54    JSR   L75B9                   ; 6D54: BD 75 B9      \n");
                                      #endif // Death Star hit zoom out
    PC = 0x6d54; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x57); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6d); 
    clockticks = clockticks + 1; 
    goto L75B9;
  case 0x6D57:
L6D57:
                                                     #ifdef DEBUG
                                      mon("L6D57    JSR   $9558                   ; 6D57: BD 95 58      \n");
                                      #endif // Process shields
    PC = 0x6d57; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x5a); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6d); 
    clockticks = clockticks + 1; 
    PC = 0x9558; 
    JUMP;
  case 0x6D5A:
L6D5A:
                                                     #ifdef DEBUG
                                      mon("L6D5A    JSR   $9890                   ; 6D5A: BD 98 90      \n");
                                      #endif // Fireball timer 3
    PC = 0x6d5a; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x5d); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6d); 
    clockticks = clockticks + 1; 
    PC = 0x9890; 
    JUMP;
  case 0x6D5D:
L6D5D:
                                                     #ifdef DEBUG
                                      mon("L6D5D    LDB   <$58                    ; 6D5D: D6 58         \n");
                                      #endif // Death Star zoom value
    PC = 0x6d5d; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x58); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SEX                           ; 6D5F: 1D            \n");
                                      #endif
 // Z = B; 
 // N = B; 
    A = ((SINT8)B < 0 ? 0xff : 0); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  <$56                    ; 6D60: D3 56         \n");
                                      #endif // Zoom value
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x56)<<8; 
    ea = ea | rd_mem(DP|0x57); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$80                    ; 6D62: C3 00 80      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0080; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$7F                    ; 6D65: C4 7F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x7f; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$56                    ; 6D67: DD 56         \n");
                                      #endif // Zoom value
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x56; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$7680                  ; 6D69: 10 83 76 80   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x7680; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   L6D73                   ; 6D6D: 25 04         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L6D73;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$13                    ; 6D6F: 86 13         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x13; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$41                    ; 6D71: 97 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x41; 
    wr_mem(ea, val); 
  case 0x6D73:
L6D73:
                                                     #ifdef DEBUG
                                      mon("L6D73    LDD   <$58                    ; 6D73: DC 58         \n");
                                      #endif // Death Star zoom value
    PC = 0x6d73; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x58); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x59); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$10                    ; 6D75: 83 00 10      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0010; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BPL   L6D7D                   ; 6D78: 2A 03         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto L6D7D;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; 6D7A: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0x6D7D:
L6D7D:
                                                     #ifdef DEBUG
                                      mon("L6D7D    STD   <$58                    ; 6D7D: DD 58         \n");
                                      #endif // Death Star zoom value
    PC = 0x6d7d; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = DP|0x58; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    // End of function sub_6D54
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 6D7F: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x6D80:
L6D80:
                                                     #ifdef DEBUG
                                      mon("L6D80    JSR   $BB7B                   ; 6D80: BD BB 7B      \n");
                                      #endif // Death Star explosion init
    PC = 0x6d80; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x83); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6d); 
    clockticks = clockticks + 1; 
    PC = 0xbb7b; 
    JUMP;
  case 0x6D83:
L6D83:
                                                     #ifdef DEBUG
                                      mon("L6D83    INC   <$41                    ; 6D83: 0C 41         \n");
                                      #endif // Game mode/screen state
    PC = 0x6d83; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x41); 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    wr_mem(DP|0x41, res); 
    clockticks = clockticks + 2; 
    // End of function sub_6D80
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 6D85: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Space wave init
  case 0x6D86:
L6D86:

                                                     #ifdef DEBUG
                                      mon("L6D86    JSR   L75D9                   ; 6D86: BD 75 D9      \n");
                                      #endif // Space wave
    PC = 0x6d86; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x89); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6d); 
    clockticks = clockticks + 1; 
    goto L75D9;
  case 0x6D89:
L6D89:
                                                     #ifdef DEBUG
                                      mon("L6D89    LDA   $48A1                   ; 6D89: B6 48 A1      \n");
                                      #endif
    PC = 0x6d89; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x48a1); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$01                    ; 6D8C: 81 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x01; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   locret_6D94             ; 6D8E: 25 04         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L6D94;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$15                    ; 6D90: 86 15         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x15; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$41                    ; 6D92: 97 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0x41; 
    wr_mem(ea, val); 
    // End of function sub_6D86
  case 0x6D94:
L6D94:
locret_6D94:
                                                     #ifdef DEBUG
                                      mon("locret_6D94 RTS                           ; 6D94: 39            \n");
                                      #endif
    PC = 0x6d94; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x6D95:
L6D95:
                                                     #ifdef DEBUG
                                      mon("L6D95    INC   <$41                    ; 6D95: 0C 41         \n");
                                      #endif // Game mode/screen state
    PC = 0x6d95; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x41); 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    wr_mem(DP|0x41, res); 
    clockticks = clockticks + 2; 
    // End of function sub_6D95
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 6D97: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x6D98:
L6D98:
                                                     #ifdef DEBUG
                                      mon("L6D98    JSR   L760A                   ; 6D98: BD 76 0A      \n");
                                      #endif // Death Star explosion
    PC = 0x6d98; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x9b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6d); 
    clockticks = clockticks + 1; 
    goto L760A;
  case 0x6D9B:
L6D9B:
                                                     #ifdef DEBUG
                                      mon("L6D9B    LDA   $48A1                   ; 6D9B: B6 48 A1      \n");
                                      #endif
    PC = 0x6d9b; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x48a1); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   locret_6DA4             ; 6D9E: 26 04         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L6DA4;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$33                    ; 6DA0: 86 33         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x33; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$41                    ; 6DA2: 97 41         \n");
                                      #endif // Game mode/screen state
    clockticks = clockticks + 4; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0x41; 
    wr_mem(ea, val); 
    // End of function sub_6D98
  case 0x6DA4:
L6DA4:
locret_6DA4:
                                                     #ifdef DEBUG
                                      mon("locret_6DA4 RTS                           ; 6DA4: 39            \n");
                                      #endif
    PC = 0x6da4; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Attract screen 2 stars forward and down translate
  case 0x6DA5:
L6DA5:
                                                     #ifdef DEBUG
                                      mon("L6DA5    LDD   <$89                    ; 6DA5: DC 89         \n");
                                      #endif
    PC = 0x6da5; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x89); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x8a); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$80                    ; 6DA7: C3 00 80      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0080; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$89                    ; 6DAA: DD 89         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x89; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $4B26                   ; 6DAC: FC 4B 26      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x4b26); // Care needed with I/O space and word fetches
    B = rd_mem(0x4b27); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$80                    ; 6DAF: C3 00 80      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0080; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B26                   ; 6DB2: FD 4B 26      \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x4b26, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b27, B); 
    // End of function sub_6DA5
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 6DB5: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Attract screen 3 stars YT move
  case 0x6DB6:
L6DB6:
                                                     #ifdef DEBUG
                                      mon("L6DB6    LDD   $4B24                   ; 6DB6: FC 4B 24      \n");
                                      #endif
    PC = 0x6db6; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x4b24); // Care needed with I/O space and word fetches
    B = rd_mem(0x4b25); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$FF80                  ; 6DB9: C3 FF 80      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0xff80; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B24                   ; 6DBC: FD 4B 24      \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x4b24, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b25, B); 
    // End of function sub_6DB6
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 6DBF: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Attract screen 4 stars ZT move
  case 0x6DC0:
L6DC0:
                                                     #ifdef DEBUG
                                      mon("L6DC0    LDD   $4B26                   ; 6DC0: FC 4B 26      \n");
                                      #endif
    PC = 0x6dc0; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x4b26); // Care needed with I/O space and word fetches
    B = rd_mem(0x4b27); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$80                    ; 6DC3: C3 00 80      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0080; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B26                   ; 6DC6: FD 4B 26      \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x4b26, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b27, B); 
    // End of function sub_6DC0
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 6DC9: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Move stars XT translate position
  case 0x6DCA:
L6DCA:
                                                     #ifdef DEBUG
                                      mon("L6DCA    LDD   <$89                    ; 6DCA: DC 89         \n");
                                      #endif
    PC = 0x6dca; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x89); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x8a); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$80                    ; 6DCC: C3 00 80      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0080; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$89                    ; 6DCF: DD 89         \n");
                                      #endif
    clockticks = clockticks + 4; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = DP|0x89; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    // End of function sub_6DCA
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 6DD1: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x6DD2:
L6DD2:
                                                     #ifdef DEBUG
                                      mon("L6DD2    LDA   <$63                    ; 6DD2: 96 63         \n");
                                      #endif
    PC = 0x6dd2; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x63); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L6DF0                   ; 6DD4: 27 1A         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L6DF0;
    }
                                                     #ifdef DEBUG
                                      mon("         BLE   L6DDF                   ; 6DD6: 2F 07         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto L6DDF;
    }
                                                     #ifdef DEBUG
                                      mon("         DEC   <$63                    ; 6DD8: 0A 63         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x63); 
    res = (UINT8)(val - 1); 
 // N = res; 
 // Z = res; 
 // V = val & ~res; 
    wr_mem(DP|0x63, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$04FF                  ; 6DDA: CC 04 FF      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x04; 
    B = 0xff; 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   L6DE4                   ; 6DDD: 20 05         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L6DE4;
    
    // ---------------------------------------------------------------------------
  case 0x6DDF:
L6DDF:
                                                     #ifdef DEBUG
                                      mon("L6DDF    INC   <$63                    ; 6DDF: 0C 63         \n");
                                      #endif
    PC = 0x6ddf; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x63); 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    wr_mem(DP|0x63, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$FB01                  ; 6DE1: CC FB 01      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xfb; 
    B = 0x01; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0x6DE4:
L6DE4:
                                                     #ifdef DEBUG
                                      mon("L6DE4    STD   $5022                   ; 6DE4: FD 50 22      \n");
                                      #endif // Sine for rotation
    PC = 0x6de4; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5022, A); // Care needed with I/O space and word fetches
    wr_mem(0x5023, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$3FCE                  ; 6DE7: CC 3F CE      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x3f; 
    B = 0xce; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5024                   ; 6DEA: FD 50 24      \n");
                                      #endif // Cosine for rotation
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x5024, A); // Care needed with I/O space and word fetches
    wr_mem(0x5025, B); 
                                                     #ifdef DEBUG
                                      mon("         JSR   $CE24                   ; 6DED: BD CE 24      \n");
                                      #endif // Run math program $00 Roll on Matrix 4
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf0); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6d); 
    clockticks = clockticks + 1; 
    PC = 0xce24; 
    JUMP;
  case 0x6DF0:
L6DF0:
                                                     #ifdef DEBUG
                                      mon("L6DF0    JSR   L6EA2                   ; 6DF0: BD 6E A2      \n");
                                      #endif
    PC = 0x6df0; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf3); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6d); 
    clockticks = clockticks + 1; 
    goto L6EA2;
  case 0x6DF3:
L6DF3:
                                                     #ifdef DEBUG
                                      mon("L6DF3    JSR   L70BD                   ; 6DF3: BD 70 BD      \n");
                                      #endif
    PC = 0x6df3; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf6); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6d); 
    clockticks = clockticks + 1; 
    goto L70BD;
  case 0x6DF6:
L6DF6:
                                                     #ifdef DEBUG
                                      mon("L6DF6    JSR   L70CC                   ; 6DF6: BD 70 CC      \n");
                                      #endif
    PC = 0x6df6; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf9); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6d); 
    clockticks = clockticks + 1; 
    goto L70CC;
    // End of function sub_6DD2
  case 0x6DF9:
L6DF9:
                                                     #ifdef DEBUG
                                      mon("L6DF9    RTS                           ; 6DF9: 39            \n");
                                      #endif
    PC = 0x6df9; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x6DFA:
L6DFA:
                                                     #ifdef DEBUG
                                      mon("L6DFA    LDA   <$63                    ; 6DFA: 96 63         \n");
                                      #endif
    PC = 0x6dfa; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x63); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L6E18                   ; 6DFC: 27 1A         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L6E18;
    }
                                                     #ifdef DEBUG
                                      mon("         BLE   L6E07                   ; 6DFE: 2F 07         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto L6E07;
    }
                                                     #ifdef DEBUG
                                      mon("         DEC   <$63                    ; 6E00: 0A 63         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x63); 
    res = (UINT8)(val - 1); 
 // N = res; 
 // Z = res; 
 // V = val & ~res; 
    wr_mem(DP|0x63, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$04FF                  ; 6E02: CC 04 FF      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x04; 
    B = 0xff; 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   L6E0C                   ; 6E05: 20 05         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L6E0C;
    
    // ---------------------------------------------------------------------------
  case 0x6E07:
L6E07:
                                                     #ifdef DEBUG
                                      mon("L6E07    INC   <$63                    ; 6E07: 0C 63         \n");
                                      #endif
    PC = 0x6e07; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x63); 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    wr_mem(DP|0x63, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$FB01                  ; 6E09: CC FB 01      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xfb; 
    B = 0x01; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0x6E0C:
L6E0C:
                                                     #ifdef DEBUG
                                      mon("L6E0C    STD   $5022                   ; 6E0C: FD 50 22      \n");
                                      #endif // Sine for rotation
    PC = 0x6e0c; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5022, A); // Care needed with I/O space and word fetches
    wr_mem(0x5023, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$3FCE                  ; 6E0F: CC 3F CE      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x3f; 
    B = 0xce; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5024                   ; 6E12: FD 50 24      \n");
                                      #endif // Cosine for rotation
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x5024, A); // Care needed with I/O space and word fetches
    wr_mem(0x5025, B); 
                                                     #ifdef DEBUG
                                      mon("         JSR   $CE24                   ; 6E15: BD CE 24      \n");
                                      #endif // Run math program $00 Roll on Matrix 4
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x18); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6e); 
    clockticks = clockticks + 1; 
    PC = 0xce24; 
    JUMP;
  case 0x6E18:
L6E18:
                                                     #ifdef DEBUG
                                      mon("L6E18    JSR   L6ECB                   ; 6E18: BD 6E CB      \n");
                                      #endif
    PC = 0x6e18; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x1b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6e); 
    clockticks = clockticks + 1; 
    goto L6ECB;
  case 0x6E1B:
L6E1B:
                                                     #ifdef DEBUG
                                      mon("L6E1B    JSR   L70BD                   ; 6E1B: BD 70 BD      \n");
                                      #endif
    PC = 0x6e1b; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x1e); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6e); 
    clockticks = clockticks + 1; 
    goto L70BD;
  case 0x6E1E:
L6E1E:
                                                     #ifdef DEBUG
                                      mon("L6E1E    JSR   L70CC                   ; 6E1E: BD 70 CC      \n");
                                      #endif
    PC = 0x6e1e; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x21); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6e); 
    clockticks = clockticks + 1; 
    goto L70CC;
    // End of function sub_6DFA
  case 0x6E21:
L6E21:
                                                     #ifdef DEBUG
                                      mon("L6E21    RTS                           ; 6E21: 39            \n");
                                      #endif
    PC = 0x6e21; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x6E22:
L6E22:
                                                     #ifdef DEBUG
                                      mon("L6E22    LDA   <$63                    ; 6E22: 96 63         \n");
                                      #endif
    PC = 0x6e22; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x63); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L6E2E                   ; 6E24: 27 08         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L6E2E;
    }
                                                     #ifdef DEBUG
                                      mon("         BLE   L6E2B                   ; 6E26: 2F 03         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto L6E2B;
    }
                                                     #ifdef DEBUG
                                      mon("         DECA                          ; 6E28: 4A            \n");
                                      #endif
    val = (UINT8)A; 
    res = (UINT8)(val - 1); 
    N = res; 
    Z = res; 
    V = val & ~res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BRA   L6E2C                   ; 6E29: 20 01         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L6E2C;
    
    // ---------------------------------------------------------------------------
  case 0x6E2B:
L6E2B:
                                                     #ifdef DEBUG
                                      mon("L6E2B    INCA                          ; 6E2B: 4C            \n");
                                      #endif
    PC = 0x6e2b; 
    INSTRUCTION_START
    val = (UINT8)A; 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    A = res; 
    clockticks = clockticks + 2; 
  case 0x6E2C:
L6E2C:
                                                     #ifdef DEBUG
                                      mon("L6E2C    STA   <$63                    ; 6E2C: 97 63         \n");
                                      #endif
    PC = 0x6e2c; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x63; 
    wr_mem(ea, val); 
  case 0x6E2E:
L6E2E:
                                                     #ifdef DEBUG
                                      mon("L6E2E    LDA   <$63                    ; 6E2E: 96 63         \n");
                                      #endif
    PC = 0x6e2e; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x63); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BPL   L6E33                   ; 6E30: 2A 01         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto L6E33;
    }
                                                     #ifdef DEBUG
                                      mon("         NEGA                          ; 6E32: 40            \n");
                                      #endif
    val = (UINT8)A; 
    res = -val; 
 // V = val & (UINT8)res; 
 // C = res & 0x100; 
    val = (UINT8)res; 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
  case 0x6E33:
L6E33:
                                                     #ifdef DEBUG
                                      mon("L6E33    LDB   #$20                    ; 6E33: C6 20         \n");
                                      #endif
    PC = 0x6e33; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x20; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         MUL                           ; 6E35: 3D            \n");
                                      #endif
    res = (UINT16)(A * B); 
 // Z = res; 
    C = res & 0x80; 
    A = res >> 8; 
    B = (UINT8)res; 
    clockticks = clockticks + 11; 
                                                     #ifdef DEBUG
                                      mon("         TST   <$63                    ; 6E36: 0D 63         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x63); 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BPL   L6E3E                   ; 6E38: 2A 04         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto L6E3E;
    }
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; 6E3A: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; 6E3B: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SBCA  #$FF                    ; 6E3C: 82 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xff; 
    res = val - (UINT8)arg - (C != 0 ? 1:0); 
    C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)res; 
  case 0x6E3E:
L6E3E:
                                                     #ifdef DEBUG
                                      mon("L6E3E    STD   <$A5                    ; 6E3E: DD A5         \n");
                                      #endif
    PC = 0x6e3e; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0xa5; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$7D                    ; 6E40: 96 7D         \n");
                                      #endif // Joystick X
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x7d); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BPL   L6E45                   ; 6E42: 2A 01         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto L6E45;
    }
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; 6E44: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
  case 0x6E45:
L6E45:
                                                     #ifdef DEBUG
                                      mon("L6E45    LDB   #$02                    ; 6E45: C6 02         \n");
                                      #endif
    PC = 0x6e45; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x02; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         MUL                           ; 6E47: 3D            \n");
                                      #endif
    res = (UINT16)(A * B); 
 // Z = res; 
    C = res & 0x80; 
    A = res >> 8; 
    B = (UINT8)res; 
    clockticks = clockticks + 11; 
                                                     #ifdef DEBUG
                                      mon("         TST   <$7D                    ; 6E48: 0D 7D         \n");
                                      #endif // Joystick X
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x7d); 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BPL   L6E50                   ; 6E4A: 2A 04         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto L6E50;
    }
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; 6E4C: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; 6E4D: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SBCA  #$FF                    ; 6E4E: 82 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xff; 
    res = val - (UINT8)arg - (C != 0 ? 1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)res; 
  case 0x6E50:
L6E50:
                                                     #ifdef DEBUG
                                      mon("L6E50    ADDD  <$A5                    ; 6E50: D3 A5         \n");
                                      #endif
    PC = 0x6e50; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xa5)<<8; 
    ea = ea | rd_mem(DP|0xa6); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         TST   <$63                    ; 6E52: 0D 63         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x63); 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L6E70                   ; 6E54: 26 1A         \n");
                                      #endif // Towers collision roll limits
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L6E70;
    }
                                                     #ifdef DEBUG
                                      mon("         SUBD  <$A3                    ; 6E56: 93 A3         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xa3)<<8; 
    ea = ea | rd_mem(DP|0xa4); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BLE   L6E65                   ; 6E58: 2F 0B         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto L6E65;
    }
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$10                    ; 6E5A: 10 83 00 10   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x0010; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BLE   L6E63                   ; 6E5E: 2F 03         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto L6E63;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$10                    ; 6E60: CC 00 10      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x10; 
    Z = A|B; 
    N = A; 
    V = 0; 
  case 0x6E63:
L6E63:
                                                     #ifdef DEBUG
                                      mon("L6E63    BRA   L6E6E                   ; 6E63: 20 09         \n");
                                      #endif
    PC = 0x6e63; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto L6E6E;
    
    // ---------------------------------------------------------------------------
  case 0x6E65:
L6E65:
                                                     #ifdef DEBUG
                                      mon("L6E65    CMPD  #$FFF0                  ; 6E65: 10 83 FF F0   \n");
                                      #endif
    PC = 0x6e65; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0xfff0; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BGE   L6E6E                   ; 6E69: 2C 03         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) >= 0) {
    clockticks = clockticks + 3; 
    goto L6E6E;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$FFF0                  ; 6E6B: CC FF F0      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xff; 
    B = 0xf0; 
    Z = A|B; 
    N = A; 
    V = 0; 
    // End of function sub_6E22
  case 0x6E6E:
L6E6E:
                                                     #ifdef DEBUG
                                      mon("L6E6E    BRA   L6E88                   ; 6E6E: 20 18         \n");
                                      #endif
    PC = 0x6e6e; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto L6E88;
    
    // =============== S U B R O U T I N E =======================================
    // Towers collision roll limits
  case 0x6E70:
L6E70:
                                                     #ifdef DEBUG
                                      mon("L6E70    SUBD  <$A3                    ; 6E70: 93 A3         \n");
                                      #endif
    PC = 0x6e70; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xa3)<<8; 
    ea = ea | rd_mem(DP|0xa4); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BLE   L6E7F                   ; 6E72: 2F 0B         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto L6E7F;
    }
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$32                    ; 6E74: 10 83 00 32   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x0032; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BLE   L6E7D                   ; 6E78: 2F 03         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto L6E7D;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$32                    ; 6E7A: CC 00 32      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x32; 
    Z = A|B; 
    N = A; 
    V = 0; 
  case 0x6E7D:
L6E7D:
                                                     #ifdef DEBUG
                                      mon("L6E7D    BRA   L6E88                   ; 6E7D: 20 09         \n");
                                      #endif
    PC = 0x6e7d; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto L6E88;
    
    // ---------------------------------------------------------------------------
  case 0x6E7F:
L6E7F:
                                                     #ifdef DEBUG
                                      mon("L6E7F    CMPD  #$FFCE                  ; 6E7F: 10 83 FF CE   \n");
                                      #endif
    PC = 0x6e7f; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0xffce; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BGE   L6E88                   ; 6E83: 2C 03         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) >= 0) {
    clockticks = clockticks + 3; 
    goto L6E88;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$FFCE                  ; 6E85: CC FF CE      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xff; 
    B = 0xce; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0x6E88:
L6E88:
                                                     #ifdef DEBUG
                                      mon("L6E88    TFR   B,A                     ; 6E88: 1F 98         \n");
                                      #endif
    PC = 0x6e88; 
    INSTRUCTION_START
    A = (UINT8)B; 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         ADDA  $4878                   ; 6E8A: BB 48 78      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    arg = rd_mem(0x4878); 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4878                   ; 6E8D: B7 48 78      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4878, val); 
                                                     #ifdef DEBUG
                                      mon("         SEX                           ; 6E90: 1D            \n");
                                      #endif
 // Z = B; 
 // N = B; 
    A = ((SINT8)B < 0 ? 0xff : 0); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  <$A3                    ; 6E91: D3 A3         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xa3)<<8; 
    ea = ea | rd_mem(DP|0xa4); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$A3                    ; 6E93: DD A3         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0xa3; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4870                  ; 6E95: 8E 48 70      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x4870; 
    Z = X; 
    N = (X) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   L7111                   ; 6E98: BD 71 11      \n");
                                      #endif // Some joystick driven matrix rotations for pitch/roll
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x9b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6e); 
    clockticks = clockticks + 1; 
    goto L7111;
  case 0x6E9B:
L6E9B:
                                                     #ifdef DEBUG
                                      mon("L6E9B    BEQ   locret_6EA0             ; 6E9B: 27 03         \n");
                                      #endif
    PC = 0x6e9b; 
    INSTRUCTION_START
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L6EA0;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   $CE24                   ; 6E9D: BD CE 24      \n");
                                      #endif // Run math program $00 Roll on Matrix 4
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xa0); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6e); 
    clockticks = clockticks + 1; 
    PC = 0xce24; 
    JUMP;
    // End of function sub_6E70
  case 0x6EA0:
L6EA0:
locret_6EA0:
                                                     #ifdef DEBUG
                                      mon("locret_6EA0 RTS                           ; 6EA0: 39            \n");
                                      #endif
    PC = 0x6ea0; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // End of function nullsub_1
  case 0x6EA1:
L6EA1:
nullL1:
                                                     #ifdef DEBUG
                                      mon("nullL1   RTS                           ; 6EA1: 39            \n");
                                      #endif
    PC = 0x6ea1; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x6EA2:
L6EA2:
                                                     #ifdef DEBUG
                                      mon("L6EA2    LDX   $4B32                   ; 6EA2: BE 4B 32      \n");
                                      #endif
    PC = 0x6ea2; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4b32)<<8; 
    ea = ea | rd_mem(0x4b33); 
    X = ea; 
    Z = X; 
    N = (X) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L6EAA                   ; 6EA5: 26 03         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L6EAA;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4900                  ; 6EA7: 8E 49 00      \n");
                                      #endif // 3x Tie fighter data structure ($19 bytes per Tie)
    clockticks = clockticks + 3; 
    X = 0x4900; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0x6EAA:
L6EAA:
                                                     #ifdef DEBUG
                                      mon("L6EAA    LDA   $03,X                   ; 6EAA: A6 03         \n");
                                      #endif
    PC = 0x6eaa; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0003)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$01                    ; 6EAC: 81 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x01; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   L6EB9                   ; 6EAE: 26 09         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L6EB9;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $06,X                   ; 6EB0: A6 06         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0006)); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L6EB9                   ; 6EB2: 26 05         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L6EB9;
    }
                                                     #ifdef DEBUG
                                      mon("         STX   <$64                    ; 6EB4: 9F 64         \n");
                                      #endif // Pointer to Tie fighter data
    clockticks = clockticks + 4; 
    val = X; 
    Z = val; 
    N = (UINT8)(val >> 8); 
    V = 0; 
    ea = DP|0x64; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         JMP   L6EF7                   ; 6EB6: 7E 6E F7      \n");
                                      #endif // Point BIC to 5080
    clockticks = clockticks + 4; 
    goto L6EF7;
    
    // ---------------------------------------------------------------------------
  case 0x6EB9:
L6EB9:
                                                     #ifdef DEBUG
                                      mon("L6EB9    LDA   $4B3C                   ; 6EB9: B6 4B 3C      \n");
                                      #endif
    PC = 0x6eb9; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b3c); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BLE   L6EC3                   ; 6EBC: 2F 05         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto L6EC3;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$09                    ; 6EBE: 86 09         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x09; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B3C                   ; 6EC0: B7 4B 3C      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b3c, val); 
  case 0x6EC3:
L6EC3:
                                                     #ifdef DEBUG
                                      mon("L6EC3    LEAX  $19,X                   ; 6EC3: 30 88 19      \n");
                                      #endif
    PC = 0x6ec3; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    X = (X + (SINT8)0x19); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$494B                  ; 6EC6: 8C 49 4B      \n");
                                      #endif // 3x Tie fighter data structure ($19 bytes per Tie)
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x494b; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   L6EAA                   ; 6EC9: 25 DF         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L6EAA;
    }
  case 0x6ECB:
L6ECB:
                                                     #ifdef DEBUG
                                      mon("L6ECB    LDD   #$00                    ; 6ECB: CC 00 00      \n");
                                      #endif
    PC = 0x6ecb; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4B32                   ; 6ECE: FD 4B 32      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4b32, A); // Care needed with I/O space and word fetches
    wr_mem(0x4b33, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $5080                   ; 6ED1: B6 50 80      \n");
                                      #endif // Matrix 4
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x5080); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BMI   L6EDB                   ; 6ED4: 2B 05         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto L6EDB;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   $5084                   ; 6ED6: F6 50 84      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x5084); 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   L6EE0                   ; 6ED9: 20 05         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L6EE0;
    
    // ---------------------------------------------------------------------------
  case 0x6EDB:
L6EDB:
                                                     #ifdef DEBUG
                                      mon("L6EDB    LDB   #$7F                    ; 6EDB: C6 7F         \n");
                                      #endif
    PC = 0x6edb; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x7f; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBB  $5084                   ; 6EDD: F0 50 84      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)B; 
    arg = rd_mem(0x5084); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    B = (UINT8)(res); 
  case 0x6EE0:
L6EE0:
                                                     #ifdef DEBUG
                                      mon("L6EE0    STB   $486D                   ; 6EE0: F7 48 6D      \n");
                                      #endif
    PC = 0x6ee0; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x486d, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $5080                   ; 6EE3: B6 50 80      \n");
                                      #endif // Matrix 4
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x5080); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BMI   L6EED                   ; 6EE6: 2B 05         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto L6EED;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   $5082                   ; 6EE8: F6 50 82      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x5082); 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   L6EF2                   ; 6EEB: 20 05         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L6EF2;
    
    // ---------------------------------------------------------------------------
  case 0x6EED:
L6EED:
                                                     #ifdef DEBUG
                                      mon("L6EED    LDB   #$7F                    ; 6EED: C6 7F         \n");
                                      #endif
    PC = 0x6eed; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x7f; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBB  $5082                   ; 6EEF: F0 50 82      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)B; 
    arg = rd_mem(0x5082); 
    res = val - (UINT8)arg; 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    B = (UINT8)(res); 
  case 0x6EF2:
L6EF2:
                                                     #ifdef DEBUG
                                      mon("L6EF2    COMB                          ; 6EF2: 53            \n");
                                      #endif
    PC = 0x6ef2; 
    INSTRUCTION_START
    val = (UINT8)B ^ 0xff; 
    B = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STB   $4876                   ; 6EF3: F7 48 76      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = B; 
    Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x4876, val); 
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 6EF6: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
  case 0x6EF7:
L6EF7:
                                                     #ifdef DEBUG
                                      mon("L6EF7    LDA   #$10                    ; 6EF7: 86 10         \n");
                                      #endif // BIC points to Matrix 4
    PC = 0x6ef7; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x10; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $CE0C                   ; 6EF9: BD CE 0C      \n");
                                      #endif // Copy transform data from [BIC] to matrix 2
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xfc); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6e); 
    clockticks = clockticks + 1; 
    PC = 0xce0c; 
    JUMP;
  case 0x6EFC:
L6EFC:
                                                     #ifdef DEBUG
                                      mon("L6EFC    JSR   L7160                   ; 6EFC: BD 71 60      \n");
                                      #endif // Update Roll, Pitch and Yaw for [A, B, C][x, y, z] 2
    PC = 0x6efc; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xff); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6e); 
    clockticks = clockticks + 1; 
    goto L7160;
  case 0x6EFF:
L6EFF:
                                                     #ifdef DEBUG
                                      mon("L6EFF    LDX   <$64                    ; 6EFF: 9E 64         \n");
                                      #endif // Pointer to Tie fighter data
    PC = 0x6eff; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x64)<<8; 
    ea = ea | rd_mem(DP|0x65); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STX   $4B32                   ; 6F01: BF 4B 32      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = X; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    wr_mem(0x4b32, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem(0x4b33, (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         CLRA                          ; 6F04: 4F            \n");
                                      #endif
    A = 0; // SEARCH_ME
 // V = 0; 
 // Z = 0; 
 // N = 0; 
 // C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $02,X                   ; 6F05: E6 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0002)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDB  #$03                    ; 6F07: CB 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x03; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4701                   ; 6F09: FD 47 01      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4701, A); // Care needed with I/O space and word fetches
    wr_mem(0x4702, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$67                    ; 6F0C: 86 67         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x67; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $CDBA                   ; 6F0E: BD CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x11); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6f); 
    clockticks = clockticks + 1; 
    PC = 0xcdba; 
    JUMP;
  case 0x6F11:
L6F11:
                                                     #ifdef DEBUG
                                      mon("L6F11    LDA   $5000                   ; 6F11: B6 50 00      \n");
                                      #endif // Math result X
    PC = 0x6f11; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x5000); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BLE   L6F39                   ; 6F14: 2F 23         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto L6F39;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $5002                   ; 6F16: FC 50 02      \n");
                                      #endif // Math result Y
    clockticks = clockticks + 5; 
    A = rd_mem(0x5002); // Care needed with I/O space and word fetches
    B = rd_mem(0x5003); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0x6F19:
L6F19:
                                                     #ifdef DEBUG
                                      mon("L6F19    ASL   $5001                   ; 6F19: 78 50 01      \n");
                                      #endif // Math result X
    PC = 0x6f19; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x5001); 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    wr_mem(0x5001, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROL   $5000                   ; 6F1C: 79 50 00      \n");
                                      #endif // Math result X
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x5000); 
    res = (val << 1) + (C != 0 ?1:0); 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)res ^ val; 
    wr_mem(0x5000, (UINT8)res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BVS   L6F54                   ; 6F1F: 29 33         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)V <  0) {
    clockticks = clockticks + 3; 
    goto L6F54;
    }
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; 6F21: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLA                          ; 6F22: 49            \n");
                                      #endif
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BVC   L6F29                   ; 6F23: 28 04         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)V >= 0) {
    clockticks = clockticks + 3; 
    goto L6F29;
    }
                                                     #ifdef DEBUG
                                      mon("         RORA                          ; 6F25: 46            \n");
                                      #endif
    res = ((UINT8)A) | ((C != 0) ? 0x100 : 0); 
    C = res & 1; 
    res = (UINT8)(res >> 1); 
 // Z = res; 
 // N = res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         RORB                          ; 6F26: 56            \n");
                                      #endif
    res = ((UINT8)B) | ((C != 0) ? 0x100 : 0); 
    C = res & 1; 
    res = (UINT8)(res >> 1); 
    Z = res; 
    N = res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BRA   L6F54                   ; 6F27: 20 2B         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L6F54;
    
    // ---------------------------------------------------------------------------
  case 0x6F29:
L6F29:
                                                     #ifdef DEBUG
                                      mon("L6F29    ASL   $5005                   ; 6F29: 78 50 05      \n");
                                      #endif // Math result Z
    PC = 0x6f29; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x5005); 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    wr_mem(0x5005, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROL   $5004                   ; 6F2C: 79 50 04      \n");
                                      #endif // Math result Z
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x5004); 
    res = (val << 1) + (C != 0 ?1:0); 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)res ^ val; 
    wr_mem(0x5004, (UINT8)res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BVC   L6F19                   ; 6F2F: 28 E8         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)V >= 0) {
    clockticks = clockticks + 3; 
    goto L6F19;
    }
                                                     #ifdef DEBUG
                                      mon("         ROR   $5004                   ; 6F31: 76 50 04      \n");
                                      #endif // Math result Z
    clockticks = clockticks + 5; 
    res = ((UINT8)rd_mem(0x5004)) | ((C != 0) ? 0x100 : 0); 
    C = res & 1; 
    res = (UINT8)(res >> 1); 
 // Z = res; 
 // N = res; 
    wr_mem(0x5004, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROR   $5005                   ; 6F34: 76 50 05      \n");
                                      #endif // Math result Z
    clockticks = clockticks + 5; 
    res = ((UINT8)rd_mem(0x5005)) | ((C != 0) ? 0x100 : 0); 
    C = res & 1; 
    res = (UINT8)(res >> 1); 
    Z = res; 
    N = res; 
    wr_mem(0x5005, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BRA   L6F54                   ; 6F37: 20 1B         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L6F54;
    
    // ---------------------------------------------------------------------------
  case 0x6F39:
L6F39:
                                                     #ifdef DEBUG
                                      mon("L6F39    LDD   $5002                   ; 6F39: FC 50 02      \n");
                                      #endif // Math result Y
    PC = 0x6f39; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x5002); // Care needed with I/O space and word fetches
    B = rd_mem(0x5003); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORB   #$01                    ; 6F3C: CA 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = B | (UINT8)0x01; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
  case 0x6F3E:
L6F3E:
                                                     #ifdef DEBUG
                                      mon("L6F3E    ASLB                          ; 6F3E: 58            \n");
                                      #endif
    PC = 0x6f3e; 
    INSTRUCTION_START
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLA                          ; 6F3F: 49            \n");
                                      #endif
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BVC   L6F46                   ; 6F40: 28 04         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)V >= 0) {
    clockticks = clockticks + 3; 
    goto L6F46;
    }
                                                     #ifdef DEBUG
                                      mon("         RORA                          ; 6F42: 46            \n");
                                      #endif
    res = ((UINT8)A) | ((C != 0) ? 0x100 : 0); 
    C = res & 1; 
    res = (UINT8)(res >> 1); 
 // Z = res; 
 // N = res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         RORB                          ; 6F43: 56            \n");
                                      #endif
    res = ((UINT8)B) | ((C != 0) ? 0x100 : 0); 
    C = res & 1; 
    res = (UINT8)(res >> 1); 
    Z = res; 
    N = res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BRA   L6F54                   ; 6F44: 20 0E         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L6F54;
    
    // ---------------------------------------------------------------------------
  case 0x6F46:
L6F46:
                                                     #ifdef DEBUG
                                      mon("L6F46    ASL   $5005                   ; 6F46: 78 50 05      \n");
                                      #endif // Math result Z
    PC = 0x6f46; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x5005); 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    wr_mem(0x5005, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROL   $5004                   ; 6F49: 79 50 04      \n");
                                      #endif // Math result Z
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x5004); 
    res = (val << 1) + (C != 0 ?1:0); 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)res ^ val; 
    wr_mem(0x5004, (UINT8)res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BVC   L6F3E                   ; 6F4C: 28 F0         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)V >= 0) {
    clockticks = clockticks + 3; 
    goto L6F3E;
    }
                                                     #ifdef DEBUG
                                      mon("         ROR   $5004                   ; 6F4E: 76 50 04      \n");
                                      #endif // Math result Z
    clockticks = clockticks + 5; 
    res = ((UINT8)rd_mem(0x5004)) | ((C != 0) ? 0x100 : 0); 
    C = res & 1; 
    res = (UINT8)(res >> 1); 
 // Z = res; 
 // N = res; 
    wr_mem(0x5004, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROR   $5005                   ; 6F51: 76 50 05      \n");
                                      #endif // Math result Z
    clockticks = clockticks + 5; 
    res = ((UINT8)rd_mem(0x5005)) | ((C != 0) ? 0x100 : 0); 
 // C = res & 1; 
    res = (UINT8)(res >> 1); 
 // Z = res; 
 // N = res; 
    wr_mem(0x5005, res); 
    clockticks = clockticks + 2; 
  case 0x6F54:
L6F54:
                                                     #ifdef DEBUG
                                      mon("L6F54    COMA                          ; 6F54: 43            \n");
                                      #endif
    PC = 0x6f54; 
    INSTRUCTION_START
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4876                   ; 6F55: B7 48 76      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4876, val); 
                                                     #ifdef DEBUG
                                      mon("         LDB   $5004                   ; 6F58: F6 50 04      \n");
                                      #endif // Math result Z
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x5004); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STB   $486D                   ; 6F5B: F7 48 6D      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = B; 
    Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x486d, val); 
    // End of function sub_6EA2
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 6F5E: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x6F5F:
L6F5F:
                                                     #ifdef DEBUG
                                      mon("L6F5F    LDD   <$42                    ; 6F5F: DC 42         \n");
                                      #endif
    PC = 0x6f5f; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x42); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x43); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $CDAB                   ; 6F61: BD CD AB      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x64); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6f); 
    clockticks = clockticks + 1; 
    PC = 0xcdab; 
    JUMP;
  case 0x6F64:
L6F64:
                                                     #ifdef DEBUG
                                      mon("L6F64    STD   <$89                    ; 6F64: DD 89         \n");
                                      #endif
    PC = 0x6f64; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = DP|0x89; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    // End of function sub_6F5F
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 6F66: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x6F67:
L6F67:
                                                     #ifdef DEBUG
                                      mon("L6F67    LDD   <$42                    ; 6F67: DC 42         \n");
                                      #endif
    PC = 0x6f67; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x42); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x43); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $CDA9                   ; 6F69: BD CD A9      \n");
                                      #endif // Shift D register left
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x6c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6f); 
    clockticks = clockticks + 1; 
    PC = 0xcda9; 
    JUMP;
  case 0x6F6C:
L6F6C:
                                                     #ifdef DEBUG
                                      mon("L6F6C    STD   <$89                    ; 6F6C: DD 89         \n");
                                      #endif
    PC = 0x6f6c; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = DP|0x89; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    // End of function sub_6F67
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 6F6E: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x6F6F:
L6F6F:
                                                     #ifdef DEBUG
                                      mon("L6F6F    LDD   $5086                   ; 6F6F: FC 50 86      \n");
                                      #endif
    PC = 0x6f6f; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x5086); // Care needed with I/O space and word fetches
    B = rd_mem(0x5087); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $5098                   ; 6F72: F3 50 98      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5098)<<8; 
    ea = ea | rd_mem(0x5099); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ res) & (val ^ res)) >> 8; 
    N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BVC   L6F7D                   ; 6F75: 28 06         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)V >= 0) {
    clockticks = clockticks + 3; 
    goto L6F7D;
    }
                                                     #ifdef DEBUG
                                      mon("         INC   <$A7                    ; 6F77: 0C A7         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xa7); 
    res = (UINT8)(val + 1); 
    Z = res; 
    N = res; 
    V = res & ~val; 
    wr_mem(DP|0xa7, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BVC   L6F7D                   ; 6F79: 28 02         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)V >= 0) {
    clockticks = clockticks + 3; 
    goto L6F7D;
    }
                                                     #ifdef DEBUG
                                      mon("         DEC   <$A7                    ; 6F7B: 0A A7         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0xa7); 
    res = (UINT8)(val - 1); 
 // N = res; 
 // Z = res; 
 // V = val & ~res; 
    wr_mem(DP|0xa7, res); 
    clockticks = clockticks + 2; 
  case 0x6F7D:
L6F7D:
                                                     #ifdef DEBUG
                                      mon("L6F7D    STD   $5098                   ; 6F7D: FD 50 98      \n");
                                      #endif
    PC = 0x6f7d; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5098, A); // Care needed with I/O space and word fetches
    wr_mem(0x5099, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $5040                   ; 6F80: FD 50 40      \n");
                                      #endif // XT2
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5040, A); // Care needed with I/O space and word fetches
    wr_mem(0x5041, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $5086                   ; 6F83: FC 50 86      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x5086); // Care needed with I/O space and word fetches
    B = rd_mem(0x5087); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $CDB1                   ; 6F86: BD CD B1      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x89); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6f); 
    clockticks = clockticks + 1; 
    PC = 0xcdb1; 
    JUMP;
  case 0x6F89:
L6F89:
                                                     #ifdef DEBUG
                                      mon("L6F89    LDB   <$7D                    ; 6F89: D6 7D         \n");
                                      #endif // Joystick X
    PC = 0x6f89; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x7d); 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BPL   L6F8E                   ; 6F8B: 2A 01         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto L6F8E;
    }
                                                     #ifdef DEBUG
                                      mon("         COMB                          ; 6F8D: 53            \n");
                                      #endif
    val = (UINT8)B ^ 0xff; 
    B = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
  case 0x6F8E:
L6F8E:
                                                     #ifdef DEBUG
                                      mon("L6F8E    ASLB                          ; 6F8E: 58            \n");
                                      #endif
    PC = 0x6f8e; 
    INSTRUCTION_START
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         MUL                           ; 6F8F: 3D            \n");
                                      #endif
    res = (UINT16)(A * B); 
 // Z = res; 
    C = res & 0x80; 
    A = res >> 8; 
    B = (UINT8)res; 
    clockticks = clockticks + 11; 
                                                     #ifdef DEBUG
                                      mon("         TST   <$7D                    ; 6F90: 0D 7D         \n");
                                      #endif // Joystick X
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x7d); 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BGE   L6F98                   ; 6F92: 2C 04         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) >= 0) {
    clockticks = clockticks + 3; 
    goto L6F98;
    }
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; 6F94: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; 6F95: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SBCA  #$FF                    ; 6F96: 82 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xff; 
    res = val - (UINT8)arg - (C != 0 ? 1:0); 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)res; 
  case 0x6F98:
L6F98:
                                                     #ifdef DEBUG
                                      mon("L6F98    JSR   $CDA0                   ; 6F98: BD CD A0      \n");
                                      #endif
    PC = 0x6f98; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x9b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6f); 
    clockticks = clockticks + 1; 
    PC = 0xcda0; 
    JUMP;
  case 0x6F9B:
L6F9B:
                                                     #ifdef DEBUG
                                      mon("L6F9B    STD   $508E                   ; 6F9B: FD 50 8E      \n");
                                      #endif
    PC = 0x6f9b; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x508e, A); // Care needed with I/O space and word fetches
    wr_mem(0x508f, B); 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $509A                   ; 6F9E: F3 50 9A      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x509a)<<8; 
    ea = ea | rd_mem(0x509b); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $509A                   ; 6FA1: FD 50 9A      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x509a, A); // Care needed with I/O space and word fetches
    wr_mem(0x509b, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $5042                   ; 6FA4: FD 50 42      \n");
                                      #endif // YT2
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5042, A); // Care needed with I/O space and word fetches
    wr_mem(0x5043, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $5086                   ; 6FA7: FC 50 86      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x5086); // Care needed with I/O space and word fetches
    B = rd_mem(0x5087); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $CDB1                   ; 6FAA: BD CD B1      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xad); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6f); 
    clockticks = clockticks + 1; 
    PC = 0xcdb1; 
    JUMP;
  case 0x6FAD:
L6FAD:
                                                     #ifdef DEBUG
                                      mon("L6FAD    LDB   <$7F                    ; 6FAD: D6 7F         \n");
                                      #endif // Joystick Y
    PC = 0x6fad; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x7f); 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BPL   L6FB2                   ; 6FAF: 2A 01         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto L6FB2;
    }
                                                     #ifdef DEBUG
                                      mon("         COMB                          ; 6FB1: 53            \n");
                                      #endif
    val = (UINT8)B ^ 0xff; 
    B = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
  case 0x6FB2:
L6FB2:
                                                     #ifdef DEBUG
                                      mon("L6FB2    NOP                           ; 6FB2: 12            \n");
                                      #endif
    PC = 0x6fb2; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         MUL                           ; 6FB3: 3D            \n");
                                      #endif
    res = (UINT16)(A * B); 
 // Z = res; 
    C = res & 0x80; 
    A = res >> 8; 
    B = (UINT8)res; 
    clockticks = clockticks + 11; 
                                                     #ifdef DEBUG
                                      mon("         TST   <$7F                    ; 6FB4: 0D 7F         \n");
                                      #endif // Joystick Y
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x7f); 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BPL   L6FBC                   ; 6FB6: 2A 04         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto L6FBC;
    }
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; 6FB8: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; 6FB9: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SBCA  #$FF                    ; 6FBA: 82 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xff; 
    res = val - (UINT8)arg - (C != 0 ? 1:0); 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)res; 
  case 0x6FBC:
L6FBC:
                                                     #ifdef DEBUG
                                      mon("L6FBC    JSR   $CDA0                   ; 6FBC: BD CD A0      \n");
                                      #endif
    PC = 0x6fbc; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xbf); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x6f); 
    clockticks = clockticks + 1; 
    PC = 0xcda0; 
    JUMP;
  case 0x6FBF:
L6FBF:
                                                     #ifdef DEBUG
                                      mon("L6FBF    STD   $5096                   ; 6FBF: FD 50 96      \n");
                                      #endif
    PC = 0x6fbf; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5096, A); // Care needed with I/O space and word fetches
    wr_mem(0x5097, B); 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $509C                   ; 6FC2: F3 50 9C      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x509c)<<8; 
    ea = ea | rd_mem(0x509d); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$1C00                  ; 6FC5: 10 83 1C 00   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x1c00; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BLE   L6FD0                   ; 6FC9: 2F 05         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto L6FD0;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$1C00                  ; 6FCB: CC 1C 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x1c; 
    B = 0x00; 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   L6FD9                   ; 6FCE: 20 09         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L6FD9;
    
    // ---------------------------------------------------------------------------
  case 0x6FD0:
L6FD0:
                                                     #ifdef DEBUG
                                      mon("L6FD0    CMPD  #$0200                  ; 6FD0: 10 83 02 00   \n");
                                      #endif
    PC = 0x6fd0; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x0200; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BGE   L6FD9                   ; 6FD4: 2C 03         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) >= 0) {
    clockticks = clockticks + 3; 
    goto L6FD9;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0200                  ; 6FD6: CC 02 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x02; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0x6FD9:
L6FD9:
                                                     #ifdef DEBUG
                                      mon("L6FD9    STD   $509C                   ; 6FD9: FD 50 9C      \n");
                                      #endif
    PC = 0x6fd9; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x509c, A); // Care needed with I/O space and word fetches
    wr_mem(0x509d, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $5044                   ; 6FDC: FD 50 44      \n");
                                      #endif // ZT2
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x5044, A); // Care needed with I/O space and word fetches
    wr_mem(0x5045, B); 
    // End of function sub_6F6F
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 6FDF: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x6FE0:
L6FE0:
                                                     #ifdef DEBUG
                                      mon("L6FE0    LDD   $509C                   ; 6FE0: FC 50 9C      \n");
                                      #endif
    PC = 0x6fe0; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x509c); // Care needed with I/O space and word fetches
    B = rd_mem(0x509d); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$0380                  ; 6FE3: 10 83 03 80   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x0380; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BLE   L6FEF                   ; 6FE7: 2F 06         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto L6FEF;
    }
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$0180                  ; 6FE9: 83 01 80      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0180; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $509C                   ; 6FEC: FD 50 9C      \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x509c, A); // Care needed with I/O space and word fetches
    wr_mem(0x509d, B); 
    // End of function sub_6FE0
  case 0x6FEF:
L6FEF:
                                                     #ifdef DEBUG
                                      mon("L6FEF    BRA   L7000                   ; 6FEF: 20 0F         \n");
                                      #endif
    PC = 0x6fef; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto L7000;
    
    // =============== S U B R O U T I N E =======================================
  case 0x6FF1:
L6FF1:
                                                     #ifdef DEBUG
                                      mon("L6FF1    LDD   $509C                   ; 6FF1: FC 50 9C      \n");
                                      #endif
    PC = 0x6ff1; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x509c); // Care needed with I/O space and word fetches
    B = rd_mem(0x509d); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$F300                  ; 6FF4: 10 83 F3 00   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0xf300; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BLE   L7000                   ; 6FF8: 2F 06         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto L7000;
    }
                                                     #ifdef DEBUG
                                      mon("         SUBD  #$0100                  ; 6FFA: 83 01 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x0100; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $509C                   ; 6FFD: FD 50 9C      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x509c, A); // Care needed with I/O space and word fetches
    wr_mem(0x509d, B); 
  case 0x7000:
L7000:
                                                     #ifdef DEBUG
                                      mon("L7000    LDD   $5086                   ; 7000: FC 50 86      \n");
                                      #endif
    PC = 0x7000; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x5086); // Care needed with I/O space and word fetches
    B = rd_mem(0x5087); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $5098                   ; 7003: F3 50 98      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5098)<<8; 
    ea = ea | rd_mem(0x5099); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5098                   ; 7006: FD 50 98      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5098, A); // Care needed with I/O space and word fetches
    wr_mem(0x5099, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0300                  ; 7009: CC 03 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x03; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5086                   ; 700C: B3 50 86      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5086)<<8; 
    ea = ea | rd_mem(0x5087); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $CDA2                   ; 700F: BD CD A2      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x12); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x70); 
    clockticks = clockticks + 1; 
    PC = 0xcda2; 
    JUMP;
  case 0x7012:
L7012:
                                                     #ifdef DEBUG
                                      mon("L7012    ADDD  $5086                   ; 7012: F3 50 86      \n");
                                      #endif
    PC = 0x7012; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5086)<<8; 
    ea = ea | rd_mem(0x5087); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5086                   ; 7015: FD 50 86      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5086, A); // Care needed with I/O space and word fetches
    wr_mem(0x5087, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B15                   ; 7018: B6 4B 15      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b15); 
    A = val; 
 // N = val; 
 // Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; 701B: 44            \n");
                                      #endif
    val = (UINT8)A; 
    C = val & 1; 
    val = val >> 1; 
    A = val; 
    N = 0; 
    Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BCC   L7023                   ; 701C: 24 05         \n");
                                      #endif // Towers roll calcs
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto L7023;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0BB8                  ; 701E: CC 0B B8      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x0b; 
    B = 0xb8; 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   L7026                   ; 7021: 20 03         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L7026;
    
    // ---------------------------------------------------------------------------
  case 0x7023:
L7023:
                                                     #ifdef DEBUG
                                      mon("L7023    LDD   #$F448                  ; 7023: CC F4 48      \n");
                                      #endif // Towers roll calcs
    PC = 0x7023; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0xf4; 
    B = 0x48; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0x7026:
L7026:
                                                     #ifdef DEBUG
                                      mon("L7026    STD   $5022                   ; 7026: FD 50 22      \n");
                                      #endif // Sine for rotation
    PC = 0x7026; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5022, A); // Care needed with I/O space and word fetches
    wr_mem(0x5023, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$3EEB                  ; 7029: CC 3E EB      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x3e; 
    B = 0xeb; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5024                   ; 702C: FD 50 24      \n");
                                      #endif // Cosine for rotation
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x5024, A); // Care needed with I/O space and word fetches
    wr_mem(0x5025, B); 
                                                     #ifdef DEBUG
                                      mon("         JSR   $CE24                   ; 702F: BD CE 24      \n");
                                      #endif // Run math program $00 Roll on Matrix 4
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x32); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x70); 
    clockticks = clockticks + 1; 
    PC = 0xce24; 
    JUMP;
  case 0x7032:
L7032:
                                                     #ifdef DEBUG
                                      mon("L7032    LDD   #$00                    ; 7032: CC 00 00      \n");
                                      #endif
    PC = 0x7032; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  <$A3                    ; 7035: 93 A3         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xa3)<<8; 
    ea = ea | rd_mem(DP|0xa4); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         JSR   L6E70                   ; 7037: BD 6E 70      \n");
                                      #endif // Towers collision roll limits
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x3a); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x70); 
    clockticks = clockticks + 1; 
    goto L6E70;
    // End of function sub_6FF1
  case 0x703A:
L703A:
                                                     #ifdef DEBUG
                                      mon("L703A    RTS                           ; 703A: 39            \n");
                                      #endif
    PC = 0x703a; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Trench viewpoint calc
  case 0x703B:
L703B:
                                                     #ifdef DEBUG
                                      mon("L703B    LDD   $5086                   ; 703B: FC 50 86      \n");
                                      #endif
    PC = 0x703b; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x5086); // Care needed with I/O space and word fetches
    B = rd_mem(0x5087); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $5098                   ; 703E: F3 50 98      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5098)<<8; 
    ea = ea | rd_mem(0x5099); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5098                   ; 7041: FD 50 98      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5098, A); // Care needed with I/O space and word fetches
    wr_mem(0x5099, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $5040                   ; 7044: FD 50 40      \n");
                                      #endif // XT2
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5040, A); // Care needed with I/O space and word fetches
    wr_mem(0x5041, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $5086                   ; 7047: FC 50 86      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x5086); // Care needed with I/O space and word fetches
    B = rd_mem(0x5087); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $CDB1                   ; 704A: BD CD B1      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x4d); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x70); 
    clockticks = clockticks + 1; 
    PC = 0xcdb1; 
    JUMP;
  case 0x704D:
L704D:
                                                     #ifdef DEBUG
                                      mon("L704D    LDB   <$7D                    ; 704D: D6 7D         \n");
                                      #endif // Joystick X
    PC = 0x704d; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x7d); 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BPL   L7052                   ; 704F: 2A 01         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto L7052;
    }
                                                     #ifdef DEBUG
                                      mon("         COMB                          ; 7051: 53            \n");
                                      #endif
    val = (UINT8)B ^ 0xff; 
    B = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
  case 0x7052:
L7052:
                                                     #ifdef DEBUG
                                      mon("L7052    MUL                           ; 7052: 3D            \n");
                                      #endif
    PC = 0x7052; 
    INSTRUCTION_START
    res = (UINT16)(A * B); 
 // Z = res; 
    C = res & 0x80; 
    A = res >> 8; 
    B = (UINT8)res; 
    clockticks = clockticks + 11; 
  case 0x7053:
L7053:
                                                     #ifdef DEBUG
                                      mon("L7053    TST   <$7D                    ; 7053: 0D 7D         \n");
                                      #endif // Joystick X
    PC = 0x7053; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x7d); 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BGE   L705B                   ; 7055: 2C 04         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) >= 0) {
    clockticks = clockticks + 3; 
    goto L705B;
    }
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; 7057: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; 7058: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SBCA  #$FF                    ; 7059: 82 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xff; 
    res = val - (UINT8)arg - (C != 0 ? 1:0); 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)res; 
  case 0x705B:
L705B:
                                                     #ifdef DEBUG
                                      mon("L705B    JSR   $CDA0                   ; 705B: BD CD A0      \n");
                                      #endif // Trench X min/max limits
    PC = 0x705b; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x5e); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x70); 
    clockticks = clockticks + 1; 
    PC = 0xcda0; 
    JUMP;
  case 0x705E:
L705E:
                                                     #ifdef DEBUG
                                      mon("L705E    STD   $508E                   ; 705E: FD 50 8E      \n");
                                      #endif
    PC = 0x705e; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x508e, A); // Care needed with I/O space and word fetches
    wr_mem(0x508f, B); 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $509A                   ; 7061: F3 50 9A      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x509a)<<8; 
    ea = ea | rd_mem(0x509b); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$01FF                  ; 7064: 10 83 01 FF   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x01ff; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BLE   L706D                   ; 7068: 2F 03         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto L706D;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$01FF                  ; 706A: CC 01 FF      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x01; 
    B = 0xff; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0x706D:
L706D:
                                                     #ifdef DEBUG
                                      mon("L706D    CMPD  #$FE01                  ; 706D: 10 83 FE 01   \n");
                                      #endif
    PC = 0x706d; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0xfe01; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BGE   L7076                   ; 7071: 2C 03         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) >= 0) {
    clockticks = clockticks + 3; 
    goto L7076;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$FE01                  ; 7073: CC FE 01      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xfe; 
    B = 0x01; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0x7076:
L7076:
                                                     #ifdef DEBUG
                                      mon("L7076    STD   $509A                   ; 7076: FD 50 9A      \n");
                                      #endif
    PC = 0x7076; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x509a, A); // Care needed with I/O space and word fetches
    wr_mem(0x509b, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $5042                   ; 7079: FD 50 42      \n");
                                      #endif // YT2
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5042, A); // Care needed with I/O space and word fetches
    wr_mem(0x5043, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $5086                   ; 707C: FC 50 86      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x5086); // Care needed with I/O space and word fetches
    B = rd_mem(0x5087); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; 707F: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLA                          ; 7080: 49            \n");
                                      #endif
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; 7081: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLA                          ; 7082: 49            \n");
                                      #endif
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; 7083: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLA                          ; 7084: 49            \n");
                                      #endif
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; 7085: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROLA                          ; 7086: 49            \n");
                                      #endif
    val = (UINT8)A; 
    res = (val << 1) + (C != 0 ?1:0); 
    C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)res ^ val; 
    A = (UINT8)res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   <$7F                    ; 7087: D6 7F         \n");
                                      #endif // Joystick Y
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x7f); 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BPL   L708C                   ; 7089: 2A 01         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto L708C;
    }
                                                     #ifdef DEBUG
                                      mon("         COMB                          ; 708B: 53            \n");
                                      #endif
    val = (UINT8)B ^ 0xff; 
    B = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
  case 0x708C:
L708C:
                                                     #ifdef DEBUG
                                      mon("L708C    ASLB                          ; 708C: 58            \n");
                                      #endif
    PC = 0x708c; 
    INSTRUCTION_START
    val = (UINT8)B; 
    res = val << 1; 
 // C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         MUL                           ; 708D: 3D            \n");
                                      #endif
    res = (UINT16)(A * B); 
 // Z = res; 
    C = res & 0x80; 
    A = res >> 8; 
    B = (UINT8)res; 
    clockticks = clockticks + 11; 
                                                     #ifdef DEBUG
                                      mon("         TST   <$7F                    ; 708E: 0D 7F         \n");
                                      #endif // Joystick Y
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x7f); 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BPL   L7096                   ; 7090: 2A 04         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto L7096;
    }
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; 7092: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; 7093: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SBCA  #$FF                    ; 7094: 82 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xff; 
    res = val - (UINT8)arg - (C != 0 ? 1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)res; 
  case 0x7096:
L7096:
                                                     #ifdef DEBUG
                                      mon("L7096    ASRA                          ; 7096: 47            \n");
                                      #endif
    PC = 0x7096; 
    INSTRUCTION_START
    val = (UINT8)A; 
    C = val & 1; 
    val = (UINT8)((SINT8)val >> 1); 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         RORB                          ; 7097: 56            \n");
                                      #endif
    res = ((UINT8)B) | ((C != 0) ? 0x100 : 0); 
 // C = res & 1; 
    res = (UINT8)(res >> 1); 
 // Z = res; 
 // N = res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASRA                          ; 7098: 47            \n");
                                      #endif
    val = (UINT8)A; 
    C = val & 1; 
    val = (UINT8)((SINT8)val >> 1); 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         RORB                          ; 7099: 56            \n");
                                      #endif
    res = ((UINT8)B) | ((C != 0) ? 0x100 : 0); 
 // C = res & 1; 
    res = (UINT8)(res >> 1); 
 // Z = res; 
 // N = res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASRA                          ; 709A: 47            \n");
                                      #endif
    val = (UINT8)A; 
    C = val & 1; 
    val = (UINT8)((SINT8)val >> 1); 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         RORB                          ; 709B: 56            \n");
                                      #endif
    res = ((UINT8)B) | ((C != 0) ? 0x100 : 0); 
 // C = res & 1; 
    res = (UINT8)(res >> 1); 
 // Z = res; 
 // N = res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ASRA                          ; 709C: 47            \n");
                                      #endif
    val = (UINT8)A; 
    C = val & 1; 
    val = (UINT8)((SINT8)val >> 1); 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         RORB                          ; 709D: 56            \n");
                                      #endif
    res = ((UINT8)B) | ((C != 0) ? 0x100 : 0); 
 // C = res & 1; 
    res = (UINT8)(res >> 1); 
 // Z = res; 
 // N = res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5096                   ; 709E: FD 50 96      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5096, A); // Care needed with I/O space and word fetches
    wr_mem(0x5097, B); 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $509C                   ; 70A1: F3 50 9C      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x509c)<<8; 
    ea = ea | rd_mem(0x509d); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$FEFF                  ; 70A4: 10 83 FE FF   \n");
                                      #endif // Trench Y top/bottom limits
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0xfeff; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BLE   L70AD                   ; 70A8: 2F 03         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto L70AD;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$FEFF                  ; 70AA: CC FE FF      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xfe; 
    B = 0xff; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0x70AD:
L70AD:
                                                     #ifdef DEBUG
                                      mon("L70AD    CMPD  #$F201                  ; 70AD: 10 83 F2 01   \n");
                                      #endif
    PC = 0x70ad; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0xf201; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BGE   L70B6                   ; 70B1: 2C 03         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) >= 0) {
    clockticks = clockticks + 3; 
    goto L70B6;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$F201                  ; 70B3: CC F2 01      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xf2; 
    B = 0x01; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0x70B6:
L70B6:
                                                     #ifdef DEBUG
                                      mon("L70B6    STD   $509C                   ; 70B6: FD 50 9C      \n");
                                      #endif
    PC = 0x70b6; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x509c, A); // Care needed with I/O space and word fetches
    wr_mem(0x509d, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $5044                   ; 70B9: FD 50 44      \n");
                                      #endif // ZT2
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x5044, A); // Care needed with I/O space and word fetches
    wr_mem(0x5045, B); 
    // End of function sub_703B
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 70BC: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x70BD:
L70BD:
                                                     #ifdef DEBUG
                                      mon("L70BD    LDX   #$4866                  ; 70BD: 8E 48 66      \n");
                                      #endif // Joystick pitch data structure
    PC = 0x70bd; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x4866; 
    Z = X; 
    N = (X) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   L70F0                   ; 70C0: BD 70 F0      \n");
                                      #endif // Some joystick data calculation ?
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xc3); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x70); 
    clockticks = clockticks + 1; 
    goto L70F0;
  case 0x70C3:
L70C3:
                                                     #ifdef DEBUG
                                      mon("L70C3    JSR   L7111                   ; 70C3: BD 71 11      \n");
                                      #endif // Some joystick driven matrix rotations for pitch/roll
    PC = 0x70c3; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xc6); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x70); 
    clockticks = clockticks + 1; 
    goto L7111;
  case 0x70C6:
L70C6:
                                                     #ifdef DEBUG
                                      mon("L70C6    BEQ   locret_70CB             ; 70C6: 27 03         \n");
                                      #endif
    PC = 0x70c6; 
    INSTRUCTION_START
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L70CB;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   $CE2F                   ; 70C8: BD CE 2F      \n");
                                      #endif // Run math program $0E Pitch on Matrix 4
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xcb); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x70); 
    clockticks = clockticks + 1; 
    PC = 0xce2f; 
    JUMP;
    // End of function sub_70BD
  case 0x70CB:
L70CB:
locret_70CB:
                                                     #ifdef DEBUG
                                      mon("locret_70CB RTS                           ; 70CB: 39            \n");
                                      #endif
    PC = 0x70cb; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x70CC:
L70CC:
                                                     #ifdef DEBUG
                                      mon("L70CC    LDX   #$486F                  ; 70CC: 8E 48 6F      \n");
                                      #endif // Joystick roll data structure
    PC = 0x70cc; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x486f; 
    Z = X; 
    N = (X) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   L70F0                   ; 70CF: BD 70 F0      \n");
                                      #endif // Some joystick data calculation ?
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xd2); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x70); 
    clockticks = clockticks + 1; 
    goto L70F0;
  case 0x70D2:
L70D2:
                                                     #ifdef DEBUG
                                      mon("L70D2    JSR   L7111                   ; 70D2: BD 71 11      \n");
                                      #endif // Some joystick driven matrix rotations for pitch/roll
    PC = 0x70d2; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xd5); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x70); 
    clockticks = clockticks + 1; 
    goto L7111;
  case 0x70D5:
L70D5:
                                                     #ifdef DEBUG
                                      mon("L70D5    BEQ   locret_70DA             ; 70D5: 27 03         \n");
                                      #endif
    PC = 0x70d5; 
    INSTRUCTION_START
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L70DA;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   $CE3A                   ; 70D7: BD CE 3A      \n");
                                      #endif // Run math program $1C Yaw on Matrix 4
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xda); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x70); 
    clockticks = clockticks + 1; 
    PC = 0xce3a; 
    JUMP;
    // End of function sub_70CC
  case 0x70DA:
L70DA:
locret_70DA:
                                                     #ifdef DEBUG
                                      mon("locret_70DA RTS                           ; 70DA: 39            \n");
                                      #endif
    PC = 0x70da; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x70DB:
L70DB:
                                                     #ifdef DEBUG
                                      mon("L70DB    ORCC  #$10                    ; 70DB: 1A 10         \n");
                                      #endif // Disable interrupts
    PC = 0x70db; 
    INSTRUCTION_START
    I = 1; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$6B                    ; 70DD: DC 6B         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x6b); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x6c); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$7F                    ; 70DF: DD 7F         \n");
                                      #endif // Joystick Y
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x7f; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$74                    ; 70E1: DC 74         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x74); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x75); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$7D                    ; 70E3: DD 7D         \n");
                                      #endif // Joystick X
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x7d; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$2F                    ; 70E5: DC 2F         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x2f); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x30); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$7B                    ; 70E7: DD 7B         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x7b; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$2D                    ; 70E9: DC 2D         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x2d); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x2e); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$79                    ; 70EB: DD 79         \n");
                                      #endif
    clockticks = clockticks + 4; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = DP|0x79; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         ANDCC #$EF                    ; 70ED: 1C EF         \n");
                                      #endif // n      ; Enable interrupts
    I = 0; 
    clockticks = clockticks + 3; 
    // End of function sub_70DB
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 70EF: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Some joystick data calculation ?
  case 0x70F0:
L70F0:
                                                     #ifdef DEBUG
                                      mon("L70F0    LDA   $07,X                   ; 70F0: A6 07         \n");
                                      #endif
    PC = 0x70f0; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0007)); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BPL   L70F5                   ; 70F2: 2A 01         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto L70F5;
    }
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; 70F4: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
  case 0x70F5:
L70F5:
                                                     #ifdef DEBUG
                                      mon("L70F5    LDB   #$80                    ; 70F5: C6 80         \n");
                                      #endif
    PC = 0x70f5; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x80; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         MUL                           ; 70F7: 3D            \n");
                                      #endif
    res = (UINT16)(A * B); 
 // Z = res; 
    C = res & 0x80; 
    A = res >> 8; 
    B = (UINT8)res; 
    clockticks = clockticks + 11; 
                                                     #ifdef DEBUG
                                      mon("         NOP                           ; 70F8: 12            \n");
                                      #endif
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         NOP                           ; 70F9: 12            \n");
                                      #endif
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         NOP                           ; 70FA: 12            \n");
                                      #endif
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $07,X                   ; 70FB: E6 07         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0007)); 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BMI   L7107                   ; 70FD: 2B 08         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N <  0) {
    clockticks = clockticks + 3; 
    goto L7107;
    }
                                                     #ifdef DEBUG
                                      mon("         ADDA  $08,X                   ; 70FF: AB 08         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    arg = rd_mem((UINT16)(X + 0x0008)); 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
    V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BVC   L7105                   ; 7101: 28 02         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)V >= 0) {
    clockticks = clockticks + 3; 
    goto L7105;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$7F                    ; 7103: 86 7F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x7f; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
  case 0x7105:
L7105:
                                                     #ifdef DEBUG
                                      mon("L7105    BRA   L710E                   ; 7105: 20 07         \n");
                                      #endif
    PC = 0x7105; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto L710E;
    
    // ---------------------------------------------------------------------------
  case 0x7107:
L7107:
                                                     #ifdef DEBUG
                                      mon("L7107    NEGA                          ; 7107: 40            \n");
                                      #endif
    PC = 0x7107; 
    INSTRUCTION_START
    val = (UINT8)A; 
    res = -val; 
 // V = val & (UINT8)res; 
 // C = res & 0x100; 
    val = (UINT8)res; 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ADDA  $08,X                   ; 7108: AB 08         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    arg = rd_mem((UINT16)(X + 0x0008)); 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
    V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BVC   L710E                   ; 710A: 28 02         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)V >= 0) {
    clockticks = clockticks + 3; 
    goto L710E;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$81                    ; 710C: 86 81         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x81; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0x710E:
L710E:
                                                     #ifdef DEBUG
                                      mon("L710E    STA   $08,X                   ; 710E: A7 08         \n");
                                      #endif
    PC = 0x710e; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = (UINT16)(X + 0x0008); 
    wr_mem(ea, val); 
    // End of function sub_70F0
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 7110: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Some joystick driven matrix rotations for pitch/roll
  case 0x7111:
L7111:
                                                     #ifdef DEBUG
                                      mon("L7111    LDA   $08,X                   ; 7111: A6 08         \n");
                                      #endif
    PC = 0x7111; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0008)); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BPL   L7116                   ; 7113: 2A 01         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto L7116;
    }
                                                     #ifdef DEBUG
                                      mon("         NEGA                          ; 7115: 40            \n");
                                      #endif
    val = (UINT8)A; 
    res = -val; 
 // V = val & (UINT8)res; 
 // C = res & 0x100; 
    val = (UINT8)res; 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
  case 0x7116:
L7116:
                                                     #ifdef DEBUG
                                      mon("L7116    CMPA  #$4E                    ; 7116: 81 4E         \n");
                                      #endif
    PC = 0x7116; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x4e; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   L713A                   ; 7118: 25 20         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L713A;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$3FC2                  ; 711A: CC 3F C2      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x3f; 
    B = 0xc2; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5024                   ; 711D: FD 50 24      \n");
                                      #endif // Cosine for rotation
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5024, A); // Care needed with I/O space and word fetches
    wr_mem(0x5025, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $08,X                   ; 7120: A6 08         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0008)); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BPL   L712F                   ; 7122: 2A 0B         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto L712F;
    }
                                                     #ifdef DEBUG
                                      mon("         ADDA  #$4E                    ; 7124: 8B 4E         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x4e; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STA   $08,X                   ; 7126: A7 08         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0008); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$FA70                  ; 7128: CC FA 70      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xfa; 
    B = 0x70; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5022                   ; 712B: FD 50 22      \n");
                                      #endif // Sine for rotation
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x5022, A); // Care needed with I/O space and word fetches
    wr_mem(0x5023, B); 
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 712E: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
  case 0x712F:
L712F:
                                                     #ifdef DEBUG
                                      mon("L712F    SUBA  #$4E                    ; 712F: 80 4E         \n");
                                      #endif
    PC = 0x712f; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x4e; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)(res); 
                                                     #ifdef DEBUG
                                      mon("         STA   $08,X                   ; 7131: A7 08         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0008); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0590                  ; 7133: CC 05 90      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x05; 
    B = 0x90; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5022                   ; 7136: FD 50 22      \n");
                                      #endif // Sine for rotation
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x5022, A); // Care needed with I/O space and word fetches
    wr_mem(0x5023, B); 
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 7139: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
  case 0x713A:
L713A:
                                                     #ifdef DEBUG
                                      mon("L713A    CMPA  #$0E                    ; 713A: 81 0E         \n");
                                      #endif
    PC = 0x713a; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x0e; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCS   L715E                   ; 713C: 25 20         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L715E;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$3FFE                  ; 713E: CC 3F FE      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x3f; 
    B = 0xfe; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5024                   ; 7141: FD 50 24      \n");
                                      #endif // Cosine for rotation
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5024, A); // Care needed with I/O space and word fetches
    wr_mem(0x5025, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $08,X                   ; 7144: A6 08         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0008)); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BPL   L7153                   ; 7146: 2A 0B         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto L7153;
    }
                                                     #ifdef DEBUG
                                      mon("         ADDA  #$0E                    ; 7148: 8B 0E         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x0e; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STA   $08,X                   ; 714A: A7 08         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0008); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$FF00                  ; 714C: CC FF 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xff; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5022                   ; 714F: FD 50 22      \n");
                                      #endif // Sine for rotation
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x5022, A); // Care needed with I/O space and word fetches
    wr_mem(0x5023, B); 
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 7152: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
  case 0x7153:
L7153:
                                                     #ifdef DEBUG
                                      mon("L7153    SUBA  #$0E                    ; 7153: 80 0E         \n");
                                      #endif
    PC = 0x7153; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x0e; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)(res); 
                                                     #ifdef DEBUG
                                      mon("         STA   $08,X                   ; 7155: A7 08         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = (UINT16)(X + 0x0008); 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0100                  ; 7157: CC 01 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x01; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5022                   ; 715A: FD 50 22      \n");
                                      #endif // Sine for rotation
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x5022, A); // Care needed with I/O space and word fetches
    wr_mem(0x5023, B); 
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 715D: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // ---------------------------------------------------------------------------
  case 0x715E:
L715E:
                                                     #ifdef DEBUG
                                      mon("L715E    CLRB                          ; 715E: 5F            \n");
                                      #endif
    PC = 0x715e; 
    INSTRUCTION_START
    B = 0; // SEARCH_ME
    V = 0; 
    Z = 0; 
    N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
    // End of function sub_7111
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 715F: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Update Roll, Pitch and Yaw for [A, B, C][x, y, z] 2
  case 0x7160:
L7160:
                                                     #ifdef DEBUG
                                      mon("L7160    LDA   $486E                   ; 7160: B6 48 6E      \n");
                                      #endif
    PC = 0x7160; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x486e); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L7181                   ; 7163: 27 1C         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L7181;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   L71C4                   ; 7165: BD 71 C4      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x68); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x71); 
    clockticks = clockticks + 1; 
    goto L71C4;
  case 0x7168:
L7168:
                                                     #ifdef DEBUG
                                      mon("L7168    LDA   $486E                   ; 7168: B6 48 6E      \n");
                                      #endif
    PC = 0x7168; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x486e); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BPL   L7176                   ; 716B: 2A 09         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto L7176;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; 716D: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5022                   ; 7170: B3 50 22      \n");
                                      #endif // Sine for rotation
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5022)<<8; 
    ea = ea | rd_mem(0x5023); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5022                   ; 7173: FD 50 22      \n");
                                      #endif // Sine for rotation
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5022, A); // Care needed with I/O space and word fetches
    wr_mem(0x5023, B); 
  case 0x7176:
L7176:
                                                     #ifdef DEBUG
                                      mon("L7176    CLRA                          ; 7176: 4F            \n");
                                      #endif
    PC = 0x7176; 
    INSTRUCTION_START
    A = 0; // SEARCH_ME
 // V = 0; 
 // Z = 0; 
 // N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$05                    ; 7177: C6 05         \n");
                                      #endif // Point BIC to[ A,B,C ][x, y, z] 2
    clockticks = clockticks + 2; 
    val = (UINT8)0x05; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4701                   ; 7179: FD 47 01      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4701, A); // Care needed with I/O space and word fetches
    wr_mem(0x4702, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$0E                    ; 717C: 86 0E         \n");
                                      #endif // Pitch program
    clockticks = clockticks + 2; 
    val = (UINT8)0x0e; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $CDBA                   ; 717E: BD CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x81); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x71); 
    clockticks = clockticks + 1; 
    PC = 0xcdba; 
    JUMP;
  case 0x7181:
L7181:
                                                     #ifdef DEBUG
                                      mon("L7181    LDA   $4877                   ; 7181: B6 48 77      \n");
                                      #endif
    PC = 0x7181; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4877); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L71A2                   ; 7184: 27 1C         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L71A2;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   L71C4                   ; 7186: BD 71 C4      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x89); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x71); 
    clockticks = clockticks + 1; 
    goto L71C4;
  case 0x7189:
L7189:
                                                     #ifdef DEBUG
                                      mon("L7189    LDA   $4877                   ; 7189: B6 48 77      \n");
                                      #endif
    PC = 0x7189; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4877); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BPL   L7197                   ; 718C: 2A 09         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto L7197;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; 718E: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5022                   ; 7191: B3 50 22      \n");
                                      #endif // Sine for rotation
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5022)<<8; 
    ea = ea | rd_mem(0x5023); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5022                   ; 7194: FD 50 22      \n");
                                      #endif // Sine for rotation
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5022, A); // Care needed with I/O space and word fetches
    wr_mem(0x5023, B); 
  case 0x7197:
L7197:
                                                     #ifdef DEBUG
                                      mon("L7197    CLRA                          ; 7197: 4F            \n");
                                      #endif
    PC = 0x7197; 
    INSTRUCTION_START
    A = 0; // SEARCH_ME
 // V = 0; 
 // Z = 0; 
 // N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$05                    ; 7198: C6 05         \n");
                                      #endif // Point BIC to[ A,B,C ][x, y, z] 2
    clockticks = clockticks + 2; 
    val = (UINT8)0x05; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4701                   ; 719A: FD 47 01      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4701, A); // Care needed with I/O space and word fetches
    wr_mem(0x4702, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$1C                    ; 719D: 86 1C         \n");
                                      #endif // Yaw program
    clockticks = clockticks + 2; 
    val = (UINT8)0x1c; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $CDBA                   ; 719F: BD CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xa2); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x71); 
    clockticks = clockticks + 1; 
    PC = 0xcdba; 
    JUMP;
  case 0x71A2:
L71A2:
                                                     #ifdef DEBUG
                                      mon("L71A2    LDA   $4878                   ; 71A2: B6 48 78      \n");
                                      #endif
    PC = 0x71a2; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4878); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   locret_71C3             ; 71A5: 27 1C         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L71C3;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   L71C4                   ; 71A7: BD 71 C4      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xaa); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x71); 
    clockticks = clockticks + 1; 
    goto L71C4;
  case 0x71AA:
L71AA:
                                                     #ifdef DEBUG
                                      mon("L71AA    LDA   $4878                   ; 71AA: B6 48 78      \n");
                                      #endif
    PC = 0x71aa; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4878); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BPL   L71B8                   ; 71AD: 2A 09         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto L71B8;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; 71AF: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5022                   ; 71B2: B3 50 22      \n");
                                      #endif // Sine for rotation
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5022)<<8; 
    ea = ea | rd_mem(0x5023); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
 // N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5022                   ; 71B5: FD 50 22      \n");
                                      #endif // Sine for rotation
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5022, A); // Care needed with I/O space and word fetches
    wr_mem(0x5023, B); 
  case 0x71B8:
L71B8:
                                                     #ifdef DEBUG
                                      mon("L71B8    CLRA                          ; 71B8: 4F            \n");
                                      #endif
    PC = 0x71b8; 
    INSTRUCTION_START
    A = 0; // SEARCH_ME
 // V = 0; 
 // Z = 0; 
 // N = 0; 
    C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$05                    ; 71B9: C6 05         \n");
                                      #endif // Point BIC to[ A,B,C ][x, y, z] 2
    clockticks = clockticks + 2; 
    val = (UINT8)0x05; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4701                   ; 71BB: FD 47 01      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4701, A); // Care needed with I/O space and word fetches
    wr_mem(0x4702, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$00                    ; 71BE: 86 00         \n");
                                      #endif // Roll program
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $CDBA                   ; 71C0: BD CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xc3); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x71); 
    clockticks = clockticks + 1; 
    PC = 0xcdba; 
    JUMP;
    // End of function sub_7160
  case 0x71C3:
L71C3:
locret_71C3:
                                                     #ifdef DEBUG
                                      mon("locret_71C3 RTS                           ; 71C3: 39            \n");
                                      #endif
    PC = 0x71c3; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x71C4:
L71C4:
                                                     #ifdef DEBUG
                                      mon("L71C4    BPL   L71C7                   ; 71C4: 2A 01         \n");
                                      #endif
    PC = 0x71c4; 
    INSTRUCTION_START
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto L71C7;
    }
                                                     #ifdef DEBUG
                                      mon("         NEGA                          ; 71C6: 40            \n");
                                      #endif
    val = (UINT8)A; 
    res = -val; 
 // V = val & (UINT8)res; 
 // C = res & 0x100; 
    val = (UINT8)res; 
    A = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
  case 0x71C7:
L71C7:
                                                     #ifdef DEBUG
                                      mon("L71C7    LDB   #$03                    ; 71C7: C6 03         \n");
                                      #endif
    PC = 0x71c7; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x03; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         MUL                           ; 71C9: 3D            \n");
                                      #endif
    res = (UINT16)(A * B); 
 // Z = res; 
 // C = res & 0x80; 
    A = res >> 8; 
    B = (UINT8)res; 
    clockticks = clockticks + 11; 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$71DA                  ; 71CA: 8E 71 DA      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x71da; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ABX                           ; 71CD: 3A            \n");
                                      #endif
    X = X + B; 
    clockticks = clockticks + 3; 
                                                     #ifdef DEBUG
                                      mon("         LDD   ,X                      ; 71CE: EC 84         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(X); // Care needed with I/O space and word fetches. Use 'ea' here?
    B = rd_mem((UINT16)(X+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5022                   ; 71D0: FD 50 22      \n");
                                      #endif // Sine for rotation
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5022, A); // Care needed with I/O space and word fetches
    wr_mem(0x5023, B); 
                                                     #ifdef DEBUG
                                      mon("         LDB   $02,X                   ; 71D3: E6 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0002)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SEX                           ; 71D5: 1D            \n");
                                      #endif
 // Z = B; 
 // N = B; 
    A = ((SINT8)B < 0 ? 0xff : 0); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$4000                  ; 71D6: C3 40 00      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x4000; 
    arg = (A << 8) | B; 
    res = arg + val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
  case 0x71D9:
L71D9:
                                                     #ifdef DEBUG
                                      mon("L71D9    STD   $5024                   ; 71D9: FD 50 24      \n");
                                      #endif // Cosine for rotation
    PC = 0x71d9; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x5024, A); // Care needed with I/O space and word fetches
    wr_mem(0x5025, B); 
    // End of function sub_71C4
    // ---------------------------------------------------------------------------
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 71DC: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Space wave
  case 0x72C7:
L72C7:
                                                     #ifdef DEBUG
                                      mon("L72C7    JSR   L6112                   ; 72C7: BD 61 12      \n");
                                      #endif // Insert vector data for four blue dots in screen corners
    PC = 0x72c7; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xca); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x72); 
    clockticks = clockticks + 1; 
    goto L6112;
  case 0x72CA:
L72CA:
                                                     #ifdef DEBUG
                                      mon("L72CA    LDA   #$10                    ; 72CA: 86 10         \n");
                                      #endif // BIC points to Matrix 4
    PC = 0x72ca; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x10; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $CE0C                   ; 72CC: BD CE 0C      \n");
                                      #endif // Copy transform data from [BIC] to matrix 2
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xcf); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x72); 
    clockticks = clockticks + 1; 
    PC = 0xce0c; 
    JUMP;
  case 0x72CF:
L72CF:
                                                     #ifdef DEBUG
                                      mon("L72CF    JSR   L7160                   ; 72CF: BD 71 60      \n");
                                      #endif // Update Roll, Pitch and Yaw for [A, B, C][x, y, z] 2
    PC = 0x72cf; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xd2); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x72); 
    clockticks = clockticks + 1; 
    goto L7160;
  case 0x72D2:
L72D2:
                                                     #ifdef DEBUG
                                      mon("L72D2    JSR   L761D                   ; 72D2: BD 76 1D      \n");
                                      #endif // Display score
    PC = 0x72d2; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xd5); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x72); 
    clockticks = clockticks + 1; 
    goto L761D;
  case 0x72D5:
L72D5:
                                                     #ifdef DEBUG
                                      mon("L72D5    LDA   $4B2D                   ; 72D5: B6 4B 2D      \n");
                                      #endif
    PC = 0x72d5; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b2d); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L72F0                   ; 72D8: 26 16         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L72F0;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $4B0E                   ; 72DA: FC 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    clockticks = clockticks + 5; 
    A = rd_mem(0x4b0e); // Care needed with I/O space and word fetches
    B = rd_mem(0x4b0f); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$A0                    ; 72DD: 10 83 00 A0   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x00a0; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCC   L72F0                   ; 72E1: 24 0D         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto L72F0;
    }
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$10                    ; 72E3: C4 10         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x10; 
    B = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L72EB                   ; 72E5: 26 04         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L72EB;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   #$4C                    ; 72E7: C6 4C         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x4c; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   L72ED                   ; 72E9: 20 02         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L72ED;
    
    // ---------------------------------------------------------------------------
  case 0x72EB:
L72EB:
                                                     #ifdef DEBUG
                                      mon("L72EB    LDB   #$4D                    ; 72EB: C6 4D         \n");
                                      #endif // "Shoot Tie Fighters text index", Shoot Tie Fighters text index
    PC = 0x72eb; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x4d; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
  case 0x72ED:
L72ED:
                                                     #ifdef DEBUG
                                      mon("L72ED    JSR   $E7C7                   ; 72ED: BD E7 C7      \n");
                                      #endif // "Print text string from pointer table", Print text string from pointer table
    PC = 0x72ed; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf0); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x72); 
    clockticks = clockticks + 1; 
    PC = 0xe7c7; 
    JUMP;
  case 0x72F0:
L72F0:
                                                     #ifdef DEBUG
                                      mon("L72F0    JSR   $95A7                   ; 72F0: BD 95 A7      \n");
                                      #endif // "Insert vector instructions for shields", Insert vector instructions for shields
				      
    PC = 0x72f0; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf3); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x72); 
    clockticks = clockticks + 1; 
    PC = 0x95a7; 
    
   JUMP;
    
    
  case 0x72F3:
L72F3:
                                                     #ifdef DEBUG
                                      mon("L72F3    JSR   L7765                   ; 72F3: BD 77 65      \n");
                                      #endif // Space wave sub_7765
    PC = 0x72f3; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf6); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x72); 
    clockticks = clockticks + 1; 
    goto L7765;
   
  case 0x72F6:
L72F6:

                                                     #ifdef DEBUG
                                      mon("L72F6    JSR   $B6B9                   ; 72F6: BD B6 B9      \n");
                                      #endif // Insert vector instructions at joystick position for laser explosion 2
    PC = 0x72f6; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf9); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x72); 
    clockticks = clockticks + 1; 
    PC = 0xb6b9; 
    JUMP;
    
  case 0x72F9:
L72F9:
                                                     #ifdef DEBUG
                                      mon("L72F9    JSR   $CD80                   ; 72F9: BD CD 80      \n");
                                      #endif // Starfield
    PC = 0x72f9; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xfc); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x72); 
    clockticks = clockticks + 1; 
    PC = 0xcd80; 
    JUMP;
  case 0x72FC:
L72FC:
                                                     #ifdef DEBUG
                                      mon("L72FC    JSR   $BA12                   ; 72FC: BD BA 12      \n");
                                      #endif // Process tie/tower/bunker explosions
    PC = 0x72fc; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xff); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x72); 
    clockticks = clockticks + 1; 
    PC = 0xba12; 
    JUMP;
  case 0x72FF:
L72FF:
                                                     #ifdef DEBUG
                                      mon("L72FF    JSR   $AE60                   ; 72FF: BD AE 60      \n");
                                      #endif
    PC = 0x72ff; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x02); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    PC = 0xae60; 
    JUMP;
  case 0x7302:
L7302:
                                                     #ifdef DEBUG
                                      mon("L7302    JSR   L786A                   ; 7302: BD 78 6A      \n");
                                      #endif // Process tie fighters and insert vectors
    PC = 0x7302; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x05); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    goto L786A;
    
  case 0x7305:
L7305:
                                                     #ifdef DEBUG
                                      mon("L7305    JSR   $AAE4                   ; 7305: BD AA E4      \n");
                                      #endif // Fireball processing
    PC = 0x7305; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x08); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    PC = 0xaae4; 
    JUMP;
  case 0x7308:
L7308:
                                                     #ifdef DEBUG
                                      mon("L7308    JSR   $B32B                   ; 7308: BD B3 2B      \n");
                                      #endif
    PC = 0x7308; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x0b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    PC = 0xb32b; 
    JUMP;
  case 0x730B:
L730B:

                                                     #ifdef DEBUG
                                      mon("L730B    JSR   $AEBD                   ; 730B: BD AE BD      \n");
                                      #endif
    PC = 0x730b; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x0e); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    PC = 0xaebd; 
    JUMP;
    
  case 0x730E:
L730E:
                                                     #ifdef DEBUG
                                      mon("L730E    JSR   $98B0                   ; 730E: BD 98 B0      \n");
                                      #endif // Insert vector laser explosion small circle
    PC = 0x730e; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x11); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    PC = 0x98b0; 
    JUMP;
  case 0x7311:
L7311:
                                                     #ifdef DEBUG
                                      mon("L7311    JSR   L612F                   ; 7311: BD 61 2F      \n");
                                      #endif // Vector instructions end
    PC = 0x7311; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x14); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    goto L612F;
    // End of function sub_72C7
  case 0x7314:
L7314:

                                                     #ifdef DEBUG
                                      mon("L7314    RTS                           ; 7314: 39            \n");
                                      #endif
    PC = 0x7314; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x7315:
L7315:
                                                     #ifdef DEBUG
                                      mon("L7315    JSR   L6112                   ; 7315: BD 61 12      \n");
                                      #endif // Insert vector data for four blue dots in screen corners
    PC = 0x7315; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x18); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    goto L6112;
  case 0x7318:
L7318:
                                                     #ifdef DEBUG
                                      mon("L7318    LDA   #$10                    ; 7318: 86 10         \n");
                                      #endif // BIC points to Matrix 4
    PC = 0x7318; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x10; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $CE0C                   ; 731A: BD CE 0C      \n");
                                      #endif // Copy transform data from [BIC] to matrix 2
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x1d); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    PC = 0xce0c; 
    JUMP;
  case 0x731D:
L731D:
                                                     #ifdef DEBUG
                                      mon("L731D    JSR   L7160                   ; 731D: BD 71 60      \n");
                                      #endif // Update Roll, Pitch and Yaw for [A, B, C][x, y, z] 2
    PC = 0x731d; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x20); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    goto L7160;
  case 0x7320:
L7320:
                                                     #ifdef DEBUG
                                      mon("L7320    JSR   L761D                   ; 7320: BD 76 1D      \n");
                                      #endif // Display score
    PC = 0x7320; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x23); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    goto L761D;
  case 0x7323:
L7323:
                                                     #ifdef DEBUG
                                      mon("L7323    JSR   $95A7                   ; 7323: BD 95 A7      \n");
                                      #endif // Insert vector instructions for shields
    PC = 0x7323; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x26); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    PC = 0x95a7; 
    JUMP;
  case 0x7326:
L7326:
                                                     #ifdef DEBUG
                                      mon("L7326    JSR   $CD80                   ; 7326: BD CD 80      \n");
                                      #endif // Starfield
    PC = 0x7326; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x29); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    PC = 0xcd80; 
    JUMP;
  case 0x7329:
L7329:
                                                     #ifdef DEBUG
                                      mon("L7329    JSR   $BA12                   ; 7329: BD BA 12      \n");
                                      #endif // Process tie/tower/bunker explosions
    PC = 0x7329; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x2c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    PC = 0xba12; 
    JUMP;
  case 0x732C:
L732C:
                                                     #ifdef DEBUG
                                      mon("L732C    JSR   L786A                   ; 732C: BD 78 6A      \n");
                                      #endif // Process tie fighters and insert vectors
    PC = 0x732c; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x2f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    goto L786A;
  case 0x732F:
L732F:
                                                     #ifdef DEBUG
                                      mon("L732F    JSR   $AAE4                   ; 732F: BD AA E4      \n");
                                      #endif // Fireball processing
    PC = 0x732f; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x32); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    PC = 0xaae4; 
    JUMP;
  case 0x7332:
L7332:
                                                     #ifdef DEBUG
                                      mon("L7332    JSR   L7707                   ; 7332: BD 77 07      \n");
                                      #endif // Game Over text handling
    PC = 0x7332; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x35); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    goto L7707;
  case 0x7335:
L7335:
                                                     #ifdef DEBUG
                                      mon("L7335    JSR   $98B0                   ; 7335: BD 98 B0      \n");
                                      #endif // Insert vector laser explosion small circle
    PC = 0x7335; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x38); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    PC = 0x98b0; 
    JUMP;
  case 0x7338:
L7338:
                                                     #ifdef DEBUG
                                      mon("L7338    JSR   L612F                   ; 7338: BD 61 2F      \n");
                                      #endif // Vector instructions end
    PC = 0x7338; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x3b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    goto L612F;
    // End of function sub_7315
  case 0x733B:
L733B:
                                                     #ifdef DEBUG
                                      mon("L733B    RTS                           ; 733B: 39            \n");
                                      #endif
    PC = 0x733b; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // End of space wave? Also Trench catwalks
  case 0x733C:
L733C:
                                                     #ifdef DEBUG
                                      mon("L733C    JSR   L6112                   ; 733C: BD 61 12      \n");
                                      #endif // Insert vector data for four blue dots in screen corners
    PC = 0x733c; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x3f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    goto L6112;
  case 0x733F:
L733F:
                                                     #ifdef DEBUG
                                      mon("L733F    LDA   #$10                    ; 733F: 86 10         \n");
                                      #endif // BIC points to Matrix 4
    PC = 0x733f; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x10; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $CE0C                   ; 7341: BD CE 0C      \n");
                                      #endif // Copy transform data from [BIC] to matrix 2
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x44); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    PC = 0xce0c; 
    JUMP;
  case 0x7344:
L7344:
                                                     #ifdef DEBUG
                                      mon("L7344    JSR   L7160                   ; 7344: BD 71 60      \n");
                                      #endif // Update Roll, Pitch and Yaw for [A, B, C][x, y, z] 2
    PC = 0x7344; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x47); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    goto L7160;
  case 0x7347:
L7347:
                                                     #ifdef DEBUG
                                      mon("L7347    JSR   L761D                   ; 7347: BD 76 1D      \n");
                                      #endif // Display score
    PC = 0x7347; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x4a); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    goto L761D;
  case 0x734A:
L734A:
                                                     #ifdef DEBUG
                                      mon("L734A    JSR   $95A7                   ; 734A: BD 95 A7      \n");
                                      #endif // Insert vector instructions for shields
    PC = 0x734a; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x4d); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    PC = 0x95a7; 
    JUMP;
  case 0x734D:
L734D:
                                                     #ifdef DEBUG
                                      mon("L734D    JSR   $B6B9                   ; 734D: BD B6 B9      \n");
                                      #endif // Insert vector instructions at joystick position for laser explosion 2
    PC = 0x734d; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x50); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    PC = 0xb6b9; 
    JUMP;
  case 0x7350:
L7350:
                                                     #ifdef DEBUG
                                      mon("L7350    JSR   $CD80                   ; 7350: BD CD 80      \n");
                                      #endif // Starfield
    PC = 0x7350; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x53); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    PC = 0xcd80; 
    JUMP;
  case 0x7353:
L7353:
                                                     #ifdef DEBUG
                                      mon("L7353    JSR   L7765                   ; 7353: BD 77 65      \n");
                                      #endif // Space wave sub_7765
    PC = 0x7353; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x56); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    goto L7765;
  case 0x7356:
L7356:
                                                     #ifdef DEBUG
                                      mon("L7356    JSR   $BA12                   ; 7356: BD BA 12      \n");
                                      #endif // Process tie/tower/bunker explosions
    PC = 0x7356; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x59); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    PC = 0xba12; 
    JUMP;
  case 0x7359:
L7359:
                                                     #ifdef DEBUG
                                      mon("L7359    JSR   $AE60                   ; 7359: BD AE 60      \n");
                                      #endif
    PC = 0x7359; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x5c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    PC = 0xae60; 
    JUMP;
  case 0x735C:
L735C:
                                                     #ifdef DEBUG
                                      mon("L735C    JSR   L786A                   ; 735C: BD 78 6A      \n");
                                      #endif // Process tie fighters and insert vectors
    PC = 0x735c; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x5f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    goto L786A;
  case 0x735F:
L735F:
                                                     #ifdef DEBUG
                                      mon("L735F    JSR   $AAE4                   ; 735F: BD AA E4      \n");
                                      #endif // Fireball processing
    PC = 0x735f; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x62); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    PC = 0xaae4; 
    JUMP;
  case 0x7362:
L7362:
                                                     #ifdef DEBUG
                                      mon("L7362    JSR   $B32B                   ; 7362: BD B3 2B      \n");
                                      #endif
    PC = 0x7362; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x65); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    PC = 0xb32b; 
    JUMP;
  case 0x7365:
L7365:
                                                     #ifdef DEBUG
                                      mon("L7365    JSR   $AEBD                   ; 7365: BD AE BD      \n");
                                      #endif
    PC = 0x7365; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x68); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    PC = 0xaebd; 
    JUMP;
  case 0x7368:
L7368:
                                                     #ifdef DEBUG
                                      mon("L7368    JSR   $98B0                   ; 7368: BD 98 B0      \n");
                                      #endif // Insert vector laser explosion small circle
    PC = 0x7368; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x6b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    PC = 0x98b0; 
    JUMP;
  case 0x736B:
L736B:
                                                     #ifdef DEBUG
                                      mon("L736B    JSR   L612F                   ; 736B: BD 61 2F      \n");
                                      #endif // Vector instructions end
    PC = 0x736b; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x6e); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    goto L612F;
    // End of function sub_733C
  case 0x736E:
L736E:
                                                     #ifdef DEBUG
                                      mon("L736E    RTS                           ; 736E: 39            \n");
                                      #endif
    PC = 0x736e; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x736F:
L736F:
                                                     #ifdef DEBUG
                                      mon("L736F    JSR   L6112                   ; 736F: BD 61 12      \n");
                                      #endif // Insert vector data for four blue dots in screen corners
    PC = 0x736f; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x72); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    goto L6112;
  case 0x7372:
L7372:
                                                     #ifdef DEBUG
                                      mon("L7372    LDA   #$10                    ; 7372: 86 10         \n");
                                      #endif // BIC points to Matrix 4
    PC = 0x7372; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x10; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $CE0C                   ; 7374: BD CE 0C      \n");
                                      #endif // Copy transform data from [BIC] to matrix 2
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x77); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    PC = 0xce0c; 
    JUMP;
  case 0x7377:
L7377:
                                                     #ifdef DEBUG
                                      mon("L7377    JSR   L7160                   ; 7377: BD 71 60      \n");
                                      #endif // Update Roll, Pitch and Yaw for [A, B, C][x, y, z] 2
    PC = 0x7377; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x7a); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    goto L7160;
  case 0x737A:
L737A:
                                                     #ifdef DEBUG
                                      mon("L737A    JSR   L761D                   ; 737A: BD 76 1D      \n");
                                      #endif // Display score
    PC = 0x737a; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x7d); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    goto L761D;
  case 0x737D:
L737D:
                                                     #ifdef DEBUG
                                      mon("L737D    JSR   $95A7                   ; 737D: BD 95 A7      \n");
                                      #endif // Insert vector instructions for shields
    PC = 0x737d; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x80); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    PC = 0x95a7; 
    JUMP;
  case 0x7380:
L7380:
                                                     #ifdef DEBUG
                                      mon("L7380    JSR   $B6B9                   ; 7380: BD B6 B9      \n");
                                      #endif // Insert vector instructions at joystick position for laser explosion 2
    PC = 0x7380; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x83); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    PC = 0xb6b9; 
    JUMP;
  case 0x7383:
L7383:
                                                     #ifdef DEBUG
                                      mon("L7383    JSR   $CD80                   ; 7383: BD CD 80      \n");
                                      #endif // Starfield
    PC = 0x7383; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x86); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    PC = 0xcd80; 
    JUMP;
  case 0x7386:
L7386:
                                                     #ifdef DEBUG
                                      mon("L7386    JSR   L77A4                   ; 7386: BD 77 A4      \n");
                                      #endif
    PC = 0x7386; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x89); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    goto L77A4;
  case 0x7389:
L7389:
                                                     #ifdef DEBUG
                                      mon("L7389    JSR   $98B0                   ; 7389: BD 98 B0      \n");
                                      #endif // Insert vector laser explosion small circle
    PC = 0x7389; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x8c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    PC = 0x98b0; 
    JUMP;
  case 0x738C:
L738C:
                                                     #ifdef DEBUG
                                      mon("L738C    JSR   L612F                   ; 738C: BD 61 2F      \n");
                                      #endif // Vector instructions end
    PC = 0x738c; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x8f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    goto L612F;
    // End of function sub_736F
  case 0x738F:
L738F:
                                                     #ifdef DEBUG
                                      mon("L738F    RTS                           ; 738F: 39            \n");
                                      #endif
    PC = 0x738f; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Towers/Bunkers wave
  case 0x7390:
L7390:
                                                     #ifdef DEBUG
                                      mon("L7390    JSR   L6112                   ; 7390: BD 61 12      \n");
                                      #endif // Towers/Bunkers wave
    PC = 0x7390; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x93); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    goto L6112;
  case 0x7393:
L7393:
                                                     #ifdef DEBUG
                                      mon("L7393    LDA   #$10                    ; 7393: 86 10         \n");
                                      #endif // BIC points to Matrix 4
    PC = 0x7393; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x10; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $CE0C                   ; 7395: BD CE 0C      \n");
                                      #endif // Copy transform data from [BIC] to matrix 2
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x98); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    PC = 0xce0c; 
    JUMP;
  case 0x7398:
L7398:
                                                     #ifdef DEBUG
                                      mon("L7398    JSR   L7160                   ; 7398: BD 71 60      \n");
                                      #endif // Update Roll, Pitch and Yaw for [A, B, C][x, y, z] 2
    PC = 0x7398; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x9b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    goto L7160;
  case 0x739B:
L739B:
                                                     #ifdef DEBUG
                                      mon("L739B    JSR   L761D                   ; 739B: BD 76 1D      \n");
                                      #endif // Display score
    PC = 0x739b; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x9e); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    goto L761D;
  case 0x739E:
L739E:
                                                     #ifdef DEBUG
                                      mon("L739E    JSR   L768D                   ; 739E: BD 76 8D      \n");
                                      #endif // Display tower count and hit score
    PC = 0x739e; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xa1); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    goto L768D;
  case 0x73A1:
L73A1:
                                                     #ifdef DEBUG
                                      mon("L73A1    JSR   $95A7                   ; 73A1: BD 95 A7      \n");
                                      #endif // Insert vector instructions for shields
    PC = 0x73a1; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xa4); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    PC = 0x95a7; 
    JUMP;
  case 0x73A4:
L73A4:
                                                     #ifdef DEBUG
                                      mon("L73A4    JSR   $B6B9                   ; 73A4: BD B6 B9      \n");
                                      #endif // Insert vector instructions at joystick position for laser explosion 2
    PC = 0x73a4; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xa7); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    PC = 0xb6b9; 
    JUMP;
  case 0x73A7:
L73A7:
                                                     #ifdef DEBUG
                                      mon("L73A7    JSR   $CD8C                   ; 73A7: BD CD 8C      \n");
                                      #endif // Towers surface dots
    PC = 0x73a7; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xaa); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    PC = 0xcd8c; 
    JUMP;
  case 0x73AA:
L73AA:
                                                     #ifdef DEBUG
                                      mon("L73AA    JSR   $AE60                   ; 73AA: BD AE 60      \n");
                                      #endif
    PC = 0x73aa; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xad); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    PC = 0xae60; 
    JUMP;
  case 0x73AD:
L73AD:
                                                     #ifdef DEBUG
                                      mon("L73AD    JSR   $AAE4                   ; 73AD: BD AA E4      \n");
                                      #endif // Fireball processing
    PC = 0x73ad; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xb0); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    PC = 0xaae4; 
    JUMP;
  case 0x73B0:
L73B0:
                                                     #ifdef DEBUG
                                      mon("L73B0    JSR   $A214                   ; 73B0: BD A2 14      \n");
                                      #endif
    PC = 0x73b0; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xb3); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    PC = 0xa214; 
    JUMP;
  case 0x73B3:
L73B3:
                                                     #ifdef DEBUG
                                      mon("L73B3    JSR   $B2D2                   ; 73B3: BD B2 D2      \n");
                                      #endif
    PC = 0x73b3; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xb6); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    PC = 0xb2d2; 
    JUMP;
  case 0x73B6:
L73B6:
                                                     #ifdef DEBUG
                                      mon("L73B6    JSR   $AEBD                   ; 73B6: BD AE BD      \n");
                                      #endif
    PC = 0x73b6; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xb9); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    PC = 0xaebd; 
    JUMP;
  case 0x73B9:
L73B9:
                                                     #ifdef DEBUG
                                      mon("L73B9    JSR   $BA12                   ; 73B9: BD BA 12      \n");
                                      #endif // Process tie/tower/bunker explosions
    PC = 0x73b9; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xbc); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    PC = 0xba12; 
    JUMP;
  case 0x73BC:
L73BC:
                                                     #ifdef DEBUG
                                      mon("L73BC    JSR   $98B0                   ; 73BC: BD 98 B0      \n");
                                      #endif // Insert vector laser explosion small circle
    PC = 0x73bc; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xbf); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    PC = 0x98b0; 
    JUMP;
  case 0x73BF:
L73BF:
                                                     #ifdef DEBUG
                                      mon("L73BF    JSR   L612F                   ; 73BF: BD 61 2F      \n");
                                      #endif // Vector instructions end
    PC = 0x73bf; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xc2); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    goto L612F;
    // End of function sub_7390
  case 0x73C2:
L73C2:
                                                     #ifdef DEBUG
                                      mon("L73C2    RTS                           ; 73C2: 39            \n");
                                      #endif
    PC = 0x73c2; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Towers
  case 0x73C3:
L73C3:
                                                     #ifdef DEBUG
                                      mon("L73C3    JSR   L6112                   ; 73C3: BD 61 12      \n");
                                      #endif // Insert vector data for four blue dots in screen corners
    PC = 0x73c3; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xc6); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    goto L6112;
  case 0x73C6:
L73C6:
                                                     #ifdef DEBUG
                                      mon("L73C6    LDA   #$10                    ; 73C6: 86 10         \n");
                                      #endif // BIC points to Matrix 4
    PC = 0x73c6; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x10; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $CE0C                   ; 73C8: BD CE 0C      \n");
                                      #endif // Copy transform data from [BIC] to matrix 2
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xcb); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    PC = 0xce0c; 
    JUMP;
  case 0x73CB:
L73CB:
                                                     #ifdef DEBUG
                                      mon("L73CB    JSR   L7160                   ; 73CB: BD 71 60      \n");
                                      #endif // Update Roll, Pitch and Yaw for [A, B, C][x, y, z] 2
    PC = 0x73cb; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xce); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    goto L7160;
  case 0x73CE:
L73CE:
                                                     #ifdef DEBUG
                                      mon("L73CE    JSR   L761D                   ; 73CE: BD 76 1D      \n");
                                      #endif // Display score
    PC = 0x73ce; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xd1); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    goto L761D;
  case 0x73D1:
L73D1:
                                                     #ifdef DEBUG
                                      mon("L73D1    JSR   L768D                   ; 73D1: BD 76 8D      \n");
                                      #endif // Display tower count and hit score
    PC = 0x73d1; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xd4); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    goto L768D;
  case 0x73D4:
L73D4:
                                                     #ifdef DEBUG
                                      mon("L73D4    JSR   $95A7                   ; 73D4: BD 95 A7      \n");
                                      #endif // Insert vector instructions for shields
    PC = 0x73d4; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xd7); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    PC = 0x95a7; 
    JUMP;
  case 0x73D7:
L73D7:
                                                     #ifdef DEBUG
                                      mon("L73D7    JSR   $CD8C                   ; 73D7: BD CD 8C      \n");
                                      #endif // Towers surface dots
    PC = 0x73d7; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xda); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    PC = 0xcd8c; 
    JUMP;
  case 0x73DA:
L73DA:
                                                     #ifdef DEBUG
                                      mon("L73DA    JSR   $AAE4                   ; 73DA: BD AA E4      \n");
                                      #endif // Fireball processing
    PC = 0x73da; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xdd); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    PC = 0xaae4; 
    JUMP;
  case 0x73DD:
L73DD:
                                                     #ifdef DEBUG
                                      mon("L73DD    JSR   $A214                   ; 73DD: BD A2 14      \n");
                                      #endif
    PC = 0x73dd; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xe0); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    PC = 0xa214; 
    JUMP;
  case 0x73E0:
L73E0:
                                                     #ifdef DEBUG
                                      mon("L73E0    JSR   L7707                   ; 73E0: BD 77 07      \n");
                                      #endif // Game Over text handling
    PC = 0x73e0; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xe3); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    goto L7707;
  case 0x73E3:
L73E3:
                                                     #ifdef DEBUG
                                      mon("L73E3    JSR   $98B0                   ; 73E3: BD 98 B0      \n");
                                      #endif // Insert vector laser explosion small circle
    PC = 0x73e3; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xe6); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    PC = 0x98b0; 
    JUMP;
  case 0x73E6:
L73E6:
                                                     #ifdef DEBUG
                                      mon("L73E6    JSR   L612F                   ; 73E6: BD 61 2F      \n");
                                      #endif // Vector instructions end
    PC = 0x73e6; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xe9); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    goto L612F;
    // End of function sub_73C3
  case 0x73E9:
L73E9:
                                                     #ifdef DEBUG
                                      mon("L73E9    RTS                           ; 73E9: 39            \n");
                                      #endif
    PC = 0x73e9; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Towers
  case 0x73EA:
L73EA:
                                                     #ifdef DEBUG
                                      mon("L73EA    JSR   L6112                   ; 73EA: BD 61 12      \n");
                                      #endif // Insert vector data for four blue dots in screen corners
    PC = 0x73ea; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xed); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    goto L6112;
  case 0x73ED:
L73ED:
                                                     #ifdef DEBUG
                                      mon("L73ED    LDA   #$10                    ; 73ED: 86 10         \n");
                                      #endif // BIC points to Matrix 4
    PC = 0x73ed; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x10; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $CE0C                   ; 73EF: BD CE 0C      \n");
                                      #endif // Copy transform data from [BIC] to matrix 2
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf2); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    PC = 0xce0c; 
    JUMP;
  case 0x73F2:
L73F2:
                                                     #ifdef DEBUG
                                      mon("L73F2    JSR   L7160                   ; 73F2: BD 71 60      \n");
                                      #endif // Update Roll, Pitch and Yaw for [A, B, C][x, y, z] 2
    PC = 0x73f2; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf5); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    goto L7160;
  case 0x73F5:
L73F5:
                                                     #ifdef DEBUG
                                      mon("L73F5    JSR   L761D                   ; 73F5: BD 76 1D      \n");
                                      #endif // Display score
    PC = 0x73f5; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    goto L761D;
  case 0x73F8:
L73F8:
                                                     #ifdef DEBUG
                                      mon("L73F8    JSR   L76D3                   ; 73F8: BD 76 D3      \n");
                                      #endif // Towers left to shoot count
    PC = 0x73f8; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xfb); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x73); 
    clockticks = clockticks + 1; 
    goto L76D3;
  case 0x73FB:
L73FB:
                                                     #ifdef DEBUG
                                      mon("L73FB    LDB   #$4F                    ; 73FB: C6 4F         \n");
                                      #endif
    PC = 0x73fb; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x4f; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $E7C7                   ; 73FD: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x00); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    PC = 0xe7c7; 
    JUMP;
  case 0x7400:
L7400:
                                                     #ifdef DEBUG
                                      mon("L7400    JSR   $95A7                   ; 7400: BD 95 A7      \n");
                                      #endif // Insert vector instructions for shields
    PC = 0x7400; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x03); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    PC = 0x95a7; 
    JUMP;
  case 0x7403:
L7403:
                                                     #ifdef DEBUG
                                      mon("L7403    JSR   $B6B9                   ; 7403: BD B6 B9      \n");
                                      #endif // Insert vector instructions at joystick position for laser explosion 2
    PC = 0x7403; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x06); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    PC = 0xb6b9; 
    JUMP;
  case 0x7406:
L7406:
                                                     #ifdef DEBUG
                                      mon("L7406    JSR   $CD8C                   ; 7406: BD CD 8C      \n");
                                      #endif // Towers surface dots
    PC = 0x7406; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x09); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    PC = 0xcd8c; 
    JUMP;
  case 0x7409:
L7409:
                                                     #ifdef DEBUG
                                      mon("L7409    JSR   $BA12                   ; 7409: BD BA 12      \n");
                                      #endif // Process tie/tower/bunker explosions
    PC = 0x7409; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x0c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    PC = 0xba12; 
    JUMP;
  case 0x740C:
L740C:
                                                     #ifdef DEBUG
                                      mon("L740C    JSR   $98B0                   ; 740C: BD 98 B0      \n");
                                      #endif // Insert vector laser explosion small circle
    PC = 0x740c; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x0f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    PC = 0x98b0; 
    JUMP;
  case 0x740F:
L740F:
                                                     #ifdef DEBUG
                                      mon("L740F    JSR   L612F                   ; 740F: BD 61 2F      \n");
                                      #endif // Vector instructions end
    PC = 0x740f; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x12); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    goto L612F;
    // End of function sub_73EA
  case 0x7412:
L7412:
                                                     #ifdef DEBUG
                                      mon("L7412    RTS                           ; 7412: 39            \n");
                                      #endif
    PC = 0x7412; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x7413:
L7413:
                                                     #ifdef DEBUG
                                      mon("L7413    JSR   L6112                   ; 7413: BD 61 12      \n");
                                      #endif // Insert vector data for four blue dots in screen corners
    PC = 0x7413; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x16); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    goto L6112;
  case 0x7416:
L7416:
                                                     #ifdef DEBUG
                                      mon("L7416    LDA   #$10                    ; 7416: 86 10         \n");
                                      #endif // BIC points to Matrix 4
    PC = 0x7416; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x10; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $CE0C                   ; 7418: BD CE 0C      \n");
                                      #endif // Copy transform data from [BIC] to matrix 2
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x1b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    PC = 0xce0c; 
    JUMP;
  case 0x741B:
L741B:
                                                     #ifdef DEBUG
                                      mon("L741B    JSR   L7160                   ; 741B: BD 71 60      \n");
                                      #endif // Update Roll, Pitch and Yaw for [A, B, C][x, y, z] 2
    PC = 0x741b; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x1e); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    goto L7160;
  case 0x741E:
L741E:
                                                     #ifdef DEBUG
                                      mon("L741E    JSR   L761D                   ; 741E: BD 76 1D      \n");
                                      #endif // Display score
    PC = 0x741e; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x21); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    goto L761D;
  case 0x7421:
L7421:
                                                     #ifdef DEBUG
                                      mon("L7421    JSR   L76D3                   ; 7421: BD 76 D3      \n");
                                      #endif // Towers left to shoot count
    PC = 0x7421; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x24); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    goto L76D3;
  case 0x7424:
L7424:
                                                     #ifdef DEBUG
                                      mon("L7424    LDB   #$4F                    ; 7424: C6 4F         \n");
                                      #endif
    PC = 0x7424; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x4f; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $E7C7                   ; 7426: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x29); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    PC = 0xe7c7; 
    JUMP;
  case 0x7429:
L7429:
                                                     #ifdef DEBUG
                                      mon("L7429    JSR   $95A7                   ; 7429: BD 95 A7      \n");
                                      #endif // Insert vector instructions for shields
    PC = 0x7429; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x2c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    PC = 0x95a7; 
    JUMP;
  case 0x742C:
L742C:
                                                     #ifdef DEBUG
                                      mon("L742C    JSR   $B6B9                   ; 742C: BD B6 B9      \n");
                                      #endif // Insert vector instructions at joystick position for laser explosion 2
    PC = 0x742c; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x2f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    PC = 0xb6b9; 
    JUMP;
  case 0x742F:
L742F:
                                                     #ifdef DEBUG
                                      mon("L742F    JSR   $859B                   ; 742F: BD 85 9B      \n");
                                      #endif
    PC = 0x742f; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x32); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    PC = 0x859b; 
    JUMP;
  case 0x7432:
L7432:
                                                     #ifdef DEBUG
                                      mon("L7432    JSR   $BA12                   ; 7432: BD BA 12      \n");
                                      #endif // Process tie/tower/bunker explosions
    PC = 0x7432; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x35); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    PC = 0xba12; 
    JUMP;
  case 0x7435:
L7435:
                                                     #ifdef DEBUG
                                      mon("L7435    JSR   $98B0                   ; 7435: BD 98 B0      \n");
                                      #endif // Insert vector laser explosion small circle
    PC = 0x7435; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x38); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    PC = 0x98b0; 
    JUMP;
  case 0x7438:
L7438:
                                                     #ifdef DEBUG
                                      mon("L7438    JSR   L612F                   ; 7438: BD 61 2F      \n");
                                      #endif // Vector instructions end
    PC = 0x7438; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x3b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    goto L612F;
    // End of function sub_7413
  case 0x743B:
L743B:
                                                     #ifdef DEBUG
                                      mon("L743B    RTS                           ; 743B: 39            \n");
                                      #endif
    PC = 0x743b; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x743C:
L743C:
                                                     #ifdef DEBUG
                                      mon("L743C    JSR   L6112                   ; 743C: BD 61 12      \n");
                                      #endif // Insert vector data for four blue dots in screen corners
    PC = 0x743c; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x3f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    goto L6112;
  case 0x743F:
L743F:
                                                     #ifdef DEBUG
                                      mon("L743F    LDA   #$10                    ; 743F: 86 10         \n");
                                      #endif // BIC points to Matrix 4
    PC = 0x743f; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x10; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $CE0C                   ; 7441: BD CE 0C      \n");
                                      #endif // Copy transform data from [BIC] to matrix 2
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x44); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    PC = 0xce0c; 
    JUMP;
  case 0x7444:
L7444:
                                                     #ifdef DEBUG
                                      mon("L7444    JSR   L7160                   ; 7444: BD 71 60      \n");
                                      #endif // Update Roll, Pitch and Yaw for [A, B, C][x, y, z] 2
    PC = 0x7444; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x47); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    goto L7160;
  case 0x7447:
L7447:
                                                     #ifdef DEBUG
                                      mon("L7447    JSR   L761D                   ; 7447: BD 76 1D      \n");
                                      #endif // Display score
    PC = 0x7447; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x4a); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    goto L761D;
  case 0x744A:
L744A:
                                                     #ifdef DEBUG
                                      mon("L744A    LDA   $4B0E                   ; 744A: B6 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    PC = 0x744a; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b0e); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$04                    ; 744D: 81 04         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x04; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BHI   L7464                   ; 744F: 22 13         \n");
                                      #endif
    // temp hack to force a flush
    if (Z && (!C)) {
    clockticks = clockticks + 3; 
    goto L7464;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   <$98                    ; 7451: 96 98         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x98); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L745A                   ; 7453: 26 05         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L745A;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   L76D3                   ; 7455: BD 76 D3      \n");
                                      #endif // Towers left to shoot count
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x58); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    goto L76D3;
  case 0x7458:
L7458:
                                                     #ifdef DEBUG
                                      mon("L7458    BRA   L7464                   ; 7458: 20 0A         \n");
                                      #endif
    PC = 0x7458; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto L7464;
    
    // ---------------------------------------------------------------------------
  case 0x745A:
L745A:
                                                     #ifdef DEBUG
                                      mon("L745A    LDD   #$7100                  ; 745A: CC 71 00      \n");
                                      #endif
    PC = 0x745a; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x71; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 745D: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$46                    ; 745F: C6 46         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x46; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $E7C7                   ; 7461: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x64); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    PC = 0xe7c7; 
    JUMP;
  case 0x7464:
L7464:
                                                     #ifdef DEBUG
                                      mon("L7464    LDA   $4B2D                   ; 7464: B6 4B 2D      \n");
                                      #endif
    PC = 0x7464; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b2d); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L7491                   ; 7467: 26 28         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L7491;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B0E                   ; 7469: B6 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b0e); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$08                    ; 746C: 81 08         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x08; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BHI   L7491                   ; 746E: 22 21         \n");
                                      #endif
    // temp hack to force a flush
    if (Z && (!C)) {
    clockticks = clockticks + 3; 
    goto L7491;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   <$98                    ; 7470: 96 98         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x98); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L7491                   ; 7472: 26 1D         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L7491;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B35                   ; 7474: B6 4B 35      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b35); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L7491                   ; 7477: 26 18         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L7491;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B12                   ; 7479: B6 4B 12      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b12); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L7482                   ; 747C: 26 04         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L7482;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   #$4C                    ; 747E: C6 4C         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x4c; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   L748E                   ; 7480: 20 0C         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L748E;
    
    // ---------------------------------------------------------------------------
  case 0x7482:
L7482:
                                                     #ifdef DEBUG
                                      mon("L7482    LDA   <$43                    ; 7482: 96 43         \n");
                                      #endif // "Game over/insert coins timer", Game over/insert coins timer
    PC = 0x7482; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x43); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$10                    ; 7484: 84 10         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x10; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
  case 0x7486:
L7486:
                                                     #ifdef DEBUG
                                      mon("L7486    BNE   L748C                   ; 7486: 26 04         \n");
                                      #endif
    PC = 0x7486; 
    INSTRUCTION_START
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L748C;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   #$4C                    ; 7488: C6 4C         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x4c; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
  case 0x748A:
L748A:
                                                     #ifdef DEBUG
                                      mon("L748A    BRA   L748E                   ; 748A: 20 02         \n");
                                      #endif
    PC = 0x748a; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto L748E;
    
    // ---------------------------------------------------------------------------
  case 0x748C:
L748C:
                                                     #ifdef DEBUG
                                      mon("L748C    LDB   #$4E                    ; 748C: C6 4E         \n");
                                      #endif
    PC = 0x748c; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x4e; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
  case 0x748E:
L748E:
                                                     #ifdef DEBUG
                                      mon("L748E    JSR   $E7C7                   ; 748E: BD E7 C7      \n");
                                      #endif // "Print text string from pointer table", Print text string from pointer table
    PC = 0x748e; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x91); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    PC = 0xe7c7; 
    JUMP;
  case 0x7491:
L7491:
                                                     #ifdef DEBUG
                                      mon("L7491    LDA   $4B2D                   ; 7491: B6 4B 2D      \n");
                                      #endif
    PC = 0x7491; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b2d); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L74A5                   ; 7494: 26 0F         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L74A5;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4895                   ; 7496: B6 48 95      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4895); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L74A5                   ; 7499: 27 0A         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L74A5;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$7100                  ; 749B: CC 71 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x71; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 749E: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$44                    ; 74A0: C6 44         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x44; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $E7C7                   ; 74A2: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xa5); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    PC = 0xe7c7; 
    JUMP;
  case 0x74A5:
L74A5:
                                                     #ifdef DEBUG
                                      mon("L74A5    LDA   $4B36                   ; 74A5: B6 4B 36      \n");
                                      #endif
    PC = 0x74a5; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b36); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BLT   L74B6                   ; 74A8: 2D 0C         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 3; 
    goto L74B6;
    }
                                                     #ifdef DEBUG
                                      mon("         BNE   L74B3                   ; 74AA: 26 07         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L74B3;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   #$4F                    ; 74AC: C6 4F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x4f; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $E7C7                   ; 74AE: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xb1); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    PC = 0xe7c7; 
    JUMP;
  case 0x74B1:
L74B1:
                                                     #ifdef DEBUG
                                      mon("L74B1    BRA   L74B6                   ; 74B1: 20 03         \n");
                                      #endif
    PC = 0x74b1; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto L74B6;
    
    // ---------------------------------------------------------------------------
  case 0x74B3:
L74B3:
                                                     #ifdef DEBUG
                                      mon("L74B3    JSR   $97C2                   ; 74B3: BD 97 C2      \n");
                                      #endif
    PC = 0x74b3; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xb6); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    PC = 0x97c2; 
    JUMP;
  case 0x74B6:
L74B6:
                                                     #ifdef DEBUG
                                      mon("L74B6    JSR   $95A7                   ; 74B6: BD 95 A7      \n");
                                      #endif // "Insert vector instructions for shields", Insert vector instructions for shields
    PC = 0x74b6; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xb9); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    PC = 0x95a7; 
    JUMP;
  case 0x74B9:
L74B9:
                                                     #ifdef DEBUG
                                      mon("L74B9    JSR   $B6B9                   ; 74B9: BD B6 B9      \n");
                                      #endif // Insert vector instructions at joystick position for laser explosion 2
    PC = 0x74b9; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xbc); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    PC = 0xb6b9; 
    JUMP;
  case 0x74BC:
L74BC:
                                                     #ifdef DEBUG
                                      mon("L74BC    JSR   $859B                   ; 74BC: BD 85 9B      \n");
                                      #endif
    PC = 0x74bc; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xbf); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    PC = 0x859b; 
    JUMP;
  case 0x74BF:
L74BF:
                                                     #ifdef DEBUG
                                      mon("L74BF    JSR   $AE60                   ; 74BF: BD AE 60      \n");
                                      #endif
    PC = 0x74bf; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xc2); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    PC = 0xae60; 
    JUMP;
  case 0x74C2:
L74C2:
                                                     #ifdef DEBUG
                                      mon("L74C2    JSR   $AAE4                   ; 74C2: BD AA E4      \n");
                                      #endif // Fireball processing
    PC = 0x74c2; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xc5); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    PC = 0xaae4; 
    JUMP;
  case 0x74C5:
L74C5:
                                                     #ifdef DEBUG
                                      mon("L74C5    JSR   $B071                   ; 74C5: BD B0 71      \n");
                                      #endif
    PC = 0x74c5; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xc8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    PC = 0xb071; 
    JUMP;
  case 0x74C8:
L74C8:
                                                     #ifdef DEBUG
                                      mon("L74C8    JSR   $AEBD                   ; 74C8: BD AE BD      \n");
                                      #endif
    PC = 0x74c8; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xcb); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    PC = 0xaebd; 
    JUMP;
  case 0x74CB:
L74CB:
                                                     #ifdef DEBUG
                                      mon("L74CB    JSR   $ADAF                   ; 74CB: BD AD AF      \n");
                                      #endif
    PC = 0x74cb; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xce); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    PC = 0xadaf; 
    JUMP;
  case 0x74CE:
L74CE:
                                                     #ifdef DEBUG
                                      mon("L74CE    JSR   $98B0                   ; 74CE: BD 98 B0      \n");
                                      #endif // Insert vector laser explosion small circle
    PC = 0x74ce; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xd1); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    PC = 0x98b0; 
    JUMP;
  case 0x74D1:
L74D1:
                                                     #ifdef DEBUG
                                      mon("L74D1    JSR   L612F                   ; 74D1: BD 61 2F      \n");
                                      #endif // Vector instructions end
    PC = 0x74d1; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xd4); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    goto L612F;
    // End of function sub_743C
  case 0x74D4:
L74D4:
                                                     #ifdef DEBUG
                                      mon("L74D4    RTS                           ; 74D4: 39            \n");
                                      #endif
    PC = 0x74d4; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Game over
  case 0x74D5:
L74D5:
                                                     #ifdef DEBUG
                                      mon("L74D5    JSR   L6112                   ; 74D5: BD 61 12      \n");
                                      #endif // Insert vector data for four blue dots in screen corners
    PC = 0x74d5; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xd8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    goto L6112;
  case 0x74D8:
L74D8:
                                                     #ifdef DEBUG
                                      mon("L74D8    LDA   #$10                    ; 74D8: 86 10         \n");
                                      #endif // BIC points to Matrix 4
    PC = 0x74d8; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x10; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $CE0C                   ; 74DA: BD CE 0C      \n");
                                      #endif // Copy transform data from [BIC] to matrix 2
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xdd); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    PC = 0xce0c; 
    JUMP;
  case 0x74DD:
L74DD:
                                                     #ifdef DEBUG
                                      mon("L74DD    JSR   L7160                   ; 74DD: BD 71 60      \n");
                                      #endif // Update Roll, Pitch and Yaw for [A, B, C][x, y, z] 2
    PC = 0x74dd; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xe0); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    goto L7160;
  case 0x74E0:
L74E0:
                                                     #ifdef DEBUG
                                      mon("L74E0    JSR   L761D                   ; 74E0: BD 76 1D      \n");
                                      #endif // Display score
    PC = 0x74e0; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xe3); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    goto L761D;
  case 0x74E3:
L74E3:
                                                     #ifdef DEBUG
                                      mon("L74E3    LDA   $4B3E                   ; 74E3: B6 4B 3E      \n");
                                      #endif
    PC = 0x74e3; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b3e); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L74F2                   ; 74E6: 27 0A         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L74F2;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$7100                  ; 74E8: CC 71 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x71; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 74EB: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$46                    ; 74ED: C6 46         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x46; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $E7C7                   ; 74EF: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf2); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    PC = 0xe7c7; 
    JUMP;
  case 0x74F2:
L74F2:
                                                     #ifdef DEBUG
                                      mon("L74F2    JSR   $95A7                   ; 74F2: BD 95 A7      \n");
                                      #endif // "Insert vector instructions for shields", Insert vector instructions for shields
    PC = 0x74f2; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf5); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    PC = 0x95a7; 
    JUMP;
  case 0x74F5:
L74F5:
                                                     #ifdef DEBUG
                                      mon("L74F5    JSR   $859B                   ; 74F5: BD 85 9B      \n");
                                      #endif
    PC = 0x74f5; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    PC = 0x859b; 
    JUMP;
  case 0x74F8:
L74F8:
                                                     #ifdef DEBUG
                                      mon("L74F8    JSR   $AAE4                   ; 74F8: BD AA E4      \n");
                                      #endif // Fireball processing
    PC = 0x74f8; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xfb); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x74); 
    clockticks = clockticks + 1; 
    PC = 0xaae4; 
    JUMP;
  case 0x74FB:
L74FB:
                                                     #ifdef DEBUG
                                      mon("L74FB    LDA   $4B2D                   ; 74FB: B6 4B 2D      \n");
                                      #endif
    PC = 0x74fb; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b2d); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L750F                   ; 74FE: 26 0F         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L750F;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4895                   ; 7500: B6 48 95      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4895); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L750F                   ; 7503: 27 0A         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L750F;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$7100                  ; 7505: CC 71 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x71; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 7508: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$44                    ; 750A: C6 44         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x44; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $E7C7                   ; 750C: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x0f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x75); 
    clockticks = clockticks + 1; 
    PC = 0xe7c7; 
    JUMP;
  case 0x750F:
L750F:
                                                     #ifdef DEBUG
                                      mon("L750F    JSR   L7707                   ; 750F: BD 77 07      \n");
                                      #endif // "Game Over text handling", Game Over text handling
    PC = 0x750f; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x12); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x75); 
    clockticks = clockticks + 1; 
    goto L7707;
  case 0x7512:
L7512:
                                                     #ifdef DEBUG
                                      mon("L7512    JSR   $98B0                   ; 7512: BD 98 B0      \n");
                                      #endif // Insert vector laser explosion small circle
    PC = 0x7512; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x15); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x75); 
    clockticks = clockticks + 1; 
    PC = 0x98b0; 
    JUMP;
  case 0x7515:
L7515:
                                                     #ifdef DEBUG
                                      mon("L7515    JSR   L612F                   ; 7515: BD 61 2F      \n");
                                      #endif // Vector instructions end
    PC = 0x7515; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x18); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x75); 
    clockticks = clockticks + 1; 
    goto L612F;
    // End of function sub_74D5
  case 0x7518:
L7518:
                                                     #ifdef DEBUG
                                      mon("L7518    RTS                           ; 7518: 39            \n");
                                      #endif
    PC = 0x7518; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x7519:
L7519:
                                                     #ifdef DEBUG
                                      mon("L7519    JSR   L6112                   ; 7519: BD 61 12      \n");
                                      #endif // Insert vector data for four blue dots in screen corners
    PC = 0x7519; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x1c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x75); 
    clockticks = clockticks + 1; 
    goto L6112;
  case 0x751C:
L751C:
                                                     #ifdef DEBUG
                                      mon("L751C    LDA   #$10                    ; 751C: 86 10         \n");
                                      #endif // BIC points to Matrix 4
    PC = 0x751c; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x10; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $CE0C                   ; 751E: BD CE 0C      \n");
                                      #endif // Copy transform data from [BIC] to matrix 2
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x21); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x75); 
    clockticks = clockticks + 1; 
    PC = 0xce0c; 
    JUMP;
  case 0x7521:
L7521:
                                                     #ifdef DEBUG
                                      mon("L7521    JSR   L7160                   ; 7521: BD 71 60      \n");
                                      #endif // Update Roll, Pitch and Yaw for [A, B, C][x, y, z] 2
    PC = 0x7521; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x24); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x75); 
    clockticks = clockticks + 1; 
    goto L7160;
  case 0x7524:
L7524:
                                                     #ifdef DEBUG
                                      mon("L7524    JSR   L761D                   ; 7524: BD 76 1D      \n");
                                      #endif // Display score
    PC = 0x7524; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x27); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x75); 
    clockticks = clockticks + 1; 
    goto L761D;
  case 0x7527:
L7527:
                                                     #ifdef DEBUG
                                      mon("L7527    JSR   $95A7                   ; 7527: BD 95 A7      \n");
                                      #endif // Insert vector instructions for shields
    PC = 0x7527; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x2a); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x75); 
    clockticks = clockticks + 1; 
    PC = 0x95a7; 
    JUMP;
  case 0x752A:
L752A:
                                                     #ifdef DEBUG
                                      mon("L752A    JSR   $B6B9                   ; 752A: BD B6 B9      \n");
                                      #endif // Insert vector instructions at joystick position for laser explosion 2
    PC = 0x752a; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x2d); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x75); 
    clockticks = clockticks + 1; 
    PC = 0xb6b9; 
    JUMP;
  case 0x752D:
L752D:
                                                     #ifdef DEBUG
                                      mon("L752D    JSR   $CD80                   ; 752D: BD CD 80      \n");
                                      #endif // Starfield
    PC = 0x752d; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x30); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x75); 
    clockticks = clockticks + 1; 
    PC = 0xcd80; 
    JUMP;
  case 0x7530:
L7530:
                                                     #ifdef DEBUG
                                      mon("L7530    LDB   #$45                    ; 7530: C6 45         \n");
                                      #endif
    PC = 0x7530; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x45; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $E7C7                   ; 7532: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x35); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x75); 
    clockticks = clockticks + 1; 
    PC = 0xe7c7; 
    JUMP;
  case 0x7535:
L7535:
                                                     #ifdef DEBUG
                                      mon("L7535    LDA   $4B0E                   ; 7535: B6 4B 0E      \n");
                                      #endif // Attract screen/game phase  timer
    PC = 0x7535; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b0e); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$02                    ; 7538: 81 02         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x02; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BGT   L755A                   ; 753A: 2E 1E         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto L755A;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   #$47                    ; 753C: C6 47         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x47; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $E7C7                   ; 753E: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x41); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x75); 
    clockticks = clockticks + 1; 
    PC = 0xe7c7; 
    JUMP;
  case 0x7541:
L7541:
                                                     #ifdef DEBUG
                                      mon("L7541    LDB   #$48                    ; 7541: C6 48         \n");
                                      #endif
    PC = 0x7541; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x48; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $E7C7                   ; 7543: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x46); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x75); 
    clockticks = clockticks + 1; 
    PC = 0xe7c7; 
    JUMP;
  case 0x7546:
L7546:
                                                     #ifdef DEBUG
                                      mon("L7546    LDD   #$90                    ; 7546: CC 00 90      \n");
                                      #endif
    PC = 0x7546; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x90; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 7549: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$70                    ; 754B: CC 00 70      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x70; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 754E: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   <$8E                    ; 7550: 96 8E         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x8e); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $E7AD                   ; 7552: BD E7 AD      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x55); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x75); 
    clockticks = clockticks + 1; 
    PC = 0xe7ad; 
    JUMP;
  case 0x7555:
L7555:
                                                     #ifdef DEBUG
                                      mon("L7555    LDD   #$8040                  ; 7555: CC 80 40      \n");
                                      #endif
    PC = 0x7555; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 7558: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
  case 0x755A:
L755A:
                                                     #ifdef DEBUG
                                      mon("L755A    LDA   $4B0E                   ; 755A: B6 4B 0E      \n");
                                      #endif // "Attract screen/game phase  timer", Attract screen/game phase  timer
    PC = 0x755a; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b0e); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$01                    ; 755D: 81 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x01; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BGT   L759C                   ; 755F: 2E 3B         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto L759C;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4845                   ; 7561: B6 48 45      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4845); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L759C                   ; 7564: 27 36         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L759C;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4592                   ; 7566: B6 45 92      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4592); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$03                    ; 7569: 84 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x03; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L759C                   ; 756B: 27 2F         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L759C;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   $4593                   ; 756D: F6 45 93      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4593); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$03                    ; 7570: C4 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x03; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDB  #$06                    ; 7572: CB 06         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x06; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         CMPB  <$60                    ; 7574: D1 60         \n");
                                      #endif // Shield count
    clockticks = clockticks + 4; 
    val = (UINT8)B; 
    arg = rd_mem(DP|0x60); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BHI   L757C                   ; 7576: 22 04         \n");
                                      #endif
    // temp hack to force a flush
    if (Z && (!C)) {
    clockticks = clockticks + 3; 
    goto L757C;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   #$4A                    ; 7578: C6 4A         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x4a; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   L7599                   ; 757A: 20 1D         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L7599;
    
    // ---------------------------------------------------------------------------
  case 0x757C:
L757C:
                                                     #ifdef DEBUG
                                      mon("L757C    LDU   #$A01A                  ; 757C: CE A0 1A      \n");
                                      #endif
    PC = 0x757c; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0xa01a; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STU   ,Y++                    ; 757F: EF A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #$48                    ; 7581: CE 00 48      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x0048; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STU   ,Y++                    ; 7584: EF A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #$1EC0                  ; 7586: CE 1E C0      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0x1ec0; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STU   ,Y++                    ; 7589: EF A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    val = U; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$01                    ; 758B: C6 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x01; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STB   <$AD                    ; 758D: D7 AD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = B; 
    Z = val; 
    N = val; 
    V = 0; 
    ea = DP|0xad; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   $E7AD                   ; 758F: BD E7 AD      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x92); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x75); 
    clockticks = clockticks + 1; 
    PC = 0xe7ad; 
    JUMP;
  case 0x7592:
L7592:
                                                     #ifdef DEBUG
                                      mon("L7592    LDD   #$8040                  ; 7592: CC 80 40      \n");
                                      #endif
    PC = 0x7592; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 7595: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$49                    ; 7597: C6 49         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x49; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
  case 0x7599:
L7599:
                                                     #ifdef DEBUG
                                      mon("L7599    JSR   $E7C7                   ; 7599: BD E7 C7      \n");
                                      #endif // "Print text string from pointer table", Print text string from pointer table
    PC = 0x7599; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x9c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x75); 
    clockticks = clockticks + 1; 
    PC = 0xe7c7; 
    JUMP;
  case 0x759C:
L759C:
                                                     #ifdef DEBUG
                                      mon("L759C    LDA   $4B0E                   ; 759C: B6 4B 0E      \n");
                                      #endif // "Attract screen/game phase  timer", Attract screen/game phase  timer
    PC = 0x759c; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b0e); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$00                    ; 759F: 81 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x00; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BGT   L75B2                   ; 75A1: 2E 0F         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto L75B2;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B2D                   ; 75A3: B6 4B 2D      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b2d); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L75B2                   ; 75A6: 26 0A         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L75B2;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   $4B15                   ; 75A8: F6 4B 15      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b15); 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L75B2                   ; 75AB: 27 05         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L75B2;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   #$4B                    ; 75AD: C6 4B         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x4b; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $E7C7                   ; 75AF: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xb2); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x75); 
    clockticks = clockticks + 1; 
    PC = 0xe7c7; 
    JUMP;
  case 0x75B2:
L75B2:
                                                     #ifdef DEBUG
                                      mon("L75B2    JSR   $98B0                   ; 75B2: BD 98 B0      \n");
                                      #endif // "Insert vector laser explosion small circle", Insert vector laser explosion small circle
    PC = 0x75b2; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xb5); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x75); 
    clockticks = clockticks + 1; 
    PC = 0x98b0; 
    JUMP;
  case 0x75B5:
L75B5:
                                                     #ifdef DEBUG
                                      mon("L75B5    JSR   L612F                   ; 75B5: BD 61 2F      \n");
                                      #endif // Vector instructions end
    PC = 0x75b5; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xb8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x75); 
    clockticks = clockticks + 1; 
    goto L612F;
    // End of function sub_7519
  case 0x75B8:
L75B8:
                                                     #ifdef DEBUG
                                      mon("L75B8    RTS                           ; 75B8: 39            \n");
                                      #endif
    PC = 0x75b8; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x75B9:
L75B9:
                                                     #ifdef DEBUG
                                      mon("L75B9    JSR   L6112                   ; 75B9: BD 61 12      \n");
                                      #endif // Insert vector data for four blue dots in screen corners
    PC = 0x75b9; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xbc); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x75); 
    clockticks = clockticks + 1; 
    goto L6112;
  case 0x75BC:
L75BC:
                                                     #ifdef DEBUG
                                      mon("L75BC    LDA   #$10                    ; 75BC: 86 10         \n");
                                      #endif // BIC points to Matrix 4
    PC = 0x75bc; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x10; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $CE0C                   ; 75BE: BD CE 0C      \n");
                                      #endif // Copy transform data from [BIC] to matrix 2
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xc1); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x75); 
    clockticks = clockticks + 1; 
    PC = 0xce0c; 
    JUMP;
  case 0x75C1:
L75C1:
                                                     #ifdef DEBUG
                                      mon("L75C1    JSR   L761D                   ; 75C1: BD 76 1D      \n");
                                      #endif // Display score
    PC = 0x75c1; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xc4); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x75); 
    clockticks = clockticks + 1; 
    goto L761D;
  case 0x75C4:
L75C4:
                                                     #ifdef DEBUG
                                      mon("L75C4    LDA   $4B36                   ; 75C4: B6 4B 36      \n");
                                      #endif
    PC = 0x75c4; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b36); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BLE   L75CC                   ; 75C7: 2F 03         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto L75CC;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   $97C2                   ; 75C9: BD 97 C2      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xcc); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x75); 
    clockticks = clockticks + 1; 
    PC = 0x97c2; 
    JUMP;
  case 0x75CC:
L75CC:
                                                     #ifdef DEBUG
                                      mon("L75CC    JSR   $95A7                   ; 75CC: BD 95 A7      \n");
                                      #endif // "Insert vector instructions for shields", Insert vector instructions for shields
    PC = 0x75cc; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xcf); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x75); 
    clockticks = clockticks + 1; 
    PC = 0x95a7; 
    JUMP;
  case 0x75CF:
L75CF:
                                                     #ifdef DEBUG
                                      mon("L75CF    JSR   $B6B9                   ; 75CF: BD B6 B9      \n");
                                      #endif // Insert vector instructions at joystick position for laser explosion 2
    PC = 0x75cf; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xd2); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x75); 
    clockticks = clockticks + 1; 
    PC = 0xb6b9; 
    JUMP;
  case 0x75D2:
L75D2:
                                                     #ifdef DEBUG
                                      mon("L75D2    JSR   L77A4                   ; 75D2: BD 77 A4      \n");
                                      #endif
    PC = 0x75d2; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xd5); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x75); 
    clockticks = clockticks + 1; 
    goto L77A4;
  case 0x75D5:
L75D5:
                                                     #ifdef DEBUG
                                      mon("L75D5    JSR   L612F                   ; 75D5: BD 61 2F      \n");
                                      #endif // Vector instructions end
    PC = 0x75d5; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xd8); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x75); 
    clockticks = clockticks + 1; 
    goto L612F;
    // End of function sub_75B9
  case 0x75D8:
L75D8:
                                                     #ifdef DEBUG
                                      mon("L75D8    RTS                           ; 75D8: 39            \n");
                                      #endif
    PC = 0x75d8; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Space wave
  case 0x75D9:
L75D9:
                                                     #ifdef DEBUG
                                      mon("L75D9    JSR   L6112                   ; 75D9: BD 61 12      \n");
                                      #endif // Insert vector data for four blue dots in screen corners
    PC = 0x75d9; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xdc); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x75); 
    clockticks = clockticks + 1; 
    goto L6112;
  case 0x75DC:
L75DC:
                                                     #ifdef DEBUG
                                      mon("L75DC    LDA   #$10                    ; 75DC: 86 10         \n");
                                      #endif // BIC points to Matrix 4
    PC = 0x75dc; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x10; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $CE0C                   ; 75DE: BD CE 0C      \n");
                                      #endif // Copy transform data from [BIC] to matrix 2
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xe1); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x75); 
    clockticks = clockticks + 1; 
    PC = 0xce0c; 
    JUMP;
  case 0x75E1:
L75E1:
                                                     #ifdef DEBUG
                                      mon("L75E1    JSR   L761D                   ; 75E1: BD 76 1D      \n");
                                      #endif // Display score
    PC = 0x75e1; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xe4); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x75); 
    clockticks = clockticks + 1; 
    goto L761D;
  case 0x75E4:
L75E4:
                                                     #ifdef DEBUG
                                      mon("L75E4    JSR   $95A7                   ; 75E4: BD 95 A7      \n");
                                      #endif // Insert vector instructions for shields
    PC = 0x75e4; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xe7); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x75); 
    clockticks = clockticks + 1; 
    PC = 0x95a7; 
    JUMP;
  case 0x75E7:
L75E7:
                                                     #ifdef DEBUG
                                      mon("L75E7    JSR   $B6B9                   ; 75E7: BD B6 B9      \n");
                                      #endif // Insert vector instructions at joystick position for laser explosion 2
    PC = 0x75e7; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xea); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x75); 
    clockticks = clockticks + 1; 
    PC = 0xb6b9; 
    JUMP;
  case 0x75EA:
L75EA:
                                                     #ifdef DEBUG
                                      mon("L75EA    LDD   #$1F98                  ; 75EA: CC 1F 98      \n");
                                      #endif
    PC = 0x75ea; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x1f; 
    B = 0x98; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 75ED: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; 75EF: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 75F2: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$7200                  ; 75F4: CC 72 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x72; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 75F7: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$BE50                  ; 75F9: CC BE 50      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0xbe; 
    B = 0x50; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 75FC: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$7200                  ; 75FE: CC 72 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x72; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 7601: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $BB85                   ; 7603: BD BB 85      \n");
                                      #endif // Death Star explosion animation
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x06); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x76); 
    clockticks = clockticks + 1; 
    PC = 0xbb85; 
    JUMP;
  case 0x7606:
L7606:
                                                     #ifdef DEBUG
                                      mon("L7606    JSR   L612F                   ; 7606: BD 61 2F      \n");
                                      #endif // Vector instructions end
    PC = 0x7606; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x09); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x76); 
    clockticks = clockticks + 1; 
    goto L612F;
    // End of function sub_75D9
  case 0x7609:
L7609:
                                                     #ifdef DEBUG
                                      mon("L7609    RTS                           ; 7609: 39            \n");
                                      #endif
    PC = 0x7609; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Death Star explosion
  case 0x760A:
L760A:
                                                     #ifdef DEBUG
                                      mon("L760A    JSR   L6112                   ; 760A: BD 61 12      \n");
                                      #endif // Insert vector data for four blue dots in screen corners
    PC = 0x760a; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x0d); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x76); 
    clockticks = clockticks + 1; 
    goto L6112;
  case 0x760D:
L760D:
                                                     #ifdef DEBUG
                                      mon("L760D    JSR   L761D                   ; 760D: BD 76 1D      \n");
                                      #endif // Display score
    PC = 0x760d; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x10); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x76); 
    clockticks = clockticks + 1; 
    goto L761D;
  case 0x7610:
L7610:
                                                     #ifdef DEBUG
                                      mon("L7610    JSR   $95A7                   ; 7610: BD 95 A7      \n");
                                      #endif // Insert vector instructions for shields
    PC = 0x7610; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x13); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x76); 
    clockticks = clockticks + 1; 
    PC = 0x95a7; 
    JUMP;
  case 0x7613:
L7613:
                                                     #ifdef DEBUG
                                      mon("L7613    JSR   $B6B9                   ; 7613: BD B6 B9      \n");
                                      #endif // Insert vector instructions at joystick position for laser explosion 2
    PC = 0x7613; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x16); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x76); 
    clockticks = clockticks + 1; 
    PC = 0xb6b9; 
    JUMP;
  case 0x7616:
L7616:
                                                     #ifdef DEBUG
                                      mon("L7616    JSR   $BB85                   ; 7616: BD BB 85      \n");
                                      #endif // Death Star explosion animation
    PC = 0x7616; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x19); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x76); 
    clockticks = clockticks + 1; 
    PC = 0xbb85; 
    JUMP;
  case 0x7619:
L7619:
                                                     #ifdef DEBUG
                                      mon("L7619    JSR   L612F                   ; 7619: BD 61 2F      \n");
                                      #endif // Vector instructions end
    PC = 0x7619; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x1c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x76); 
    clockticks = clockticks + 1; 
    goto L612F;
    // End of function sub_760A
  case 0x761C:
L761C:
                                                     #ifdef DEBUG
                                      mon("L761C    RTS                           ; 761C: 39            \n");
                                      #endif
    PC = 0x761c; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Display score
  case 0x761D:
L761D:
                                                     #ifdef DEBUG
                                      mon("L761D    LDD   #$B9F2                  ; 761D: CC B9 F2      \n");
                                      #endif
    PC = 0x761d; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0xb9; 
    B = 0xf2; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 7620: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$6280                  ; 7622: CC 62 80      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x62; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 7625: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$01E0                  ; 7627: CC 01 E0      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x01; 
    B = 0xe0; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0x762A:
L762A:
                                                     #ifdef DEBUG
                                      mon("L762A    STD   ,Y++                    ; 762A: ED A1         \n");
                                      #endif
    PC = 0x762a; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
  case 0x762C:
L762C:
                                                     #ifdef DEBUG
                                      mon("L762C    LDD   #$1E20                  ; 762C: CC 1E 20      \n");
                                      #endif
    PC = 0x762c; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x1e; 
    B = 0x20; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 762F: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$06                    ; 7631: 86 06         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x06; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$AD                    ; 7633: 97 AD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xad; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$485C                  ; 7635: 8E 48 5C      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x485c; 
    Z = X; 
    N = (X) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $E764                   ; 7638: BD E7 64      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x3b); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x76); 
    clockticks = clockticks + 1; 
    PC = 0xe764; 
    JUMP;
  case 0x763B:
L763B:
                                                     #ifdef DEBUG
                                      mon("L763B    LDD   #$8040                  ; 763B: CC 80 40      \n");
                                      #endif
    PC = 0x763b; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 763E: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $4B2C                   ; 7640: F6 4B 2C      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b2c); 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L766E                   ; 7643: 27 29         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L766E;
    }
                                                     #ifdef DEBUG
                                      mon("         SUBB  #$08                    ; 7645: C0 08         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x08; 
    res = val - (UINT8)arg; 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    B = (UINT8)(res); 
                                                     #ifdef DEBUG
                                      mon("         CMPB  #$20                    ; 7647: C1 20         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x20; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BCC   L764D                   ; 7649: 24 02         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto L764D;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   #$00                    ; 764B: C6 00         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x00; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0x764D:
L764D:
                                                     #ifdef DEBUG
                                      mon("L764D    STB   $4B2C                   ; 764D: F7 4B 2C      \n");
                                      #endif
    PC = 0x764d; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4b2c, val); 
                                                     #ifdef DEBUG
                                      mon("         LSRB                          ; 7650: 54            \n");
                                      #endif
    val = (UINT8)B; 
    C = val & 1; 
    val = val >> 1; 
    B = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
  case 0x7651:
L7651:
                                                     #ifdef DEBUG
                                      mon("L7651    LDA   #$66                    ; 7651: 86 66         \n");
                                      #endif
    PC = 0x7651; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x66; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 7653: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$01B0                  ; 7655: CC 01 B0      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x01; 
    B = 0xb0; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 7658: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$1E50                  ; 765A: CC 1E 50      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x1e; 
    B = 0x50; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 765D: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$05                    ; 765F: 86 05         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x05; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$AD                    ; 7661: 97 AD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xad; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDX   #$4B28                  ; 7663: 8E 4B 28      \n");
                                      #endif
    clockticks = clockticks + 3; 
    X = 0x4b28; 
    Z = X; 
    N = (X) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $E772                   ; 7666: BD E7 72      \n");
                                      #endif // Display BCD number text
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x69); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x76); 
    clockticks = clockticks + 1; 
    PC = 0xe772; 
    JUMP;
  case 0x7669:
L7669:
                                                     #ifdef DEBUG
                                      mon("L7669    LDD   #$8040                  ; 7669: CC 80 40      \n");
                                      #endif
    PC = 0x7669; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 766C: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
  case 0x766E:
L766E:
                                                     #ifdef DEBUG
                                      mon("L766E    LDD   #$6280                  ; 766E: CC 62 80      \n");
                                      #endif
    PC = 0x766e; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x62; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 7671: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0210                  ; 7673: CC 02 10      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x02; 
    B = 0x10; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 7676: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0138                  ; 7678: CC 01 38      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x01; 
    B = 0x38; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 767B: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$01                    ; 767D: 86 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x01; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$AD                    ; 767F: 97 AD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xad; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B16                   ; 7681: B6 4B 16      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b16); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $E790                   ; 7684: BD E7 90      \n");
                                      #endif // Display BCD numbers
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x87); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x76); 
    clockticks = clockticks + 1; 
    PC = 0xe790; 
    JUMP;
  case 0x7687:
L7687:
                                                     #ifdef DEBUG
                                      mon("L7687    LDD   #$8040                  ; 7687: CC 80 40      \n");
                                      #endif
    PC = 0x7687; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 768A: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
    // End of function sub_761D
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 768C: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Display tower count and hit score
  case 0x768D:
L768D:
                                                     #ifdef DEBUG
                                      mon("L768D    LDA   $4B13                   ; 768D: B6 4B 13      \n");
                                      #endif // Display tower hit score
    PC = 0x768d; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b13); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BLE   L76FC                   ; 7690: 2F 6A         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto L76FC;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B1A                   ; 7692: B6 4B 1A      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b1a); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L76D3                   ; 7695: 27 3C         \n");
                                      #endif // Towers left to shoot count
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L76D3;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   <$43                    ; 7697: 96 43         \n");
                                      #endif // Game over/insert coins timer
    clockticks = clockticks + 4; 
    val = (UINT8)rd_mem(DP|0x43); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$30                    ; 7699: 84 30         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0x30; 
    A = res; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L76CE                   ; 769B: 27 31         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L76CE;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   #$40                    ; 769D: C6 40         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x40; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $E7C7                   ; 769F: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xa2); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x76); 
    clockticks = clockticks + 1; 
    PC = 0xe7c7; 
    JUMP;
  case 0x76A2:
L76A2:
                                                     #ifdef DEBUG
                                      mon("L76A2    LDD   #$6280                  ; 76A2: CC 62 80      \n");
                                      #endif // Vector STAT 2,80 instruction
    PC = 0x76a2; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x62; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 76A5: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0180                  ; 76A7: CC 01 80      \n");
                                      #endif // Vector draw to position
    clockticks = clockticks + 3; 
    A = 0x01; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 76AA: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$1ED0                  ; 76AC: CC 1E D0      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x1e; 
    B = 0xd0; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 76AF: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$04                    ; 76B1: 86 04         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x04; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$AD                    ; 76B3: 97 AD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xad; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B2E                   ; 76B5: B6 4B 2E      \n");
                                      #endif // Temporary score adder towers 1
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b2e); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $E790                   ; 76B8: BD E7 90      \n");
                                      #endif // Display BCD numbers
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xbb); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x76); 
    clockticks = clockticks + 1; 
    PC = 0xe790; 
    JUMP;
  case 0x76BB:
L76BB:
                                                     #ifdef DEBUG
                                      mon("L76BB    LDA   $4B2F                   ; 76BB: B6 4B 2F      \n");
                                      #endif // Temporary score adder towers 2
    PC = 0x76bb; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b2f); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $E790                   ; 76BE: BD E7 90      \n");
                                      #endif // Display BCD numbers
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xc1); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x76); 
    clockticks = clockticks + 1; 
    PC = 0xe790; 
    JUMP;
  case 0x76C1:
L76C1:
                                                     #ifdef DEBUG
                                      mon("L76C1    LDA   $4B30                   ; 76C1: B6 4B 30      \n");
                                      #endif // Temporary score adder towers 3
    PC = 0x76c1; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b30); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $E790                   ; 76C4: BD E7 90      \n");
                                      #endif // Display BCD numbers
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xc7); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x76); 
    clockticks = clockticks + 1; 
    PC = 0xe790; 
    JUMP;
  case 0x76C7:
L76C7:
                                                     #ifdef DEBUG
                                      mon("L76C7    LDD   #$8040                  ; 76C7: CC 80 40      \n");
                                      #endif // Vector CNTR instruction
    PC = 0x76c7; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 76CA: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         BRA   L76D3                   ; 76CC: 20 05         \n");
                                      #endif // Towers left to shoot count
    clockticks = clockticks + 3; 
    goto L76D3;
    
    // ---------------------------------------------------------------------------
  case 0x76CE:
L76CE:
                                                     #ifdef DEBUG
                                      mon("L76CE    LDB   #$43                    ; 76CE: C6 43         \n");
                                      #endif
    PC = 0x76ce; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x43; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
    // End of function sub_768D
                                                     #ifdef DEBUG
                                      mon("         JSR   $E7C7                   ; 76D0: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xd3); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x76); 
    clockticks = clockticks + 1; 
    PC = 0xe7c7; 
    JUMP;
    // =============== S U B R O U T I N E =======================================
    // Towers left to shoot count
  case 0x76D3:
L76D3:
                                                     #ifdef DEBUG
                                      mon("L76D3    LDA   $4B13                   ; 76D3: B6 4B 13      \n");
                                      #endif // Display towers left to shoot count
    PC = 0x76d3; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b13); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BLE   L76FC                   ; 76D6: 2F 24         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto L76FC;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$41                    ; 76D8: CC 00 41      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x41; 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $E7C7                   ; 76DB: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xde); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x76); 
    clockticks = clockticks + 1; 
    PC = 0xe7c7; 
    JUMP;
  case 0x76DE:
L76DE:
                                                     #ifdef DEBUG
                                      mon("L76DE    LDD   #$6280                  ; 76DE: CC 62 80      \n");
                                      #endif // Vector STAT 2,80 instruction
    PC = 0x76de; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x62; 
    B = 0x80; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 76E1: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0198                  ; 76E3: CC 01 98      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x01; 
    B = 0x98; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 76E6: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$0168                  ; 76E8: CC 01 68      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x01; 
    B = 0x68; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 76EB: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$01                    ; 76ED: 86 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x01; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$AD                    ; 76EF: 97 AD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xad; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B1A                   ; 76F1: B6 4B 1A      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b1a); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $E790                   ; 76F4: BD E7 90      \n");
                                      #endif // Display BCD numbers
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf7); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x76); 
    clockticks = clockticks + 1; 
    PC = 0xe790; 
    JUMP;
  case 0x76F7:
L76F7:
                                                     #ifdef DEBUG
                                      mon("L76F7    LDD   #$8040                  ; 76F7: CC 80 40      \n");
                                      #endif // Vector CNTR instruction
    PC = 0x76f7; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 76FA: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
  case 0x76FC:
L76FC:
                                                     #ifdef DEBUG
                                      mon("L76FC    LDA   $4B35                   ; 76FC: B6 4B 35      \n");
                                      #endif
    PC = 0x76fc; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b35); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   locret_7706             ; 76FF: 27 05         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L7706;
    }
                                                     #ifdef DEBUG
                                      mon("         LDB   #$42                    ; 7701: C6 42         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x42; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $E7C7                   ; 7703: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x06); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x77); 
    clockticks = clockticks + 1; 
    PC = 0xe7c7; 
    JUMP;
    // End of function sub_76D3
  case 0x7706:
L7706:
locret_7706:
                                                     #ifdef DEBUG
                                      mon("locret_7706 RTS                           ; 7706: 39            \n");
                                      #endif
    PC = 0x7706; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Game Over text handling
  case 0x7707:
L7707:
                                                     #ifdef DEBUG
                                      mon("L7707    LDA   $4B0F                   ; 7707: B6 4B 0F      \n");
                                      #endif // Attract screen/game phase  timer
    PC = 0x7707; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b0f); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$20                    ; 770A: 81 20         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x20; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BLS   L7710                   ; 770C: 23 02         \n");
                                      #endif
    // temp hack to force a flush
    if ((!Z) || C) {
    clockticks = clockticks + 3; 
    goto L7710;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$20                    ; 770E: 86 20         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x20; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
  case 0x7710:
L7710:
                                                     #ifdef DEBUG
                                      mon("L7710    LDB   #$06                    ; 7710: C6 06         \n");
                                      #endif
    PC = 0x7710; 
    INSTRUCTION_START
    clockticks = clockticks + 2; 
    val = (UINT8)0x06; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         MUL                           ; 7712: 3D            \n");
                                      #endif
    res = (UINT16)(A * B); 
 // Z = res; 
 // C = res & 0x80; 
    A = res >> 8; 
    B = (UINT8)res; 
    clockticks = clockticks + 11; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; 7713: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
 // C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ADDB  #$C0                    ; 7714: CB C0         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0xc0; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$70                    ; 7716: 86 70         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x70; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 7718: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$04                    ; 771A: C6 04         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x04; 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $E7C7                   ; 771C: BD E7 C7      \n");
                                      #endif // Print text string from pointer table
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x1f); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x77); 
    clockticks = clockticks + 1; 
    PC = 0xe7c7; 
    JUMP;
    // End of function sub_7707
  case 0x771F:
L771F:
                                                     #ifdef DEBUG
                                      mon("L771F    RTS                           ; 771F: 39            \n");
                                      #endif
    PC = 0x771f; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x7720:
L7720:
                                                     #ifdef DEBUG
                                      mon("L7720    STD   $4AD7                   ; 7720: FD 4A D7      \n");
                                      #endif
    PC = 0x7720; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4ad7, A); // Care needed with I/O space and word fetches
    wr_mem(0x4ad8, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$00                    ; 7723: CC 00 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4AD4                   ; 7726: FD 4A D4      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4ad4, A); // Care needed with I/O space and word fetches
    wr_mem(0x4ad5, B); 
                                                     #ifdef DEBUG
                                      mon("         STA   $4AD6                   ; 7729: B7 4A D6      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4ad6, val); 
  case 0x772C:
L772C:
                                                     #ifdef DEBUG
                                      mon("L772C    ASL   $4AD8                   ; 772C: 78 4A D8      \n");
                                      #endif
    PC = 0x772c; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4ad8); 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    wr_mem(0x4ad8, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ROL   $4AD7                   ; 772F: 79 4A D7      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4ad7); 
    res = (val << 1) + (C != 0 ?1:0); 
    C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)res ^ val; 
    wr_mem(0x4ad7, (UINT8)res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4AD6                   ; 7732: B6 4A D6      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4ad6); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADCA  $4AD6                   ; 7735: B9 4A D6      \n");
                                      #endif
    clockticks = clockticks + 5; 
    arg = A; 
    val = rd_mem(0x4ad6); 
    res = arg + val + (C != 0 ? 1:0); 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = arg ^ val ^ (UINT8)res ^ C; 
 // V = arg ^ val ^ (UINT8)res ^ C; 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         DAA                           ; 7738: 19            \n");
                                      #endif
    res = A; 
    msn = res & 0xf0; 
    lsn = res & 0x0f; 
    res = res + (((lsn > 0x09) || (H & 0x10)) ? 0x06 : 0); 
    res = res + ((((UINT8)msn > 0x80U) && ((UINT8)lsn > 0x09U)) || (((UINT8)msn > 0x90U) || (C != 0)) ? 0x60 : 0); 
    C = C | (res & 0x100); 
    res = (UINT8)res; 
    A = res; 
 // N = res; 
 // Z = res; 
 // V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4AD6                   ; 7739: B7 4A D6      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4ad6, val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4AD5                   ; 773C: B6 4A D5      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4ad5); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADCA  $4AD5                   ; 773F: B9 4A D5      \n");
                                      #endif
    clockticks = clockticks + 5; 
    arg = A; 
    val = rd_mem(0x4ad5); 
    res = arg + val + (C != 0 ? 1:0); 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = arg ^ val ^ (UINT8)res ^ C; 
 // V = arg ^ val ^ (UINT8)res ^ C; 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         DAA                           ; 7742: 19            \n");
                                      #endif
    res = A; 
    msn = res & 0xf0; 
    lsn = res & 0x0f; 
    res = res + (((lsn > 0x09) || (H & 0x10)) ? 0x06 : 0); 
    res = res + ((((UINT8)msn > 0x80U) && ((UINT8)lsn > 0x09U)) || (((UINT8)msn > 0x90U) || (C != 0)) ? 0x60 : 0); 
    C = C | (res & 0x100); 
    res = (UINT8)res; 
    A = res; 
 // N = res; 
 // Z = res; 
 // V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4AD5                   ; 7743: B7 4A D5      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4ad5, val); 
                                                     #ifdef DEBUG
                                      mon("         ROL   $4AD4                   ; 7746: 79 4A D4      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4ad4); 
    res = (val << 1) + (C != 0 ?1:0); 
    C = res & 0x100; 
 // Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)res ^ val; 
    wr_mem(0x4ad4, (UINT8)res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LEAX  -1,X                    ; 7749: 30 1F         \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + 0xffff); 
    Z = X; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L772C                   ; 774B: 26 DF         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L772C;
    }
    // End of function sub_7720
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 774D: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x774E:
L774E:
                                                     #ifdef DEBUG
                                      mon("L774E    STA   $4AD7                   ; 774E: B7 4A D7      \n");
                                      #endif
    PC = 0x774e; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4ad7, val); 
                                                     #ifdef DEBUG
                                      mon("         ANDA  #$F0                    ; 7751: 84 F0         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    res = val & (SINT8)0xf0; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   #$A0                    ; 7753: C6 A0         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xa0; 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         MUL                           ; 7755: 3D            \n");
                                      #endif
    res = (UINT16)(A * B); 
 // Z = res; 
 // C = res & 0x80; 
    A = res >> 8; 
    B = (UINT8)res; 
    clockticks = clockticks + 11; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $4AD7                   ; 7756: F6 4A D7      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4ad7); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ANDB  #$0F                    ; 7759: C4 0F         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    res = val & (SINT8)0x0f; 
    B = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STB   $4AD7                   ; 775B: F7 4A D7      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = B; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4ad7, val); 
                                                     #ifdef DEBUG
                                      mon("         ADDA  $4AD7                   ; 775E: BB 4A D7      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    arg = rd_mem(0x4ad7); 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    A = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4AD7                   ; 7761: B7 4A D7      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x4ad7, val); 
    // End of function sub_774E
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 7764: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Space wave sub_7765
  case 0x7765:
L7765:
                                                     #ifdef DEBUG
                                      mon("L7765    LDD   $5028                   ; 7765: FC 50 28      \n");
                                      #endif // Ax2
    PC = 0x7765; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x5028); // Care needed with I/O space and word fetches
    B = rd_mem(0x5029); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BLE   locret_77A3             ; 7768: 2F 39         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto L77A3;
    }
                                                     #ifdef DEBUG
                                      mon("         STD   $4704                   ; 776A: FD 47 04      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4704, A); // Care needed with I/O space and word fetches
    wr_mem(0x4705, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $502A                   ; 776D: FC 50 2A      \n");
                                      #endif // Ay2
    clockticks = clockticks + 5; 
    A = rd_mem(0x502a); // Care needed with I/O space and word fetches
    B = rd_mem(0x502b); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5002                   ; 7770: FD 50 02      \n");
                                      #endif // Math result Y
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5002, A); // Care needed with I/O space and word fetches
    wr_mem(0x5003, B); 
                                                     #ifdef DEBUG
                                      mon("         TSTA                          ; 7773: 4D            \n");
                                      #endif
    val = (UINT8)A; 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BPL   L777A                   ; 7774: 2A 04         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto L777A;
    }
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; 7776: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; 7777: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SBCA  #$FF                    ; 7778: 82 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xff; 
    res = val - (UINT8)arg - (C != 0 ? 1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)res; 
  case 0x777A:
L777A:
                                                     #ifdef DEBUG
                                      mon("L777A    SUBD  $5028                   ; 777A: B3 50 28      \n");
                                      #endif // "Ax2", Ax2
    PC = 0x777a; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5028)<<8; 
    ea = ea | rd_mem(0x5029); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BGE   locret_77A3             ; 777D: 2C 24         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) >= 0) {
    clockticks = clockticks + 3; 
    goto L77A3;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $502C                   ; 777F: FC 50 2C      \n");
                                      #endif // Az2
    clockticks = clockticks + 5; 
    A = rd_mem(0x502c); // Care needed with I/O space and word fetches
    B = rd_mem(0x502d); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5004                   ; 7782: FD 50 04      \n");
                                      #endif // Math result Z
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5004, A); // Care needed with I/O space and word fetches
    wr_mem(0x5005, B); 
                                                     #ifdef DEBUG
                                      mon("         TSTA                          ; 7785: 4D            \n");
                                      #endif
    val = (UINT8)A; 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BPL   L778C                   ; 7786: 2A 04         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto L778C;
    }
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; 7788: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; 7789: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SBCA  #$FF                    ; 778A: 82 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xff; 
    res = val - (UINT8)arg - (C != 0 ? 1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)res; 
  case 0x778C:
L778C:
                                                     #ifdef DEBUG
                                      mon("L778C    SUBD  $5028                   ; 778C: B3 50 28      \n");
                                      #endif // "Ax2", Ax2
    PC = 0x778c; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5028)<<8; 
    ea = ea | rd_mem(0x5029); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
  case 0x778F:
L778F:
                                                     #ifdef DEBUG
                                      mon("L778F    BGE   locret_77A3             ; 778F: 2C 12         \n");
                                      #endif
    PC = 0x778f; 
    INSTRUCTION_START
    // temp hack to force a flush
    if ((SINT8)(N^V) >= 0) {
    clockticks = clockticks + 3; 
    goto L77A3;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   $CCF0                   ; 7791: BD CC F0      \n");
                                      #endif // Get divider result and multiply by Math result Z, insert VCTR instruction
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x94); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x77); 
    clockticks = clockticks + 1; 
    PC = 0xccf0; 
    JUMP;
  case 0x7794:
L7794:
                                                     #ifdef DEBUG
                                      mon("L7794    LDD   #$7300                  ; 7794: CC 73 00      \n");
                                      #endif
    PC = 0x7794; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x73; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 7797: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$BE50                  ; 7799: CC BE 50      \n");
                                      #endif // Vector JRSL Small Death Star
    clockticks = clockticks + 3; 
    A = 0xbe; 
    B = 0x50; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 779C: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   #$7200                  ; 779E: CC 72 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x72; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 77A1: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
    // End of function sub_7765
  case 0x77A3:
L77A3:
locret_77A3:
                                                     #ifdef DEBUG
                                      mon("locret_77A3 RTS                           ; 77A3: 39            \n");
                                      #endif
    PC = 0x77a3; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x77A4:
L77A4:
                                                     #ifdef DEBUG
                                      mon("L77A4    LDD   $5028                   ; 77A4: FC 50 28      \n");
                                      #endif // Ax2
    PC = 0x77a4; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x5028); // Care needed with I/O space and word fetches
    B = rd_mem(0x5029); 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BLE   locret_77D3             ; 77A7: 2F 2A         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 3; 
    goto L77D3;
    }
                                                     #ifdef DEBUG
                                      mon("         STD   $4704                   ; 77A9: FD 47 04      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4704, A); // Care needed with I/O space and word fetches
    wr_mem(0x4705, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $502A                   ; 77AC: FC 50 2A      \n");
                                      #endif // Ay2
    clockticks = clockticks + 5; 
    A = rd_mem(0x502a); // Care needed with I/O space and word fetches
    B = rd_mem(0x502b); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5002                   ; 77AF: FD 50 02      \n");
                                      #endif // Math result Y
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5002, A); // Care needed with I/O space and word fetches
    wr_mem(0x5003, B); 
                                                     #ifdef DEBUG
                                      mon("         TSTA                          ; 77B2: 4D            \n");
                                      #endif
    val = (UINT8)A; 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BPL   L77B9                   ; 77B3: 2A 04         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto L77B9;
    }
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; 77B5: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; 77B6: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SBCA  #$FF                    ; 77B7: 82 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xff; 
    res = val - (UINT8)arg - (C != 0 ? 1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)res; 
  case 0x77B9:
L77B9:
                                                     #ifdef DEBUG
                                      mon("L77B9    SUBD  $5028                   ; 77B9: B3 50 28      \n");
                                      #endif // "Ax2", Ax2
    PC = 0x77b9; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5028)<<8; 
    ea = ea | rd_mem(0x5029); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BGE   locret_77D3             ; 77BC: 2C 15         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) >= 0) {
    clockticks = clockticks + 3; 
    goto L77D3;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $502C                   ; 77BE: FC 50 2C      \n");
                                      #endif // Az2
    clockticks = clockticks + 5; 
    A = rd_mem(0x502c); // Care needed with I/O space and word fetches
    B = rd_mem(0x502d); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5004                   ; 77C1: FD 50 04      \n");
                                      #endif // Math result Z
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5004, A); // Care needed with I/O space and word fetches
    wr_mem(0x5005, B); 
                                                     #ifdef DEBUG
                                      mon("         TSTA                          ; 77C4: 4D            \n");
                                      #endif
    val = (UINT8)A; 
    Z = val; 
    N = val; 
    V = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BPL   L77CB                   ; 77C5: 2A 04         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto L77CB;
    }
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; 77C7: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; 77C8: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SBCA  #$FF                    ; 77C9: 82 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xff; 
    res = val - (UINT8)arg - (C != 0 ? 1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)res; 
  case 0x77CB:
L77CB:
                                                     #ifdef DEBUG
                                      mon("L77CB    SUBD  $5028                   ; 77CB: B3 50 28      \n");
                                      #endif // "Ax2", Ax2
    PC = 0x77cb; 
    INSTRUCTION_START
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5028)<<8; 
    ea = ea | rd_mem(0x5029); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BGE   locret_77D3             ; 77CE: 2C 03         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) >= 0) {
    clockticks = clockticks + 3; 
    goto L77D3;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   L77D4                   ; 77D0: BD 77 D4      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xd3); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x77); 
    clockticks = clockticks + 1; 
    goto L77D4;
    // End of function sub_77A4
  case 0x77D3:
L77D3:
locret_77D3:
                                                     #ifdef DEBUG
                                      mon("locret_77D3 RTS                           ; 77D3: 39            \n");
                                      #endif
    PC = 0x77d3; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x77D4:
L77D4:
                                                     #ifdef DEBUG
                                      mon("L77D4    JSR   $CCF0                   ; 77D4: BD CC F0      \n");
                                      #endif // Get divider result and multiply by Math result Z, insert VCTR instruction
    PC = 0x77d4; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xd7); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x77); 
    clockticks = clockticks + 1; 
    PC = 0xccf0; 
    JUMP;
  case 0x77D7:
L77D7:
                                                     #ifdef DEBUG
                                      mon("L77D7    LDD   -4,Y                    ; 77D7: EC 3C         \n");
                                      #endif
    PC = 0x77d7; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    ea = (UINT16)(Y + 0xfffc); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$05                    ; 77D9: DD 05         \n");
                                      #endif // Zoom value
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x05; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   -2,Y                    ; 77DB: EC 3E         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(Y + 0xfffe); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$03                    ; 77DD: DD 03         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x03; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$56                    ; 77DF: DC 56         \n");
                                      #endif // Zoom value
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x56); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x57); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$01                    ; 77E1: DD 01         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x01; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDU   #$BD68                  ; 77E3: CE BD 68      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0xbd68; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   L7863                   ; 77E6: BD 78 63      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xe9); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x77); 
    clockticks = clockticks + 1; 
    goto L7863;
  case 0x77E9:
L77E9:
                                                     #ifdef DEBUG
                                      mon("L77E9    LDU   #$BDA6                  ; 77E9: CE BD A6      \n");
                                      #endif
    PC = 0x77e9; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0xbda6; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   L785B                   ; 77EC: BD 78 5B      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xef); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x77); 
    clockticks = clockticks + 1; 
    goto L785B;
  case 0x77EF:
L77EF:
                                                     #ifdef DEBUG
                                      mon("L77EF    LDU   #$BDB2                  ; 77EF: CE BD B2      \n");
                                      #endif
    PC = 0x77ef; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0xbdb2; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   L785B                   ; 77F2: BD 78 5B      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xf5); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x77); 
    clockticks = clockticks + 1; 
    goto L785B;
  case 0x77F5:
L77F5:
                                                     #ifdef DEBUG
                                      mon("L77F5    LDU   #$BDDA                  ; 77F5: CE BD DA      \n");
                                      #endif
    PC = 0x77f5; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0xbdda; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   L785B                   ; 77F8: BD 78 5B      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xfb); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x77); 
    clockticks = clockticks + 1; 
    goto L785B;
  case 0x77FB:
L77FB:
                                                     #ifdef DEBUG
                                      mon("L77FB    LDU   #$BE06                  ; 77FB: CE BE 06      \n");
                                      #endif
    PC = 0x77fb; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0xbe06; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   L785B                   ; 77FE: BD 78 5B      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x01); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x78); 
    clockticks = clockticks + 1; 
    goto L785B;
  case 0x7801:
L7801:
                                                     #ifdef DEBUG
                                      mon("L7801    LDD   <$56                    ; 7801: DC 56         \n");
                                      #endif // Zoom value
    PC = 0x7801; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x56); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x57); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBA  #$03                    ; 7803: 80 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x03; 
    res = val - (UINT8)arg; 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)(res); 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #L7000                  ; 7805: 10 83 70 00   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x7000; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCC   L780E                   ; 7809: 24 03         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto L780E;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #L7000                  ; 780B: CC 70 00      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x70; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0x780E:
L780E:
                                                     #ifdef DEBUG
                                      mon("L780E    STD   <$01                    ; 780E: DD 01         \n");
                                      #endif
    PC = 0x780e; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x01; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$70                    ; 7810: 81 70         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x70; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   L7819                   ; 7812: 26 05         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L7819;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   #$6660                  ; 7814: CC 66 60      \n");
                                      #endif
    clockticks = clockticks + 3; 
    A = 0x66; 
    B = 0x60; 
    Z = A|B; 
    N = A; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   L781C                   ; 7817: 20 03         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L781C;
    
    // ---------------------------------------------------------------------------
  case 0x7819:
L7819:
                                                     #ifdef DEBUG
                                      mon("L7819    LDD   #$6630                  ; 7819: CC 66 30      \n");
                                      #endif
    PC = 0x7819; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x66; 
    B = 0x30; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
  case 0x781C:
L781C:
                                                     #ifdef DEBUG
                                      mon("L781C    STD   ,Y++                    ; 781C: ED A1         \n");
                                      #endif
    PC = 0x781c; 
    INSTRUCTION_START
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B14                   ; 781E: B6 4B 14      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b14); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BITA  #$01                    ; 7821: 85 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A & (SINT8)0x01; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L782A                   ; 7823: 26 05         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L782A;
    }
                                                     #ifdef DEBUG
                                      mon("         LDU   #$B728                  ; 7825: CE B7 28      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0xb728; 
    Z = U; 
    N = (U) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   L7839                   ; 7828: 20 0F         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L7839;
    
    // ---------------------------------------------------------------------------
  case 0x782A:
L782A:
                                                     #ifdef DEBUG
                                      mon("L782A    LDU   #$B73C                  ; 782A: CE B7 3C      \n");
                                      #endif
    PC = 0x782a; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0xb73c; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   L785B                   ; 782D: BD 78 5B      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x30); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x78); 
    clockticks = clockticks + 1; 
    goto L785B;
  case 0x7830:
L7830:
                                                     #ifdef DEBUG
                                      mon("L7830    LDU   #$B749                  ; 7830: CE B7 49      \n");
                                      #endif
    PC = 0x7830; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0xb749; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   L785B                   ; 7833: BD 78 5B      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x36); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x78); 
    clockticks = clockticks + 1; 
    goto L785B;
  case 0x7836:
L7836:
                                                     #ifdef DEBUG
                                      mon("L7836    LDU   #$B754                  ; 7836: CE B7 54      \n");
                                      #endif
    PC = 0x7836; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0xb754; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
  case 0x7839:
L7839:
                                                     #ifdef DEBUG
                                      mon("L7839    JSR   L785B                   ; 7839: BD 78 5B      \n");
                                      #endif
    PC = 0x7839; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x3c); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x78); 
    clockticks = clockticks + 1; 
    goto L785B;
  case 0x783C:
L783C:
                                                     #ifdef DEBUG
                                      mon("L783C    LDA   $4B14                   ; 783C: B6 4B 14      \n");
                                      #endif
    PC = 0x783c; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b14); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BITA  #$01                    ; 783F: 85 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A & (SINT8)0x01; 
    Z = res; 
    N = res; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L7848                   ; 7841: 26 05         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L7848;
    }
                                                     #ifdef DEBUG
                                      mon("         LDU   #$B75E                  ; 7843: CE B7 5E      \n");
                                      #endif
    clockticks = clockticks + 3; 
    U = 0xb75e; 
    Z = U; 
    N = (U) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BRA   L7857                   ; 7846: 20 0F         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L7857;
    
    // ---------------------------------------------------------------------------
  case 0x7848:
L7848:
                                                     #ifdef DEBUG
                                      mon("L7848    LDU   #$B770                  ; 7848: CE B7 70      \n");
                                      #endif
    PC = 0x7848; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0xb770; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   L785B                   ; 784B: BD 78 5B      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x4e); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x78); 
    clockticks = clockticks + 1; 
    goto L785B;
  case 0x784E:
L784E:
                                                     #ifdef DEBUG
                                      mon("L784E    LDU   #$B77C                  ; 784E: CE B7 7C      \n");
                                      #endif
    PC = 0x784e; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0xb77c; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   L785B                   ; 7851: BD 78 5B      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x54); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x78); 
    clockticks = clockticks + 1; 
    goto L785B;
  case 0x7854:
L7854:
                                                     #ifdef DEBUG
                                      mon("L7854    LDU   #$B788                  ; 7854: CE B7 88      \n");
                                      #endif
    PC = 0x7854; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0xb788; 
    Z = U; 
    N = (U) >> 8; 
    V = 0; 
  case 0x7857:
L7857:
                                                     #ifdef DEBUG
                                      mon("L7857    JSR   L785B                   ; 7857: BD 78 5B      \n");
                                      #endif
    PC = 0x7857; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x5a); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x78); 
    clockticks = clockticks + 1; 
    goto L785B;
    // End of function sub_77D4
  case 0x785A:
L785A:
                                                     #ifdef DEBUG
                                      mon("L785A    RTS                           ; 785A: 39            \n");
                                      #endif
    PC = 0x785a; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x785B:
L785B:
                                                     #ifdef DEBUG
                                      mon("L785B    LDD   <$05                    ; 785B: DC 05         \n");
                                      #endif
    PC = 0x785b; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x05); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x06); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 785D: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$03                    ; 785F: DC 03         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x03); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x04); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
    // End of function sub_785B
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 7861: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
    // =============== S U B R O U T I N E =======================================
  case 0x7863:
L7863:
                                                     #ifdef DEBUG
                                      mon("L7863    LDD   <$01                    ; 7863: DC 01         \n");
                                      #endif
    PC = 0x7863; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x01); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x02); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 7865: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         STU   ,Y++                    ; 7867: EF A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    val = U; 
    Z = val; 
    N = (UINT8)(val >> 8); 
    V = 0; 
    ea = Y; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
    Y = Y + 2; 
    // End of function sub_7863
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 7869: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
    // Process tie fighters and insert vectors
  case 0x786A:
L786A:
                                                     #ifdef DEBUG
                                      mon("L786A    LDX   #$4900                  ; 786A: 8E 49 00      \n");
                                      #endif // 3x Tie fighter data structure ($19 bytes per Tie)
    PC = 0x786a; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    X = 0x4900; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
  case 0x786D:
L786D:
                                                     #ifdef DEBUG
                                      mon("L786D    STX   <$64                    ; 786D: 9F 64         \n");
                                      #endif // "Pointer to Tie fighter data", Pointer to Tie fighter data
    PC = 0x786d; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    val = X; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = DP|0x64; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $03,X                   ; 786F: A6 03         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0003)); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BEQ   L7876                   ; 7871: 27 03         \n");
                                      #endif
    // temp hack to force a flush
    if (!Z) {
    clockticks = clockticks + 3; 
    goto L7876;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   L7881                   ; 7873: BD 78 81      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x76); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x78); 
    clockticks = clockticks + 1; 
    goto L7881;
  case 0x7876:
L7876:
                                                     #ifdef DEBUG
                                      mon("L7876    LDX   <$64                    ; 7876: 9E 64         \n");
                                      #endif // "Pointer to Tie fighter data", Pointer to Tie fighter data
    PC = 0x7876; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x64)<<8; 
    ea = ea | rd_mem(DP|0x65); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LEAX  $19,X                   ; 7878: 30 88 19      \n");
                                      #endif
    clockticks = clockticks + 5; 
    X = (X + (SINT8)0x19); 
 // Z = X; 
                                                     #ifdef DEBUG
                                      mon("         CMPX  #$494B                  ; 787B: 8C 49 4B      \n");
                                      #endif // 3x Tie fighter data structure ($19 bytes per Tie)
    clockticks = clockticks + 4; 
    val = X; 
    arg = 0x494b; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BCS   L786D                   ; 787E: 25 ED         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L786D;
    }
    // End of function sub_786A
  case 0x7880:
L7880:
locret_7880:
                                                     #ifdef DEBUG
                                      mon("locret_7880 RTS                           ; 7880: 39            \n");
                                      #endif
    PC = 0x7880; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x7881:
L7881:
                                                     #ifdef DEBUG
                                      mon("L7881    LDX   <$64                    ; 7881: 9E 64         \n");
                                      #endif // Pointer to Tie fighter data
    PC = 0x7881; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x64)<<8; 
    ea = ea | rd_mem(DP|0x65); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CLRA                          ; 7883: 4F            \n");
                                      #endif
    A = 0; // SEARCH_ME
 // V = 0; 
 // Z = 0; 
 // N = 0; 
 // C = 0; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $02,X                   ; 7884: E6 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0002)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDB  #$03                    ; 7886: CB 03         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)B; 
    arg = 0x03; 
    res = val + (UINT8)arg; 
    C = (res >> 1) & 0x80; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
    H = (UINT8)(val ^ arg ^ res ^ C); 
 // V = (UINT8)(val ^ arg ^ res ^ C); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   $4701                   ; 7888: FD 47 01      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4701, A); // Care needed with I/O space and word fetches
    wr_mem(0x4702, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$67                    ; 788B: 86 67         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0x67; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $CDBA                   ; 788D: BD CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x90); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x78); 
    clockticks = clockticks + 1; 
    PC = 0xcdba; 
    JUMP;
  case 0x7890:
L7890:
                                                     #ifdef DEBUG
                                      mon("L7890    LDA   $5000                   ; 7890: B6 50 00      \n");
                                      #endif // Math result X
    PC = 0x7890; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x5000); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLA                          ; 7893: 48            \n");
                                      #endif
    val = (UINT8)A; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
    Z = res; 
    N = res; 
    V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BVS   L7909                   ; 7894: 29 73         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)V <  0) {
    clockticks = clockticks + 3; 
    goto L7909;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $5002                   ; 7896: B6 50 02      \n");
                                      #endif // Math result Y
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x5002); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLA                          ; 7899: 48            \n");
                                      #endif
    val = (UINT8)A; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
    Z = res; 
    N = res; 
    V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BVS   L7909                   ; 789A: 29 6D         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)V <  0) {
    clockticks = clockticks + 3; 
    goto L7909;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $5004                   ; 789C: B6 50 04      \n");
                                      #endif // Math result Z
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x5004); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLA                          ; 789F: 48            \n");
                                      #endif
    val = (UINT8)A; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
    Z = res; 
    N = res; 
    V = val ^ res; 
    A = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BVS   L7909                   ; 78A0: 29 67         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)V <  0) {
    clockticks = clockticks + 3; 
    goto L7909;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $5070                   ; 78A2: FC 50 70      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x5070); // Care needed with I/O space and word fetches
    B = rd_mem(0x5071); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $5072                   ; 78A5: F3 50 72      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5072)<<8; 
    ea = ea | rd_mem(0x5073); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  $5074                   ; 78A8: F3 50 74      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5074)<<8; 
    ea = ea | rd_mem(0x5075); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         TFR   D,U                     ; 78AB: 1F 03         \n");
                                      #endif
    U = ((A << 8) | B); 
    clockticks = clockticks + 6; 
                                                     #ifdef DEBUG
                                      mon("         CMPU  #$0900                  ; 78AD: 11 83 09 00   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
    arg = 0x0900; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BHI   L78BB                   ; 78B1: 22 08         \n");
                                      #endif
    // temp hack to force a flush
    if (Z && (!C)) {
    clockticks = clockticks + 3; 
    goto L78BB;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $15,X                   ; 78B3: EC 88 15      \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + (SINT8)0x15); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORA   #$20                    ; 78B6: 8A 20         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A | (UINT8)0x20; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $15,X                   ; 78B8: ED 88 15      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + (SINT8)0x15); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
  case 0x78BB:
L78BB:
                                                     #ifdef DEBUG
                                      mon("L78BB    CMPU  #$0100                  ; 78BB: 11 83 01 00   \n");
                                      #endif
    PC = 0x78bb; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = U; 
    arg = 0x0100; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BHI   L78C9                   ; 78BF: 22 08         \n");
                                      #endif
    // temp hack to force a flush
    if (Z && (!C)) {
    clockticks = clockticks + 3; 
    goto L78C9;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $15,X                   ; 78C1: EC 88 15      \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + (SINT8)0x15); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORA   #$04                    ; 78C4: 8A 04         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A | (UINT8)0x04; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $15,X                   ; 78C6: ED 88 15      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + (SINT8)0x15); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
  case 0x78C9:
L78C9:
                                                     #ifdef DEBUG
                                      mon("L78C9    CMPU  #$A0                    ; 78C9: 11 83 00 A0   \n");
                                      #endif
    PC = 0x78c9; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = U; 
    arg = 0x00a0; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BHI   L78FF                   ; 78CD: 22 30         \n");
                                      #endif
    // temp hack to force a flush
    if (Z && (!C)) {
    clockticks = clockticks + 3; 
    goto L78FF;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B38                   ; 78CF: B6 4B 38      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b38); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L78E4                   ; 78D2: 26 10         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L78E4;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $02,X                   ; 78D4: A6 02         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0002)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B38                   ; 78D6: B7 4B 38      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x4b38, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   $BD08                   ; 78D9: BD BD 08      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xdc); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x78); 
    clockticks = clockticks + 1; 
    PC = 0xbd08; 
    JUMP;
  case 0x78DC:
L78DC:
                                                     #ifdef DEBUG
                                      mon("L78DC    JSR   $BDC6                   ; 78DC: BD BD C6      \n");
                                      #endif
    PC = 0x78dc; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xdf); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x78); 
    clockticks = clockticks + 1; 
    PC = 0xbdc6; 
    JUMP;
  case 0x78DF:
L78DF:
                                                     #ifdef DEBUG
                                      mon("L78DF    STU   $4B39                   ; 78DF: FF 4B 39      \n");
                                      #endif
    PC = 0x78df; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = U; 
    Z = val; 
    N = (UINT8)(val >> 8); 
    V = 0; 
    wr_mem(0x4b39, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem(0x4b3a, (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         BRA   L78FD                   ; 78E2: 20 19         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L78FD;
    
    // ---------------------------------------------------------------------------
  case 0x78E4:
L78E4:
                                                     #ifdef DEBUG
                                      mon("L78E4    CMPA  $02,X                   ; 78E4: A1 02         \n");
                                      #endif
    PC = 0x78e4; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    arg = rd_mem((UINT16)(X + 0x0002)); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   L78FD                   ; 78E6: 26 15         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L78FD;
    }
                                                     #ifdef DEBUG
                                      mon("         CMPU  $4B39                   ; 78E8: 11 B3 4B 39   \n");
                                      #endif
    clockticks = clockticks + 7; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x4b39)<<8; 
    ea = ea | rd_mem(0x4b3a); 
    val = U; 
    arg = ea; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         BGT   L78F3                   ; 78EC: 2E 05         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto L78F3;
    }
                                                     #ifdef DEBUG
                                      mon("         STU   $4B39                   ; 78EE: FF 4B 39      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = U; 
    Z = val; 
    N = (UINT8)(val >> 8); 
    V = 0; 
    wr_mem(0x4b39, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem(0x4b3a, (UINT8)val); 
                                                     #ifdef DEBUG
                                      mon("         BRA   L78FD                   ; 78F1: 20 0A         \n");
                                      #endif
    clockticks = clockticks + 3; 
    goto L78FD;
    
    // ---------------------------------------------------------------------------
  case 0x78F3:
L78F3:
                                                     #ifdef DEBUG
                                      mon("L78F3    BCS   L78FD                   ; 78F3: 25 08         \n");
                                      #endif
    PC = 0x78f3; 
    INSTRUCTION_START
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L78FD;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   #$FF                    ; 78F5: 86 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)0xff; 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   $4B39                   ; 78F7: B7 4B 39      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
    Z = val; 
    N = val; 
    V = 0; 
    wr_mem(0x4b39, val); 
                                                     #ifdef DEBUG
                                      mon("         JSR   $BDDA                   ; 78FA: BD BD DA      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xfd); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x78); 
    clockticks = clockticks + 1; 
    PC = 0xbdda; 
    JUMP;
  case 0x78FD:
L78FD:
                                                     #ifdef DEBUG
                                      mon("L78FD    BRA   L7909                   ; 78FD: 20 0A         \n");
                                      #endif
    PC = 0x78fd; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto L7909;
    
    // ---------------------------------------------------------------------------
  case 0x78FF:
L78FF:
                                                     #ifdef DEBUG
                                      mon("L78FF    LDA   $02,X                   ; 78FF: A6 02         \n");
                                      #endif
    PC = 0x78ff; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0002)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  $4B38                   ; 7901: B1 4B 38      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)A; 
    arg = rd_mem(0x4b38); 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   L7909                   ; 7904: 26 03         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L7909;
    }
                                                     #ifdef DEBUG
                                      mon("         CLR   $4B38                   ; 7906: 7F 4B 38      \n");
                                      #endif
    clockticks = clockticks + 5; 
    wr_mem(0x4b38, 0); 
 // V = 0; 
 // Z = 0; 
 // N = 0; 
 // C = 0; 
    clockticks = clockticks + 2; 
  case 0x7909:
L7909:
                                                     #ifdef DEBUG
                                      mon("L7909    LDD   $5000                   ; 7909: FC 50 00      \n");
                                      #endif // "Math result X", Math result X
    PC = 0x7909; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x5000); // Care needed with I/O space and word fetches
    B = rd_mem(0x5001); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$10                    ; 790C: 10 83 00 10   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x0010; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         LBLE  locret_7880             ; 7910: 10 2F FF 6C   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if (((SINT8)(N^V) <  0) || (!Z)) {
    clockticks = clockticks + 1; 
    goto L7880;
    }
                                                     #ifdef DEBUG
                                      mon("         CMPD  #$7F00                  ; 7914: 10 83 7F 00   \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = 0x7f00; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
                                                     #ifdef DEBUG
                                      mon("         LBHI  locret_7880             ; 7918: 10 22 FF 64   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if (Z && (!C)) {
    clockticks = clockticks + 1; 
    goto L7880;
    }
                                                     #ifdef DEBUG
                                      mon("         STD   $4704                   ; 791C: FD 47 04      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4704, A); // Care needed with I/O space and word fetches
    wr_mem(0x4705, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $5018                   ; 791F: FD 50 18      \n");
                                      #endif // XT
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5018, A); // Care needed with I/O space and word fetches
    wr_mem(0x5019, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $5002                   ; 7922: FC 50 02      \n");
                                      #endif // Math result Y
    clockticks = clockticks + 5; 
    A = rd_mem(0x5002); // Care needed with I/O space and word fetches
    B = rd_mem(0x5003); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $501A                   ; 7925: FD 50 1A      \n");
                                      #endif // YT
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x501a, A); // Care needed with I/O space and word fetches
    wr_mem(0x501b, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $5072                   ; 7928: FC 50 72      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x5072); // Care needed with I/O space and word fetches
    B = rd_mem(0x5073); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5070                   ; 792B: B3 50 70      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5070)<<8; 
    ea = ea | rd_mem(0x5071); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         LBCC  locret_7880             ; 792E: 10 24 FF 4E   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if (!C) {
    clockticks = clockticks + 1; 
    goto L7880;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $5004                   ; 7932: FC 50 04      \n");
                                      #endif // Math result Z
    clockticks = clockticks + 5; 
    A = rd_mem(0x5004); // Care needed with I/O space and word fetches
    B = rd_mem(0x5005); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $501C                   ; 7935: FD 50 1C      \n");
                                      #endif // ZT
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x501c, A); // Care needed with I/O space and word fetches
    wr_mem(0x501d, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   $5074                   ; 7938: FC 50 74      \n");
                                      #endif
    clockticks = clockticks + 5; 
    A = rd_mem(0x5074); // Care needed with I/O space and word fetches
    B = rd_mem(0x5075); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  $5070                   ; 793B: B3 50 70      \n");
                                      #endif
    clockticks = clockticks + 6; 
    clockticks = clockticks + 1; 
    ea = rd_mem(0x5070)<<8; 
    ea = ea | rd_mem(0x5071); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         LBCC  locret_7880             ; 793E: 10 24 FF 3E   \n");
                                      #endif
    clockticks = clockticks + 5; 
    if (!C) {
    clockticks = clockticks + 1; 
    goto L7880;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   <$64                    ; 7942: 9E 64         \n");
                                      #endif // Pointer to Tie fighter data
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x64)<<8; 
    ea = ea | rd_mem(DP|0x65); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDD   $15,X                   ; 7944: EC 88 15      \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + (SINT8)0x15); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORA   #$10                    ; 7947: 8A 10         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A | (UINT8)0x10; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $15,X                   ; 7949: ED 88 15      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + (SINT8)0x15); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B3B                   ; 794C: B6 4B 3B      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b3b); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BNE   L7972                   ; 794F: 26 21         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L7972;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $04,X                   ; 7951: A6 04         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0004)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$04                    ; 7953: 81 04         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x04; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   L7972                   ; 7955: 26 1B         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L7972;
    }
                                                     #ifdef DEBUG
                                      mon("         INC   $4B3B                   ; 7957: 7C 4B 3B      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b3b); 
    res = (UINT8)(val + 1); 
 // Z = res; 
 // N = res; 
 // V = res & ~val; 
    wr_mem(0x4b3b, res); 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $4B14                   ; 795A: B6 4B 14      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4b14); 
    A = val; 
 // N = val; 
 // Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; 795D: 44            \n");
                                      #endif
    val = (UINT8)A; 
    C = val & 1; 
    val = val >> 1; 
    A = val; 
    N = 0; 
    Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         BCS   L796F                   ; 795E: 25 0F         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L796F;
    }
                                                     #ifdef DEBUG
                                      mon("         LDA   $4703                   ; 7960: B6 47 03      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem(0x4703); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         BPL   L796A                   ; 7963: 2A 05         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto L796A;
    }
                                                     #ifdef DEBUG
                                      mon("         JSR   $BD5D                   ; 7965: BD BD 5D      \n");
                                      #endif
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x68); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x79); 
    clockticks = clockticks + 1; 
    PC = 0xbd5d; 
    JUMP;
  case 0x7968:
L7968:
                                                     #ifdef DEBUG
                                      mon("L7968    BRA   L796D                   ; 7968: 20 03         \n");
                                      #endif
    PC = 0x7968; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto L796D;
    
    // ---------------------------------------------------------------------------
  case 0x796A:
L796A:
                                                     #ifdef DEBUG
                                      mon("L796A    JSR   $BD2B                   ; 796A: BD BD 2B      \n");
                                      #endif
    PC = 0x796a; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x6d); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x79); 
    clockticks = clockticks + 1; 
    PC = 0xbd2b; 
    JUMP;
  case 0x796D:
L796D:
                                                     #ifdef DEBUG
                                      mon("L796D    BRA   L7972                   ; 796D: 20 03         \n");
                                      #endif
    PC = 0x796d; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    goto L7972;
    
    // ---------------------------------------------------------------------------
  case 0x796F:
L796F:
                                                     #ifdef DEBUG
                                      mon("L796F    JSR   $BD1C                   ; 796F: BD BD 1C      \n");
                                      #endif
    PC = 0x796f; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x72); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x79); 
    clockticks = clockticks + 1; 
    PC = 0xbd1c; 
    JUMP;
  case 0x7972:
L7972:
                                                     #ifdef DEBUG
                                      mon("L7972    LDA   $02,X                   ; 7972: A6 02         \n");
                                      #endif
    PC = 0x7972; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0002)); 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $CE18                   ; 7974: BD CE 18      \n");
                                      #endif // Run math program $80 Copy [BIC] to Matrix 3
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x77); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x79); 
    clockticks = clockticks + 1; 
    PC = 0xce18; 
    JUMP;
  case 0x7977:
L7977:
                                                     #ifdef DEBUG
                                      mon("L7977    JSR   $CCF0                   ; 7977: BD CC F0      \n");
                                      #endif // Get divider result and multiply by Math result Z, insert VCTR instruction
    PC = 0x7977; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x7a); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x79); 
    clockticks = clockticks + 1; 
    PC = 0xccf0; 
    JUMP;
  case 0x797A:
L797A:
                                                     #ifdef DEBUG
                                      mon("L797A    LDD   #$50                    ; 797A: CC 00 50      \n");
                                      #endif
    PC = 0x797a; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x50; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5002                   ; 797D: FD 50 02      \n");
                                      #endif // Math result Y
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5002, A); // Care needed with I/O space and word fetches
    wr_mem(0x5003, B); 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$86                    ; 7980: 86 86         \n");
                                      #endif // Reg02 = Reg02 x Reg00
    clockticks = clockticks + 2; 
    val = (UINT8)0x86; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $CDBA                   ; 7982: BD CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x85); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x79); 
    clockticks = clockticks + 1; 
    PC = 0xcdba; 
    JUMP;
  case 0x7985:
L7985:
                                                     #ifdef DEBUG
                                      mon("L7985    LDD   $5002                   ; 7985: FC 50 02      \n");
                                      #endif // Math result Y
    PC = 0x7985; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    A = rd_mem(0x5002); // Care needed with I/O space and word fetches
    B = rd_mem(0x5003); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  #$0A                    ; 7988: C3 00 0A      \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = 0x000a; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$01                    ; 798B: DD 01         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x01; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$D6                    ; 798D: DC D6         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0xd6); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0xd7); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  <$B3                    ; 798F: 93 B3         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xb3)<<8; 
    ea = ea | rd_mem(DP|0xb4); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BPL   L7997                   ; 7991: 2A 04         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto L7997;
    }
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; 7993: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; 7994: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SBCA  #$FF                    ; 7995: 82 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xff; 
    res = val - (UINT8)arg - (C != 0 ? 1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)res; 
  case 0x7997:
L7997:
                                                     #ifdef DEBUG
                                      mon("L7997    STD   <$05                    ; 7997: DD 05         \n");
                                      #endif
    PC = 0x7997; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x05; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   <$03                    ; 7999: DD 03         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x03; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$D8                    ; 799B: DC D8         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0xd8); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0xd9); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  <$B5                    ; 799D: 93 B5         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xb5)<<8; 
    ea = ea | rd_mem(DP|0xb6); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BPL   L79A5                   ; 799F: 2A 04         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)N >= 0) {
    clockticks = clockticks + 3; 
    goto L79A5;
    }
                                                     #ifdef DEBUG
                                      mon("         COMA                          ; 79A1: 43            \n");
                                      #endif
    val = (UINT8)A ^ 0xff; 
    A = val; 
 // Z = val; 
 // N = val; 
 // V = 0; 
 // C = 1; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         NEGB                          ; 79A2: 50            \n");
                                      #endif
    val = (UINT8)B; 
    res = -val; 
 // V = val & (UINT8)res; 
    C = res & 0x100; 
    val = (UINT8)res; 
    B = val; 
 // Z = val; 
 // N = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         SBCA  #$FF                    ; 79A3: 82 FF         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0xff; 
    res = val - (UINT8)arg - (C != 0 ? 1:0); 
 // C = res & 0x100; 
 // Z = (UINT8)res; 
 // N = (UINT8)res; 
 // V = (UINT8)((val ^ arg) & (val ^ res)); 
    A = (UINT8)res; 
  case 0x79A5:
L79A5:
                                                     #ifdef DEBUG
                                      mon("L79A5    STD   <$07                    ; 79A5: DD 07         \n");
                                      #endif
    PC = 0x79a5; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x07; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         ADDD  <$03                    ; 79A7: D3 03         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x03)<<8; 
    ea = ea | rd_mem(DP|0x04); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         STD   <$03                    ; 79A9: DD 03         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0x03; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDD   <$05                    ; 79AB: DC 05         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x05); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x06); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  <$01                    ; 79AD: 93 01         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x01)<<8; 
    ea = ea | rd_mem(DP|0x02); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BGT   L79CF                   ; 79AF: 2E 1E         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto L79CF;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   <$07                    ; 79B1: DC 07         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x07); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x08); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  <$01                    ; 79B3: 93 01         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x01)<<8; 
    ea = ea | rd_mem(DP|0x02); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BGT   L79CF                   ; 79B5: 2E 18         \n");
                                      #endif
    // temp hack to force a flush
    if (((SINT8)(N^V) >= 0) && Z) {
    clockticks = clockticks + 3; 
    goto L79CF;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   <$01                    ; 79B7: DC 01         \n");
                                      #endif
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x01); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x02); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LSRA                          ; 79B9: 44            \n");
                                      #endif
    val = (UINT8)A; 
    C = val & 1; 
    val = val >> 1; 
    A = val; 
 // N = 0; 
 // Z = val; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         RORB                          ; 79BA: 56            \n");
                                      #endif
    res = ((UINT8)B) | ((C != 0) ? 0x100 : 0); 
 // C = res & 1; 
    res = (UINT8)(res >> 1); 
 // Z = res; 
 // N = res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  <$01                    ; 79BB: D3 01         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x01)<<8; 
    ea = ea | rd_mem(DP|0x02); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  <$03                    ; 79BD: 93 03         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x03)<<8; 
    ea = ea | rd_mem(DP|0x04); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BLT   L79CF                   ; 79BF: 2D 0E         \n");
                                      #endif
    // temp hack to force a flush
    if ((SINT8)(N^V) <  0) {
    clockticks = clockticks + 3; 
    goto L79CF;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $5018                   ; 79C1: FC 50 18      \n");
                                      #endif // XT
    clockticks = clockticks + 5; 
    A = rd_mem(0x5018); // Care needed with I/O space and word fetches
    B = rd_mem(0x5019); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPD  <$C4                    ; 79C4: 10 93 C4      \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0xc4)<<8; 
    ea = ea | rd_mem(DP|0xc5); 
    val = (((UINT8)A<<8)|(UINT8)B); 
    arg = ea; 
    res = val - arg; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    N = res >> 8; 
    V = ((val ^ arg) & (val ^ res)) >> 8; 
    clockticks = clockticks + 1; 
                                                     #ifdef DEBUG
                                      mon("         BCC   L79CF                   ; 79C7: 24 06         \n");
                                      #endif
    // temp hack to force a flush
    if (!C) {
    clockticks = clockticks + 3; 
    goto L79CF;
    }
                                                     #ifdef DEBUG
                                      mon("         STD   <$C4                    ; 79C9: DD C4         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0xc4; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         LDX   <$64                    ; 79CB: 9E 64         \n");
                                      #endif // Pointer to Tie fighter data
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x64)<<8; 
    ea = ea | rd_mem(DP|0x65); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STX   <$C2                    ; 79CD: 9F C2         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = X; 
 // Z = val; 
 // N = (UINT8)(val >> 8); 
 // V = 0; 
    ea = DP|0xc2; 
    wr_mem(ea, (UINT8)(val >> 8)); // Care needed with I/O space and word fetches
    wr_mem((UINT16)(ea + 1), (UINT8)val); 
  case 0x79CF:
L79CF:
                                                     #ifdef DEBUG
                                      mon("L79CF    LDD   <$01                    ; 79CF: DC 01         \n");
                                      #endif
    PC = 0x79cf; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    A = rd_mem(DP|0x01); // Care needed with I/O space and word fetches
    B = rd_mem(DP|0x02); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  <$01                    ; 79D1: D3 01         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x01)<<8; 
    ea = ea | rd_mem(DP|0x02); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         ADDD  <$01                    ; 79D3: D3 01         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x01)<<8; 
    ea = ea | rd_mem(DP|0x02); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg + val; 
 // C = res & 0x10000; 
    res = (UINT16)res; 
 // Z = res; 
 // V = ((arg ^ res) & (val ^ res)) >> 8; 
 // N = res >> 8; 
    A = (UINT8)(res >> 8); 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         SUBD  <$03                    ; 79D5: 93 03         \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x03)<<8; 
    ea = ea | rd_mem(DP|0x04); 
    val = ea; 
    arg = (A << 8) | B; 
    res = arg - val; 
    C = res & 0x10000; 
    res = (UINT16)res; 
    Z = res; 
    V = ((arg ^ val) & (arg ^ res)) >> 8; 
    A = (UINT8)(res >> 8); 
    N = res >> 8; 
    B = (UINT8)res; 
                                                     #ifdef DEBUG
                                      mon("         BCS   L79E9                   ; 79D7: 25 10         \n");
                                      #endif
    // temp hack to force a flush
    if (C) {
    clockticks = clockticks + 3; 
    goto L79E9;
    }
                                                     #ifdef DEBUG
                                      mon("         LDX   <$64                    ; 79D9: 9E 64         \n");
                                      #endif // Pointer to Tie fighter data
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x64)<<8; 
    ea = ea | rd_mem(DP|0x65); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDA   $03,X                   ; 79DB: A6 03         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0003)); 
    A = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         CMPA  #$01                    ; 79DD: 81 01         \n");
                                      #endif
    clockticks = clockticks + 2; 
    val = (UINT8)A; 
    arg = 0x01; 
    res = val - (UINT8)arg; 
    C = res & 0x100; 
    Z = (UINT8)res; 
    N = (UINT8)res; 
    V = (UINT8)((val ^ arg) & (val ^ res)); 
                                                     #ifdef DEBUG
                                      mon("         BNE   L79E9                   ; 79DF: 26 08         \n");
                                      #endif
    // temp hack to force a flush
    if (Z) {
    clockticks = clockticks + 3; 
    goto L79E9;
    }
                                                     #ifdef DEBUG
                                      mon("         LDD   $15,X                   ; 79E1: EC 88 15      \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(X + (SINT8)0x15); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ORA   #$08                    ; 79E4: 8A 08         \n");
                                      #endif
    clockticks = clockticks + 2; 
    res = A | (UINT8)0x08; 
    A = res; 
 // Z = res; 
 // N = res; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $15,X                   ; 79E6: ED 88 15      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = (UINT16)(X + (SINT8)0x15); 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
  case 0x79E9:
L79E9:
                                                     #ifdef DEBUG
                                      mon("L79E9    LDX   <$64                    ; 79E9: 9E 64         \n");
                                      #endif // "Pointer to Tie fighter data", Pointer to Tie fighter data
    PC = 0x79e9; 
    INSTRUCTION_START
    clockticks = clockticks + 4; 
    clockticks = clockticks + 1; 
    ea = rd_mem(DP|0x64)<<8; 
    ea = ea | rd_mem(DP|0x65); 
    X = ea; 
 // Z = X; 
 // N = (X) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDB   $06,X                   ; 79EB: E6 06         \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0006)); 
    B = val; 
 // N = val; 
 // Z = val; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         LDU   #word_7A08              ; 79ED: CE 7A 08      \n");
                                      #endif // Tie fighter colour table
    clockticks = clockticks + 3; 
    U = 0x7a08; 
 // Z = U; 
 // N = (U) >> 8; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         ASLB                          ; 79F0: 58            \n");
                                      #endif
    val = (UINT8)B; 
    res = val << 1; 
    C = res & 0x100; 
    res = (UINT8)res; 
 // Z = res; 
 // N = res; 
 // V = val ^ res; 
    B = res; 
    clockticks = clockticks + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDD   B,U                     ; 79F1: EC C5         \n");
                                      #endif
    clockticks = clockticks + 5; 
    ea = (UINT16)(U + (SINT8)B); 
    A = rd_mem(ea); // Care needed with I/O space and word fetches
    B = rd_mem((UINT16)(ea+1)); 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 79F3: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
                                                     #ifdef DEBUG
                                      mon("         LDA   #$40                    ; 79F5: 86 40         \n");
                                      #endif // Matrix 1 = Matrix 2 x Matrix 3
    clockticks = clockticks + 2; 
    val = (UINT8)0x40; 
    A = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $CDBA                   ; 79F7: BD CD BA      \n");
                                      #endif // Do math program run
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xfa); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x79); 
    clockticks = clockticks + 1; 
    PC = 0xcdba; 
    JUMP;
  case 0x79FA:
L79FA:
                                                     #ifdef DEBUG
                                      mon("L79FA    LDB   $04,X                   ; 79FA: E6 04         \n");
                                      #endif
    PC = 0x79fa; 
    INSTRUCTION_START
    clockticks = clockticks + 5; 
    val = (UINT8)rd_mem((UINT16)(X + 0x0004)); 
    B = val; 
    N = val; 
    Z = val; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $CD14                   ; 79FC: BD CD 14      \n");
                                      #endif // Math program 0x50. Matrix Multiply - Transposed, Then do perspective division?
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0xff); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x79); 
    clockticks = clockticks + 1; 
    PC = 0xcd14; 
    JUMP;
  case 0x79FF:
L79FF:
                                                     #ifdef DEBUG
                                      mon("L79FF    JSR   $CD2C                   ; 79FF: BD CD 2C      \n");
                                      #endif // Format vectors for ties, and tower/bunker explosions
    PC = 0x79ff; 
    INSTRUCTION_START
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x02); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x7a); 
    clockticks = clockticks + 1; 
    PC = 0xcd2c; 
    JUMP;
  case 0x7A02:
L7A02:
                                                     #ifdef DEBUG
                                      mon("L7A02    LDD   #$8040                  ; 7A02: CC 80 40      \n");
                                      #endif // Insert vector CNTR instruction
    PC = 0x7a02; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x80; 
    B = 0x40; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   ,Y++                    ; 7A05: ED A1         \n");
                                      #endif
    clockticks = clockticks + 7; 
    Z = A | B; 
    N = A; 
    V = 0; 
    ea = Y; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
    Y = Y + 2; 
    // End of function sub_7881
    // ---------------------------------------------------------------------------
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 7A07: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
    // =============== S U B R O U T I N E =======================================
  case 0x7A48:
L7A48:
                                                     #ifdef DEBUG
                                      mon("L7A48    LDU   #$5090                  ; 7A48: CE 50 90      \n");
                                      #endif
    PC = 0x7a48; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    U = 0x5090; 
    Z = U; 
    N = (U) >> 8; 
    V = 0; 
                                                     #ifdef DEBUG
                                      mon("         JSR   $CDC3                   ; 7A4B: BD CD C3      \n");
                                      #endif // Initialise math registers matrix
    clockticks = clockticks + 8; 
    --S;
    wr_mem(S, 0x4e); 
    clockticks = clockticks + 1; 
    --S;
    wr_mem(S, 0x7a); 
    clockticks = clockticks + 1; 
    PC = 0xcdc3; 
    JUMP;
  case 0x7A4E:
L7A4E:
                                                     #ifdef DEBUG
                                      mon("L7A4E    LDD   #$00                    ; 7A4E: CC 00 00      \n");
                                      #endif
    PC = 0x7a4e; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STD   $5098                   ; 7A51: FD 50 98      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x5098, A); // Care needed with I/O space and word fetches
    wr_mem(0x5099, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $509A                   ; 7A54: FD 50 9A      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x509a, A); // Care needed with I/O space and word fetches
    wr_mem(0x509b, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $509C                   ; 7A57: FD 50 9C      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x509c, A); // Care needed with I/O space and word fetches
    wr_mem(0x509d, B); 
  case 0x7A5A:
L7A5A:
                                                     #ifdef DEBUG
                                      mon("L7A5A    LDD   #$00                    ; 7A5A: CC 00 00      \n");
                                      #endif
    PC = 0x7a5a; 
    INSTRUCTION_START
    clockticks = clockticks + 3; 
    A = 0x00; 
    B = 0x00; 
 // Z = A|B; 
 // N = A; 
 // V = 0; 
                                                     #ifdef DEBUG
                                      mon("         STA   <$62                    ; 7A5D: 97 62         \n");
                                      #endif // Timer for fireball hit?
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x62; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   <$63                    ; 7A5F: 97 63         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x63; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   <$31                    ; 7A61: 97 31         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0x31; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   <$BC                    ; 7A63: 97 BC         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xbc; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   <$B7                    ; 7A65: 97 B7         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xb7; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   <$BD                    ; 7A67: 97 BD         \n");
                                      #endif
    clockticks = clockticks + 4; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    ea = DP|0xbd; 
    wr_mem(ea, val); 
                                                     #ifdef DEBUG
                                      mon("         STD   <$A3                    ; 7A69: DD A3         \n");
                                      #endif
    clockticks = clockticks + 4; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    ea = DP|0xa3; 
    wr_mem(ea, A); // Care needed with I/O space and word fetches
    wr_mem(ea + 1, B); 
                                                     #ifdef DEBUG
                                      mon("         STA   $4878                   ; 7A6B: B7 48 78      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4878, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   $486E                   ; 7A6E: B7 48 6E      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x486e, val); 
                                                     #ifdef DEBUG
                                      mon("         STA   $4877                   ; 7A71: B7 48 77      \n");
                                      #endif
    clockticks = clockticks + 5; 
    val = A; 
 // Z = val; 
 // N = val; 
 // V = 0; 
    wr_mem(0x4877, val); 
                                                     #ifdef DEBUG
                                      mon("         STD   $4874                   ; 7A74: FD 48 74      \n");
                                      #endif
    clockticks = clockticks + 5; 
 // Z = A | B; 
 // N = A; 
 // V = 0; 
    wr_mem(0x4874, A); // Care needed with I/O space and word fetches
    wr_mem(0x4875, B); 
                                                     #ifdef DEBUG
                                      mon("         STD   $486B                   ; 7A77: FD 48 6B      \n");
                                      #endif
    clockticks = clockticks + 5; 
    Z = A | B; 
    N = A; 
    V = 0; 
    wr_mem(0x486b, A); // Care needed with I/O space and word fetches
    wr_mem(0x486c, B); 
    // End of function sub_7A48
    // ---------------------------------------------------------------------------
                                                     #ifdef DEBUG
                                      mon("         RTS                           ; 7A7A: 39            \n");
                                      #endif
    clockticks = clockticks + 5; 
    clockticks = clockticks + 1; 
    PC = rd_mem(S)<<8; 
    S++;
    PC = PC | rd_mem(S); 
    S++;
    JUMP;
    
